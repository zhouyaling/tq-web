(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("Vue"), require("moment"));
	else if(typeof define === 'function' && define.amd)
		define("ta404-ui", ["Vue", "moment"], factory);
	else if(typeof exports === 'object')
		exports["ta404-ui"] = factory(require("Vue"), require("moment"));
	else
		root["ta404-ui"] = factory(root["Vue"], root["moment"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__10__, __WEBPACK_EXTERNAL_MODULE__12__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 972);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}



var VuePropTypes = {
  get any() {
    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])('any', {
      type: null
    });
  },

  get func() {
    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])('function', {
      type: Function
    }).def(currentDefaults.func);
  },

  get bool() {
    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])('boolean', {
      type: Boolean
    }).def(currentDefaults.bool);
  },

  get string() {
    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])('string', {
      type: String
    }).def(currentDefaults.string);
  },

  get number() {
    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])('number', {
      type: Number
    }).def(currentDefaults.number);
  },

  get array() {
    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])('array', {
      type: Array
    }).def(currentDefaults.array);
  },

  get object() {
    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])('object', {
      type: Object
    }).def(currentDefaults.object);
  },

  get integer() {
    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])('integer', {
      type: Number,
      validator: function validator(value) {
        return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* isInteger */ "d"])(value);
      }
    }).def(currentDefaults.integer);
  },

  get symbol() {
    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])('symbol', {
      type: null,
      validator: function validator(value) {
        return _typeof(value) === 'symbol';
      }
    });
  },

  custom: function custom(validatorFn) {
    var warnMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'custom validation failed';

    if (typeof validatorFn !== 'function') {
      throw new TypeError('[VueTypes error]: You must provide a function as argument');
    }

    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])(validatorFn.name || '<<anonymous function>>', {
      validator: function validator() {
        var valid = validatorFn.apply(void 0, arguments);
        if (!valid) Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* warn */ "g"])("".concat(this._vueTypes_name, " - ").concat(warnMsg));
        return valid;
      }
    });
  },
  oneOf: function oneOf(arr) {
    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* isArray */ "b"])(arr)) {
      throw new TypeError('[VueTypes error]: You must provide an array as argument');
    }

    var msg = "oneOf - value should be one of \"".concat(arr.join('", "'), "\"");
    var allowedTypes = arr.reduce(function (ret, v) {
      if (v !== null && v !== undefined) {
        ret.indexOf(v.constructor) === -1 && ret.push(v.constructor);
      }

      return ret;
    }, []);
    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])('oneOf', {
      type: allowedTypes.length > 0 ? allowedTypes : null,
      validator: function validator(value) {
        var valid = arr.indexOf(value) !== -1;
        if (!valid) Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* warn */ "g"])(msg);
        return valid;
      }
    });
  },
  instanceOf: function instanceOf(instanceConstructor) {
    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])('instanceOf', {
      type: instanceConstructor
    });
  },
  oneOfType: function oneOfType(arr) {
    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* isArray */ "b"])(arr)) {
      throw new TypeError('[VueTypes error]: You must provide an array as argument');
    }

    var hasCustomValidators = false;
    var nativeChecks = arr.reduce(function (ret, type, i) {
      if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default()(type)) {
        if (type._vueTypes_name === 'oneOf') {
          return ret.concat(type.type || []);
        }

        if (type.type && !Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* isFunction */ "c"])(type.validator)) {
          if (Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* isArray */ "b"])(type.type)) return ret.concat(type.type);
          ret.push(type.type);
        } else if (Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* isFunction */ "c"])(type.validator)) {
          hasCustomValidators = true;
        }

        return ret;
      }

      ret.push(type);
      return ret;
    }, []);

    if (!hasCustomValidators) {
      // we got just native objects (ie: Array, Object)
      // delegate to Vue native prop check
      return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])('oneOfType', {
        type: nativeChecks
      }).def(undefined);
    }

    var typesStr = arr.map(function (type) {
      if (type && Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* isArray */ "b"])(type.type)) {
        return type.type.map(_utils__WEBPACK_IMPORTED_MODULE_1__[/* getType */ "a"]);
      }

      return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* getType */ "a"])(type);
    }).reduce(function (ret, type) {
      return ret.concat(Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* isArray */ "b"])(type) ? type : [type]);
    }, []).join('", "');
    return this.custom(function oneOfType(value) {
      var valid = arr.some(function (type) {
        if (type._vueTypes_name === 'oneOf') {
          return type.type ? Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* validateType */ "f"])(type.type, value, true) : true;
        }

        return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* validateType */ "f"])(type, value, true);
      });
      if (!valid) Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* warn */ "g"])("oneOfType - value type should be one of \"".concat(typesStr, "\""));
      return valid;
    }).def(undefined);
  },
  arrayOf: function arrayOf(type) {
    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])('arrayOf', {
      type: Array,
      validator: function validator(values) {
        var valid = values.every(function (value) {
          return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* validateType */ "f"])(type, value);
        });
        if (!valid) Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* warn */ "g"])("arrayOf - value must be an array of \"".concat(Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* getType */ "a"])(type), "\""));
        return valid;
      }
    });
  },
  objectOf: function objectOf(type) {
    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])('objectOf', {
      type: Object,
      validator: function validator(obj) {
        var valid = Object.keys(obj).every(function (key) {
          return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* validateType */ "f"])(type, obj[key]);
        });
        if (!valid) Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* warn */ "g"])("objectOf - value must be an object of \"".concat(Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* getType */ "a"])(type), "\""));
        return valid;
      }
    });
  },
  shape: function shape(obj) {
    var keys = Object.keys(obj);
    var requiredKeys = keys.filter(function (key) {
      return obj[key] && obj[key].required === true;
    });
    var type = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* toType */ "e"])('shape', {
      type: Object,
      validator: function validator(value) {
        var _this = this;

        if (!lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default()(value)) {
          return false;
        }

        var valueKeys = Object.keys(value); // check for required keys (if any)

        if (requiredKeys.length > 0 && requiredKeys.some(function (req) {
          return valueKeys.indexOf(req) === -1;
        })) {
          Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* warn */ "g"])("shape - at least one of required properties \"".concat(requiredKeys.join('", "'), "\" is not present"));
          return false;
        }

        return valueKeys.every(function (key) {
          if (keys.indexOf(key) === -1) {
            if (_this._vueTypes_isLoose === true) return true;
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* warn */ "g"])("shape - object is missing \"".concat(key, "\" property"));
            return false;
          }

          var type = obj[key];
          return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* validateType */ "f"])(type, value[key]);
        });
      }
    });
    Object.defineProperty(type, '_vueTypes_isLoose', {
      enumerable: false,
      writable: true,
      value: false
    });
    Object.defineProperty(type, 'loose', {
      get: function get() {
        this._vueTypes_isLoose = true;
        return this;
      },
      enumerable: false
    });
    return type;
  }
};

var typeDefaults = function typeDefaults() {
  return {
    func: undefined,
    bool: undefined,
    string: undefined,
    number: undefined,
    array: undefined,
    object: undefined,
    integer: undefined
  };
};

var currentDefaults = typeDefaults();
Object.defineProperty(VuePropTypes, 'sensibleDefaults', {
  enumerable: false,
  set: function set(value) {
    if (value === false) {
      currentDefaults = {};
    } else if (value === true) {
      currentDefaults = typeDefaults();
    } else if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default()(value)) {
      currentDefaults = value;
    }
  },
  get: function get() {
    return currentDefaults;
  }
});
/* harmony default export */ __webpack_exports__["a"] = (VuePropTypes);

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return getEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return getClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return getStyle; });
/* unused harmony export getComponentName */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return isEmptyElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return filterEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return mergeProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return hasProp; });
/* unused harmony export filterProps */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return getOptionProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getComponentFromProp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return getSlotOptions; });
/* unused harmony export slotHasProp */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return getPropsData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return getKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getAttrs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return getValueByProp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return parseStyleText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return initDefaultProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return isValidElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return camelize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return getSlots; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getAllProps; });
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0__);
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

var camelizeRE = /-(\w)/g;

var camelize = function camelize(str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
};

var parseStyleText = function parseStyleText() {
  var cssText = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var camel = arguments.length > 1 ? arguments[1] : undefined;
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);

      if (tmp.length > 1) {
        var k = camel ? camelize(tmp[0].trim()) : tmp[0].trim();
        res[k] = tmp[1].trim();
      }
    }
  });
  return res;
};

var hasProp = function hasProp(instance, prop) {
  var $options = instance.$options || {};
  var propsData = $options.propsData || {};
  return prop in propsData;
};

var slotHasProp = function slotHasProp(slot, prop) {
  var $options = slot.componentOptions || {};
  var propsData = $options.propsData || {};
  return prop in propsData;
};

var filterProps = function filterProps(props) {
  var propsData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var res = {};
  Object.keys(props).forEach(function (k) {
    if (k in propsData || props[k] !== undefined) {
      res[k] = props[k];
    }
  });
  return res;
};

var getSlots = function getSlots(ele) {
  var componentOptions = ele.componentOptions || {};

  if (ele.$vnode) {
    componentOptions = ele.$vnode.componentOptions || {};
  }

  var children = componentOptions.children || [];
  var slots = {};
  children.forEach(function (child) {
    var name = child.data && child.data.slot || 'default';
    slots[name] = slots[name] || [];
    slots[name].push(child);
  });
  return slots;
};

var getSlotOptions = function getSlotOptions(ele) {
  if (ele.fnOptions) {
    // 函数式组件
    return ele.fnOptions;
  }

  var componentOptions = ele.componentOptions;

  if (ele.$vnode) {
    componentOptions = ele.$vnode.componentOptions;
  }

  return componentOptions ? componentOptions.Ctor.options || {} : {};
};

var getOptionProps = function getOptionProps(instance) {
  if (instance.componentOptions) {
    var componentOptions = instance.componentOptions;
    var _componentOptions$pro = componentOptions.propsData,
        propsData = _componentOptions$pro === void 0 ? {} : _componentOptions$pro,
        _componentOptions$Cto = componentOptions.Ctor,
        Ctor = _componentOptions$Cto === void 0 ? {} : _componentOptions$Cto;
    var props = (Ctor.options || {}).props || {};
    var res = {};

    for (var _i = 0, _Object$entries = Object.entries(props); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          k = _Object$entries$_i[0],
          v = _Object$entries$_i[1];

      var def = v["default"];

      if (def !== undefined) {
        res[k] = typeof def === 'function' && getType(v.type) !== 'Function' ? def.call(instance) : def;
      }
    }

    return _objectSpread({}, res, propsData);
  }

  var _instance$$options = instance.$options,
      $options = _instance$$options === void 0 ? {} : _instance$$options,
      _instance$$props = instance.$props,
      $props = _instance$$props === void 0 ? {} : _instance$$props;
  return filterProps($props, $options.propsData);
};

var getComponentFromProp = function getComponentFromProp(instance, prop) {
  if (instance.$createElement) {
    var h = instance.$createElement;
    var temp = instance[prop];

    if (temp !== undefined) {
      return typeof temp === 'function' ? temp(h) : temp;
    }

    return instance.$slots[prop];
  } else {
    var _h = instance.context.$createElement;
    var _temp = getPropsData(instance)[prop];

    if (_temp !== undefined) {
      return typeof _temp === 'function' ? _temp(_h) : _temp;
    }

    var slotsProp = [];
    var componentOptions = instance.componentOptions || {};
    (componentOptions.children || []).forEach(function (child) {
      if (child.data && child.data.slot === prop) {
        if (child.tag === 'template') {
          slotsProp.push(child.children);
        } else {
          slotsProp.push(child);
        }
      }
    });
    return slotsProp.length ? slotsProp : undefined;
  }
};

var getAllProps = function getAllProps(ele) {
  var data = ele.data || {};
  var componentOptions = ele.componentOptions || {};

  if (ele.$vnode) {
    data = ele.$vnode.data || {};
    componentOptions = ele.$vnode.componentOptions || {};
  }

  return _objectSpread({}, data.props, data.attrs, componentOptions.propsData);
};

var getPropsData = function getPropsData(ele) {
  var componentOptions = ele.componentOptions;

  if (ele.$vnode) {
    componentOptions = ele.$vnode.componentOptions;
  }

  return componentOptions ? componentOptions.propsData || {} : {};
};

var getValueByProp = function getValueByProp(ele, prop) {
  return getPropsData(ele)[prop];
};

var getAttrs = function getAttrs(ele) {
  var data = ele.data;

  if (ele.$vnode) {
    data = ele.$vnode.data;
  }

  return data ? data.attrs || {} : {};
};

var getKey = function getKey(ele) {
  var key = ele.key;

  if (ele.$vnode) {
    key = ele.$vnode.key;
  }

  return key;
};

function getEvents(child) {
  var events = {};

  if (child.componentOptions && child.componentOptions.listeners) {
    events = child.componentOptions.listeners;
  } else if (child.data && child.data.on) {
    events = child.data.on;
  }

  return _objectSpread({}, events);
}
function getClass(ele) {
  var data = {};

  if (ele.data) {
    data = ele.data;
  } else if (ele.$vnode && ele.$vnode.data) {
    data = ele.$vnode.data;
  }

  var tempCls = data["class"] || data.staticClass;
  var cls = {};

  if (typeof tempCls === 'string') {
    tempCls.split(' ').forEach(function (c) {
      cls[c.trim()] = true;
    });
  } else {
    cls = tempCls;
  }

  return cls;
}
function getStyle(ele, camel) {
  var data = {};

  if (ele.data) {
    data = ele.data;
  } else if (ele.$vnode && ele.$vnode.data) {
    data = ele.$vnode.data;
  }

  var style = data.style || data.staticStyle;

  if (typeof style === 'string') {
    style = parseStyleText(style, camel);
  } else if (camel && style) {
    // 驼峰化
    var res = {};
    Object.keys(style).forEach(function (k) {
      return res[camelize(k)] = style[k];
    });
    return res;
  }

  return style;
}
function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}
function isEmptyElement(ele) {
  return !(ele.tag || ele.text.trim() !== '');
}
function filterEmpty() {
  var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return children.filter(function (c) {
    return c.tag || c.text && c.text.trim() !== '';
  });
}

var initDefaultProps = function initDefaultProps(propTypes, defaultProps) {
  Object.keys(defaultProps).forEach(function (k) {
    if (propTypes[k]) {
      propTypes[k].def && (propTypes[k] = propTypes[k].def(defaultProps[k]));
    } else {
      throw new Error("not have ".concat(k, " prop"));
    }
  });
  return propTypes;
};

function mergeProps() {
  var args = [].slice.call(arguments, 0);
  var props = {};
  args.forEach(function (p, i) {
    for (var _i2 = 0, _Object$entries2 = Object.entries(p); _i2 < _Object$entries2.length; _i2++) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
          k = _Object$entries2$_i[0],
          v = _Object$entries2$_i[1];

      props[k] = props[k] || {};

      if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default()(v)) {
        Object.assign(props[k], v);
      } else {
        props[k] = v;
      }
    }
  });
  return props;
}

function isValidElement(element) {
  return element && element.context && element.context._isVue;
}


/* harmony default export */ __webpack_exports__["b"] = (hasProp);

/***/ }),
/* 2 */,
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _props_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}


/* harmony default export */ __webpack_exports__["a"] = ({
  directives: {
    ref: {
      bind: function bind(el, binding, vnode) {
        binding.value(vnode.componentInstance ? vnode.componentInstance : vnode.elm);
      },
      update: function update(el, binding, vnode) {
        binding.value(vnode.componentInstance ? vnode.componentInstance : vnode.elm);
      },
      unbind: function unbind(el, binding, vnode) {
        binding.value(null);
      }
    }
  },
  methods: {
    setState: function setState(state, callback) {
      var newState = typeof state === 'function' ? state(this.$data) : state;

      if (this.getDerivedStateFromProps) {
        Object.assign(newState, this.getDerivedStateFromProps(Object(_props_util__WEBPACK_IMPORTED_MODULE_0__[/* getOptionProps */ "j"])(this), this.$data, true) || {});
      }

      Object.assign(this.$data, newState);
      this.$nextTick(function () {
        callback && callback();
      });
    },
    __emit: function __emit() {
      // 直接调用listeners，底层组件不需要vueTool记录events
      var args = [].slice.call(arguments, 0);
      var filterEvent = [];
      var eventName = args[0];

      if (args.length && this.$listeners[eventName]) {
        if (filterEvent.includes(eventName)) {
          this.$emit.apply(this, [eventName].concat(_toConsumableArray(args.slice(1))));
        } else {
          var _this$$listeners;

          (_this$$listeners = this.$listeners)[eventName].apply(_this$$listeners, _toConsumableArray(args.slice(1)));
        }
      }
    }
  }
});

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

/* global define */
(function () {
  'use strict';

  var hasOwn = {}.hasOwnProperty;

  function classNames() {
    var classes = [];

    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (!arg) continue;

      var argType = _typeof(arg);

      if (argType === 'string' || argType === 'number') {
        classes.push(arg);
      } else if (Array.isArray(arg) && arg.length) {
        var inner = classNames.apply(null, arg);

        if (inner) {
          classes.push(inner);
        }
      } else if (argType === 'object') {
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes.push(key);
          }
        }
      }
    }

    return classes.join(' ');
  }

  if ( true && module.exports) {
    classNames["default"] = classNames;
    module.exports = classNames;
  } else if ( true && _typeof(__webpack_require__(269)) === 'object' && __webpack_require__(269)) {
    // register as 'classnames', consistent with npm package name
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return classNames;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    window.classNames = classNames;
  }
})();

/***/ }),
/* 5 */
/***/ (function(module, exports) {

var nestRE = /^(attrs|props|on|nativeOn|class|style|hook)$/;

module.exports = function mergeJSXProps(objs) {
  return objs.reduce(function (a, b) {
    var aa, bb, key, nestedKey, temp;

    for (key in b) {
      aa = a[key];
      bb = b[key];

      if (aa && nestRE.test(key)) {
        // normalize class
        if (key === 'class') {
          if (typeof aa === 'string') {
            temp = aa;
            a[key] = aa = {};
            aa[temp] = true;
          }

          if (typeof bb === 'string') {
            temp = bb;
            b[key] = bb = {};
            bb[temp] = true;
          }
        }

        if (key === 'on' || key === 'nativeOn' || key === 'hook') {
          // merge functions
          for (nestedKey in bb) {
            aa[nestedKey] = mergeFn(aa[nestedKey], bb[nestedKey]);
          }
        } else if (Array.isArray(aa)) {
          a[key] = aa.concat(bb);
        } else if (Array.isArray(bb)) {
          a[key] = [aa].concat(bb);
        } else {
          for (nestedKey in bb) {
            aa[nestedKey] = bb[nestedKey];
          }
        }
      } else {
        a[key] = b[key];
      }
    }

    return a;
  }, {});
};

function mergeFn(a, b) {
  return function () {
    a && a.apply(this, arguments);
    b && b.apply(this, arguments);
  };
}

/***/ }),
/* 6 */,
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return on; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return off; });
/* unused harmony export once */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return hasClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return removeClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getStyle; });
/* unused harmony export setStyle */
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}
/* istanbul ignore next */



var isServer = vue__WEBPACK_IMPORTED_MODULE_0___default.a.prototype.$isServer;
var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
var MOZ_HACK_REGEXP = /^moz([A-Z])/;
var ieVersion = isServer ? 0 : Number(document.documentMode);
/* istanbul ignore next */

var trim = function trim(string) {
  return (string || '').replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
};
/* istanbul ignore next */


var camelCase = function camelCase(name) {
  return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
    return offset ? letter.toUpperCase() : letter;
  }).replace(MOZ_HACK_REGEXP, 'Moz$1');
};
/* istanbul ignore next */


var on = function () {
  if (!isServer && document.addEventListener) {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.addEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.attachEvent('on' + event, handler);
      }
    };
  }
}();
/* istanbul ignore next */

var off = function () {
  if (!isServer && document.removeEventListener) {
    return function (element, event, handler) {
      if (element && event) {
        element.removeEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event) {
        element.detachEvent('on' + event, handler);
      }
    };
  }
}();
/* istanbul ignore next */

var once = function once(el, event, fn) {
  var listener = function listener() {
    if (fn) {
      fn.apply(this, arguments);
    }

    off(el, event, listener);
  };

  on(el, event, listener);
};
/* istanbul ignore next */

function hasClass(el, cls) {
  if (!el || !cls) return false;
  if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');

  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
  }
}
;
/* istanbul ignore next */

function addClass(el, cls) {
  if (!el) return;
  var curClass = el.className;
  var classes = (cls || '').split(' ');

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.add(clsName);
    } else if (!hasClass(el, clsName)) {
      curClass += ' ' + clsName;
    }
  }

  if (!el.classList) {
    el.className = curClass;
  }
}
;
/* istanbul ignore next */

function removeClass(el, cls) {
  if (!el || !cls) return;
  var classes = cls.split(' ');
  var curClass = ' ' + el.className + ' ';

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.remove(clsName);
    } else if (hasClass(el, clsName)) {
      curClass = curClass.replace(' ' + clsName + ' ', ' ');
    }
  }

  if (!el.classList) {
    el.className = trim(curClass);
  }
}
;
/* istanbul ignore next */

var getStyle = ieVersion < 9 ? function (element, styleName) {
  if (isServer) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);

  if (styleName === 'float') {
    styleName = 'styleFloat';
  }

  try {
    switch (styleName) {
      case 'opacity':
        try {
          return element.filters.item('alpha').opacity / 100;
        } catch (e) {
          return 1.0;
        }

      default:
        return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;
    }
  } catch (e) {
    return element.style[styleName];
  }
} : function (element, styleName) {
  if (isServer) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);

  if (styleName === 'float') {
    styleName = 'cssFloat';
  }

  try {
    var computed = document.defaultView.getComputedStyle(element, '');
    return element.style[styleName] || computed ? computed[styleName] : null;
  } catch (e) {
    return element.style[styleName];
  }
};
/* istanbul ignore next */

function setStyle(element, styleName, value) {
  if (!element || !styleName) return;

  if (_typeof(styleName) === 'object') {
    for (var prop in styleName) {
      if (styleName.hasOwnProperty(prop)) {
        setStyle(element, prop, styleName[prop]);
      }
    }
  } else {
    styleName = camelCase(styleName);

    if (styleName === 'opacity' && ieVersion < 9) {
      element.style.filter = isNaN(value) ? '' : 'alpha(opacity=' + value * 100 + ')';
    } else {
      element.style[styleName] = value;
    }
  }
}
;

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export cloneVNode */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return cloneVNodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cloneElement; });
/* harmony import */ var _props_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


function cloneVNode(vnode, deep) {
  var componentOptions = vnode.componentOptions;
  var data = vnode.data;
  var listeners = {};

  if (componentOptions && componentOptions.listeners) {
    listeners = _objectSpread({}, componentOptions.listeners);
  }

  var on = {};

  if (data && data.on) {
    on = _objectSpread({}, data.on);
  }

  var cloned = new vnode.constructor(vnode.tag, data ? _objectSpread({}, data, {
    on: on
  }) : data, vnode.children, vnode.text, vnode.elm, vnode.context, componentOptions ? _objectSpread({}, componentOptions, {
    listeners: listeners
  }) : componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.isCloned = true;

  if (deep) {
    if (vnode.children) {
      cloned.children = cloneVNodes(vnode.children, true);
    }

    if (componentOptions && componentOptions.children) {
      componentOptions.children = cloneVNodes(componentOptions.children, true);
    }
  }

  return cloned;
}
function cloneVNodes(vnodes, deep) {
  var len = vnodes.length;
  var res = new Array(len);

  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i], deep);
  }

  return res;
}
function cloneElement(n, nodeProps, deep) {
  var ele = n;

  if (Array.isArray(n)) {
    ele = Object(_props_util__WEBPACK_IMPORTED_MODULE_0__[/* filterEmpty */ "c"])(n)[0];
  }

  if (!ele) {
    return null;
  }

  var node = cloneVNode(ele, deep);
  var _nodeProps$props = nodeProps.props,
      props = _nodeProps$props === void 0 ? {} : _nodeProps$props,
      key = nodeProps.key,
      _nodeProps$on = nodeProps.on,
      on = _nodeProps$on === void 0 ? {} : _nodeProps$on,
      children = nodeProps.children,
      _nodeProps$directives = nodeProps.directives,
      directives = _nodeProps$directives === void 0 ? [] : _nodeProps$directives;
  var data = node.data || {};
  var cls = {};
  var style = {};
  var _nodeProps$attrs = nodeProps.attrs,
      attrs = _nodeProps$attrs === void 0 ? {} : _nodeProps$attrs,
      ref = nodeProps.ref,
      _nodeProps$domProps = nodeProps.domProps,
      domProps = _nodeProps$domProps === void 0 ? {} : _nodeProps$domProps,
      _nodeProps$style = nodeProps.style,
      tempStyle = _nodeProps$style === void 0 ? {} : _nodeProps$style,
      _nodeProps$class = nodeProps["class"],
      tempCls = _nodeProps$class === void 0 ? {} : _nodeProps$class,
      _nodeProps$scopedSlot = nodeProps.scopedSlots,
      scopedSlots = _nodeProps$scopedSlot === void 0 ? {} : _nodeProps$scopedSlot;

  if (typeof data.style === 'string') {
    style = Object(_props_util__WEBPACK_IMPORTED_MODULE_0__[/* parseStyleText */ "u"])(data.style);
  } else {
    style = _objectSpread({}, data.style, style);
  }

  if (typeof tempStyle === 'string') {
    style = _objectSpread({}, style, Object(_props_util__WEBPACK_IMPORTED_MODULE_0__[/* parseStyleText */ "u"])(style));
  } else {
    style = _objectSpread({}, style, tempStyle);
  }

  if (typeof data["class"] === 'string' && data["class"].trim() !== '') {
    data["class"].split(' ').forEach(function (c) {
      cls[c.trim()] = true;
    });
  } else {
    cls = _objectSpread({}, data["class"], cls);
  }

  if (typeof tempCls === 'string' && tempCls.trim() !== '') {
    tempCls.split(' ').forEach(function (c) {
      cls[c.trim()] = true;
    });
  } else {
    cls = _objectSpread({}, cls, tempCls);
  }

  node.data = Object.assign({}, data, {
    style: style,
    attrs: _objectSpread({}, data.attrs, attrs),
    "class": cls,
    domProps: _objectSpread({}, data.domProps, domProps),
    scopedSlots: _objectSpread({}, data.scopedSlots, scopedSlots),
    directives: [].concat(_toConsumableArray(data.directives || []), _toConsumableArray(directives))
  });

  if (node.componentOptions) {
    node.componentOptions.propsData = node.componentOptions.propsData || {};
    node.componentOptions.listeners = node.componentOptions.listeners || {};
    node.componentOptions.propsData = _objectSpread({}, node.componentOptions.propsData, props);
    node.componentOptions.listeners = _objectSpread({}, node.componentOptions.listeners, on);

    if (children) {
      node.componentOptions.children = children;
    }
  } else {
    node.data.on = _objectSpread({}, node.data.on || {}, on);
  }

  if (key !== undefined) {
    node.key = key;
    node.data.key = key;
  }

  if (typeof ref === 'string') {
    node.data.ref = ref;
  }

  return node;
}

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export hasOwn */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getType; });
/* unused harmony export getNativeType */
/* unused harmony export noop */
/* unused harmony export has */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isInteger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isFunction; });
/* unused harmony export withDefault */
/* unused harmony export withRequired */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return toType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return validateType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return warn; });
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0__);

var ObjProto = Object.prototype;
var toString = ObjProto.toString;
var hasOwn = ObjProto.hasOwnProperty;
var FN_MATCH_REGEXP = /^\s*function (\w+)/; // https://github.com/vuejs/vue/blob/dev/src/core/util/props.js#L159

var getType = function getType(fn) {
  var type = fn !== null && fn !== undefined ? fn.type ? fn.type : fn : null;
  var match = type && type.toString().match(FN_MATCH_REGEXP);
  return match && match[1];
};
var getNativeType = function getNativeType(value) {
  if (value === null || value === undefined) return null;
  var match = value.constructor.toString().match(FN_MATCH_REGEXP);
  return match && match[1];
};
/**
 * No-op function
 */

var noop = function noop() {};
/**
 * Checks for a own property in an object
 *
 * @param {object} obj - Object
 * @param {string} prop - Property to check
 */

var has = function has(obj, prop) {
  return hasOwn.call(obj, prop);
};
/**
 * Determines whether the passed value is an integer. Uses `Number.isInteger` if available
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
 * @param {*} value - The value to be tested for being an integer.
 * @returns {boolean}
 */

var isInteger = Number.isInteger || function (value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
};
/**
 * Determines whether the passed value is an Array.
 *
 * @param {*} value - The value to be tested for being an array.
 * @returns {boolean}
 */

var isArray = Array.isArray || function (value) {
  return toString.call(value) === '[object Array]';
};
/**
 * Checks if a value is a function
 *
 * @param {any} value - Value to check
 * @returns {boolean}
 */

var isFunction = function isFunction(value) {
  return toString.call(value) === '[object Function]';
};
/**
 * Adds a `def` method to the object returning a new object with passed in argument as `default` property
 *
 * @param {object} type - Object to enhance
 */

var withDefault = function withDefault(type) {
  Object.defineProperty(type, 'def', {
    value: function value(def) {
      if (def === undefined && this["default"] === undefined) {
        this["default"] = undefined;
        return this;
      }

      if (!isFunction(def) && !validateType(this, def)) {
        warn("".concat(this._vueTypes_name, " - invalid default value: \"").concat(def, "\""), def);
        return this;
      }

      this["default"] = isArray(def) || lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default()(def) ? function () {
        return def;
      } : def;
      return this;
    },
    enumerable: false,
    writable: false
  });
};
/**
 * Adds a `isRequired` getter returning a new object with `required: true` key-value
 *
 * @param {object} type - Object to enhance
 */

var withRequired = function withRequired(type) {
  Object.defineProperty(type, 'isRequired', {
    get: function get() {
      this.required = true;
      return this;
    },
    enumerable: false
  });
};
/**
 * Adds `isRequired` and `def` modifiers to an object
 *
 * @param {string} name - Type internal name
 * @param {object} obj - Object to enhance
 * @returns {object}
 */

var toType = function toType(name, obj) {
  Object.defineProperty(obj, '_vueTypes_name', {
    enumerable: false,
    writable: false,
    value: name
  });
  withRequired(obj);
  withDefault(obj);

  if (isFunction(obj.validator)) {
    obj.validator = obj.validator.bind(obj);
  }

  return obj;
};
/**
 * Validates a given value against a prop type object
 *
 * @param {Object|*} type - Type to use for validation. Either a type object or a constructor
 * @param {*} value - Value to check
 * @param {boolean} silent - Silence warnings
 * @returns {boolean}
 */

var validateType = function validateType(type, value) {
  var silent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var typeToCheck = type;
  var valid = true;
  var expectedType;

  if (!lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default()(type)) {
    typeToCheck = {
      type: type
    };
  }

  var namePrefix = typeToCheck._vueTypes_name ? typeToCheck._vueTypes_name + ' - ' : '';

  if (hasOwn.call(typeToCheck, 'type') && typeToCheck.type !== null) {
    if (isArray(typeToCheck.type)) {
      valid = typeToCheck.type.some(function (type) {
        return validateType(type, value, true);
      });
      expectedType = typeToCheck.type.map(function (type) {
        return getType(type);
      }).join(' or ');
    } else {
      expectedType = getType(typeToCheck);

      if (expectedType === 'Array') {
        valid = isArray(value);
      } else if (expectedType === 'Object') {
        valid = lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default()(value);
      } else if (expectedType === 'String' || expectedType === 'Number' || expectedType === 'Boolean' || expectedType === 'Function') {
        valid = getNativeType(value) === expectedType;
      } else {
        valid = value instanceof typeToCheck.type;
      }
    }
  }

  if (!valid) {
    silent === false && warn("".concat(namePrefix, "value \"").concat(value, "\" should be of type \"").concat(expectedType, "\""));
    return false;
  }

  if (hasOwn.call(typeToCheck, 'validator') && isFunction(typeToCheck.validator)) {
    valid = typeToCheck.validator(value);
    if (!valid && silent === false) warn("".concat(namePrefix, "custom validation failed"));
    return valid;
  }

  return valid;
};
var warn = noop;

if (false) { var hasConsole; }



/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__10__;

/***/ }),
/* 11 */,
/* 12 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__12__;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 14 */,
/* 15 */,
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return warnOnlyTreeNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return arrDel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return arrAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return posToArr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return getPosition; });
/* unused harmony export isTreeNode */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return getNodeChildren; });
/* unused harmony export isCheckDisabled */
/* unused harmony export traverseTreeNodes */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return mapChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return getDragNodesKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return calcDropPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return calcSelectedKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return convertDataToTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return convertTreeToEntities; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return parseCheckedKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return conductCheck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return conductExpandParent; });
/* unused harmony export getDataAndAria */
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var omit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _TreeNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(108);
/* harmony import */ var _util_props_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1);
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}
/* eslint no-loop-func: 0 */






var DRAG_SIDE_RANGE = 0.25;
var DRAG_MIN_GAP = 2;
var onlyTreeNodeWarned = false;
function warnOnlyTreeNode() {
  if (onlyTreeNodeWarned) return;
  onlyTreeNodeWarned = true;
  warning__WEBPACK_IMPORTED_MODULE_0___default()(false, 'Tree only accept TreeNode as children.');
}
function arrDel(list, value) {
  var clone = list.slice();
  var index = clone.indexOf(value);

  if (index >= 0) {
    clone.splice(index, 1);
  }

  return clone;
}
function arrAdd(list, value) {
  var clone = list.slice();

  if (clone.indexOf(value) === -1) {
    clone.push(value);
  }

  return clone;
}
function posToArr(pos) {
  return pos.split('-');
}
function getPosition(level, index) {
  return "".concat(level, "-").concat(index);
}
function isTreeNode(node) {
  return Object(_util_props_util__WEBPACK_IMPORTED_MODULE_3__[/* getSlotOptions */ "l"])(node).isTreeNode;
}
function getNodeChildren() {
  var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return children.filter(isTreeNode);
}
function isCheckDisabled(node) {
  var _ref = Object(_util_props_util__WEBPACK_IMPORTED_MODULE_3__[/* getOptionProps */ "j"])(node) || {},
      disabled = _ref.disabled,
      disableCheckbox = _ref.disableCheckbox;

  return !!(disabled || disableCheckbox);
}
function traverseTreeNodes(treeNodes, callback) {
  function processNode(node, index, parent) {
    var children = node ? node.componentOptions.children : treeNodes;
    var pos = node ? getPosition(parent.pos, index) : 0; // Filter children

    var childList = getNodeChildren(children); // Process node if is not root

    if (node) {
      var data = {
        node: node,
        index: index,
        pos: pos,
        key: node.key || pos,
        parentPos: parent.node ? parent.pos : null
      };
      callback(data);
    } // Process children node


    childList.forEach(function (subNode, subIndex) {
      processNode(subNode, subIndex, {
        node: node,
        pos: pos
      });
    });
  }

  processNode(null);
}
/**
 * Use `rc-util` `toArray` to get the children list which keeps the key.
 * And return single node if children is only one(This can avoid `key` missing check).
 */

function mapChildren() {
  var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var func = arguments.length > 1 ? arguments[1] : undefined;
  var list = children.map(func);

  if (list.length === 1) {
    return list[0];
  }

  return list;
}
function getDragNodesKeys(treeNodes, node) {
  var _getOptionProps = Object(_util_props_util__WEBPACK_IMPORTED_MODULE_3__[/* getOptionProps */ "j"])(node),
      eventKey = _getOptionProps.eventKey,
      pos = _getOptionProps.pos;

  var dragNodesKeys = [];
  traverseTreeNodes(treeNodes, function (_ref2) {
    var key = _ref2.key;
    dragNodesKeys.push(key);
  });
  dragNodesKeys.push(eventKey || pos);
  return dragNodesKeys;
}
function calcDropPosition(event, treeNode) {
  var clientY = event.clientY;

  var _treeNode$$refs$selec = treeNode.$refs.selectHandle.getBoundingClientRect(),
      top = _treeNode$$refs$selec.top,
      bottom = _treeNode$$refs$selec.bottom,
      height = _treeNode$$refs$selec.height;

  var des = Math.max(height * DRAG_SIDE_RANGE, DRAG_MIN_GAP);

  if (clientY <= top + des) {
    return -1;
  } else if (clientY >= bottom - des) {
    return 1;
  }

  return 0;
}
/**
 * Return selectedKeys according with multiple prop
 * @param selectedKeys
 * @param props
 * @returns [string]
 */

function calcSelectedKeys(selectedKeys, props) {
  if (!selectedKeys) {
    return undefined;
  }

  var multiple = props.multiple;

  if (multiple) {
    return selectedKeys.slice();
  }

  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }

  return selectedKeys;
}
/**
 * Since React internal will convert key to string,
 * we need do this to avoid `checkStrictly` use number match
 */

function keyListToString(keyList) {
  if (!keyList) return keyList;
  return keyList.map(function (key) {
    return String(key);
  });
}

var internalProcessProps = function internalProcessProps() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    props: Object(omit_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(props, ['on', 'key', 'class', 'className', 'style']),
    on: props.on || {},
    "class": props["class"] || props.className,
    style: props.style,
    key: props.key
  };
};

function convertDataToTree(h, treeData, processer) {
  if (!treeData) return [];

  var _ref3 = processer || {},
      _ref3$processProps = _ref3.processProps,
      processProps = _ref3$processProps === void 0 ? internalProcessProps : _ref3$processProps;

  var list = Array.isArray(treeData) ? treeData : [treeData];
  return list.map(function (_ref4) {
    var children = _ref4.children,
        props = _objectWithoutProperties(_ref4, ["children"]);

    var childrenNodes = convertDataToTree(h, children, processer);
    return h(_TreeNode__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], processProps(props), [childrenNodes]);
  });
} // TODO: ========================= NEW LOGIC =========================

/**
 * Calculate treeNodes entities. `processTreeEntity` is used for `rc-tree-select`
 * @param treeNodes
 * @param processTreeEntity  User can customize the entity
 */

function convertTreeToEntities(treeNodes) {
  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      initWrapper = _ref5.initWrapper,
      processEntity = _ref5.processEntity,
      onProcessFinished = _ref5.onProcessFinished;

  var posEntities = {};
  var keyEntities = {};
  var wrapper = {
    posEntities: posEntities,
    keyEntities: keyEntities
  };

  if (initWrapper) {
    wrapper = initWrapper(wrapper) || wrapper;
  }

  traverseTreeNodes(treeNodes, function (item) {
    var node = item.node,
        index = item.index,
        pos = item.pos,
        key = item.key,
        parentPos = item.parentPos;
    var entity = {
      node: node,
      index: index,
      key: key,
      pos: pos
    };
    posEntities[pos] = entity;
    keyEntities[key] = entity; // Fill children

    entity.parent = posEntities[parentPos];

    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }

    if (processEntity) {
      processEntity(entity, wrapper);
    }
  });

  if (onProcessFinished) {
    onProcessFinished(wrapper);
  }

  return wrapper;
}
/**
 * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style
 */

function parseCheckedKeys(keys) {
  if (!keys) {
    return null;
  } // Convert keys to object format


  var keyProps;

  if (Array.isArray(keys)) {
    // [Legacy] Follow the api doc
    keyProps = {
      checkedKeys: keys,
      halfCheckedKeys: undefined
    };
  } else if (_typeof(keys) === 'object') {
    keyProps = {
      checkedKeys: keys.checked || undefined,
      halfCheckedKeys: keys.halfChecked || undefined
    };
  } else {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(false, '`checkedKeys` is not an array or an object');
    return null;
  }

  keyProps.checkedKeys = keyListToString(keyProps.checkedKeys);
  keyProps.halfCheckedKeys = keyListToString(keyProps.halfCheckedKeys);
  return keyProps;
}
/**
 * Conduct check state by the keyList. It will conduct up & from the provided key.
 * If the conduct path reach the disabled or already checked / unchecked node will stop conduct.
 * @param keyList       list of keys
 * @param isCheck       is check the node or not
 * @param keyEntities   parsed by `convertTreeToEntities` function in Tree
 * @param checkStatus   Can pass current checked status for process (usually for uncheck operation)
 * @returns {{checkedKeys: [], halfCheckedKeys: []}}
 */

function conductCheck(keyList, isCheck, keyEntities) {
  var checkStatus = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var checkedKeys = {};
  var halfCheckedKeys = {}; // Record the key has some child checked (include child half checked)

  (checkStatus.checkedKeys || []).forEach(function (key) {
    checkedKeys[key] = true;
  });
  (checkStatus.halfCheckedKeys || []).forEach(function (key) {
    halfCheckedKeys[key] = true;
  }); // Conduct up

  function conductUp(key) {
    if (checkedKeys[key] === isCheck) return;
    var entity = keyEntities[key];
    if (!entity) return;
    var children = entity.children,
        parent = entity.parent,
        node = entity.node;
    if (isCheckDisabled(node)) return; // Check child node checked status

    var everyChildChecked = true;
    var someChildChecked = false; // Child checked or half checked

    (children || []).filter(function (child) {
      return !isCheckDisabled(child.node);
    }).forEach(function (_ref6) {
      var childKey = _ref6.key;
      var childChecked = checkedKeys[childKey];
      var childHalfChecked = halfCheckedKeys[childKey];
      if (childChecked || childHalfChecked) someChildChecked = true;
      if (!childChecked) everyChildChecked = false;
    }); // Update checked status

    if (isCheck) {
      checkedKeys[key] = everyChildChecked;
    } else {
      checkedKeys[key] = false;
    }

    halfCheckedKeys[key] = someChildChecked;

    if (parent) {
      conductUp(parent.key);
    }
  } // Conduct down


  function conductDown(key) {
    if (checkedKeys[key] === isCheck) return;
    var entity = keyEntities[key];
    if (!entity) return;
    var children = entity.children,
        node = entity.node;
    if (isCheckDisabled(node)) return;
    checkedKeys[key] = isCheck;
    (children || []).forEach(function (child) {
      conductDown(child.key);
    });
  }

  function conduct(key) {
    var entity = keyEntities[key];

    if (!entity) {
      warning__WEBPACK_IMPORTED_MODULE_0___default()(false, "'".concat(key, "' does not exist in the tree."));
      return;
    }

    var children = entity.children,
        parent = entity.parent,
        node = entity.node;
    checkedKeys[key] = isCheck;
    if (isCheckDisabled(node)) return; // Conduct down

    (children || []).filter(function (child) {
      return !isCheckDisabled(child.node);
    }).forEach(function (child) {
      conductDown(child.key);
    }); // Conduct up

    if (parent) {
      conductUp(parent.key);
    }
  }

  (keyList || []).forEach(function (key) {
    conduct(key);
  });
  var checkedKeyList = [];
  var halfCheckedKeyList = []; // Fill checked list

  Object.keys(checkedKeys).forEach(function (key) {
    if (checkedKeys[key]) {
      checkedKeyList.push(key);
    }
  }); // Fill half checked list

  Object.keys(halfCheckedKeys).forEach(function (key) {
    if (!checkedKeys[key] && halfCheckedKeys[key]) {
      halfCheckedKeyList.push(key);
    }
  });
  return {
    checkedKeys: checkedKeyList,
    halfCheckedKeys: halfCheckedKeyList
  };
}
/**
 * If user use `autoExpandParent` we should get the list of parent node
 * @param keyList
 * @param keyEntities
 */

function conductExpandParent(keyList, keyEntities) {
  var expandedKeys = {};

  function conductUp(key) {
    if (expandedKeys[key]) return;
    var entity = keyEntities[key];
    if (!entity) return;
    expandedKeys[key] = true;
    var parent = entity.parent,
        node = entity.node;
    if (isCheckDisabled(node)) return;

    if (parent) {
      conductUp(parent.key);
    }
  }

  (keyList || []).forEach(function (key) {
    conductUp(key);
  });
  return Object.keys(expandedKeys);
}
/**
 * Returns only the data- and aria- key/value pairs
 * @param {object} props
 */

function getDataAndAria(props) {
  return Object.keys(props).reduce(function (prev, key) {
    if (key.substr(0, 5) === 'data-' || key.substr(0, 5) === 'aria-') {
      prev[key] = props[key];
    }

    return prev;
  }, {});
}

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64);
/* harmony import */ var babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);


function omit(obj, fields) {
  var shallowCopy = babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, obj);

  for (var i = 0; i < fields.length; i++) {
    var key = fields[i];
    delete shallowCopy[key];
  }

  return shallowCopy;
}

/* harmony default export */ __webpack_exports__["a"] = (omit);

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 19 */,
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _css_animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57);


var noop = function noop() {};

var getTransitionProps = function getTransitionProps(transitionName) {
  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var beforeEnter = opt.beforeEnter,
      enter = opt.enter,
      afterEnter = opt.afterEnter,
      leave = opt.leave,
      afterLeave = opt.afterLeave,
      _opt$appear = opt.appear,
      appear = _opt$appear === void 0 ? true : _opt$appear,
      tag = opt.tag;
  var transitionProps = {
    props: {
      appear: appear,
      css: false
    },
    on: {
      beforeEnter: beforeEnter || noop,
      enter: enter || function (el, done) {
        Object(_css_animation__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(el, "".concat(transitionName, "-enter"), done);
      },
      afterEnter: afterEnter || noop,
      leave: leave || function (el, done) {
        Object(_css_animation__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(el, "".concat(transitionName, "-leave"), done);
      },
      afterLeave: afterLeave || noop // transition-group

    }
  };

  if (tag) {
    transitionProps.tag = tag;
  }

  return transitionProps;
};

/* harmony default export */ __webpack_exports__["a"] = (getTransitionProps);

/***/ }),
/* 21 */,
/* 22 */,
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(58),
    getPrototype = __webpack_require__(110),
    isObjectLike = __webpack_require__(45);
/** `Object#toString` result references. */


var objectTag = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

/***/ }),
/* 24 */,
/* 25 */,
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function warning() {};

if (false) {}

module.exports = warning;

/***/ }),
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var now = __webpack_require__(522),
    root = typeof window === 'undefined' ? global : window,
    vendors = ['moz', 'webkit'],
    suffix = 'AnimationFrame',
    raf = root['request' + suffix],
    caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for (var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix] || root[vendors[i] + 'CancelRequest' + suffix];
} // Some versions of FF have rAF but not cAF


if (!raf || !caf) {
  var last = 0,
      id = 0,
      queue = [],
      frameDuration = 1000 / 60;

  raf = function raf(callback) {
    if (queue.length === 0) {
      var _now = now(),
          next = Math.max(0, frameDuration - (_now - last));

      last = next + _now;
      setTimeout(function () {
        var cp = queue.slice(0); // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue

        queue.length = 0;

        for (var i = 0; i < cp.length; i++) {
          if (!cp[i].cancelled) {
            try {
              cp[i].callback(last);
            } catch (e) {
              setTimeout(function () {
                throw e;
              }, 0);
            }
          }
        }
      }, Math.round(next));
    }

    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id;
  };

  caf = function caf(handle) {
    for (var i = 0; i < queue.length; i++) {
      if (queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

module.exports = function (fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn);
};

module.exports.cancel = function () {
  caf.apply(root, arguments);
};

module.exports.polyfill = function (object) {
  if (!object) {
    object = root;
  }

  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(67)))

/***/ }),
/* 36 */,
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./src/components/_util/getRequestAnimationFrame.js
var availablePrefixs = ['moz', 'ms', 'webkit'];

function requestAnimationFramePolyfill() {
  var lastTime = 0;
  return function (callback) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = window.setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
}

function getRequestAnimationFrame() {
  if (typeof window === 'undefined') {
    return function () {};
  }

  if (window.requestAnimationFrame) {
    // https://github.com/vuejs/vue/issues/4465
    return window.requestAnimationFrame.bind(window);
  }

  var prefix = availablePrefixs.filter(function (key) {
    return "".concat(key, "RequestAnimationFrame") in window;
  })[0];
  return prefix ? window["".concat(prefix, "RequestAnimationFrame")] : requestAnimationFramePolyfill();
}
function cancelRequestAnimationFrame(id) {
  if (typeof window === 'undefined') {
    return null;
  }

  if (window.cancelAnimationFrame) {
    return window.cancelAnimationFrame(id);
  }

  var prefix = availablePrefixs.filter(function (key) {
    return "".concat(key, "CancelAnimationFrame") in window || "".concat(key, "CancelRequestAnimationFrame") in window;
  })[0];
  return prefix ? (window["".concat(prefix, "CancelAnimationFrame")] || window["".concat(prefix, "CancelRequestAnimationFrame")]).call(this, id) : clearTimeout(id);
}
// CONCATENATED MODULE: ./src/components/_util/requestAnimationTimeout.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return requestAnimationTimeout_cancelAnimationTimeout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return requestAnimationTimeout; });

var raf = getRequestAnimationFrame();
var requestAnimationTimeout_cancelAnimationTimeout = function cancelAnimationTimeout(frame) {
  return cancelRequestAnimationFrame(frame.id);
};
var requestAnimationTimeout = function requestAnimationTimeout(callback, delay) {
  var start = Date.now();

  function timeout() {
    if (Date.now() - start >= delay) {
      callback.call();
    } else {
      frame.id = raf(timeout);
    }
  }

  var frame = {
    id: raf(timeout)
  };
  return frame;
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var freeGlobal = __webpack_require__(134);
/** Detect free variable `self`. */


var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = _typeof(value);

  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),
/* 40 */,
/* 41 */,
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(39),
    now = __webpack_require__(578),
    toNumber = __webpack_require__(579);
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */

function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  wait = toNumber(wait) || 0;

  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

//
module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (_typeof(objA) !== "object" || !objA || _typeof(objB) !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB); // Test for A's keys different from B.

  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];
    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || ret === void 0 && valueA !== valueB) {
      return false;
    }
  }

  return true;
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var baseSet = __webpack_require__(303);
/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */


function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

module.exports = set;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && _typeof(value) == 'object';
}

module.exports = isObjectLike;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var bind = __webpack_require__(262);

var isBuffer = __webpack_require__(441);
/*global toString:true*/
// utils is a library of generic helper functions non-specific to axios


var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */

function isArray(val) {
  return toString.call(val) === '[object Array]';
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */


function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */


function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */


function isArrayBufferView(val) {
  var result;

  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }

  return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */


function isString(val) {
  return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */


function isNumber(val) {
  return typeof val === 'number';
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */


function isUndefined(val) {
  return typeof val === 'undefined';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */


function isObject(val) {
  return val !== null && _typeof(val) === 'object';
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */


function isDate(val) {
  return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */


function isFile(val) {
  return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */


function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */


function isFunction(val) {
  return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */


function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */


function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */


function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */


function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */


function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  } // Force an array if not already something iterable


  if (_typeof(obj) !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function merge()
/* obj1, obj2, obj3, ... */
{
  var result = {};

  function assignValue(val, key) {
    if (_typeof(result[key]) === 'object' && _typeof(val) === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */


function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};

/***/ }),
/* 47 */,
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  install: function install(Vue, options) {
    Vue.directive('ant-ref', {
      bind: function bind(el, binding, vnode) {
        binding.value(vnode.componentInstance ? vnode.componentInstance : vnode.elm);
      },
      update: function update(el, binding, vnode) {
        binding.value(vnode.componentInstance ? vnode.componentInstance : vnode.elm);
      },
      unbind: function unbind(el, binding, vnode) {
        binding.value(null);
      }
    });
  }
});

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

exports.__esModule = true;

var _iterator = __webpack_require__(605);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(617);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2["default"] === "function" && _typeof2(_iterator2["default"]) === "symbol" ? function (obj) {
  return _typeof2(obj);
} : function (obj) {
  return obj && typeof _symbol2["default"] === "function" && obj.constructor === _symbol2["default"] && obj !== _symbol2["default"].prototype ? "symbol" : _typeof2(obj);
};

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

exports["default"] = typeof _symbol2["default"] === "function" && _typeof(_iterator2["default"]) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2["default"] === "function" && obj.constructor === _symbol2["default"] && obj !== _symbol2["default"].prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 50 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

/***/ }),
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export isCssAnimationSupported */
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66);
/* harmony import */ var component_classes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73);
/* harmony import */ var component_classes__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(component_classes__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}




var isCssAnimationSupported = _Event__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].endEvents.length !== 0;
var capitalPrefixes = ['Webkit', 'Moz', 'O', // ms is special .... !
'ms'];
var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];

function getStyleProperty(node, name) {
  // old ff need null, https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle
  var style = window.getComputedStyle(node, null);
  var ret = '';

  for (var i = 0; i < prefixes.length; i++) {
    ret = style.getPropertyValue(prefixes[i] + name);

    if (ret) {
      break;
    }
  }

  return ret;
}

function fixBrowserByTimeout(node) {
  if (isCssAnimationSupported) {
    var transitionDelay = parseFloat(getStyleProperty(node, 'transition-delay')) || 0;
    var transitionDuration = parseFloat(getStyleProperty(node, 'transition-duration')) || 0;
    var animationDelay = parseFloat(getStyleProperty(node, 'animation-delay')) || 0;
    var animationDuration = parseFloat(getStyleProperty(node, 'animation-duration')) || 0;
    var time = Math.max(transitionDuration + transitionDelay, animationDuration + animationDelay); // sometimes, browser bug

    node.rcEndAnimTimeout = setTimeout(function () {
      node.rcEndAnimTimeout = null;

      if (node.rcEndListener) {
        node.rcEndListener();
      }
    }, time * 1000 + 200);
  }
}

function clearBrowserBugTimeout(node) {
  if (node.rcEndAnimTimeout) {
    clearTimeout(node.rcEndAnimTimeout);
    node.rcEndAnimTimeout = null;
  }
}

var cssAnimation = function cssAnimation(node, transitionName, endCallback) {
  var nameIsObj = _typeof(transitionName) === 'object';
  var className = nameIsObj ? transitionName.name : transitionName;
  var activeClassName = nameIsObj ? transitionName.active : "".concat(transitionName, "-active");
  var end = endCallback;
  var start;
  var active;
  var nodeClasses = component_classes__WEBPACK_IMPORTED_MODULE_1___default()(node);

  if (endCallback && Object.prototype.toString.call(endCallback) === '[object Object]') {
    end = endCallback.end;
    start = endCallback.start;
    active = endCallback.active;
  }

  if (node.rcEndListener) {
    node.rcEndListener();
  }

  node.rcEndListener = function (e) {
    if (e && e.target !== node) {
      return;
    }

    if (node.rcAnimTimeout) {
      Object(_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_2__[/* cancelAnimationTimeout */ "a"])(node.rcAnimTimeout);
      node.rcAnimTimeout = null;
    }

    clearBrowserBugTimeout(node);
    nodeClasses.remove(className);
    nodeClasses.remove(activeClassName);
    _Event__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].removeEndEventListener(node, node.rcEndListener);
    node.rcEndListener = null; // Usually this optional end is used for informing an owner of
    // a leave animation and telling it to remove the child.

    if (end) {
      end();
    }
  };

  _Event__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].addEndEventListener(node, node.rcEndListener);

  if (start) {
    start();
  }

  nodeClasses.add(className);
  node.rcAnimTimeout = Object(_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_2__[/* requestAnimationTimeout */ "b"])(function () {
    node.rcAnimTimeout = null;
    nodeClasses.add(activeClassName);

    if (active) {
      Object(_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_2__[/* requestAnimationTimeout */ "b"])(active, 0);
    }

    fixBrowserByTimeout(node); // 30ms for firefox
  }, 30);
  return {
    stop: function stop() {
      if (node.rcEndListener) {
        node.rcEndListener();
      }
    }
  };
};

cssAnimation.style = function (node, style, callback) {
  if (node.rcEndListener) {
    node.rcEndListener();
  }

  node.rcEndListener = function (e) {
    if (e && e.target !== node) {
      return;
    }

    if (node.rcAnimTimeout) {
      Object(_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_2__[/* cancelAnimationTimeout */ "a"])(node.rcAnimTimeout);
      node.rcAnimTimeout = null;
    }

    clearBrowserBugTimeout(node);
    _Event__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].removeEndEventListener(node, node.rcEndListener);
    node.rcEndListener = null; // Usually this optional callback is used for informing an owner of
    // a leave animation and telling it to remove the child.

    if (callback) {
      callback();
    }
  };

  _Event__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].addEndEventListener(node, node.rcEndListener);
  node.rcAnimTimeout = Object(_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_2__[/* requestAnimationTimeout */ "b"])(function () {
    for (var s in style) {
      if (style.hasOwnProperty(s)) {
        node.style[s] = style[s];
      }
    }

    node.rcAnimTimeout = null;
    fixBrowserByTimeout(node);
  }, 0);
};

cssAnimation.setTransition = function (node, p, value) {
  var property = p;
  var v = value;

  if (value === undefined) {
    v = property;
    property = '';
  }

  property = property || '';
  capitalPrefixes.forEach(function (prefix) {
    node.style["".concat(prefix, "Transition").concat(property)] = v;
  });
};

cssAnimation.isCssAnimationSupported = isCssAnimationSupported;

/* harmony default export */ __webpack_exports__["a"] = (cssAnimation);

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(59),
    getRawTag = __webpack_require__(193),
    objectToString = __webpack_require__(194);
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(38);
/** Built-in value references. */


var _Symbol = root.Symbol;
module.exports = _Symbol;

/***/ }),
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function (target) {
  for (var i = 1, j = arguments.length; i < j; i++) {
    var source = arguments[i] || {};

    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        var value = source[prop];

        if (value !== undefined) {
          target[prop] = value;
        }
      }
    }
  }

  return target;
});
;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__(513);

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

exports["default"] = _assign2["default"] || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// based on rc-tree 1.14.6


module.exports = __webpack_require__(979);

/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var EVENT_NAME_MAP = {
  transitionend: {
    transition: 'transitionend',
    WebkitTransition: 'webkitTransitionEnd',
    MozTransition: 'mozTransitionEnd',
    OTransition: 'oTransitionEnd',
    msTransition: 'MSTransitionEnd'
  },
  animationend: {
    animation: 'animationend',
    WebkitAnimation: 'webkitAnimationEnd',
    MozAnimation: 'mozAnimationEnd',
    OAnimation: 'oAnimationEnd',
    msAnimation: 'MSAnimationEnd'
  }
};
var endEvents = [];

function detectEvents() {
  var testEl = document.createElement('div');
  var style = testEl.style;

  if (!('AnimationEvent' in window)) {
    delete EVENT_NAME_MAP.animationend.animation;
  }

  if (!('TransitionEvent' in window)) {
    delete EVENT_NAME_MAP.transitionend.transition;
  }

  for (var baseEventName in EVENT_NAME_MAP) {
    if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
      var baseEvents = EVENT_NAME_MAP[baseEventName];

      for (var styleName in baseEvents) {
        if (styleName in style) {
          endEvents.push(baseEvents[styleName]);
          break;
        }
      }
    }
  }
}

if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  detectEvents();
}

function addEventListener(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}

function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}

var TransitionEvents = {
  addEndEventListener: function addEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      window.setTimeout(eventListener, 0);
      return;
    }

    endEvents.forEach(function (endEvent) {
      addEventListener(node, endEvent, eventListener);
    });
  },
  endEvents: endEvents,
  removeEndEventListener: function removeEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }

    endEvents.forEach(function (endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};
/* harmony default export */ __webpack_exports__["a"] = (TransitionEvents);

/***/ }),
/* 67 */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 68 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export noop */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return hasOwn; });
/* unused harmony export toObject */
/* unused harmony export getValueByPath */
/* unused harmony export getPropByPath */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return generateId; });
/* unused harmony export valueEquals */
/* unused harmony export escapeRegexpString */
/* unused harmony export arrayFindIndex */
/* unused harmony export arrayFind */
/* unused harmony export coerceTruthyValueToArray */
/* unused harmony export isIE */
/* unused harmony export isEdge */
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);

var hasOwnProperty = Object.prototype.hasOwnProperty;
function noop() {}
;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
;

function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}

;
function toObject(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
;
var getValueByPath = function getValueByPath(object, prop) {
  prop = prop || '';
  var paths = prop.split('.');
  var current = object;
  var result = null;

  for (var i = 0, j = paths.length; i < j; i++) {
    var path = paths[i];
    if (!current) break;

    if (i === j - 1) {
      result = current[path];
      break;
    }

    current = current[path];
  }

  return result;
};
function getPropByPath(obj, path, strict) {
  var tempObj = obj;
  path = path.replace(/\[(\w+)\]/g, '.$1');
  path = path.replace(/^\./, '');
  var keyArr = path.split('.');
  var i = 0;

  for (var len = keyArr.length; i < len - 1; ++i) {
    if (!tempObj && !strict) break;
    var key = keyArr[i];

    if (key in tempObj) {
      tempObj = tempObj[key];
    } else {
      if (strict) {
        throw new Error('please transfer a valid prop path to form item!');
      }

      break;
    }
  }

  return {
    o: tempObj,
    k: keyArr[i],
    v: tempObj ? tempObj[keyArr[i]] : null
  };
}
;
var generateId = function generateId() {
  return Math.floor(Math.random() * 10000);
};
var valueEquals = function valueEquals(a, b) {
  // see: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript
  if (a === b) return true;
  if (!(a instanceof Array)) return false;
  if (!(b instanceof Array)) return false;
  if (a.length !== b.length) return false;

  for (var i = 0; i !== a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }

  return true;
};
var escapeRegexpString = function escapeRegexpString() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return String(value).replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
}; // TODO: use native Array.find, Array.findIndex when IE support is dropped

var arrayFindIndex = function arrayFindIndex(arr, pred) {
  for (var i = 0; i !== arr.length; ++i) {
    if (pred(arr[i])) {
      return i;
    }
  }

  return -1;
};
var arrayFind = function arrayFind(arr, pred) {
  var idx = arrayFindIndex(arr, pred);
  return idx !== -1 ? arr[idx] : undefined;
}; // coerce truthy value to array

var coerceTruthyValueToArray = function coerceTruthyValueToArray(val) {
  if (Array.isArray(val)) {
    return val;
  } else if (val) {
    return [val];
  } else {
    return [];
  }
};
var isIE = function isIE() {
  return !vue__WEBPACK_IMPORTED_MODULE_0___default.a.prototype.$isServer && !isNaN(Number(document.documentMode));
};
var isEdge = function isEdge() {
  return !vue__WEBPACK_IMPORTED_MODULE_0___default.a.prototype.$isServer && navigator.userAgent.indexOf('Edge') > -1;
};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */
try {
  var index = __webpack_require__(276);
} catch (err) {
  var index = __webpack_require__(276);
}
/**
 * Whitespace regexp.
 */


var re = /\s+/;
/**
 * toString reference.
 */

var toString = Object.prototype.toString;
/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

module.exports = function (el) {
  return new ClassList(el);
};
/**
 * Initialize a new ClassList for `el`.
 *
 * @param {Element} el
 * @api private
 */


function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error('A DOM element reference is required');
  }

  this.el = el;
  this.list = el.classList;
}
/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */


ClassList.prototype.add = function (name) {
  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  } // fallback


  var arr = this.array();
  var i = index(arr, name);
  if (!~i) arr.push(name);
  this.el.className = arr.join(' ');
  return this;
};
/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */


ClassList.prototype.remove = function (name) {
  if ('[object RegExp]' == toString.call(name)) {
    return this.removeMatching(name);
  } // classList


  if (this.list) {
    this.list.remove(name);
    return this;
  } // fallback


  var arr = this.array();
  var i = index(arr, name);
  if (~i) arr.splice(i, 1);
  this.el.className = arr.join(' ');
  return this;
};
/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */


ClassList.prototype.removeMatching = function (re) {
  var arr = this.array();

  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }

  return this;
};
/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */


ClassList.prototype.toggle = function (name, force) {
  // classList
  if (this.list) {
    if ("undefined" !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }

    return this;
  } // fallback


  if ("undefined" !== typeof force) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};
/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */


ClassList.prototype.array = function () {
  var className = this.el.getAttribute('class') || '';
  var str = className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) arr.shift();
  return arr;
};
/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */


ClassList.prototype.has = ClassList.prototype.contains = function (name) {
  return this.list ? this.list.contains(name) : !!~index(this.array(), name);
};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(157);
/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */


function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

/***/ }),
/* 75 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(533),
    getValue = __webpack_require__(536);
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function () {
  'use strict';

  function arrayTreeFilter(data, filterFn, options) {
    options = options || {};
    options.childrenKeyName = options.childrenKeyName || "children";
    var children = data || [];
    var result = [];
    var level = 0;

    do {
      var foundItem = children.filter(function (item) {
        return filterFn(item, level);
      })[0];

      if (!foundItem) {
        break;
      }

      result.push(foundItem);
      children = foundItem[options.childrenKeyName] || [];
      level += 1;
    } while (children.length > 0);

    return result;
  }

  return arrayTreeFilter;
});

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(90);

var createDesc = __webpack_require__(137);

module.exports = __webpack_require__(91) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(136);

var IE8_DOM_DEFINE = __webpack_require__(270);

var toPrimitive = __webpack_require__(198);

var dP = Object.defineProperty;
exports.f = __webpack_require__(91) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(113)(function () {
  return Object.defineProperty({}, 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(273);

var defined = __webpack_require__(199);

module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(208),
    baseAssignValue = __webpack_require__(209);
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

module.exports = copyObject;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(50),
    isKey = __webpack_require__(216),
    stringToPath = __webpack_require__(586),
    toString = __webpack_require__(589);
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */


function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(156);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(202)('wks');

var uid = __webpack_require__(140);

var _Symbol = __webpack_require__(68).Symbol;

var USE_SYMBOL = typeof _Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return wrapWithConnect; });
/* harmony import */ var babel_helper_vue_jsx_merge_props__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var babel_helper_vue_jsx_merge_props__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_helper_vue_jsx_merge_props__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _vue_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _props_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);


function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




function getDisplayName(WrappedComponent) {
  return WrappedComponent.name || 'Component';
}

function wrapWithConnect(WrappedComponent) {
  var tempProps = WrappedComponent.props || {};
  var methods = WrappedComponent.methods || {};
  var props = {};
  Object.keys(tempProps).forEach(function (k) {
    props[k] = _objectSpread({}, k, {
      required: false
    });
  });
  WrappedComponent.props.__propsSymbol__ = _vue_types__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].any;
  WrappedComponent.props.children = _vue_types__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].array.def([]);
  var ProxyWrappedComponent = {
    props: props,
    model: WrappedComponent.model,
    name: "Proxy_".concat(getDisplayName(WrappedComponent)),
    methods: {
      getProxyWrappedInstance: function getProxyWrappedInstance() {
        return this.$refs.wrappedInstance;
      }
    },
    render: function render() {
      var h = arguments[0];
      var $listeners = this.$listeners,
          _this$$slots = this.$slots,
          $slots = _this$$slots === void 0 ? {} : _this$$slots,
          $attrs = this.$attrs,
          $scopedSlots = this.$scopedSlots;
      var props = Object(_props_util__WEBPACK_IMPORTED_MODULE_2__[/* getOptionProps */ "j"])(this);
      var wrapProps = {
        props: _objectSpread({}, props, {
          __propsSymbol__: Symbol(),
          children: $slots["default"] || props.children || []
        }),
        on: $listeners,
        attrs: $attrs,
        scopedSlots: $scopedSlots
      };
      return h(WrappedComponent, babel_helper_vue_jsx_merge_props__WEBPACK_IMPORTED_MODULE_0___default()([wrapProps, {
        ref: 'wrappedInstance'
      }]), [Object.keys($slots).map(function (name) {
        return h("template", {
          slot: name
        }, [$slots[name]]);
      })]);
    }
  };
  Object.keys(methods).map(function (m) {
    ProxyWrappedComponent.methods[m] = function () {
      var _this$getProxyWrapped;

      return (_this$getProxyWrapped = this.getProxyWrappedInstance())[m].apply(_this$getProxyWrapped, arguments);
    };
  });
  return ProxyWrappedComponent;
}

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(576);

/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _util_vue_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16);
/* harmony import */ var _util_props_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1);
/* harmony import */ var _util_BaseMixin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3);
/* harmony import */ var _util_getTransitionProps__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(20);
/* harmony import */ var _util_vnode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









function noop() {}

var ICON_OPEN = 'open';
var ICON_CLOSE = 'close';
var defaultTitle = '---';
var TreeNode = {
  name: 'TreeNode',
  mixins: [_util_BaseMixin__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]],
  __ANT_TREE_NODE: true,
  props: Object(_util_props_util__WEBPACK_IMPORTED_MODULE_3__[/* initDefaultProps */ "q"])({
    eventKey: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].string,
    // Pass by parent `cloneElement`
    prefixCls: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].string,
    // className: PropTypes.string,
    root: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].object,
    // onSelect: PropTypes.func,
    // By parent
    expanded: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].bool,
    selected: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].bool,
    checked: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].bool,
    loaded: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].bool,
    loading: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].bool,
    halfChecked: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].bool,
    title: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].any,
    pos: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].string,
    dragOver: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].bool,
    dragOverGapTop: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].bool,
    dragOverGapBottom: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].bool,
    // By user
    isLeaf: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].bool,
    selectable: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].bool,
    disabled: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].bool,
    disableCheckbox: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].bool,
    icon: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].any,
    dataRef: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].object,
    switcherIcon: _util_vue_types__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].any
  }, {}),
  data: function data() {
    return {
      dragNodeHighlight: false
    };
  },
  inject: {
    vcTree: {
      "default": {}
    },
    vcTreeNode: {
      "default": {}
    }
  },
  provide: function provide() {
    return {
      vcTreeNode: this
    };
  },
  // Isomorphic needn't load data in server side
  mounted: function mounted() {
    this.syncLoadData(this.$props);
  },
  updated: function updated() {
    this.syncLoadData(this.$props);
  },
  methods: {
    onSelectorClick: function onSelectorClick(e) {
      // Click trigger before select/check operation
      var onNodeClick = this.vcTree.onNodeClick;
      onNodeClick(e, this);

      if (this.isSelectable()) {
        this.onSelect(e);
      } else {
        this.onCheck(e);
      }
    },
    onSelectorDoubleClick: function onSelectorDoubleClick(e) {
      var onNodeDoubleClick = this.vcTree.onNodeDoubleClick;
      onNodeDoubleClick(e, this);
    },
    onSelect: function onSelect(e) {
      if (this.isDisabled()) return;
      var onNodeSelect = this.vcTree.onNodeSelect;
      e.preventDefault();
      onNodeSelect(e, this);
    },
    onCheck: function onCheck(e) {
      if (this.isDisabled()) return;
      var disableCheckbox = this.disableCheckbox,
          checked = this.checked;
      var _this$vcTree = this.vcTree,
          checkable = _this$vcTree.checkable,
          onNodeCheck = _this$vcTree.onNodeCheck;
      if (!checkable || disableCheckbox) return;
      e.preventDefault();
      var targetChecked = !checked;
      onNodeCheck(e, this, targetChecked);
    },
    onMouseEnter: function onMouseEnter(e) {
      var onNodeMouseEnter = this.vcTree.onNodeMouseEnter;
      onNodeMouseEnter(e, this);
    },
    onMouseLeave: function onMouseLeave(e) {
      var onNodeMouseLeave = this.vcTree.onNodeMouseLeave;
      onNodeMouseLeave(e, this);
    },
    onContextMenu: function onContextMenu(e) {
      var onNodeContextMenu = this.vcTree.onNodeContextMenu;
      onNodeContextMenu(e, this);
    },
    onDragStart: function onDragStart(e) {
      var onNodeDragStart = this.vcTree.onNodeDragStart;
      e.stopPropagation();
      this.setState({
        dragNodeHighlight: true
      });
      onNodeDragStart(e, this);

      try {
        // ie throw error
        // firefox-need-it
        e.dataTransfer.setData('text/plain', '');
      } catch (error) {// empty
      }
    },
    onDragEnter: function onDragEnter(e) {
      var onNodeDragEnter = this.vcTree.onNodeDragEnter;
      e.preventDefault();
      e.stopPropagation();
      onNodeDragEnter(e, this);
    },
    onDragOver: function onDragOver(e) {
      var onNodeDragOver = this.vcTree.onNodeDragOver;
      e.preventDefault();
      e.stopPropagation();
      onNodeDragOver(e, this);
    },
    onDragLeave: function onDragLeave(e) {
      var onNodeDragLeave = this.vcTree.onNodeDragLeave;
      e.stopPropagation();
      onNodeDragLeave(e, this);
    },
    onDragEnd: function onDragEnd(e) {
      var onNodeDragEnd = this.vcTree.onNodeDragEnd;
      e.stopPropagation();
      this.setState({
        dragNodeHighlight: false
      });
      onNodeDragEnd(e, this);
    },
    onDrop: function onDrop(e) {
      var onNodeDrop = this.vcTree.onNodeDrop;
      e.preventDefault();
      e.stopPropagation();
      this.setState({
        dragNodeHighlight: false
      });
      onNodeDrop(e, this);
    },
    // Disabled item still can be switch
    onExpand: function onExpand(e) {
      var onNodeExpand = this.vcTree.onNodeExpand;
      onNodeExpand(e, this);
    },
    getNodeChildren: function getNodeChildren() {
      var children = this.$slots["default"];
      var originList = Object(_util_props_util__WEBPACK_IMPORTED_MODULE_3__[/* filterEmpty */ "c"])(children);

      var targetList = Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* getNodeChildren */ "j"])(originList);

      if (originList.length !== targetList.length) {
        Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* warnOnlyTreeNode */ "o"])();
      }

      return targetList;
    },
    getNodeState: function getNodeState() {
      var expanded = this.expanded;

      if (this.isLeaf2()) {
        return null;
      }

      return expanded ? ICON_OPEN : ICON_CLOSE;
    },
    isLeaf2: function isLeaf2() {
      var isLeaf = this.isLeaf,
          loaded = this.loaded;
      var loadData = this.vcTree.loadData;
      var hasChildren = this.getNodeChildren().length !== 0;

      if (isLeaf === false) {
        return false;
      }

      return isLeaf || !loadData && !hasChildren || loadData && loaded && !hasChildren;
    },
    isDisabled: function isDisabled() {
      var disabled = this.disabled;
      var treeDisabled = this.vcTree.disabled; // Follow the logic of Selectable

      if (disabled === false) {
        return false;
      }

      return !!(treeDisabled || disabled);
    },
    isSelectable: function isSelectable() {
      var selectable = this.selectable;
      var treeSelectable = this.vcTree.selectable; // Ignore when selectable is undefined or null

      if (typeof selectable === 'boolean') {
        return selectable;
      }

      return treeSelectable;
    },
    // Load data to avoid default expanded tree without data
    syncLoadData: function syncLoadData(props) {
      var expanded = props.expanded,
          loading = props.loading,
          loaded = props.loaded;
      var _this$vcTree2 = this.vcTree,
          loadData = _this$vcTree2.loadData,
          onNodeLoad = _this$vcTree2.onNodeLoad;
      if (loading) return; // read from state to avoid loadData at same time

      if (loadData && expanded && !this.isLeaf2()) {
        // We needn't reload data when has children in sync logic
        // It's only needed in node expanded
        var hasChildren = this.getNodeChildren().length !== 0;

        if (!hasChildren && !loaded) {
          onNodeLoad(this);
        }
      }
    },
    // Switcher
    renderSwitcher: function renderSwitcher() {
      var h = this.$createElement;
      var expanded = this.expanded;
      var prefixCls = this.vcTree.prefixCls;
      var switcherIcon = Object(_util_props_util__WEBPACK_IMPORTED_MODULE_3__[/* getComponentFromProp */ "g"])(this, 'switcherIcon') || Object(_util_props_util__WEBPACK_IMPORTED_MODULE_3__[/* getComponentFromProp */ "g"])(this.vcTree, 'switcherIcon');

      if (this.isLeaf2()) {
        return h("span", {
          key: 'switcher',
          "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher-noop"))
        }, [typeof switcherIcon === 'function' ? Object(_util_vnode__WEBPACK_IMPORTED_MODULE_6__[/* cloneElement */ "a"])(switcherIcon, {
          props: _objectSpread({}, this.$props, {
            isLeaf: true
          })
        }) : switcherIcon]);
      }

      var switcherCls = classnames__WEBPACK_IMPORTED_MODULE_1___default()("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher_").concat(expanded ? ICON_OPEN : ICON_CLOSE));
      return h("span", {
        key: 'switcher',
        on: {
          "click": this.onExpand
        },
        "class": switcherCls
      }, [typeof switcherIcon === 'function' ? Object(_util_vnode__WEBPACK_IMPORTED_MODULE_6__[/* cloneElement */ "a"])(switcherIcon, {
        props: _objectSpread({}, this.$props, {
          isLeaf: false
        })
      }) : switcherIcon]);
    },
    // Checkbox
    renderCheckbox: function renderCheckbox() {
      var h = this.$createElement;
      var checked = this.checked,
          halfChecked = this.halfChecked,
          disableCheckbox = this.disableCheckbox;
      var _this$vcTree3 = this.vcTree,
          prefixCls = _this$vcTree3.prefixCls,
          checkable = _this$vcTree3.checkable;
      var disabled = this.isDisabled();
      if (!checkable) return null; // [Legacy] Custom element should be separate with `checkable` in future

      var $custom = typeof checkable !== 'boolean' ? checkable : null;
      return h("span", {
        key: 'checkbox',
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()("".concat(prefixCls, "-checkbox"), checked && "".concat(prefixCls, "-checkbox-checked"), !checked && halfChecked && "".concat(prefixCls, "-checkbox-indeterminate"), (disabled || disableCheckbox) && "".concat(prefixCls, "-checkbox-disabled")),
        on: {
          "click": this.onCheck
        }
      }, [$custom]);
    },
    renderIcon: function renderIcon() {
      var h = this.$createElement;
      var loading = this.loading;
      var prefixCls = this.vcTree.prefixCls;
      return h("span", {
        key: 'icon',
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__").concat(this.getNodeState() || 'docu'), loading && "".concat(prefixCls, "-icon_loading"))
      });
    },
    // Icon + Title
    renderSelector: function renderSelector(h) {
      var selected = this.selected,
          icon = this.icon,
          loading = this.loading,
          dragNodeHighlight = this.dragNodeHighlight;
      var _this$vcTree4 = this.vcTree,
          prefixCls = _this$vcTree4.prefixCls,
          showIcon = _this$vcTree4.showIcon,
          treeIcon = _this$vcTree4.icon,
          draggable = _this$vcTree4.draggable,
          loadData = _this$vcTree4.loadData;
      var disabled = this.isDisabled();
      var title = Object(_util_props_util__WEBPACK_IMPORTED_MODULE_3__[/* getComponentFromProp */ "g"])(this, 'title') || defaultTitle;
      var wrapClass = "".concat(prefixCls, "-node-content-wrapper"); // Icon - Still show loading icon when loading without showIcon

      var $icon;

      if (showIcon) {
        var currentIcon = icon || treeIcon;
        $icon = currentIcon ? h("span", {
          "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__customize"))
        }, [typeof currentIcon === 'function' ? currentIcon(h, _objectSpread({}, this.$props)) : currentIcon]) : this.renderIcon();
      } else if (loadData && loading) {
        $icon = this.renderIcon();
      } // Title


      var $title = h("span", {
        "class": "".concat(prefixCls, "-title")
      }, [title]);
      return h("span", {
        key: 'selector',
        ref: 'selectHandle',
        attrs: {
          title: typeof title === 'string' ? title : '',
          draggable: !disabled && draggable || undefined,
          "aria-grabbed": !disabled && draggable || undefined
        },
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()("".concat(wrapClass), "".concat(wrapClass, "-").concat(this.getNodeState() || 'normal'), !disabled && (selected || dragNodeHighlight) && "".concat(prefixCls, "-node-selected"), !disabled && draggable && 'draggable'),
        on: {
          "mouseenter": this.onMouseEnter,
          "mouseleave": this.onMouseLeave,
          "contextmenu": this.onContextMenu,
          "click": this.onSelectorClick,
          "doubleclick": this.onSelectorDoubleClick,
          "dragstart": draggable ? this.onDragStart : noop
        }
      }, [$icon, $title]);
    },
    // Children list wrapped with `Animation`
    renderChildren: function renderChildren() {
      var h = this.$createElement;
      var expanded = this.expanded,
          pos = this.pos;
      var _this$vcTree5 = this.vcTree,
          prefixCls = _this$vcTree5.prefixCls,
          openTransitionName = _this$vcTree5.openTransitionName,
          openAnimation = _this$vcTree5.openAnimation,
          renderTreeNode = _this$vcTree5.renderTreeNode;
      var animProps = {};

      if (openTransitionName) {
        animProps = Object(_util_getTransitionProps__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(openTransitionName);
      } else if (_typeof(openAnimation) === 'object') {
        animProps = _objectSpread({}, openAnimation);
        animProps.props = _objectSpread({
          css: false
        }, animProps.props);
      } // Children TreeNode


      var nodeList = this.getNodeChildren();

      if (nodeList.length === 0) {
        return null;
      }

      var $children;

      if (expanded) {
        $children = h("ul", {
          "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()("".concat(prefixCls, "-child-tree"), expanded && "".concat(prefixCls, "-child-tree-open")),
          attrs: {
            "data-expanded": expanded,
            role: 'group'
          }
        }, [Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* mapChildren */ "l"])(nodeList, function (node, index) {
          return renderTreeNode(node, index, pos);
        })]);
      }

      return h("transition", animProps, [$children]);
    }
  },
  render: function render(h) {
    var _ref;

    var _this$$props = this.$props,
        dragOver = _this$$props.dragOver,
        dragOverGapTop = _this$$props.dragOverGapTop,
        dragOverGapBottom = _this$$props.dragOverGapBottom,
        isLeaf = _this$$props.isLeaf,
        expanded = _this$$props.expanded,
        selected = _this$$props.selected,
        checked = _this$$props.checked,
        halfChecked = _this$$props.halfChecked,
        loading = _this$$props.loading;
    var _this$vcTree6 = this.vcTree,
        prefixCls = _this$vcTree6.prefixCls,
        filterTreeNode = _this$vcTree6.filterTreeNode,
        draggable = _this$vcTree6.draggable;
    var disabled = this.isDisabled();
    return h("li", {
      "class": (_ref = {}, _defineProperty(_ref, "".concat(prefixCls, "-treenode-disabled"), disabled), _defineProperty(_ref, "".concat(prefixCls, "-treenode-switcher-").concat(expanded ? 'open' : 'close'), !isLeaf), _defineProperty(_ref, "".concat(prefixCls, "-treenode-checkbox-checked"), checked), _defineProperty(_ref, "".concat(prefixCls, "-treenode-checkbox-indeterminate"), halfChecked), _defineProperty(_ref, "".concat(prefixCls, "-treenode-selected"), selected), _defineProperty(_ref, "".concat(prefixCls, "-treenode-loading"), loading), _defineProperty(_ref, 'drag-over', !disabled && dragOver), _defineProperty(_ref, 'drag-over-gap-top', !disabled && dragOverGapTop), _defineProperty(_ref, 'drag-over-gap-bottom', !disabled && dragOverGapBottom), _defineProperty(_ref, 'filter-node', filterTreeNode && filterTreeNode(this)), _ref),
      attrs: {
        role: 'treeitem'
      },
      on: {
        "dragenter": draggable ? this.onDragEnter : noop,
        "dragover": draggable ? this.onDragOver : noop,
        "dragleave": draggable ? this.onDragLeave : noop,
        "drop": draggable ? this.onDrop : noop,
        "dragend": draggable ? this.onDragEnd : noop
      }
    }, [this.renderSwitcher(), this.renderCheckbox(), this.renderSelector(h), this.renderChildren()]);
  }
};
TreeNode.isTreeNode = 1;
/* harmony default export */ __webpack_exports__["a"] = (TreeNode);

/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./src/utils/js/pinyin.js
var _arguments = arguments;

var pinyin = function pinyin() {
  var Pinyin = function Pinyin(ops) {
    this.initialize(ops);
  },
      options = {
    checkPolyphone: false,
    charcase: 'default'
  };

  Pinyin.fn = Pinyin.prototype = {
    init: function init(ops) {
      this.options = extend(options, ops);
    },
    initialize: function initialize(ops) {
      this.init(ops);
      this.char_dict = 'YDYQSXMWZSSXJBYMGCCZQPSSQBYCDSCDQLDYLYBSSJGYZZJJFKCCLZDHWDWZJLJPFYYNWJJTMYHZWZHFLZPPQHGSCYYYNJQYXXGJHHSDSJNKKTMOMLCRXYPSNQSECCQZGGLLYJLMYZZSECYKYYHQWJSSGGYXYZYJWWKDJHYCHMYXJTLXJYQBYXZLDWRDJRWYSRLDZJPCBZJJBRCFTLECZSTZFXXZHTRQHYBDLYCZSSYMMRFMYQZPWWJJYFCRWFDFZQPYDDWYXKYJAWJFFXYPSFTZYHHYZYSWCJYXSCLCXXWZZXNBGNNXBXLZSZSBSGPYSYZDHMDZBQBZCWDZZYYTZHBTSYYBZGNTNXQYWQSKBPHHLXGYBFMJEBJHHGQTJCYSXSTKZHLYCKGLYSMZXYALMELDCCXGZYRJXSDLTYZCQKCNNJWHJTZZCQLJSTSTBNXBTYXCEQXGKWJYFLZQLYHYXSPSFXLMPBYSXXXYDJCZYLLLSJXFHJXPJBTFFYABYXBHZZBJYZLWLCZGGBTSSMDTJZXPTHYQTGLJSCQFZKJZJQNLZWLSLHDZBWJNCJZYZSQQYCQYRZCJJWYBRTWPYFTWEXCSKDZCTBZHYZZYYJXZCFFZZMJYXXSDZZOTTBZLQWFCKSZSXFYRLNYJMBDTHJXSQQCCSBXYYTSYFBXDZTGBCNSLCYZZPSAZYZZSCJCSHZQYDXLBPJLLMQXTYDZXSQJTZPXLCGLQTZWJBHCTSYJSFXYEJJTLBGXSXJMYJQQPFZASYJNTYDJXKJCDJSZCBARTDCLYJQMWNQNCLLLKBYBZZSYHQQLTWLCCXTXLLZNTYLNEWYZYXCZXXGRKRMTCNDNJTSYYSSDQDGHSDBJGHRWRQLYBGLXHLGTGXBQJDZPYJSJYJCTMRNYMGRZJCZGJMZMGXMPRYXKJNYMSGMZJYMKMFXMLDTGFBHCJHKYLPFMDXLQJJSMTQGZSJLQDLDGJYCALCMZCSDJLLNXDJFFFFJCZFMZFFPFKHKGDPSXKTACJDHHZDDCRRCFQYJKQCCWJDXHWJLYLLZGCFCQDSMLZPBJJPLSBCJGGDCKKDEZSQCCKJGCGKDJTJDLZYCXKLQSCGJCLTFPCQCZGWPJDQYZJJBYJHSJDZWGFSJGZKQCCZLLPSPKJGQJHZZLJPLGJGJJTHJJYJZCZMLZLYQBGJWMLJKXZDZNJQSYZMLJLLJKYWXMKJLHSKJGBMCLYYMKXJQLBMLLKMDXXKWYXYSLMLPSJQQJQXYXFJTJDXMXXLLCXQBSYJBGWYMBGGBCYXPJYGPEPFGDJGBHBNSQJYZJKJKHXQFGQZKFHYGKHDKLLSDJQXPQYKYBNQSXQNSZSWHBSXWHXWBZZXDMNSJBSBKBBZKLYLXGWXDRWYQZMYWSJQLCJXXJXKJEQXSCYETLZHLYYYSDZPAQYZCMTLSHTZCFYZYXYLJSDCJQAGYSLCQLYYYSHMRQQKLDXZSCSSSYDYCJYSFSJBFRSSZQSBXXPXJYSDRCKGJLGDKZJZBDKTCSYQPYHSTCLDJDHMXMCGXYZHJDDTMHLTXZXYLYMOHYJCLTYFBQQXPFBDFHHTKSQHZYYWCNXXCRWHOWGYJLEGWDQCWGFJYCSNTMYTOLBYGWQWESJPWNMLRYDZSZTXYQPZGCWXHNGPYXSHMYQJXZTDPPBFYHZHTJYFDZWKGKZBLDNTSXHQEEGZZYLZMMZYJZGXZXKHKSTXNXXWYLYAPSTHXDWHZYMPXAGKYDXBHNHXKDPJNMYHYLPMGOCSLNZHKXXLPZZLBMLSFBHHGYGYYGGBHSCYAQTYWLXTZQCEZYDQDQMMHTKLLSZHLSJZWFYHQSWSCWLQAZYNYTLSXTHAZNKZZSZZLAXXZWWCTGQQTDDYZTCCHYQZFLXPSLZYGPZSZNGLNDQTBDLXGTCTAJDKYWNSYZLJHHZZCWNYYZYWMHYCHHYXHJKZWSXHZYXLYSKQYSPSLYZWMYPPKBYGLKZHTYXAXQSYSHXASMCHKDSCRSWJPWXSGZJLWWSCHSJHSQNHCSEGNDAQTBAALZZMSSTDQJCJKTSCJAXPLGGXHHGXXZCXPDMMHLDGTYBYSJMXHMRCPXXJZCKZXSHMLQXXTTHXWZFKHCCZDYTCJYXQHLXDHYPJQXYLSYYDZOZJNYXQEZYSQYAYXWYPDGXDDXSPPYZNDLTWRHXYDXZZJHTCXMCZLHPYYYYMHZLLHNXMYLLLMDCPPXHMXDKYCYRDLTXJCHHZZXZLCCLYLNZSHZJZZLNNRLWHYQSNJHXYNTTTKYJPYCHHYEGKCTTWLGQRLGGTGTYGYHPYHYLQYQGCWYQKPYYYTTTTLHYHLLTYTTSPLKYZXGZWGPYDSSZZDQXSKCQNMJJZZBXYQMJRTFFBTKHZKBXLJJKDXJTLBWFZPPTKQTZTGPDGNTPJYFALQMKGXBDCLZFHZCLLLLADPMXDJHLCCLGYHDZFGYDDGCYYFGYDXKSSEBDHYKDKDKHNAXXYBPBYYHXZQGAFFQYJXDMLJCSQZLLPCHBSXGJYNDYBYQSPZWJLZKSDDTACTBXZDYZYPJZQSJNKKTKNJDJGYYPGTLFYQKASDNTCYHBLWDZHBBYDWJRYGKZYHEYYFJMSDTYFZJJHGCXPLXHLDWXXJKYTCYKSSSMTWCTTQZLPBSZDZWZXGZAGYKTYWXLHLSPBCLLOQMMZSSLCMBJCSZZKYDCZJGQQDSMCYTZQQLWZQZXSSFPTTFQMDDZDSHDTDWFHTDYZJYQJQKYPBDJYYXTLJHDRQXXXHAYDHRJLKLYTWHLLRLLRCXYLBWSRSZZSYMKZZHHKYHXKSMDSYDYCJPBZBSQLFCXXXNXKXWYWSDZYQOGGQMMYHCDZTTFJYYBGSTTTYBYKJDHKYXBELHTYPJQNFXFDYKZHQKZBYJTZBXHFDXKDASWTAWAJLDYJSFHBLDNNTNQJTJNCHXFJSRFWHZFMDRYJYJWZPDJKZYJYMPCYZNYNXFBYTFYFWYGDBNZZZDNYTXZEMMQBSQEHXFZMBMFLZZSRXYMJGSXWZJSPRYDJSJGXHJJGLJJYNZZJXHGXKYMLPYYYCXYTWQZSWHWLYRJLPXSLSXMFSWWKLCTNXNYNPSJSZHDZEPTXMYYWXYYSYWLXJQZQXZDCLEEELMCPJPCLWBXSQHFWWTFFJTNQJHJQDXHWLBYZNFJLALKYYJLDXHHYCSTYYWNRJYXYWTRMDRQHWQCMFJDYZMHMYYXJWMYZQZXTLMRSPWWCHAQBXYGZYPXYYRRCLMPYMGKSJSZYSRMYJSNXTPLNBAPPYPYLXYYZKYNLDZYJZCZNNLMZHHARQMPGWQTZMXXMLLHGDZXYHXKYXYCJMFFYYHJFSBSSQLXXNDYCANNMTCJCYPRRNYTYQNYYMBMSXNDLYLYSLJRLXYSXQMLLYZLZJJJKYZZCSFBZXXMSTBJGNXYZHLXNMCWSCYZYFZLXBRNNNYLBNRTGZQYSATSWRYHYJZMZDHZGZDWYBSSCSKXSYHYTXXGCQGXZZSHYXJSCRHMKKBXCZJYJYMKQHZJFNBHMQHYSNJNZYBKNQMCLGQHWLZNZSWXKHLJHYYBQLBFCDSXDLDSPFZPSKJYZWZXZDDXJSMMEGJSCSSMGCLXXKYYYLNYPWWWGYDKZJGGGZGGSYCKNJWNJPCXBJJTQTJWDSSPJXZXNZXUMELPXFSXTLLXCLJXJJLJZXCTPSWXLYDHLYQRWHSYCSQYYBYAYWJJJQFWQCQQCJQGXALDBZZYJGKGXPLTZYFXJLTPADKYQHPMATLCPDCKBMTXYBHKLENXDLEEGQDYMSAWHZMLJTWYGXLYQZLJEEYYBQQFFNLYXRDSCTGJGXYYNKLLYQKCCTLHJLQMKKZGCYYGLLLJDZGYDHZWXPYSJBZKDZGYZZHYWYFQYTYZSZYEZZLYMHJJHTSMQWYZLKYYWZCSRKQYTLTDXWCTYJKLWSQZWBDCQYNCJSRSZJLKCDCDTLZZZACQQZZDDXYPLXZBQJYLZLLLQDDZQJYJYJZYXNYYYNYJXKXDAZWYRDLJYYYRJLXLLDYXJCYWYWNQCCLDDNYYYNYCKCZHXXCCLGZQJGKWPPCQQJYSBZZXYJSQPXJPZBSBDSFNSFPZXHDWZTDWPPTFLZZBZDMYYPQJRSDZSQZSQXBDGCPZSWDWCSQZGMDHZXMWWFYBPDGPHTMJTHZSMMBGZMBZJCFZWFZBBZMQCFMBDMCJXLGPNJBBXGYHYYJGPTZGZMQBQTCGYXJXLWZKYDPDYMGCFTPFXYZTZXDZXTGKMTYBBCLBJASKYTSSQYYMSZXFJEWLXLLSZBQJJJAKLYLXLYCCTSXMCWFKKKBSXLLLLJYXTYLTJYYTDPJHNHNNKBYQNFQYYZBYYESSESSGDYHFHWTCJBSDZZTFDMXHCNJZYMQWSRYJDZJQPDQBBSTJGGFBKJBXTGQHNGWJXJGDLLTHZHHYYYYYYSXWTYYYCCBDBPYPZYCCZYJPZYWCBDLFWZCWJDXXHYHLHWZZXJTCZLCDPXUJCZZZLYXJJTXPHFXWPYWXZPTDZZBDZCYHJHMLXBQXSBYLRDTGJRRCTTTHYTCZWMXFYTWWZCWJWXJYWCSKYBZSCCTZQNHXNWXXKHKFHTSWOCCJYBCMPZZYKBNNZPBZHHZDLSYDDYTYFJPXYNGFXBYQXCBHXCPSXTYZDMKYSNXSXLHKMZXLYHDHKWHXXSSKQYHHCJYXGLHZXCSNHEKDTGZXQYPKDHEXTYKCNYMYYYPKQYYYKXZLTHJQTBYQHXBMYHSQCKWWYLLHCYYLNNEQXQWMCFBDCCMLJGGXDQKTLXKGNQCDGZJWYJJLYHHQTTTNWCHMXCXWHWSZJYDJCCDBQCDGDNYXZTHCQRXCBHZTQCBXWGQWYYBXHMBYMYQTYEXMQKYAQYRGYZSLFYKKQHYSSQYSHJGJCNXKZYCXSBXYXHYYLSTYCXQTHYSMGSCPMMGCCCCCMTZTASMGQZJHKLOSQYLSWTMXSYQKDZLJQQYPLSYCZTCQQPBBQJZCLPKHQZYYXXDTDDTSJCXFFLLCHQXMJLWCJCXTSPYCXNDTJSHJWXDQQJSKXYAMYLSJHMLALYKXCYYDMNMDQMXMCZNNCYBZKKYFLMCHCMLHXRCJJHSYLNMTJZGZGYWJXSRXCWJGJQHQZDQJDCJJZKJKGDZQGJJYJYLXZXXCDQHHHEYTMHLFSBDJSYYSHFYSTCZQLPBDRFRZTZYKYWHSZYQKWDQZRKMSYNBCRXQBJYFAZPZZEDZCJYWBCJWHYJBQSZYWRYSZPTDKZPFPBNZTKLQYHBBZPNPPTYZZYBQNYDCPJMMCYCQMCYFZZDCMNLFPBPLNGQJTBTTNJZPZBBZNJKLJQYLNBZQHKSJZNGGQSZZKYXSHPZSNBCGZKDDZQANZHJKDRTLZLSWJLJZLYWTJNDJZJHXYAYNCBGTZCSSQMNJPJYTYSWXZFKWJQTKHTZPLBHSNJZSYZBWZZZZLSYLSBJHDWWQPSLMMFBJDWAQYZTCJTBNNWZXQXCDSLQGDSDPDZHJTQQPSWLYYJZLGYXYZLCTCBJTKTYCZJTQKBSJLGMGZDMCSGPYNJZYQYYKNXRPWSZXMTNCSZZYXYBYHYZAXYWQCJTLLCKJJTJHGDXDXYQYZZBYWDLWQCGLZGJGQRQZCZSSBCRPCSKYDZNXJSQGXSSJMYDNSTZTPBDLTKZWXQWQTZEXNQCZGWEZKSSBYBRTSSSLCCGBPSZQSZLCCGLLLZXHZQTHCZMQGYZQZNMCOCSZJMMZSQPJYGQLJYJPPLDXRGZYXCCSXHSHGTZNLZWZKJCXTCFCJXLBMQBCZZWPQDNHXLJCTHYZLGYLNLSZZPCXDSCQQHJQKSXZPBAJYEMSMJTZDXLCJYRYYNWJBNGZZTMJXLTBSLYRZPYLSSCNXPHLLHYLLQQZQLXYMRSYCXZLMMCZLTZSDWTJJLLNZGGQXPFSKYGYGHBFZPDKMWGHCXMSGDXJMCJZDYCABXJDLNBCDQYGSKYDQTXDJJYXMSZQAZDZFSLQXYJSJZYLBTXXWXQQZBJZUFBBLYLWDSLJHXJYZJWTDJCZFQZQZZDZSXZZQLZCDZFJHYSPYMPQZMLPPLFFXJJNZZYLSJEYQZFPFZKSYWJJJHRDJZZXTXXGLGHYDXCSKYSWMMZCWYBAZBJKSHFHJCXMHFQHYXXYZFTSJYZFXYXPZLCHMZMBXHZZSXYFYMNCWDABAZLXKTCSHHXKXJJZJSTHYGXSXYYHHHJWXKZXSSBZZWHHHCWTZZZPJXSNXQQJGZYZYWLLCWXZFXXYXYHXMKYYSWSQMNLNAYCYSPMJKHWCQHYLAJJMZXHMMCNZHBHXCLXTJPLTXYJHDYYLTTXFSZHYXXSJBJYAYRSMXYPLCKDUYHLXRLNLLSTYZYYQYGYHHSCCSMZCTZQXKYQFPYYRPFFLKQUNTSZLLZMWWTCQQYZWTLLMLMPWMBZSSTZRBPDDTLQJJBXZCSRZQQYGWCSXFWZLXCCRSZDZMCYGGDZQSGTJSWLJMYMMZYHFBJDGYXCCPSHXNZCSBSJYJGJMPPWAFFYFNXHYZXZYLREMZGZCYZSSZDLLJCSQFNXZKPTXZGXJJGFMYYYSNBTYLBNLHPFZDCYFBMGQRRSSSZXYSGTZRNYDZZCDGPJAFJFZKNZBLCZSZPSGCYCJSZLMLRSZBZZLDLSLLYSXSQZQLYXZLSKKBRXBRBZCYCXZZZEEYFGKLZLYYHGZSGZLFJHGTGWKRAAJYZKZQTSSHJJXDCYZUYJLZYRZDQQHGJZXSSZBYKJPBFRTJXLLFQWJHYLQTYMBLPZDXTZYGBDHZZRBGXHWNJTJXLKSCFSMWLSDQYSJTXKZSCFWJLBXFTZLLJZLLQBLSQMQQCGCZFPBPHZCZJLPYYGGDTGWDCFCZQYYYQYSSCLXZSKLZZZGFFCQNWGLHQYZJJCZLQZZYJPJZZBPDCCMHJGXDQDGDLZQMFGPSYTSDYFWWDJZJYSXYYCZCYHZWPBYKXRYLYBHKJKSFXTZJMMCKHLLTNYYMSYXYZPYJQYCSYCWMTJJKQYRHLLQXPSGTLYYCLJSCPXJYZFNMLRGJJTYZBXYZMSJYJHHFZQMSYXRSZCWTLRTQZSSTKXGQKGSPTGCZNJSJCQCXHMXGGZTQYDJKZDLBZSXJLHYQGGGTHQSZPYHJHHGYYGKGGCWJZZYLCZLXQSFTGZSLLLMLJSKCTBLLZZSZMMNYTPZSXQHJCJYQXYZXZQZCPSHKZZYSXCDFGMWQRLLQXRFZTLYSTCTMJCXJJXHJNXTNRZTZFQYHQGLLGCXSZSJDJLJCYDSJTLNYXHSZXCGJZYQPYLFHDJSBPCCZHJJJQZJQDYBSSLLCMYTTMQTBHJQNNYGKYRQYQMZGCJKPDCGMYZHQLLSLLCLMHOLZGDYYFZSLJCQZLYLZQJESHNYLLJXGJXLYSYYYXNBZLJSSZCQQCJYLLZLTJYLLZLLBNYLGQCHXYYXOXCXQKYJXXXYKLXSXXYQXCYKQXQCSGYXXYQXYGYTQOHXHXPYXXXULCYEYCHZZCBWQBBWJQZSCSZSSLZYLKDESJZWMYMCYTSDSXXSCJPQQSQYLYYZYCMDJDZYWCBTJSYDJKCYDDJLBDJJSODZYSYXQQYXDHHGQQYQHDYXWGMMMAJDYBBBPPBCMUUPLJZSMTXERXJMHQNUTPJDCBSSMSSSTKJTSSMMTRCPLZSZMLQDSDMJMQPNQDXCFYNBFSDQXYXHYAYKQYDDLQYYYSSZBYDSLNTFQTZQPZMCHDHCZCWFDXTMYQSPHQYYXSRGJCWTJTZZQMGWJJTJHTQJBBHWZPXXHYQFXXQYWYYHYSCDYDHHQMNMTMWCPBSZPPZZGLMZFOLLCFWHMMSJZTTDHZZYFFYTZZGZYSKYJXQYJZQBHMBZZLYGHGFMSHPZFZSNCLPBQSNJXZSLXXFPMTYJYGBXLLDLXPZJYZJYHHZCYWHJYLSJEXFSZZYWXKZJLUYDTMLYMQJPWXYHXSKTQJEZRPXXZHHMHWQPWQLYJJQJJZSZCPHJLCHHNXJLQWZJHBMZYXBDHHYPZLHLHLGFWLCHYYTLHJXCJMSCPXSTKPNHQXSRTYXXTESYJCTLSSLSTDLLLWWYHDHRJZSFGXTSYCZYNYHTDHWJSLHTZDQDJZXXQHGYLTZPHCSQFCLNJTCLZPFSTPDYNYLGMJLLYCQHYSSHCHYLHQYQTMZYPBYWRFQYKQSYSLZDQJMPXYYSSRHZJNYWTQDFZBWWTWWRXCWHGYHXMKMYYYQMSMZHNGCEPMLQQMTCWCTMMPXJPJJHFXYYZSXZHTYBMSTSYJTTQQQYYLHYNPYQZLCYZHZWSMYLKFJXLWGXYPJYTYSYXYMZCKTTWLKSMZSYLMPWLZWXWQZSSAQSYXYRHSSNTSRAPXCPWCMGDXHXZDZYFJHGZTTSBJHGYZSZYSMYCLLLXBTYXHBBZJKSSDMALXHYCFYGMQYPJYCQXJLLLJGSLZGQLYCJCCZOTYXMTMTTLLWTGPXYMZMKLPSZZZXHKQYSXCTYJZYHXSHYXZKXLZWPSQPYHJWPJPWXQQYLXSDHMRSLZZYZWTTCYXYSZZSHBSCCSTPLWSSCJCHNLCGCHSSPHYLHFHHXJSXYLLNYLSZDHZXYLSXLWZYKCLDYAXZCMDDYSPJTQJZLNWQPSSSWCTSTSZLBLNXSMNYYMJQBQHRZWTYYDCHQLXKPZWBGQYBKFCMZWPZLLYYLSZYDWHXPSBCMLJBSCGBHXLQHYRLJXYSWXWXZSLDFHLSLYNJLZYFLYJYCDRJLFSYZFSLLCQYQFGJYHYXZLYLMSTDJCYHBZLLNWLXXYGYYHSMGDHXXHHLZZJZXCZZZCYQZFNGWPYLCPKPYYPMCLQKDGXZGGWQBDXZZKZFBXXLZXJTPJPTTBYTSZZDWSLCHZHSLTYXHQLHYXXXYYZYSWTXZKHLXZXZPYHGCHKCFSYHUTJRLXFJXPTZTWHPLYXFCRHXSHXKYXXYHZQDXQWULHYHMJTBFLKHTXCWHJFWJCFPQRYQXCYYYQYGRPYWSGSUNGWCHKZDXYFLXXHJJBYZWTSXXNCYJJYMSWZJQRMHXZWFQSYLZJZGBHYNSLBGTTCSYBYXXWXYHXYYXNSQYXMQYWRGYQLXBBZLJSYLPSYTJZYHYZAWLRORJMKSCZJXXXYXCHDYXRYXXJDTSQFXLYLTSFFYXLMTYJMJUYYYXLTZCSXQZQHZXLYYXZHDNBRXXXJCTYHLBRLMBRLLAXKYLLLJLYXXLYCRYLCJTGJCMTLZLLCYZZPZPCYAWHJJFYBDYYZSMPCKZDQYQPBPCJPDCYZMDPBCYYDYCNNPLMTMLRMFMMGWYZBSJGYGSMZQQQZTXMKQWGXLLPJGZBQCDJJJFPKJKCXBLJMSWMDTQJXLDLPPBXCWRCQFBFQJCZAHZGMYKPHYYHZYKNDKZMBPJYXPXYHLFPNYYGXJDBKXNXHJMZJXSTRSTLDXSKZYSYBZXJLXYSLBZYSLHXJPFXPQNBYLLJQKYGZMCYZZYMCCSLCLHZFWFWYXZMWSXTYNXJHPYYMCYSPMHYSMYDYSHQYZCHMJJMZCAAGCFJBBHPLYZYLXXSDJGXDHKXXTXXNBHRMLYJSLTXMRHNLXQJXYZLLYSWQGDLBJHDCGJYQYCMHWFMJYBMBYJYJWYMDPWHXQLDYGPDFXXBCGJSPCKRSSYZJMSLBZZJFLJJJLGXZGYXYXLSZQYXBEXYXHGCXBPLDYHWETTWWCJMBTXCHXYQXLLXFLYXLLJLSSFWDPZSMYJCLMWYTCZPCHQEKCQBWLCQYDPLQPPQZQFJQDJHYMMCXTXDRMJWRHXCJZYLQXDYYNHYYHRSLSRSYWWZJYMTLTLLGTQCJZYABTCKZCJYCCQLJZQXALMZYHYWLWDXZXQDLLQSHGPJFJLJHJABCQZDJGTKHSSTCYJLPSWZLXZXRWGLDLZRLZXTGSLLLLZLYXXWGDZYGBDPHZPBRLWSXQBPFDWOFMWHLYPCBJCCLDMBZPBZZLCYQXLDOMZBLZWPDWYYGDSTTHCSQSCCRSSSYSLFYBFNTYJSZDFNDPDHDZZMBBLSLCMYFFGTJJQWFTMTPJWFNLBZCMMJTGBDZLQLPYFHYYMJYLSDCHDZJWJCCTLJCLDTLJJCPDDSQDSSZYBNDBJLGGJZXSXNLYCYBJXQYCBYLZCFZPPGKCXZDZFZTJJFJSJXZBNZYJQTTYJYHTYCZHYMDJXTTMPXSPLZCDWSLSHXYPZGTFMLCJTYCBPMGDKWYCYZCDSZZYHFLYCTYGWHKJYYLSJCXGYWJCBLLCSNDDBTZBSCLYZCZZSSQDLLMQYYHFSLQLLXFTYHABXGWNYWYYPLLSDLDLLBJCYXJZMLHLJDXYYQYTDLLLBUGBFDFBBQJZZMDPJHGCLGMJJPGAEHHBWCQXAXHHHZCHXYPHJAXHLPHJPGPZJQCQZGJJZZUZDMQYYBZZPHYHYBWHAZYJHYKFGDPFQSDLZMLJXKXGALXZDAGLMDGXMWZQYXXDXXPFDMMSSYMPFMDMMKXKSYZYSHDZKXSYSMMZZZMSYDNZZCZXFPLSTMZDNMXCKJMZTYYMZMZZMSXHHDCZJEMXXKLJSTLWLSQLYJZLLZJSSDPPMHNLZJCZYHMXXHGZCJMDHXTKGRMXFWMCGMWKDTKSXQMMMFZZYDKMSCLCMPCGMHSPXQPZDSSLCXKYXTWLWJYAHZJGZQMCSNXYYMMPMLKJXMHLMLQMXCTKZMJQYSZJSYSZHSYJZJCDAJZYBSDQJZGWZQQXFKDMSDJLFWEHKZQKJPEYPZYSZCDWYJFFMZZYLTTDZZEFMZLBNPPLPLPEPSZALLTYLKCKQZKGENQLWAGYXYDPXLHSXQQWQCQXQCLHYXXMLYCCWLYMQYSKGCHLCJNSZKPYZKCQZQLJPDMDZHLASXLBYDWQLWDNBQCRYDDZTJYBKBWSZDXDTNPJDTCTQDFXQQMGNXECLTTBKPWSLCTYQLPWYZZKLPYGZCQQPLLKCCYLPQMZCZQCLJSLQZDJXLDDHPZQDLJJXZQDXYZQKZLJCYQDYJPPYPQYKJYRMPCBYMCXKLLZLLFQPYLLLMBSGLCYSSLRSYSQTMXYXZQZFDZUYSYZTFFMZZSMZQHZSSCCMLYXWTPZGXZJGZGSJSGKDDHTQGGZLLBJDZLCBCHYXYZHZFYWXYZYMSDBZZYJGTSMTFXQYXQSTDGSLNXDLRYZZLRYYLXQHTXSRTZNGZXBNQQZFMYKMZJBZYMKBPNLYZPBLMCNQYZZZSJZHJCTZKHYZZJRDYZHNPXGLFZTLKGJTCTSSYLLGZRZBBQZZKLPKLCZYSSUYXBJFPNJZZXCDWXZYJXZZDJJKGGRSRJKMSMZJLSJYWQSKYHQJSXPJZZZLSNSHRNYPZTWCHKLPSRZLZXYJQXQKYSJYCZTLQZYBBYBWZPQDWWYZCYTJCJXCKCWDKKZXSGKDZXWWYYJQYYTCYTDLLXWKCZKKLCCLZCQQDZLQLCSFQCHQHSFSMQZZLNBJJZBSJHTSZDYSJQJPDLZCDCWJKJZZLPYCGMZWDJJBSJQZSYZYHHXJPBJYDSSXDZNCGLQMBTSFSBPDZDLZNFGFJGFSMPXJQLMBLGQCYYXBQKDJJQYRFKZTJDHCZKLBSDZCFJTPLLJGXHYXZCSSZZXSTJYGKGCKGYOQXJPLZPBPGTGYJZGHZQZZLBJLSQFZGKQQJZGYCZBZQTLDXRJXBSXXPZXHYZYCLWDXJJHXMFDZPFZHQHQMQGKSLYHTYCGFRZGNQXCLPDLBZCSCZQLLJBLHBZCYPZZPPDYMZZSGYHCKCPZJGSLJLNSCDSLDLXBMSTLDDFJMKDJDHZLZXLSZQPQPGJLLYBDSZGQLBZLSLKYYHZTTNTJYQTZZPSZQZTLLJTYYLLQLLQYZQLBDZLSLYYZYMDFSZSNHLXZNCZQZPBWSKRFBSYZMTHBLGJPMCZZLSTLXSHTCSYZLZBLFEQHLXFLCJLYLJQCBZLZJHHSSTBRMHXZHJZCLXFNBGXGTQJCZTMSFZKJMSSNXLJKBHSJXNTNLZDNTLMSJXGZJYJCZXYJYJWRWWQNZTNFJSZPZSHZJFYRDJSFSZJZBJFZQZZHZLXFYSBZQLZSGYFTZDCSZXZJBQMSZKJRHYJZCKMJKHCHGTXKXQGLXPXFXTRTYLXJXHDTSJXHJZJXZWZLCQSBTXWXGXTXXHXFTSDKFJHZYJFJXRZSDLLLTQSQQZQWZXSYQTWGWBZCGZLLYZBCLMQQTZHZXZXLJFRMYZFLXYSQXXJKXRMQDZDMMYYBSQBHGZMWFWXGMXLZPYYTGZYCCDXYZXYWGSYJYZNBHPZJSQSYXSXRTFYZGRHZTXSZZTHCBFCLSYXZLZQMZLMPLMXZJXSFLBYZMYQHXJSXRXSQZZZSSLYFRCZJRCRXHHZXQYDYHXSJJHZCXZBTYNSYSXJBQLPXZQPYMLXZKYXLXCJLCYSXXZZLXDLLLJJYHZXGYJWKJRWYHCPSGNRZLFZWFZZNSXGXFLZSXZZZBFCSYJDBRJKRDHHGXJLJJTGXJXXSTJTJXLYXQFCSGSWMSBCTLQZZWLZZKXJMLTMJYHSDDBXGZHDLBMYJFRZFSGCLYJBPMLYSMSXLSZJQQHJZFXGFQFQBPXZGYYQXGZTCQWYLTLGWSGWHRLFSFGZJMGMGBGTJFSYZZGZYZAFLSSPMLPFLCWBJZCLJJMZLPJJLYMQDMYYYFBGYGYZMLYZDXQYXRQQQHSYYYQXYLJTYXFSFSLLGNQCYHYCWFHCCCFXPYLYPLLZYXXXXXKQHHXSHJZCFZSCZJXCPZWHHHHHAPYLQALPQAFYHXDYLUKMZQGGGDDESRNNZLTZGCHYPPYSQJJHCLLJTOLNJPZLJLHYMHEYDYDSQYCDDHGZUNDZCLZYZLLZNTNYZGSLHSLPJJBDGWXPCDUTJCKLKCLWKLLCASSTKZZDNQNTTLYYZSSYSSZZRYLJQKCQDHHCRXRZYDGRGCWCGZQFFFPPJFZYNAKRGYWYQPQXXFKJTSZZXSWZDDFBBXTBGTZKZNPZZPZXZPJSZBMQHKCYXYLDKLJNYPKYGHGDZJXXEAHPNZKZTZCMXCXMMJXNKSZQNMNLWBWWXJKYHCPSTMCSQTZJYXTPCTPDTNNPGLLLZSJLSPBLPLQHDTNJNLYYRSZFFJFQWDPHZDWMRZCCLODAXNSSNYZRESTYJWJYJDBCFXNMWTTBYLWSTSZGYBLJPXGLBOCLHPCBJLTMXZLJYLZXCLTPNCLCKXTPZJSWCYXSFYSZDKNTLBYJCYJLLSTGQCBXRYZXBXKLYLHZLQZLNZCXWJZLJZJNCJHXMNZZGJZZXTZJXYCYYCXXJYYXJJXSSSJSTSSTTPPGQTCSXWZDCSYFPTFBFHFBBLZJCLZZDBXGCXLQPXKFZFLSYLTUWBMQJHSZBMDDBCYSCCLDXYCDDQLYJJWMQLLCSGLJJSYFPYYCCYLTJANTJJPWYCMMGQYYSXDXQMZHSZXPFTWWZQSWQRFKJLZJQQYFBRXJHHFWJJZYQAZMYFRHCYYBYQWLPEXCCZSTYRLTTDMQLYKMBBGMYYJPRKZNPBSXYXBHYZDJDNGHPMFSGMWFZMFQMMBCMZZCJJLCNUXYQLMLRYGQZCYXZLWJGCJCGGMCJNFYZZJHYCPRRCMTZQZXHFQGTJXCCJEAQCRJYHPLQLSZDJRBCQHQDYRHYLYXJSYMHZYDWLDFRYHBPYDTSSCNWBXGLPZMLZZTQSSCPJMXXYCSJYTYCGHYCJWYRXXLFEMWJNMKLLSWTXHYYYNCMMCWJDQDJZGLLJWJRKHPZGGFLCCSCZMCBLTBHBQJXQDSPDJZZGKGLFQYWBZYZJLTSTDHQHCTCBCHFLQMPWDSHYYTQWCNZZJTLBYMBPDYYYXSQKXWYYFLXXNCWCXYPMAELYKKJMZZZBRXYYQJFLJPFHHHYTZZXSGQQMHSPGDZQWBWPJHZJDYSCQWZKTXXSQLZYYMYSDZGRXCKKUJLWPYSYSCSYZLRMLQSYLJXBCXTLWDQZPCYCYKPPPNSXFYZJJRCEMHSZMSXLXGLRWGCSTLRSXBZGBZGZTCPLUJLSLYLYMTXMTZPALZXPXJTJWTCYYZLBLXBZLQMYLXPGHDSLSSDMXMBDZZSXWHAMLCZCPJMCNHJYSNSYGCHSKQMZZQDLLKABLWJXSFMOCDXJRRLYQZKJMYBYQLYHETFJZFRFKSRYXFJTWDSXXSYSQJYSLYXWJHSNLXYYXHBHAWHHJZXWMYLJCSSLKYDZTXBZSYFDXGXZJKHSXXYBSSXDPYNZWRPTQZCZENYGCXQFJYKJBZMLJCMQQXUOXSLYXXLYLLJDZBTYMHPFSTTQQWLHOKYBLZZALZXQLHZWRRQHLSTMYPYXJJXMQSJFNBXYXYJXXYQYLTHYLQYFMLKLJTMLLHSZWKZHLJMLHLJKLJSTLQXYLMBHHLNLZXQJHXCFXXLHYHJJGBYZZKBXSCQDJQDSUJZYYHZHHMGSXCSYMXFEBCQWWRBPYYJQTYZCYQYQQZYHMWFFHGZFRJFCDPXNTQYZPDYKHJLFRZXPPXZDBBGZQSTLGDGYLCQMLCHHMFYWLZYXKJLYPQHSYWMQQGQZMLZJNSQXJQSYJYCBEHSXFSZPXZWFLLBCYYJDYTDTHWZSFJMQQYJLMQXXLLDTTKHHYBFPWTYYSQQWNQWLGWDEBZWCMYGCULKJXTMXMYJSXHYBRWFYMWFRXYQMXYSZTZZTFYKMLDHQDXWYYNLCRYJBLPSXCXYWLSPRRJWXHQYPHTYDNXHHMMYWYTZCSQMTSSCCDALWZTCPQPYJLLQZYJSWXMZZMMYLMXCLMXCZMXMZSQTZPPQQBLPGXQZHFLJJHYTJSRXWZXSCCDLXTYJDCQJXSLQYCLZXLZZXMXQRJMHRHZJBHMFLJLMLCLQNLDXZLLLPYPSYJYSXCQQDCMQJZZXHNPNXZMEKMXHYKYQLXSXTXJYYHWDCWDZHQYYBGYBCYSCFGPSJNZDYZZJZXRZRQJJYMCANYRJTLDPPYZBSTJKXXZYPFDWFGZZRPYMTNGXZQBYXNBUFNQKRJQZMJEGRZGYCLKXZDSKKNSXKCLJSPJYYZLQQJYBZSSQLLLKJXTBKTYLCCDDBLSPPFYLGYDTZJYQGGKQTTFZXBDKTYYHYBBFYTYYBCLPDYTGDHRYRNJSPTCSNYJQHKLLLZSLYDXXWBCJQSPXBPJZJCJDZFFXXBRMLAZHCSNDLBJDSZBLPRZTSWSBXBCLLXXLZDJZSJPYLYXXYFTFFFBHJJXGBYXJPMMMPSSJZJMTLYZJXSWXTYLEDQPJMYGQZJGDJLQJWJQLLSJGJGYGMSCLJJXDTYGJQJQJCJZCJGDZZSXQGSJGGCXHQXSNQLZZBXHSGZXCXYLJXYXYYDFQQJHJFXDHCTXJYRXYSQTJXYEFYYSSYYJXNCYZXFXMSYSZXYYSCHSHXZZZGZZZGFJDLTYLNPZGYJYZYYQZPBXQBDZTZCZYXXYHHSQXSHDHGQHJHGYWSZTMZMLHYXGEBTYLZKQWYTJZRCLEKYSTDBCYKQQSAYXCJXWWGSBHJYZYDHCSJKQCXSWXFLTYNYZPZCCZJQTZWJQDZZZQZLJJXLSBHPYXXPSXSHHEZTXFPTLQYZZXHYTXNCFZYYHXGNXMYWXTZSJPTHHGYMXMXQZXTSBCZYJYXXTYYZYPCQLMMSZMJZZLLZXGXZAAJZYXJMZXWDXZSXZDZXLEYJJZQBHZWZZZQTZPSXZTDSXJJJZNYAZPHXYYSRNQDTHZHYYKYJHDZXZLSWCLYBZYECWCYCRYLCXNHZYDZYDYJDFRJJHTRSQTXYXJRJHOJYNXELXSFSFJZGHPZSXZSZDZCQZBYYKLSGSJHCZSHDGQGXYZGXCHXZJWYQWGYHKSSEQZZNDZFKWYSSTCLZSTSYMCDHJXXYWEYXCZAYDMPXMDSXYBSQMJMZJMTZQLPJYQZCGQHXJHHLXXHLHDLDJQCLDWBSXFZZYYSCHTYTYYBHECXHYKGJPXHHYZJFXHWHBDZFYZBCAPNPGNYDMSXHMMMMAMYNBYJTMPXYYMCTHJBZYFCGTYHWPHFTWZZEZSBZEGPFMTSKFTYCMHFLLHGPZJXZJGZJYXZSBBQSCZZLZCCSTPGXMJSFTCCZJZDJXCYBZLFCJSYZFGSZLYBCWZZBYZDZYPSWYJZXZBDSYUXLZZBZFYGCZXBZHZFTPBGZGEJBSTGKDMFHYZZJHZLLZZGJQZLSFDJSSCBZGPDLFZFZSZYZYZSYGCXSNXXCHCZXTZZLJFZGQSQYXZJQDCCZTQCDXZJYQJQCHXZTDLGSCXZSYQJQTZWLQDQZTQCHQQJZYEZZZPBWKDJFCJPZTYPQYQTTYNLMBDKTJZPQZQZZFPZSBNJLGYJDXJDZZKZGQKXDLPZJTCJDQBXDJQJSTCKNXBXZMSLYJCQMTJQWWCJQNJNLLLHJCWQTBZQYDZCZPZZDZYDDCYZZZCCJTTJFZDPRRTZTJDCQTQZDTJNPLZBCLLCTZSXKJZQZPZLBZRBTJDCXFCZDBCCJJLTQQPLDCGZDBBZJCQDCJWYNLLZYZCCDWLLXWZLXRXNTQQCZXKQLSGDFQTDDGLRLAJJTKUYMKQLLTZYTDYYCZGJWYXDXFRSKSTQTENQMRKQZHHQKDLDAZFKYPBGGPZREBZZYKZZSPEGJXGYKQZZZSLYSYYYZWFQZYLZZLZHWCHKYPQGNPGBLPLRRJYXCCSYYHSFZFYBZYYTGZXYLXCZWXXZJZBLFFLGSKHYJZEYJHLPLLLLCZGXDRZELRHGKLZZYHZLYQSZZJZQLJZFLNBHGWLCZCFJYSPYXZLZLXGCCPZBLLCYBBBBUBBCBPCRNNZCZYRBFSRLDCGQYYQXYGMQZWTZYTYJXYFWTEHZZJYWLCCNTZYJJZDEDPZDZTSYQJHDYMBJNYJZLXTSSTPHNDJXXBYXQTZQDDTJTDYYTGWSCSZQFLSHLGLBCZPHDLYZJYCKWTYTYLBNYTSDSYCCTYSZYYEBHEXHQDTWNYGYCLXTSZYSTQMYGZAZCCSZZDSLZCLZRQXYYELJSBYMXSXZTEMBBLLYYLLYTDQYSHYMRQWKFKBFXNXSBYCHXBWJYHTQBPBSBWDZYLKGZSKYHXQZJXHXJXGNLJKZLYYCDXLFYFGHLJGJYBXQLYBXQPQGZTZPLNCYPXDJYQYDYMRBESJYYHKXXSTMXRCZZYWXYQYBMCLLYZHQYZWQXDBXBZWZMSLPDMYSKFMZKLZCYQYCZLQXFZZYDQZPZYGYJYZMZXDZFYFYTTQTZHGSPCZMLCCYTZXJCYTJMKSLPZHYSNZLLYTPZCTZZCKTXDHXXTQCYFKSMQCCYYAZHTJPCYLZLYJBJXTPNYLJYYNRXSYLMMNXJSMYBCSYSYLZYLXJJQYLDZLPQBFZZBLFNDXQKCZFYWHGQMRDSXYCYTXNQQJZYYPFZXDYZFPRXEJDGYQBXRCNFYYQPGHYJDYZXGRHTKYLNWDZNTSMPKLBTHBPYSZBZTJZSZZJTYYXZPHSSZZBZCZPTQFZMYFLYPYBBJQXZMXXDJMTSYSKKBJZXHJCKLPSMKYJZCXTMLJYXRZZQSLXXQPYZXMKYXXXJCLJPRMYYGADYSKQLSNDHYZKQXZYZTCGHZTLMLWZYBWSYCTBHJHJFCWZTXWYTKZLXQSHLYJZJXTMPLPYCGLTBZZTLZJCYJGDTCLKLPLLQPJMZPAPXYZLKKTKDZCZZBNZDYDYQZJYJGMCTXLTGXSZLMLHBGLKFWNWZHDXUHLFMKYSLGXDTWWFRJEJZTZHYDXYKSHWFZCQSHKTMQQHTZHYMJDJSKHXZJZBZZXYMPAGQMSTPXLSKLZYNWRTSQLSZBPSPSGZWYHTLKSSSWHZZLYYTNXJGMJSZSUFWNLSOZTXGXLSAMMLBWLDSZYLAKQCQCTMYCFJBSLXCLZZCLXXKSBZQCLHJPSQPLSXXCKSLNHPSFQQYTXYJZLQLDXZQJZDYYDJNZPTUZDSKJFSLJHYLZSQZLBTXYDGTQFDBYAZXDZHZJNHHQBYKNXJJQCZMLLJZKSPLDYCLBBLXKLELXJLBQYCXJXGCNLCQPLZLZYJTZLJGYZDZPLTQCSXFDMNYCXGBTJDCZNBGBQYQJWGKFHTNPYQZQGBKPBBYZMTJDYTBLSQMPSXTBNPDXKLEMYYCJYNZCTLDYKZZXDDXHQSHDGMZSJYCCTAYRZLPYLTLKXSLZCGGEXCLFXLKJRTLQJAQZNCMBYDKKCXGLCZJZXJHPTDJJMZQYKQSECQZDSHHADMLZFMMZBGNTJNNLGBYJBRBTMLBYJDZXLCJLPLDLPCQDHLXZLYCBLCXZZJADJLNZMMSSSMYBHBSQKBHRSXXJMXSDZNZPXLGBRHWGGFCXGMSKLLTSJYYCQLTSKYWYYHYWXBXQYWPYWYKQLSQPTNTKHQCWDQKTWPXXHCPTHTWUMSSYHBWCRWXHJMKMZNGWTMLKFGHKJYLSYYCXWHYECLQHKQHTTQKHFZLDXQWYZYYDESBPKYRZPJFYYZJCEQDZZDLATZBBFJLLCXDLMJSSXEGYGSJQXCWBXSSZPDYZCXDNYXPPZYDLYJCZPLTXLSXYZYRXCYYYDYLWWNZSAHJSYQYHGYWWAXTJZDAXYSRLTDPSSYYFNEJDXYZHLXLLLZQZSJNYQYQQXYJGHZGZCYJCHZLYCDSHWSHJZYJXCLLNXZJJYYXNFXMWFPYLCYLLABWDDHWDXJMCXZTZPMLQZHSFHZYNZTLLDYWLSLXHYMMYLMBWWKYXYADTXYLLDJPYBPWUXJMWMLLSAFDLLYFLBHHHBQQLTZJCQJLDJTFFKMMMBYTHYGDCQRDDWRQJXNBYSNWZDBYYTBJHPYBYTTJXAAHGQDQTMYSTQXKBTZPKJLZRBEQQSSMJJBDJOTGTBXPGBKTLHQXJJJCTHXQDWJLWRFWQGWSHCKRYSWGFTGYGBXSDWDWRFHWYTJJXXXJYZYSLPYYYPAYXHYDQKXSHXYXGSKQHYWFDDDPPLCJLQQEEWXKSYYKDYPLTJTHKJLTCYYHHJTTPLTZZCDLTHQKZXQYSTEEYWYYZYXXYYSTTJKLLPZMCYHQGXYHSRMBXPLLNQYDQHXSXXWGDQBSHYLLPJJJTHYJKYPPTHYYKTYEZYENMDSHLCRPQFDGFXZPSFTLJXXJBSWYYSKSFLXLPPLBBBLBSFXFYZBSJSSYLPBBFFFFSSCJDSTZSXZRYYSYFFSYZYZBJTBCTSBSDHRTJJBYTCXYJEYLXCBNEBJDSYXYKGSJZBXBYTFZWGENYHHTHZHHXFWGCSTBGXKLSXYWMTMBYXJSTZSCDYQRCYTWXZFHMYMCXLZNSDJTTTXRYCFYJSBSDYERXJLJXBBDEYNJGHXGCKGSCYMBLXJMSZNSKGXFBNBPTHFJAAFXYXFPXMYPQDTZCXZZPXRSYWZDLYBBKTYQPQJPZYPZJZNJPZJLZZFYSBTTSLMPTZRTDXQSJEHBZYLZDHLJSQMLHTXTJECXSLZZSPKTLZKQQYFSYGYWPCPQFHQHYTQXZKRSGTTSQCZLPTXCDYYZXSQZSLXLZMYCPCQBZYXHBSXLZDLTCDXTYLZJYYZPZYZLTXJSJXHLPMYTXCQRBLZSSFJZZTNJYTXMYJHLHPPLCYXQJQQKZZSCPZKSWALQSBLCCZJSXGWWWYGYKTJBBZTDKHXHKGTGPBKQYSLPXPJCKBMLLXDZSTBKLGGQKQLSBKKTFXRMDKBFTPZFRTBBRFERQGXYJPZSSTLBZTPSZQZSJDHLJQLZBPMSMMSXLQQNHKNBLRDDNXXDHDDJCYYGYLXGZLXSYGMQQGKHBPMXYXLYTQWLWGCPBMQXCYZYDRJBHTDJYHQSHTMJSBYPLWHLZFFNYPMHXXHPLTBQPFBJWQDBYGPNZTPFZJGSDDTQSHZEAWZZYLLTYYBWJKXXGHLFKXDJTMSZSQYNZGGSWQSPHTLSSKMCLZXYSZQZXNCJDQGZDLFNYKLJCJLLZLMZZNHYDSSHTHZZLZZBBHQZWWYCRZHLYQQJBEYFXXXWHSRXWQHWPSLMSSKZTTYGYQQWRSLALHMJTQJSMXQBJJZJXZYZKXBYQXBJXSHZTSFJLXMXZXFGHKZSZGGYLCLSARJYHSLLLMZXELGLXYDJYTLFBHBPNLYZFBBHPTGJKWETZHKJJXZXXGLLJLSTGSHJJYQLQZFKCGNNDJSSZFDBCTWWSEQFHQJBSAQTGYPQLBXBMMYWXGSLZHGLZGQYFLZBYFZJFRYSFMBYZHQGFWZSYFYJJPHZBYYZFFWODGRLMFTWLBZGYCQXCDJYGZYYYYTYTYDWEGAZYHXJLZYYHLRMGRXXZCLHNELJJTJTPWJYBJJBXJJTJTEEKHWSLJPLPSFYZPQQBDLQJJTYYQLYZKDKSQJYYQZLDQTGJQYZJSUCMRYQTHTEJMFCTYHYPKMHYZWJDQFHYYXWSHCTXRLJHQXHCCYYYJLTKTTYTMXGTCJTZAYYOCZLYLBSZYWJYTSJYHBYSHFJLYGJXXTMZYYLTXXYPZLXYJZYZYYPNHMYMDYYLBLHLSYYQQLLNJJYMSOYQBZGDLYXYLCQYXTSZEGXHZGLHWBLJHEYXTWQMAKBPQCGYSHHEGQCMWYYWLJYJHYYZLLJJYLHZYHMGSLJLJXCJJYCLYCJPCPZJZJMMYLCQLNQLJQJSXYJMLSZLJQLYCMMHCFMMFPQQMFYLQMCFFQMMMMHMZNFHHJGTTHHKHSLNCHHYQDXTMMQDCYZYXYQMYQYLTDCYYYZAZZCYMZYDLZFFFMMYCQZWZZMABTBYZTDMNZZGGDFTYPCGQYTTSSFFWFDTZQSSYSTWXJHXYTSXXYLBYQHWWKXHZXWZNNZZJZJJQJCCCHYYXBZXZCYZTLLCQXYNJYCYYCYNZZQYYYEWYCZDCJYCCHYJLBTZYYCQWMPWPYMLGKDLDLGKQQBGYCHJXY';
      this.full_dict = {
        'a': "\u554A\u963F\u9515",
        'ai': "\u57C3\u6328\u54CE\u5509\u54C0\u7691\u764C\u853C\u77EE\u827E\u788D\u7231\u9698\u8BF6\u6371\u55F3\u55CC\u5AD2\u7477\u66A7\u7839\u953F\u972D",
        'an': "\u978D\u6C28\u5B89\u4FFA\u6309\u6697\u5CB8\u80FA\u6848\u8C19\u57EF\u63DE\u72B4\u5EB5\u6849\u94F5\u9E4C\u9878\u9EEF",
        'ang': "\u80AE\u6602\u76CE",
        'ao': "\u51F9\u6556\u71AC\u7FF1\u8884\u50B2\u5965\u61CA\u6FB3\u5773\u62D7\u55F7\u5662\u5C99\u5ED2\u9068\u5AAA\u9A9C\u8071\u87AF\u93CA\u9CCC\u93D6",
        'ba': "\u82AD\u634C\u6252\u53ED\u5427\u7B06\u516B\u75A4\u5DF4\u62D4\u8DCB\u9776\u628A\u8019\u575D\u9738\u7F62\u7238\u8307\u83DD\u8406\u636D\u5C9C\u705E\u6777\u94AF\u7C91\u9C85\u9B43",
        'bai': "\u767D\u67CF\u767E\u6446\u4F70\u8D25\u62DC\u7A17\u859C\u63B0\u97B4",
        'ban': "\u6591\u73ED\u642C\u6273\u822C\u9881\u677F\u7248\u626E\u62CC\u4F34\u74E3\u534A\u529E\u7ECA\u962A\u5742\u8C73\u94A3\u7622\u764D\u8228",
        'bang': "\u90A6\u5E2E\u6886\u699C\u8180\u7ED1\u68D2\u78C5\u868C\u9551\u508D\u8C24\u84A1\u8783",
        'bao': "\u82DE\u80DE\u5305\u8912\u96F9\u4FDD\u5821\u9971\u5B9D\u62B1\u62A5\u66B4\u8C79\u9C8D\u7206\u52F9\u8446\u5B80\u5B62\u7172\u9E28\u8913\u8DB5\u9F85",
        'bo': "\u5265\u8584\u73BB\u83E0\u64AD\u62E8\u94B5\u6CE2\u535A\u52C3\u640F\u94C2\u7B94\u4F2F\u5E1B\u8236\u8116\u818A\u6E24\u6CCA\u9A73\u4EB3\u8543\u5575\u997D\u6A97\u64D8\u7934\u94B9\u9E41\u7C38\u8DDB",
        'bei': "\u676F\u7891\u60B2\u5351\u5317\u8F88\u80CC\u8D1D\u94A1\u500D\u72C8\u5907\u60EB\u7119\u88AB\u5B5B\u9642\u90B6\u57E4\u84D3\u5457\u602B\u6096\u789A\u9E4E\u8919\u943E",
        'ben': "\u5954\u82EF\u672C\u7B28\u755A\u574C\u951B",
        'beng': "\u5D29\u7EF7\u752D\u6CF5\u8E66\u8FF8\u552A\u5623\u750F",
        'bi': "\u903C\u9F3B\u6BD4\u9119\u7B14\u5F7C\u78A7\u84D6\u853D\u6BD5\u6BD9\u6BD6\u5E01\u5E87\u75F9\u95ED\u655D\u5F0A\u5FC5\u8F9F\u58C1\u81C2\u907F\u965B\u5315\u4EF3\u4FFE\u8298\u835C\u8378\u5421\u54D4\u72F4\u5EB3\u610E\u6ED7\u6FDE\u5F3C\u59A3\u5A62\u5B16\u74A7\u8D32\u7540\u94CB\u79D5\u88E8\u7B5A\u7B85\u7BE6\u822D\u895E\u8DF8\u9AC0",
        'bian': "\u97AD\u8FB9\u7F16\u8D2C\u6241\u4FBF\u53D8\u535E\u8FA8\u8FA9\u8FAB\u904D\u533E\u5F01\u82C4\u5FED\u6C74\u7F0F\u7178\u782D\u78A5\u7A39\u7A86\u8759\u7B3E\u9CCA",
        'biao': "\u6807\u5F6A\u8198\u8868\u5A4A\u9AA0\u98D1\u98D9\u98DA\u706C\u9556\u9573\u762D\u88F1\u9CD4",
        'bie': "\u9CD6\u618B\u522B\u762A\u8E69\u9CD8",
        'bin': "\u5F6C\u658C\u6FD2\u6EE8\u5BBE\u6448\u50A7\u6D5C\u7F24\u73A2\u6BA1\u8191\u9554\u9ACC\u9B13",
        'bing': "\u5175\u51B0\u67C4\u4E19\u79C9\u997C\u70B3\u75C5\u5E76\u7980\u90B4\u6452\u7EE0\u678B\u69DF\u71F9",
        'bu': "\u6355\u535C\u54FA\u8865\u57E0\u4E0D\u5E03\u6B65\u7C3F\u90E8\u6016\u62CA\u535F\u900B\u74FF\u6661\u949A\u91AD",
        'ca': "\u64E6\u5693\u7924",
        'cai': "\u731C\u88C1\u6750\u624D\u8D22\u776C\u8E29\u91C7\u5F69\u83DC\u8521",
        'can': "\u9910\u53C2\u8695\u6B8B\u60ED\u60E8\u707F\u9A96\u74A8\u7CB2\u9EEA",
        'cang': "\u82CD\u8231\u4ED3\u6CA7\u85CF\u4F27",
        'cao': "\u64CD\u7CD9\u69FD\u66F9\u8349\u8279\u5608\u6F15\u87AC\u825A",
        'ce': "\u5395\u7B56\u4FA7\u518C\u6D4B\u5202\u5E3B\u607B",
        'ceng': "\u5C42\u8E6D\u564C",
        'cha': "\u63D2\u53C9\u832C\u8336\u67E5\u78B4\u643D\u5BDF\u5C94\u5DEE\u8BE7\u7339\u9987\u6C4A\u59F9\u6748\u6942\u69CE\u6AAB\u9497\u9538\u9572\u8869",
        'chai': "\u62C6\u67F4\u8C7A\u4FAA\u8308\u7625\u867F\u9F87",
        'chan': "\u6400\u63BA\u8749\u998B\u8C17\u7F20\u94F2\u4EA7\u9610\u98A4\u5181\u8C04\u8C36\u8487\u5EDB\u5FCF\u6F7A\u6FB6\u5B71\u7FBC\u5A75\u5B17\u9AA3\u89C7\u7985\u9561\u88E3\u87FE\u8E94",
        'chang': "\u660C\u7316\u573A\u5C1D\u5E38\u957F\u507F\u80A0\u5382\u655E\u7545\u5531\u5021\u4F25\u9B2F\u82CC\u83D6\u5F9C\u6005\u60DD\u960A\u5A3C\u5AE6\u6636\u6C05\u9CB3",
        'chao': "\u8D85\u6284\u949E\u671D\u5632\u6F6E\u5DE2\u5435\u7092\u600A\u7EC9\u6641\u8016",
        'che': "\u8F66\u626F\u64A4\u63A3\u5F7B\u6F88\u577C\u5C6E\u7817",
        'chen': "\u90F4\u81E3\u8FB0\u5C18\u6668\u5FF1\u6C89\u9648\u8D81\u886C\u79F0\u8C0C\u62BB\u55D4\u5BB8\u741B\u6987\u809C\u80C2\u789C\u9F80",
        'cheng': "\u6491\u57CE\u6A59\u6210\u5448\u4E58\u7A0B\u60E9\u6F84\u8BDA\u627F\u901E\u9A8B\u79E4\u57D5\u5D4A\u5FB5\u6D48\u67A8\u67FD\u6A18\u665F\u584D\u77A0\u94D6\u88CE\u86CF\u9172",
        'chi': "\u5403\u75F4\u6301\u5319\u6C60\u8FDF\u5F1B\u9A70\u803B\u9F7F\u4F88\u5C3A\u8D64\u7FC5\u65A5\u70BD\u50BA\u5880\u82AA\u830C\u640B\u53F1\u54E7\u557B\u55E4\u5F73\u996C\u6CB2\u5AB8\u6555\u80DD\u7719\u7735\u9E31\u761B\u892B\u86A9\u87AD\u7B1E\u7BEA\u8C49\u8E05\u8E1F\u9B51",
        'chong': "\u5145\u51B2\u866B\u5D07\u5BA0\u833A\u5FE1\u61A7\u94F3\u825F",
        'chou': "\u62BD\u916C\u7574\u8E0C\u7A20\u6101\u7B79\u4EC7\u7EF8\u7785\u4E11\u4FE6\u5733\u5E31\u60C6\u6EB4\u59AF\u7633\u96E0\u9C8B",
        'chu': "\u81ED\u521D\u51FA\u6A71\u53A8\u8E87\u9504\u96CF\u6EC1\u9664\u695A\u7840\u50A8\u77D7\u6410\u89E6\u5904\u4E8D\u520D\u61B7\u7ECC\u6775\u696E\u6A17\u870D\u8E70\u9EDC",
        'chuan': "\u63E3\u5DDD\u7A7F\u693D\u4F20\u8239\u5598\u4E32\u63BE\u821B\u60F4\u9044\u5DDB\u6C1A\u948F\u9569\u8221",
        'chuang': "\u75AE\u7A97\u5E62\u5E8A\u95EF\u521B\u6006",
        'chui': "\u5439\u708A\u6376\u9524\u5782\u9672\u68F0\u69CC",
        'chun': "\u6625\u693F\u9187\u5507\u6DF3\u7EAF\u8822\u4FC3\u83BC\u6C8C\u80AB\u6710\u9E51\u877D",
        'chuo': "\u6233\u7EF0\u851F\u8FB6\u8F8D\u955E\u8E14\u9F8A",
        'ci': "\u75B5\u8328\u78C1\u96CC\u8F9E\u6148\u74F7\u8BCD\u6B64\u523A\u8D50\u6B21\u8360\u5472\u5D6F\u9E5A\u8785\u7CCD\u8D91",
        'cong': "\u806A\u8471\u56F1\u5306\u4ECE\u4E1B\u506C\u82C1\u6DD9\u9AA2\u742E\u7481\u679E",
        'cu': "\u51D1\u7C97\u918B\u7C07\u731D\u6B82\u8E59",
        'cuan': "\u8E7F\u7BE1\u7A9C\u6C46\u64BA\u6615\u7228",
        'cui': "\u6467\u5D14\u50AC\u8106\u7601\u7CB9\u6DEC\u7FE0\u8403\u60B4\u7480\u69B1\u96B9",
        'cun': "\u6751\u5B58\u5BF8\u78CB\u5FD6\u76B4",
        'cuo': "\u64AE\u6413\u63AA\u632B\u9519\u539D\u811E\u9509\u77EC\u75E4\u9E7E\u8E49\u8E9C",
        'da': "\u642D\u8FBE\u7B54\u7629\u6253\u5927\u8037\u54D2\u55D2\u601B\u59B2\u75B8\u8921\u7B2A\u977C\u9791",
        'dai': "\u5446\u6B79\u50A3\u6234\u5E26\u6B86\u4EE3\u8D37\u888B\u5F85\u902E\u6020\u57ED\u7519\u5454\u5CB1\u8FE8\u902F\u9A80\u7ED0\u73B3\u9EDB",
        'dan': "\u803D\u62C5\u4E39\u5355\u90F8\u63B8\u80C6\u65E6\u6C2E\u4F46\u60EE\u6DE1\u8BDE\u5F39\u86CB\u4EBB\u510B\u5369\u840F\u5556\u6FB9\u6A90\u6B9A\u8D55\u7708\u7605\u8043\u7BAA",
        'dang': "\u5F53\u6321\u515A\u8361\u6863\u8C20\u51FC\u83EA\u5B95\u7800\u94DB\u88C6",
        'dao': "\u5200\u6363\u8E48\u5012\u5C9B\u7977\u5BFC\u5230\u7A3B\u60BC\u9053\u76D7\u53E8\u5541\u5FC9\u6D2E\u6C18\u7118\u5FD1\u7E9B",
        'de': "\u5FB7\u5F97\u7684\u951D",
        'deng': "\u8E6C\u706F\u767B\u7B49\u77AA\u51F3\u9093\u5654\u5D9D\u6225\u78F4\u956B\u7C26",
        'di': "\u5824\u4F4E\u6EF4\u8FEA\u654C\u7B1B\u72C4\u6DA4\u7FDF\u5AE1\u62B5\u5E95\u5730\u8482\u7B2C\u5E1D\u5F1F\u9012\u7F14\u6C10\u7C74\u8BCB\u8C1B\u90B8\u577B\u839C\u837B\u5600\u5A23\u67E2\u68E3\u89CC\u7825\u78B2\u7747\u955D\u7F9D\u9AB6",
        'dian': "\u98A0\u6382\u6EC7\u7898\u70B9\u5178\u975B\u57AB\u7535\u4F43\u7538\u5E97\u60E6\u5960\u6DC0\u6BBF\u4E36\u963D\u576B\u57DD\u5DC5\u73B7\u765C\u766B\u7C1F\u8E2E",
        'diao': "\u7889\u53FC\u96D5\u51CB\u5201\u6389\u540A\u9493\u8C03\u8F7A\u94DE\u8729\u7C9C\u8C82",
        'die': "\u8DCC\u7239\u789F\u8776\u8FED\u8C0D\u53E0\u4F5A\u57A4\u581E\u63F2\u558B\u6E2B\u8F76\u7252\u74DE\u8936\u800B\u8E40\u9CBD\u9CCE",
        'ding': "\u4E01\u76EF\u53EE\u9489\u9876\u9F0E\u952D\u5B9A\u8BA2\u4E22\u4EC3\u5576\u738E\u815A\u7887\u753A\u94E4\u7594\u8035\u914A",
        'dong': "\u4E1C\u51AC\u8463\u61C2\u52A8\u680B\u4F97\u606B\u51BB\u6D1E\u578C\u549A\u5CBD\u5CD2\u5902\u6C21\u80E8\u80F4\u7850\u9E2B",
        'dou': "\u515C\u6296\u6597\u9661\u8C46\u9017\u75D8\u8538\u94AD\u7AA6\u7AAC\u86AA\u7BFC\u9161",
        'du': "\u90FD\u7763\u6BD2\u728A\u72EC\u8BFB\u5835\u7779\u8D4C\u675C\u9540\u809A\u5EA6\u6E21\u5992\u828F\u561F\u6E0E\u691F\u6A50\u724D\u8839\u7B03\u9AD1\u9EE9",
        'duan': "\u7AEF\u77ED\u953B\u6BB5\u65AD\u7F0E\u5F56\u6934\u7145\u7C16",
        'dui': "\u5806\u5151\u961F\u5BF9\u603C\u619D\u7893",
        'dun': "\u58A9\u5428\u8E72\u6566\u987F\u56E4\u949D\u76FE\u9041\u7096\u7818\u7905\u76F9\u9566\u8DB8",
        'duo': "\u6387\u54C6\u591A\u593A\u579B\u8EB2\u6735\u8DFA\u8235\u5241\u60F0\u5815\u5484\u54DA\u7F0D\u67C1\u94CE\u88F0\u8E31",
        'e': "\u86FE\u5CE8\u9E45\u4FC4\u989D\u8BB9\u5A25\u6076\u5384\u627C\u904F\u9102\u997F\u5669\u8C14\u57A9\u57AD\u82CA\u83AA\u843C\u5443\u6115\u5C59\u5A40\u8F6D\u66F7\u816D\u786A\u9507\u9537\u9E57\u989A\u9CC4",
        'en': "\u6069\u84BD\u6441\u5514\u55EF",
        'er': "\u800C\u513F\u8033\u5C14\u9975\u6D31\u4E8C\u8D30\u8FE9\u73E5\u94D2\u9E38\u9C95",
        'fa': "\u53D1\u7F5A\u7B4F\u4F10\u4E4F\u9600\u6CD5\u73D0\u57A1\u781D",
        'fan': "\u85E9\u5E06\u756A\u7FFB\u6A0A\u77FE\u9492\u7E41\u51E1\u70E6\u53CD\u8FD4\u8303\u8D29\u72AF\u996D\u6CDB\u8629\u5E61\u72AD\u68B5\u6535\u71D4\u7548\u8E6F",
        'fang': "\u574A\u82B3\u65B9\u80AA\u623F\u9632\u59A8\u4EFF\u8BBF\u7EBA\u653E\u531A\u90A1\u5F77\u94AB\u822B\u9C82",
        'fei': "\u83F2\u975E\u5561\u98DE\u80A5\u532A\u8BFD\u5420\u80BA\u5E9F\u6CB8\u8D39\u82BE\u72D2\u60B1\u6DDD\u5983\u7ECB\u7EEF\u69A7\u8153\u6590\u6249\u7953\u7829\u9544\u75F1\u871A\u7BDA\u7FE1\u970F\u9CB1",
        'fen': "\u82AC\u915A\u5429\u6C1B\u5206\u7EB7\u575F\u711A\u6C7E\u7C89\u594B\u4EFD\u5FFF\u6124\u7CAA\u507E\u7035\u68FC\u610D\u9CBC\u9F22",
        'feng': "\u4E30\u5C01\u67AB\u8702\u5CF0\u950B\u98CE\u75AF\u70FD\u9022\u51AF\u7F1D\u8BBD\u5949\u51E4\u4FF8\u9146\u8451\u6CA3\u781C",
        'fu': "\u4F5B\u5426\u592B\u6577\u80A4\u5B75\u6276\u62C2\u8F90\u5E45\u6C1F\u7B26\u4F0F\u4FD8\u670D\u6D6E\u6DAA\u798F\u88B1\u5F17\u752B\u629A\u8F85\u4FEF\u91DC\u65A7\u812F\u8151\u5E9C\u8150\u8D74\u526F\u8986\u8D4B\u590D\u5085\u4ED8\u961C\u7236\u8179\u8D1F\u5BCC\u8BA3\u9644\u5987\u7F1A\u5490\u5310\u51EB\u90DB\u8299\u82FB\u832F\u83A9\u83D4\u544B\u5E5E\u6ECF\u8274\u5B5A\u9A78\u7EC2\u6874\u8D59\u9EFB\u9EFC\u7F58\u7A03\u99A5\u864D\u86A8\u8709\u8760\u876E\u9EB8\u8DBA\u8DD7\u9CC6",
        'ga': "\u5676\u560E\u86E4\u5C2C\u5477\u5C15\u5C1C\u65EE\u9486",
        'gai': "\u8BE5\u6539\u6982\u9499\u76D6\u6E89\u4E10\u9654\u5793\u6224\u8D45\u80F2",
        'gan': "\u5E72\u7518\u6746\u67D1\u7AFF\u809D\u8D76\u611F\u79C6\u6562\u8D63\u5769\u82F7\u5C34\u64C0\u6CD4\u6DE6\u6F89\u7EC0\u6A44\u65F0\u77F8\u75B3\u9150",
        'gang': "\u5188\u521A\u94A2\u7F38\u809B\u7EB2\u5C97\u6E2F\u6206\u7F61\u9883\u7B7B",
        'gong': "\u6760\u5DE5\u653B\u529F\u606D\u9F9A\u4F9B\u8EAC\u516C\u5BAB\u5F13\u5DE9\u6C5E\u62F1\u8D21\u5171\u857B\u5EFE\u54A3\u73D9\u80B1\u86A3\u86E9\u89E5",
        'gao': "\u7BD9\u768B\u9AD8\u818F\u7F94\u7CD5\u641E\u9550\u7A3F\u544A\u777E\u8BF0\u90DC\u84BF\u85C1\u7F1F\u69D4\u69C1\u6772\u9506",
        'ge': "\u54E5\u6B4C\u6401\u6208\u9E3D\u80F3\u7599\u5272\u9769\u845B\u683C\u9601\u9694\u94EC\u4E2A\u5404\u9B32\u4EE1\u54FF\u5865\u55DD\u7EA5\u643F\u8188\u784C\u94EA\u9549\u88BC\u988C\u867C\u8238\u9ABC\u9AC2",
        'gei': "\u7ED9",
        'gen': "\u6839\u8DDF\u4E98\u831B\u54CF\u826E",
        'geng': "\u8015\u66F4\u5E9A\u7FB9\u57C2\u803F\u6897\u54FD\u8D53\u9CA0",
        'gou': "\u94A9\u52FE\u6C9F\u82DF\u72D7\u57A2\u6784\u8D2D\u591F\u4F5D\u8BDF\u5CA3\u9058\u5ABE\u7F11\u89CF\u5F40\u9E32\u7B31\u7BDD\u97B2",
        'gu': "\u8F9C\u83C7\u5495\u7B8D\u4F30\u6CBD\u5B64\u59D1\u9F13\u53E4\u86CA\u9AA8\u8C37\u80A1\u6545\u987E\u56FA\u96C7\u560F\u8BC2\u83F0\u54CC\u5D2E\u6C69\u688F\u8F71\u726F\u727F\u80CD\u81CC\u6BC2\u77BD\u7F5F\u94B4\u9522\u74E0\u9E2A\u9E44\u75FC\u86C4\u9164\u89DA\u9CB4\u9AB0\u9E58",
        'gua': "\u522E\u74DC\u5250\u5BE1\u6302\u8902\u5366\u8BD6\u5471\u681D\u9E39",
        'guai': "\u4E56\u62D0\u602A\u54D9",
        'guan': "\u68FA\u5173\u5B98\u51A0\u89C2\u7BA1\u9986\u7F50\u60EF\u704C\u8D2F\u500C\u839E\u63BC\u6DAB\u76E5\u9E73\u9CCF",
        'guang': "\u5149\u5E7F\u901B\u72B7\u6844\u80F1\u7592",
        'gui': "\u7470\u89C4\u572D\u7845\u5F52\u9F9F\u95FA\u8F68\u9B3C\u8BE1\u7678\u6842\u67DC\u8DEA\u8D35\u523D\u5326\u523F\u5E8B\u5B84\u59AB\u6867\u7085\u6677\u7688\u7C0B\u9C91\u9CDC",
        'gun': "\u8F8A\u6EDA\u68CD\u4E28\u886E\u7EF2\u78D9\u9CA7",
        'guo': "\u9505\u90ED\u56FD\u679C\u88F9\u8FC7\u9998\u8803\u57DA\u63B4\u5459\u56D7\u5E3C\u5D1E\u7313\u6901\u8662\u951E\u8052\u872E\u873E\u8748",
        'ha': "\u54C8",
        'hai': "\u9AB8\u5B69\u6D77\u6C26\u4EA5\u5BB3\u9A87\u54B4\u55E8\u988F\u91A2",
        'han': "\u9163\u61A8\u90AF\u97E9\u542B\u6DB5\u5BD2\u51FD\u558A\u7F55\u7FF0\u64BC\u634D\u65F1\u61BE\u608D\u710A\u6C57\u6C49\u9097\u83E1\u6496\u961A\u701A\u6657\u7113\u9894\u86B6\u9F3E",
        'hen': "\u592F\u75D5\u5F88\u72E0\u6068",
        'hang': "\u676D\u822A\u6C86\u7ED7\u73E9\u6841",
        'hao': "\u58D5\u568E\u8C6A\u6BEB\u90DD\u597D\u8017\u53F7\u6D69\u8585\u55E5\u5686\u6FE0\u704F\u660A\u7693\u98A2\u869D",
        'he': "\u5475\u559D\u8377\u83CF\u6838\u79BE\u548C\u4F55\u5408\u76D2\u8C89\u9602\u6CB3\u6DB8\u8D6B\u8910\u9E64\u8D3A\u8BC3\u52BE\u58D1\u85FF\u55D1\u55EC\u9616\u76CD\u86B5\u7FEE",
        'hei': "\u563F\u9ED1",
        'heng': "\u54FC\u4EA8\u6A2A\u8861\u6052\u8A07\u8605",
        'hong': "\u8F70\u54C4\u70D8\u8679\u9E3F\u6D2A\u5B8F\u5F18\u7EA2\u9EC9\u8BA7\u836D\u85A8\u95F3\u6CD3",
        'hou': "\u5589\u4FAF\u7334\u543C\u539A\u5019\u540E\u5820\u5F8C\u9005\u760A\u7BCC\u7CC7\u9C8E\u9ABA",
        'hu': "\u547C\u4E4E\u5FFD\u745A\u58F6\u846B\u80E1\u8774\u72D0\u7CCA\u6E56\u5F27\u864E\u552C\u62A4\u4E92\u6CAA\u6237\u51B1\u553F\u56EB\u5CB5\u7322\u6019\u60DA\u6D52\u6EF9\u7425\u69F2\u8F77\u89F3\u70C0\u7173\u623D\u6248\u795C\u9E55\u9E71\u7B0F\u9190\u659B",
        'hua': "\u82B1\u54D7\u534E\u733E\u6ED1\u753B\u5212\u5316\u8BDD\u5290\u6D4D\u9A85\u6866\u94E7\u7A1E",
        'huai': "\u69D0\u5F8A\u6000\u6DEE\u574F\u8FD8\u8E1D",
        'huan': "\u6B22\u73AF\u6853\u7F13\u6362\u60A3\u5524\u75EA\u8C62\u7115\u6DA3\u5BA6\u5E7B\u90C7\u5942\u57B8\u64D0\u571C\u6D39\u6D63\u6F36\u5BF0\u902D\u7F33\u953E\u9CA9\u9B1F",
        'huang': "\u8352\u614C\u9EC4\u78FA\u8757\u7C27\u7687\u51F0\u60F6\u714C\u6643\u5E4C\u604D\u8C0E\u968D\u5FA8\u6E5F\u6F62\u9051\u749C\u8093\u7640\u87E5\u7BC1\u9CC7",
        'hui': "\u7070\u6325\u8F89\u5FBD\u6062\u86D4\u56DE\u6BC1\u6094\u6167\u5349\u60E0\u6666\u8D3F\u79FD\u4F1A\u70E9\u6C47\u8BB3\u8BF2\u7ED8\u8BD9\u8334\u835F\u8559\u54D5\u5599\u96B3\u6D04\u5F57\u7F0B\u73F2\u6656\u605A\u867A\u87EA\u9EBE",
        'hun': "\u8364\u660F\u5A5A\u9B42\u6D51\u6DF7\u8BE8\u9984\u960D\u6EB7\u7F17",
        'huo': "\u8C41\u6D3B\u4F19\u706B\u83B7\u6216\u60D1\u970D\u8D27\u7978\u6509\u56AF\u5925\u94AC\u952A\u956C\u8020\u8816",
        'ji': "\u51FB\u573E\u57FA\u673A\u7578\u7A3D\u79EF\u7B95\u808C\u9965\u8FF9\u6FC0\u8BA5\u9E21\u59EC\u7EE9\u7F09\u5409\u6781\u68D8\u8F91\u7C4D\u96C6\u53CA\u6025\u75BE\u6C72\u5373\u5AC9\u7EA7\u6324\u51E0\u810A\u5DF1\u84DF\u6280\u5180\u5B63\u4F0E\u796D\u5242\u60B8\u6D4E\u5BC4\u5BC2\u8BA1\u8BB0\u65E2\u5FCC\u9645\u5993\u7EE7\u7EAA\u5C45\u4E0C\u4E69\u525E\u4F76\u4F74\u8114\u58BC\u82A8\u82B0\u8401\u84BA\u857A\u638E\u53FD\u54AD\u54DC\u5527\u5C8C\u5D74\u6D0E\u5F50\u5C50\u9AA5\u757F\u7391\u696B\u6B9B\u621F\u6222\u8D4D\u89CA\u7284\u9F51\u77F6\u7F81\u5D47\u7A37\u7620\u7635\u866E\u7B08\u7B04\u66A8\u8DFB\u8DFD\u9701\u9C9A\u9CAB\u9AFB\u9E82",
        'jia': "\u5609\u67B7\u5939\u4F73\u5BB6\u52A0\u835A\u988A\u8D3E\u7532\u94BE\u5047\u7A3C\u4EF7\u67B6\u9A7E\u5AC1\u4F3D\u90CF\u62EE\u5CAC\u6D43\u8FE6\u73C8\u621B\u80DB\u605D\u94D7\u9553\u75C2\u86F1\u7B33\u8888\u8DCF",
        'jian': "\u6B7C\u76D1\u575A\u5C16\u7B3A\u95F4\u714E\u517C\u80A9\u8270\u5978\u7F04\u8327\u68C0\u67EC\u78B1\u7877\u62E3\u6361\u7B80\u4FED\u526A\u51CF\u8350\u69DB\u9274\u8DF5\u8D31\u89C1\u952E\u7BAD\u4EF6\u5065\u8230\u5251\u996F\u6E10\u6E85\u6DA7\u5EFA\u50ED\u8C0F\u8C2B\u83C5\u84B9\u641B\u56DD\u6E54\u8E47\u8B07\u7F23\u67A7\u67D9\u6957\u620B\u622C\u726E\u728D\u6BFD\u8171\u7751\u950F\u9E63\u88E5\u7B15\u7BB4\u7FE6\u8DBC\u8E3A\u9CA3\u97AF",
        'jiang': "\u50F5\u59DC\u5C06\u6D46\u6C5F\u7586\u848B\u6868\u5956\u8BB2\u5320\u9171\u964D\u8333\u6D1A\u7EDB\u7F30\u729F\u7913\u8029\u7CE8\u8C47",
        'jiao': "\u8549\u6912\u7901\u7126\u80F6\u4EA4\u90CA\u6D47\u9A84\u5A07\u56BC\u6405\u94F0\u77EB\u4FA5\u811A\u72E1\u89D2\u997A\u7F34\u7EDE\u527F\u6559\u9175\u8F7F\u8F83\u53EB\u4F7C\u50EC\u832D\u6322\u564D\u5CE4\u5FBC\u59E3\u7E9F\u656B\u768E\u9E6A\u86DF\u91AE\u8DE4\u9C9B",
        'jie': "\u7A96\u63ED\u63A5\u7686\u79F8\u8857\u9636\u622A\u52AB\u8282\u6854\u6770\u6377\u776B\u7AED\u6D01\u7ED3\u89E3\u59D0\u6212\u85C9\u82A5\u754C\u501F\u4ECB\u75A5\u8BEB\u5C4A\u5048\u8BA6\u8BD8\u5588\u55DF\u736C\u5A55\u5B51\u6840\u7352\u78A3\u9534\u7596\u88B7\u9889\u86A7\u7FAF\u9C92\u9AB1\u9AEB",
        'jin': "\u5DFE\u7B4B\u65A4\u91D1\u4ECA\u6D25\u895F\u7D27\u9526\u4EC5\u8C28\u8FDB\u9773\u664B\u7981\u8FD1\u70EC\u6D78\u5C3D\u537A\u8369\u5807\u5664\u9991\u5ED1\u5997\u7F19\u747E\u69FF\u8D46\u89D0\u9485\u9513\u887F\u77DC",
        'jing': "\u52B2\u8346\u5162\u830E\u775B\u6676\u9CB8\u4EAC\u60CA\u7CBE\u7CB3\u7ECF\u4E95\u8B66\u666F\u9888\u9759\u5883\u656C\u955C\u5F84\u75C9\u9756\u7ADF\u7ADE\u51C0\u522D\u5106\u9631\u83C1\u734D\u61AC\u6CFE\u8FF3\u5F2A\u5A67\u80BC\u80EB\u8148\u65CC",
        'jiong': "\u70AF\u7A98\u5182\u8FE5\u6243",
        'jiu': "\u63EA\u7A76\u7EA0\u7396\u97ED\u4E45\u7078\u4E5D\u9152\u53A9\u6551\u65E7\u81FC\u8205\u548E\u5C31\u759A\u50E6\u557E\u9604\u67E9\u6855\u9E6B\u8D73\u9B0F",
        'ju': "\u97A0\u62D8\u72D9\u75BD\u9A79\u83CA\u5C40\u5480\u77E9\u4E3E\u6CAE\u805A\u62D2\u636E\u5DE8\u5177\u8DDD\u8E1E\u952F\u4FF1\u53E5\u60E7\u70AC\u5267\u5028\u8BB5\u82E3\u82F4\u8392\u63AC\u907D\u5C66\u741A\u67B8\u6910\u6998\u6989\u6A58\u728B\u98D3\u949C\u9514\u7AAD\u88FE\u8D84\u91B5\u8E3D\u9F83\u96CE\u97AB",
        'juan': "\u6350\u9E43\u5A1F\u5026\u7737\u5377\u7EE2\u9104\u72F7\u6D93\u684A\u8832\u9529\u954C\u96BD",
        'jue': "\u6485\u652B\u6289\u6398\u5014\u7235\u89C9\u51B3\u8BC0\u7EDD\u53A5\u5282\u8C32\u77CD\u8568\u5658\u5D1B\u7357\u5B53\u73CF\u6877\u6A5B\u721D\u9562\u8E76\u89D6",
        'jun': "\u5747\u83CC\u94A7\u519B\u541B\u5CFB\u4FCA\u7AE3\u6D5A\u90E1\u9A8F\u6343\u72FB\u76B2\u7B60\u9E87",
        'ka': "\u5580\u5496\u5361\u4F67\u5494\u80E9",
        'ke': "\u54AF\u5777\u82DB\u67EF\u68F5\u78D5\u9897\u79D1\u58F3\u54B3\u53EF\u6E34\u514B\u523B\u5BA2\u8BFE\u5CA2\u606A\u6E98\u9A92\u7F02\u73C2\u8F72\u6C2A\u778C\u94B6\u75B4\u7AA0\u874C\u9AC1",
        'kai': "\u5F00\u63E9\u6977\u51EF\u6168\u5240\u57B2\u8488\u5FFE\u607A\u94E0\u950E",
        'kan': "\u520A\u582A\u52D8\u574E\u780D\u770B\u4F83\u51F5\u83B0\u83B6\u6221\u9F9B\u77B0",
        'kang': "\u5EB7\u6177\u7CE0\u625B\u6297\u4EA2\u7095\u5751\u4F09\u95F6\u94AA",
        'kao': "\u8003\u62F7\u70E4\u9760\u5C3B\u6832\u7292\u94D0",
        'ken': "\u80AF\u5543\u57A6\u6073\u57A0\u88C9\u9880",
        'keng': "\u542D\u5FD0\u94FF",
        'kong': "\u7A7A\u6050\u5B54\u63A7\u5025\u5D06\u7B9C",
        'kou': "\u62A0\u53E3\u6263\u5BC7\u82A4\u853B\u53E9\u770D\u7B58",
        'ku': "\u67AF\u54ED\u7A9F\u82E6\u9177\u5E93\u88E4\u5233\u5800\u55BE\u7ED4\u9AB7",
        'kua': "\u5938\u57AE\u630E\u8DE8\u80EF\u4F89",
        'kuai': "\u5757\u7B77\u4FA9\u5FEB\u84AF\u90D0\u8489\u72EF\u810D",
        'kuan': "\u5BBD\u6B3E\u9ACB",
        'kuang': "\u5321\u7B50\u72C2\u6846\u77FF\u7736\u65F7\u51B5\u8BD3\u8BF3\u909D\u5739\u593C\u54D0\u7EA9\u8D36",
        'kui': "\u4E8F\u76D4\u5CBF\u7AA5\u8475\u594E\u9B41\u5080\u9988\u6127\u6E83\u9997\u532E\u5914\u9697\u63C6\u55B9\u559F\u609D\u6126\u9615\u9035\u668C\u777D\u8069\u8770\u7BD1\u81FE\u8DEC",
        'kun': "\u5764\u6606\u6346\u56F0\u6083\u9603\u7428\u951F\u918C\u9CB2\u9AE1",
        'kuo': "\u62EC\u6269\u5ED3\u9614\u86DE",
        'la': "\u5783\u62C9\u5587\u8721\u814A\u8FA3\u5566\u524C\u647A\u908B\u65EF\u782C\u760C",
        'lai': "\u83B1\u6765\u8D56\u5D03\u5F95\u6D9E\u6FD1\u8D49\u7750\u94FC\u765E\u7C41",
        'lan': "\u84DD\u5A6A\u680F\u62E6\u7BEE\u9611\u5170\u6F9C\u8C30\u63FD\u89C8\u61D2\u7F06\u70C2\u6EE5\u5549\u5C9A\u61D4\u6F24\u6984\u6593\u7F71\u9567\u8934",
        'lang': "\u7405\u6994\u72FC\u5ECA\u90CE\u6717\u6D6A\u83A8\u8497\u5577\u9606\u9512\u7A02\u8782",
        'lao': "\u635E\u52B3\u7262\u8001\u4F6C\u59E5\u916A\u70D9\u6D9D\u5520\u5D02\u6833\u94D1\u94F9\u75E8\u91AA",
        'le': "\u52D2\u4E50\u808B\u4EC2\u53FB\u561E\u6CD0\u9CD3",
        'lei': "\u96F7\u956D\u857E\u78CA\u7D2F\u5121\u5792\u64C2\u7C7B\u6CEA\u7FB8\u8BD4\u837D\u54A7\u6F2F\u5AD8\u7F27\u6A91\u8012\u9179",
        'ling': "\u68F1\u51B7\u62CE\u73B2\u83F1\u96F6\u9F84\u94C3\u4F36\u7F9A\u51CC\u7075\u9675\u5CAD\u9886\u53E6\u4EE4\u9143\u5844\u82D3\u5464\u56F9\u6CE0\u7EEB\u67C3\u68C2\u74F4\u8046\u86C9\u7FCE\u9CAE",
        'leng': "\u695E\u6123",
        'li': "\u5398\u68A8\u7281\u9ECE\u7BF1\u72F8\u79BB\u6F13\u7406\u674E\u91CC\u9CA4\u793C\u8389\u8354\u540F\u6817\u4E3D\u5389\u52B1\u783E\u5386\u5229\u5088\u4F8B\u4FD0\u75E2\u7ACB\u7C92\u6CA5\u96B6\u529B\u7483\u54E9\u4FEA\u4FDA\u90E6\u575C\u82C8\u8385\u84E0\u85DC\u6369\u5456\u5533\u55B1\u7301\u6EA7\u6FA7\u9026\u5A0C\u5AE0\u9A8A\u7F21\u73DE\u67A5\u680E\u8F79\u623E\u783A\u8A48\u7F79\u9502\u9E42\u75A0\u75AC\u86CE\u870A\u8821\u7B20\u7BE5\u7C9D\u91B4\u8DDE\u96F3\u9CA1\u9CE2\u9EE7",
        'lian': "\u4FE9\u8054\u83B2\u8FDE\u9570\u5EC9\u601C\u6D9F\u5E18\u655B\u8138\u94FE\u604B\u70BC\u7EC3\u631B\u8539\u5941\u6F4B\u6FC2\u5A08\u740F\u695D\u6B93\u81C1\u81A6\u88E2\u880A\u9CA2",
        'liang': "\u7CAE\u51C9\u6881\u7CB1\u826F\u4E24\u8F86\u91CF\u667E\u4EAE\u8C05\u589A\u690B\u8E09\u9753\u9B49",
        'liao': "\u64A9\u804A\u50DA\u7597\u71CE\u5BE5\u8FBD\u6F66\u4E86\u6482\u9563\u5ED6\u6599\u84FC\u5C25\u5639\u7360\u5BEE\u7F2D\u948C\u9E69\u8022",
        'lie': "\u5217\u88C2\u70C8\u52A3\u730E\u51BD\u57D2\u6D0C\u8D94\u8E90\u9B23",
        'lin': "\u7433\u6797\u78F7\u9716\u4E34\u90BB\u9CDE\u6DCB\u51DB\u8D41\u541D\u853A\u5D99\u5EEA\u9074\u6AA9\u8F9A\u77B5\u7CBC\u8E8F\u9E9F",
        'liu': "\u6E9C\u7409\u69B4\u786B\u998F\u7559\u5218\u7624\u6D41\u67F3\u516D\u62A1\u507B\u848C\u6CD6\u6D4F\u905B\u9A9D\u7EFA\u65D2\u7198\u950D\u954F\u9E68\u938F",
        'long': "\u9F99\u804B\u5499\u7B3C\u7ABF\u9686\u5784\u62E2\u9647\u5F04\u5785\u830F\u6CF7\u73D1\u680A\u80E7\u783B\u7643",
        'lou': "\u697C\u5A04\u6402\u7BD3\u6F0F\u964B\u55BD\u5D5D\u9542\u7618\u8027\u877C\u9AC5",
        'lu': "\u82A6\u5362\u9885\u5E90\u7089\u63B3\u5364\u864F\u9C81\u9E93\u788C\u9732\u8DEF\u8D42\u9E7F\u6F5E\u7984\u5F55\u9646\u622E\u5786\u6445\u64B8\u565C\u6CF8\u6E0C\u6F09\u7490\u680C\u6A79\u8F73\u8F82\u8F98\u6C07\u80EA\u9565\u9E2C\u9E6D\u7C0F\u823B\u9C88",
        'lv': "\u9A74\u5415\u94DD\u4FA3\u65C5\u5C65\u5C61\u7F15\u8651\u6C2F\u5F8B\u7387\u6EE4\u7EFF\u634B\u95FE\u6988\u8182\u7A06\u891B",
        'luan': "\u5CE6\u5B6A\u6EE6\u5375\u4E71\u683E\u9E3E\u92AE",
        'lue': "\u63A0\u7565\u950A",
        'lun': "\u8F6E\u4F26\u4ED1\u6CA6\u7EB6\u8BBA\u56F5",
        'luo': "\u841D\u87BA\u7F57\u903B\u9523\u7BA9\u9AA1\u88F8\u843D\u6D1B\u9A86\u7EDC\u502E\u8366\u645E\u7321\u6CFA\u6924\u8136\u9559\u7630\u96D2",
        'ma': "\u5988\u9EBB\u739B\u7801\u8682\u9A6C\u9A82\u561B\u5417\u551B\u72B8\u5B37\u6769\u9EBD",
        'mai': "\u57CB\u4E70\u9EA6\u5356\u8FC8\u8109\u52A2\u836C\u54AA\u973E",
        'man': "\u7792\u9992\u86EE\u6EE1\u8513\u66FC\u6162\u6F2B\u8C29\u5881\u5E54\u7F26\u71B3\u9558\u989F\u87A8\u9CD7\u9794",
        'mang': "\u8292\u832B\u76F2\u5FD9\u83BD\u9099\u6F2D\u6726\u786D\u87D2",
        'meng': "\u6C13\u840C\u8499\u6AAC\u76DF\u9530\u731B\u68A6\u5B5F\u52D0\u750D\u77A2\u61F5\u791E\u867B\u8722\u8813\u824B\u8268\u9EFE",
        'miao': "\u732B\u82D7\u63CF\u7784\u85D0\u79D2\u6E3A\u5E99\u5999\u55B5\u9088\u7F08\u7F2A\u676A\u6DFC\u7707\u9E4B\u8731",
        'mao': "\u8305\u951A\u6BDB\u77DB\u94C6\u536F\u8302\u5192\u5E3D\u8C8C\u8D38\u4F94\u88A4\u52D6\u8306\u5CC1\u7441\u6634\u7266\u8004\u65C4\u61CB\u7780\u86D1\u8765\u87CA\u9AE6",
        'me': "\u4E48",
        'mei': "\u73AB\u679A\u6885\u9176\u9709\u7164\u6CA1\u7709\u5A92\u9541\u6BCF\u7F8E\u6627\u5BD0\u59B9\u5A9A\u5776\u8393\u5D4B\u7338\u6D7C\u6E44\u6963\u9545\u9E5B\u8882\u9B45",
        'men': "\u95E8\u95F7\u4EEC\u626A\u739F\u7116\u61D1\u9494",
        'mi': "\u772F\u919A\u9761\u7CDC\u8FF7\u8C1C\u5F25\u7C73\u79D8\u89C5\u6CCC\u871C\u5BC6\u5E42\u8288\u5196\u8C27\u863C\u5627\u7315\u736F\u6C68\u5B93\u5F2D\u8112\u6549\u7CF8\u7E3B\u9E8B",
        'mian': "\u68C9\u7720\u7EF5\u5195\u514D\u52C9\u5A29\u7F05\u9762\u6C94\u6E4E\u817C\u7704",
        'mie': "\u8511\u706D\u54A9\u881B\u7BFE",
        'min': "\u6C11\u62BF\u76BF\u654F\u60AF\u95FD\u82E0\u5CB7\u95F5\u6CEF\u73C9",
        'ming': "\u660E\u879F\u9E23\u94ED\u540D\u547D\u51A5\u8317\u6E9F\u669D\u7791\u9169",
        'miu': "\u8C2C",
        'mo': "\u6478\u6479\u8611\u6A21\u819C\u78E8\u6469\u9B54\u62B9\u672B\u83AB\u58A8\u9ED8\u6CAB\u6F20\u5BDE\u964C\u8C1F\u8309\u84E6\u998D\u5AEB\u9546\u79E3\u763C\u8031\u87C6\u8C8A\u8C98",
        'mou': "\u8C0B\u725F\u67D0\u53B6\u54DE\u5A7A\u7738\u936A",
        'mu': "\u62C7\u7261\u4EA9\u59C6\u6BCD\u5893\u66AE\u5E55\u52DF\u6155\u6728\u76EE\u7766\u7267\u7A46\u4EEB\u82DC\u5452\u6C90\u6BEA\u94BC",
        'na': "\u62FF\u54EA\u5450\u94A0\u90A3\u5A1C\u7EB3\u5185\u637A\u80AD\u954E\u8872\u7BAC",
        'nai': "\u6C16\u4E43\u5976\u8010\u5948\u9F10\u827F\u8418\u67F0",
        'nan': "\u5357\u7537\u96BE\u56CA\u5583\u56E1\u6960\u8169\u877B\u8D67",
        'nao': "\u6320\u8111\u607C\u95F9\u5B6C\u57B4\u7331\u7459\u7847\u94D9\u86F2",
        'ne': "\u6DD6\u5462\u8BB7",
        'nei': "\u9981",
        'nen': "\u5AE9\u80FD\u6798\u6041",
        'ni': "\u59AE\u9713\u502A\u6CE5\u5C3C\u62DF\u4F60\u533F\u817B\u9006\u6EBA\u4F32\u576D\u730A\u6029\u6EE0\u6635\u65CE\u7962\u615D\u7768\u94CC\u9CB5",
        'nian': "\u852B\u62C8\u5E74\u78BE\u64B5\u637B\u5FF5\u5EFF\u8F87\u9ECF\u9C87\u9CB6",
        'niang': "\u5A18\u917F",
        'niao': "\u9E1F\u5C3F\u8311\u5B32\u8132\u8885",
        'nie': "\u634F\u8042\u5B7D\u556E\u954A\u954D\u6D85\u4E5C\u9667\u8616\u55EB\u8080\u989E\u81EC\u8E51",
        'nin': "\u60A8\u67E0",
        'ning': "\u72DE\u51DD\u5B81\u62E7\u6CDE\u4F5E\u84E5\u549B\u752F\u804D",
        'niu': "\u725B\u626D\u94AE\u7EBD\u72C3\u5FF8\u599E\u86B4",
        'nong': "\u8113\u6D53\u519C\u4FAC",
        'nu': "\u5974\u52AA\u6012\u5476\u5E11\u5F29\u80EC\u5B65\u9A7D",
        'nv': "\u5973\u6067\u9495\u8844",
        'nuan': "\u6696",
        'nuenue': "\u8650",
        'nue': "\u759F\u8C11",
        'nuo': "\u632A\u61E6\u7CEF\u8BFA\u50A9\u6426\u558F\u9518",
        'ou': "\u54E6\u6B27\u9E25\u6BB4\u85D5\u5455\u5076\u6CA4\u6004\u74EF\u8026",
        'pa': "\u556A\u8DB4\u722C\u5E15\u6015\u7436\u8469\u7B62",
        'pai': "\u62CD\u6392\u724C\u5F98\u6E43\u6D3E\u4FF3\u848E",
        'pan': "\u6500\u6F58\u76D8\u78D0\u76FC\u7554\u5224\u53DB\u723F\u6CEE\u88A2\u897B\u87E0\u8E52",
        'pang': "\u4E53\u5E9E\u65C1\u802A\u80D6\u6EC2\u9004",
        'pao': "\u629B\u5486\u5228\u70AE\u888D\u8DD1\u6CE1\u530F\u72CD\u5E96\u812C\u75B1",
        'pei': "\u5478\u80DA\u57F9\u88F4\u8D54\u966A\u914D\u4F69\u6C9B\u638A\u8F94\u5E14\u6DE0\u65C6\u952B\u9185\u9708",
        'pen': "\u55B7\u76C6\u6E53",
        'peng': "\u7830\u62A8\u70F9\u6F8E\u5F6D\u84EC\u68DA\u787C\u7BF7\u81A8\u670B\u9E4F\u6367\u78B0\u576F\u580B\u562D\u6026\u87DB",
        'pi': "\u7812\u9739\u6279\u62AB\u5288\u7435\u6BD7\u5564\u813E\u75B2\u76AE\u5339\u75DE\u50FB\u5C41\u8B6C\u4E15\u9674\u90B3\u90EB\u572E\u9F19\u64D7\u567C\u5E80\u5AB2\u7EB0\u6787\u7513\u7765\u7F74\u94CD\u75E6\u7656\u758B\u868D\u8C94",
        'pian': "\u7BC7\u504F\u7247\u9A97\u8C1D\u9A88\u728F\u80FC\u890A\u7FE9\u8E41",
        'piao': "\u98D8\u6F02\u74E2\u7968\u527D\u560C\u5AD6\u7F25\u6B8D\u779F\u87B5",
        'pie': "\u6487\u77A5\u4E3F\u82E4\u6C15",
        'pin': "\u62FC\u9891\u8D2B\u54C1\u8058\u62DA\u59D8\u5AD4\u6980\u725D\u98A6",
        'ping': "\u4E52\u576A\u82F9\u840D\u5E73\u51ED\u74F6\u8BC4\u5C4F\u4FDC\u5A09\u67B0\u9C86",
        'po': "\u5761\u6CFC\u9887\u5A46\u7834\u9B44\u8FEB\u7C95\u53F5\u9131\u6EA5\u73C0\u948B\u94B7\u76A4\u7B38",
        'pou': "\u5256\u88D2\u8E23",
        'pu': "\u6251\u94FA\u4EC6\u8386\u8461\u83E9\u84B2\u57D4\u6734\u5703\u666E\u6D66\u8C31\u66DD\u7011\u530D\u5657\u6FEE\u749E\u6C06\u9564\u9568\u8E7C",
        'qi': "\u671F\u6B3A\u6816\u621A\u59BB\u4E03\u51C4\u6F06\u67D2\u6C8F\u5176\u68CB\u5947\u6B67\u7566\u5D0E\u8110\u9F50\u65D7\u7948\u7941\u9A91\u8D77\u5C82\u4E5E\u4F01\u542F\u5951\u780C\u5668\u6C14\u8FC4\u5F03\u6C7D\u6CE3\u8BAB\u4E9F\u4E93\u573B\u8291\u840B\u847A\u5601\u5C7A\u5C90\u6C54\u6DC7\u9A90\u7EEE\u742A\u7426\u675E\u6864\u69ED\u6B39\u797A\u61A9\u789B\u86F4\u871E\u7DA6\u7DAE\u8DBF\u8E4A\u9CCD\u9E92",
        'qia': "\u6390\u6070\u6D3D\u845C",
        'qian': "\u7275\u6266\u948E\u94C5\u5343\u8FC1\u7B7E\u4EDF\u8C26\u4E7E\u9ED4\u94B1\u94B3\u524D\u6F5C\u9063\u6D45\u8C34\u5811\u5D4C\u6B20\u6B49\u4F65\u9621\u828A\u82A1\u8368\u63AE\u5C8D\u60AD\u614A\u9A9E\u6434\u8930\u7F31\u6920\u80B7\u6106\u94A4\u8654\u7B9D",
        'qiang': "\u67AA\u545B\u8154\u7F8C\u5899\u8537\u5F3A\u62A2\u5AF1\u6A2F\u6217\u709D\u9516\u9535\u956A\u8941\u8723\u7F9F\u8DEB\u8DC4",
        'qiao': "\u6A47\u9539\u6572\u6084\u6865\u77A7\u4E54\u4FA8\u5DE7\u9798\u64AC\u7FD8\u5CED\u4FCF\u7A8D\u5281\u8BEE\u8C2F\u835E\u6100\u6194\u7F32\u6A35\u6BF3\u7857\u8DF7\u9792",
        'qie': "\u5207\u8304\u4E14\u602F\u7A83\u90C4\u553C\u60EC\u59BE\u6308\u9532\u7BA7",
        'qin': "\u94A6\u4FB5\u4EB2\u79E6\u7434\u52E4\u82B9\u64D2\u79BD\u5BDD\u6C81\u82A9\u84C1\u8572\u63FF\u5423\u55EA\u5659\u6EB1\u6A8E\u8793\u887E",
        'qing': "\u9752\u8F7B\u6C22\u503E\u537F\u6E05\u64CE\u6674\u6C30\u60C5\u9877\u8BF7\u5E86\u5029\u82D8\u570A\u6AA0\u78EC\u873B\u7F44\u7B90\u8B26\u9CAD\u9EE5",
        'qiong': "\u743C\u7A77\u909B\u8315\u7A79\u7B47\u928E",
        'qiu': "\u79CB\u4E18\u90B1\u7403\u6C42\u56DA\u914B\u6CC5\u4FC5\u6C3D\u5DEF\u827D\u72B0\u6E6B\u9011\u9052\u6978\u8D47\u9E20\u866C\u86AF\u8764\u88D8\u7CD7\u9CC5\u9F3D",
        'qu': "\u8D8B\u533A\u86C6\u66F2\u8EAF\u5C48\u9A71\u6E20\u53D6\u5A36\u9F8B\u8DA3\u53BB\u8BCE\u52AC\u8556\u8627\u5C96\u8862\u9612\u74A9\u89D1\u6C0D\u795B\u78F2\u766F\u86D0\u883C\u9EB4\u77BF\u9EE2",
        'quan': "\u5708\u98A7\u6743\u919B\u6CC9\u5168\u75CA\u62F3\u72AC\u5238\u529D\u8BE0\u8343\u737E\u609B\u7EFB\u8F81\u754E\u94E8\u8737\u7B4C\u9B08",
        'que': "\u7F3A\u7094\u7638\u5374\u9E4A\u69B7\u786E\u96C0\u9619\u60AB",
        'qun': "\u88D9\u7FA4\u9021",
        'ran': "\u7136\u71C3\u5189\u67D3\u82D2\u9AEF",
        'rang': "\u74E4\u58E4\u6518\u56B7\u8BA9\u79B3\u7A70",
        'rao': "\u9976\u6270\u7ED5\u835B\u5A06\u6861",
        'ruo': "\u60F9\u82E5\u5F31",
        're': "\u70ED\u504C",
        'ren': "\u58EC\u4EC1\u4EBA\u5FCD\u97E7\u4EFB\u8BA4\u5203\u598A\u7EAB\u4EDE\u834F\u845A\u996A\u8F6B\u7A14\u887D",
        'reng': "\u6254\u4ECD",
        'ri': "\u65E5",
        'rong': "\u620E\u8338\u84C9\u8363\u878D\u7194\u6EB6\u5BB9\u7ED2\u5197\u5D58\u72E8\u7F1B\u6995\u877E",
        'rou': "\u63C9\u67D4\u8089\u7CC5\u8E42\u97A3",
        'ru': "\u8339\u8815\u5112\u5B7A\u5982\u8FB1\u4E73\u6C5D\u5165\u8925\u84D0\u85B7\u5685\u6D33\u6EBD\u6FE1\u94F7\u8966\u98A5",
        'ruan': "\u8F6F\u962E\u670A",
        'rui': "\u854A\u745E\u9510\u82AE\u8564\u777F\u868B",
        'run': "\u95F0\u6DA6",
        'sa': "\u6492\u6D12\u8428\u5345\u4EE8\u6332\u98D2",
        'sai': "\u816E\u9CC3\u585E\u8D5B\u567B",
        'san': "\u4E09\u53C1\u4F1E\u6563\u5F61\u9993\u6C35\u6BF5\u7CC1\u9730",
        'sang': "\u6851\u55D3\u4E27\u6421\u78C9\u98A1",
        'sao': "\u6414\u9A9A\u626B\u5AC2\u57FD\u81CA\u7619\u9CCB",
        'se': "\u745F\u8272\u6DA9\u556C\u94E9\u94EF\u7A51",
        'sen': "\u68EE",
        'seng': "\u50E7",
        'sha': "\u838E\u7802\u6740\u5239\u6C99\u7EB1\u50BB\u5565\u715E\u810E\u6B43\u75E7\u88DF\u970E\u9CA8",
        'shai': "\u7B5B\u6652\u917E",
        'shan': "\u73CA\u82EB\u6749\u5C71\u5220\u717D\u886B\u95EA\u9655\u64C5\u8D61\u81B3\u5584\u6C55\u6247\u7F2E\u5261\u8BAA\u912F\u57CF\u829F\u6F78\u59D7\u9A9F\u81BB\u9490\u759D\u87EE\u8222\u8DDA\u9CDD",
        'shang': "\u5892\u4F24\u5546\u8D4F\u664C\u4E0A\u5C1A\u88F3\u57A7\u7EF1\u6B87\u71B5\u89DE",
        'shao': "\u68A2\u634E\u7A0D\u70E7\u828D\u52FA\u97F6\u5C11\u54E8\u90B5\u7ECD\u52AD\u82D5\u6F72\u86F8\u7B24\u7B72\u8244",
        'she': "\u5962\u8D4A\u86C7\u820C\u820D\u8D66\u6444\u5C04\u6151\u6D89\u793E\u8BBE\u538D\u4F58\u731E\u7572\u9E9D",
        'shen': "\u7837\u7533\u547B\u4F38\u8EAB\u6DF1\u5A20\u7EC5\u795E\u6C88\u5BA1\u5A76\u751A\u80BE\u614E\u6E17\u8BDC\u8C02\u5432\u54C2\u6E16\u6939\u77E7\u8703",
        'sheng': "\u58F0\u751F\u7525\u7272\u5347\u7EF3\u7701\u76DB\u5269\u80DC\u5723\u4E1E\u6E11\u5AB5\u771A\u7B19",
        'shi': "\u5E08\u5931\u72EE\u65BD\u6E7F\u8BD7\u5C38\u8671\u5341\u77F3\u62FE\u65F6\u4EC0\u98DF\u8680\u5B9E\u8BC6\u53F2\u77E2\u4F7F\u5C4E\u9A76\u59CB\u5F0F\u793A\u58EB\u4E16\u67FF\u4E8B\u62ED\u8A93\u901D\u52BF\u662F\u55DC\u566C\u9002\u4ED5\u4F8D\u91CA\u9970\u6C0F\u5E02\u6043\u5BA4\u89C6\u8BD5\u8C25\u57D8\u83B3\u84CD\u5F11\u5511\u9963\u8F7C\u8006\u8D33\u70BB\u793B\u94C8\u94CA\u87AB\u8210\u7B6E\u8C55\u9CA5\u9CBA",
        'shou': "\u6536\u624B\u9996\u5B88\u5BFF\u6388\u552E\u53D7\u7626\u517D\u624C\u72E9\u7EF6\u824F",
        'shu': "\u852C\u67A2\u68B3\u6B8A\u6292\u8F93\u53D4\u8212\u6DD1\u758F\u4E66\u8D4E\u5B70\u719F\u85AF\u6691\u66D9\u7F72\u8700\u9ECD\u9F20\u5C5E\u672F\u8FF0\u6811\u675F\u620D\u7AD6\u5885\u5EB6\u6570\u6F31\u6055\u500F\u587E\u83FD\u5FC4\u6CAD\u6D91\u6F8D\u59DD\u7EBE\u6BF9\u8167\u6BB3\u956F\u79EB\u9E6C",
        'shua': "\u5237\u800D\u5530\u6DAE",
        'shuai': "\u6454\u8870\u7529\u5E05\u87C0",
        'shuan': "\u6813\u62F4\u95E9",
        'shuang': "\u971C\u53CC\u723D\u5B40",
        'shui': "\u8C01\u6C34\u7761\u7A0E",
        'shun': "\u542E\u77AC\u987A\u821C\u6042",
        'shuo': "\u8BF4\u7855\u6714\u70C1\u84B4\u6420\u55CD\u6FEF\u5981\u69CA\u94C4",
        'si': "\u65AF\u6495\u5636\u601D\u79C1\u53F8\u4E1D\u6B7B\u8086\u5BFA\u55E3\u56DB\u4F3A\u4F3C\u9972\u5DF3\u53AE\u4FDF\u5155\u83E5\u549D\u6C5C\u6CD7\u6F8C\u59D2\u9A77\u7F0C\u7940\u7960\u9536\u9E36\u801C\u86F3\u7B25",
        'song': "\u677E\u8038\u6002\u9882\u9001\u5B8B\u8BBC\u8BF5\u51C7\u83D8\u5D27\u5D69\u5FEA\u609A\u6DDE\u7AE6",
        'sou': "\u641C\u8258\u64DE\u55FD\u53DF\u55D6\u55FE\u998A\u6EB2\u98D5\u778D\u953C\u878B",
        'su': "\u82CF\u9165\u4FD7\u7D20\u901F\u7C9F\u50F3\u5851\u6EAF\u5BBF\u8BC9\u8083\u5919\u8C21\u850C\u55C9\u612B\u7C0C\u89EB\u7A23",
        'suan': "\u9178\u849C\u7B97",
        'sui': "\u867D\u968B\u968F\u7EE5\u9AD3\u788E\u5C81\u7A57\u9042\u96A7\u795F\u84D1\u51AB\u8C07\u6FC9\u9083\u71E7\u772D\u7762",
        'sun': "\u5B59\u635F\u7B0B\u836A\u72F2\u98E7\u69AB\u8DE3\u96BC",
        'suo': "\u68AD\u5506\u7F29\u7410\u7D22\u9501\u6240\u5522\u55E6\u5A11\u686B\u7743\u7FA7",
        'ta': "\u584C\u4ED6\u5B83\u5979\u5854\u736D\u631E\u8E4B\u8E0F\u95FC\u6EBB\u9062\u69BB\u6C93",
        'tai': "\u80CE\u82D4\u62AC\u53F0\u6CF0\u915E\u592A\u6001\u6C70\u90B0\u85B9\u80BD\u70B1\u949B\u8DC6\u9C90",
        'tan': "\u574D\u644A\u8D2A\u762B\u6EE9\u575B\u6A80\u75F0\u6F6D\u8C2D\u8C08\u5766\u6BEF\u8892\u78B3\u63A2\u53F9\u70AD\u90EF\u8548\u6619\u94BD\u952C\u8983",
        'tang': "\u6C64\u5858\u642A\u5802\u68E0\u819B\u5510\u7CD6\u50A5\u9967\u6E8F\u746D\u94F4\u9557\u8025\u8797\u87B3\u7FB0\u91A3",
        'thang': "\u5018\u8EBA\u6DCC",
        'theng': "\u8D9F\u70EB",
        'tao': "\u638F\u6D9B\u6ED4\u7EE6\u8404\u6843\u9003\u6DD8\u9676\u8BA8\u5957\u6311\u9F17\u5555\u97EC\u9955",
        'te': "\u7279",
        'teng': "\u85E4\u817E\u75BC\u8A8A\u6ED5",
        'ti': "\u68AF\u5254\u8E22\u9511\u63D0\u9898\u8E44\u557C\u4F53\u66FF\u568F\u60D5\u6D95\u5243\u5C49\u8351\u608C\u9016\u7EE8\u7F07\u9E48\u88FC\u918D",
        'tian': "\u5929\u6DFB\u586B\u7530\u751C\u606C\u8214\u8146\u63AD\u5FDD\u9617\u6B84\u754B\u94BF\u86BA",
        'tiao': "\u6761\u8FE2\u773A\u8DF3\u4F7B\u7967\u94EB\u7A95\u9F86\u9CA6",
        'tie': "\u8D34\u94C1\u5E16\u841C\u992E",
        'ting': "\u5385\u542C\u70C3\u6C40\u5EF7\u505C\u4EAD\u5EAD\u633A\u8247\u839B\u8476\u5A77\u6883\u8713\u9706",
        'tong': "\u901A\u6850\u916E\u77B3\u540C\u94DC\u5F64\u7AE5\u6876\u6345\u7B52\u7EDF\u75DB\u4F5F\u50EE\u4EDD\u833C\u55F5\u6078\u6F7C\u783C",
        'tou': "\u5077\u6295\u5934\u900F\u4EA0",
        'tu': "\u51F8\u79C3\u7A81\u56FE\u5F92\u9014\u6D82\u5C60\u571F\u5410\u5154\u580D\u837C\u83DF\u948D\u9174",
        'tuan': "\u6E4D\u56E2\u7583",
        'tui': "\u63A8\u9893\u817F\u8715\u892A\u9000\u5FD2\u717A",
        'tun': "\u541E\u5C6F\u81C0\u9968\u66BE\u8C5A\u7A80",
        'tuo': "\u62D6\u6258\u8131\u9E35\u9640\u9A6E\u9A7C\u692D\u59A5\u62D3\u553E\u4E47\u4F57\u5768\u5EB9\u6CB1\u67DD\u7823\u7BA8\u8204\u8DCE\u9F0D",
        'wa': "\u6316\u54C7\u86D9\u6D3C\u5A03\u74E6\u889C\u4F64\u5A32\u817D",
        'wai': "\u6B6A\u5916",
        'wan': "\u8C4C\u5F2F\u6E7E\u73A9\u987D\u4E38\u70F7\u5B8C\u7897\u633D\u665A\u7696\u60CB\u5B9B\u5A49\u4E07\u8155\u525C\u8284\u82CB\u83C0\u7EA8\u7EFE\u742C\u8118\u7579\u873F\u7BA2",
        'wang': "\u6C6A\u738B\u4EA1\u6789\u7F51\u5F80\u65FA\u671B\u5FD8\u5984\u7F54\u5C22\u60D8\u8F8B\u9B4D",
        'wei': "\u5A01\u5DCD\u5FAE\u5371\u97E6\u8FDD\u6845\u56F4\u552F\u60DF\u4E3A\u6F4D\u7EF4\u82C7\u840E\u59D4\u4F1F\u4F2A\u5C3E\u7EAC\u672A\u851A\u5473\u754F\u80C3\u5582\u9B4F\u4F4D\u6E2D\u8C13\u5C09\u6170\u536B\u502D\u504E\u8BFF\u9688\u8473\u8587\u5E0F\u5E37\u5D34\u5D6C\u7325\u732C\u95F1\u6CA9\u6D27\u6DA0\u9036\u5A13\u73AE\u97EA\u8ECE\u709C\u7168\u71A8\u75FF\u8249\u9C94",
        'wen': "\u761F\u6E29\u868A\u6587\u95FB\u7EB9\u543B\u7A33\u7D0A\u95EE\u520E\u6120\u960C\u6C76\u74BA\u97EB\u6B81\u96EF",
        'weng': "\u55E1\u7FC1\u74EE\u84CA\u8579",
        'wo': "\u631D\u8717\u6DA1\u7A9D\u6211\u65A1\u5367\u63E1\u6C83\u83B4\u5E44\u6E25\u674C\u809F\u9F8C",
        'wu': "\u5DEB\u545C\u94A8\u4E4C\u6C61\u8BEC\u5C4B\u65E0\u829C\u68A7\u543E\u5434\u6BCB\u6B66\u4E94\u6342\u5348\u821E\u4F0D\u4FAE\u575E\u620A\u96FE\u6664\u7269\u52FF\u52A1\u609F\u8BEF\u5140\u4EF5\u9622\u90AC\u572C\u82B4\u5E91\u6003\u5FE4\u6D6F\u5BE4\u8FD5\u59A9\u9A9B\u727E\u7110\u9E49\u9E5C\u8708\u92C8\u9F2F",
        'xi': "\u6614\u7199\u6790\u897F\u7852\u77FD\u6670\u563B\u5438\u9521\u727A\u7A00\u606F\u5E0C\u6089\u819D\u5915\u60DC\u7184\u70EF\u6EAA\u6C50\u7280\u6A84\u88AD\u5E2D\u4E60\u5AB3\u559C\u94E3\u6D17\u7CFB\u9699\u620F\u7EC6\u50D6\u516E\u96B0\u90D7\u831C\u8478\u84F0\u595A\u550F\u5F99\u9969\u960B\u6D60\u6DC5\u5C63\u5B09\u73BA\u6A28\u66E6\u89CB\u6B37\u71B9\u798A\u79A7\u94B8\u7699\u7A78\u8725\u87CB\u823E\u7FB2\u7C9E\u7FD5\u91AF\u9F37",
        'xia': "\u778E\u867E\u5323\u971E\u8F96\u6687\u5CE1\u4FA0\u72ED\u4E0B\u53A6\u590F\u5413\u6380\u846D\u55C4\u72CE\u9050\u7455\u7856\u7615\u7F45\u9EE0",
        'xian': "\u9528\u5148\u4ED9\u9C9C\u7EA4\u54B8\u8D24\u8854\u8237\u95F2\u6D8E\u5F26\u5ACC\u663E\u9669\u73B0\u732E\u53BF\u817A\u9985\u7FA1\u5BAA\u9677\u9650\u7EBF\u51BC\u85D3\u5C98\u7303\u66B9\u5A34\u6C19\u7946\u9E47\u75EB\u86AC\u7B45\u7C7C\u9170\u8DF9",
        'xiang': "\u76F8\u53A2\u9576\u9999\u7BB1\u8944\u6E58\u4E61\u7FD4\u7965\u8BE6\u60F3\u54CD\u4EAB\u9879\u5DF7\u6A61\u50CF\u5411\u8C61\u8297\u8459\u9977\u5EA0\u9AA7\u7F03\u87D3\u9C9E\u98E8",
        'xiao': "\u8427\u785D\u9704\u524A\u54EE\u56A3\u9500\u6D88\u5BB5\u6DC6\u6653\u5C0F\u5B5D\u6821\u8096\u5578\u7B11\u6548\u54D3\u54BB\u5D24\u6F47\u900D\u9A81\u7EE1\u67AD\u67B5\u7B71\u7BAB\u9B48",
        'xie': "\u6954\u4E9B\u6B47\u874E\u978B\u534F\u631F\u643A\u90AA\u659C\u80C1\u8C10\u5199\u68B0\u5378\u87F9\u61C8\u6CC4\u6CFB\u8C22\u5C51\u5055\u4EB5\u52F0\u71EE\u85A4\u64B7\u5EE8\u7023\u9082\u7EC1\u7F2C\u69AD\u698D\u6B59\u8E9E",
        'xin': "\u85AA\u82AF\u950C\u6B23\u8F9B\u65B0\u5FFB\u5FC3\u4FE1\u8845\u56DF\u99A8\u8398\u6B46\u94FD\u946B",
        'xing': "\u661F\u8165\u7329\u60FA\u5174\u5211\u578B\u5F62\u90A2\u884C\u9192\u5E78\u674F\u6027\u59D3\u9649\u8347\u8365\u64E4\u60BB\u784E",
        'xiong': "\u5144\u51F6\u80F8\u5308\u6C79\u96C4\u718A\u828E",
        'xiu': "\u4F11\u4FEE\u7F9E\u673D\u55C5\u9508\u79C0\u8896\u7EE3\u83A0\u5CAB\u9990\u5EA5\u9E3A\u8C85\u9AF9",
        'xu': "\u589F\u620C\u9700\u865A\u5618\u987B\u5F90\u8BB8\u84C4\u9157\u53D9\u65ED\u5E8F\u755C\u6064\u7D6E\u5A7F\u7EEA\u7EED\u8BB4\u8BE9\u5729\u84FF\u6035\u6D2B\u6E86\u987C\u6829\u7166\u7809\u76F1\u80E5\u7CC8\u9191",
        'xuan': "\u8F69\u55A7\u5BA3\u60AC\u65CB\u7384\u9009\u7663\u7729\u7EDA\u5107\u8C16\u8431\u63CE\u9994\u6CEB\u6D35\u6E32\u6F29\u7487\u6966\u6684\u70AB\u714A\u78B9\u94C9\u955F\u75C3",
        'xue': "\u9774\u859B\u5B66\u7A74\u96EA\u8840\u5671\u6CF6\u9CD5",
        'xun': "\u52CB\u718F\u5FAA\u65EC\u8BE2\u5BFB\u9A6F\u5DE1\u6B89\u6C5B\u8BAD\u8BAF\u900A\u8FC5\u5DFD\u57D9\u8340\u85B0\u5CCB\u5F87\u6D54\u66DB\u7AA8\u91BA\u9C9F",
        'ya': "\u538B\u62BC\u9E26\u9E2D\u5440\u4E2B\u82BD\u7259\u869C\u5D16\u8859\u6DAF\u96C5\u54D1\u4E9A\u8BB6\u4F22\u63E0\u5416\u5C88\u8FD3\u5A05\u740A\u6860\u6C29\u7811\u775A\u75D6",
        'yan': "\u7109\u54BD\u9609\u70DF\u6DF9\u76D0\u4E25\u7814\u8712\u5CA9\u5EF6\u8A00\u989C\u960E\u708E\u6CBF\u5944\u63A9\u773C\u884D\u6F14\u8273\u5830\u71D5\u538C\u781A\u96C1\u5501\u5F66\u7130\u5BB4\u8C1A\u9A8C\u53A3\u9765\u8D5D\u4FE8\u5043\u5156\u8BA0\u8C33\u90FE\u9122\u82AB\u83F8\u5D26\u6079\u95EB\u960F\u6D07\u6E6E\u6EDF\u598D\u5AE3\u7430\u664F\u80ED\u814C\u7131\u7F68\u7B75\u917D\u9B47\u990D\u9F39",
        'yang': "\u6B83\u592E\u9E2F\u79E7\u6768\u626C\u4F6F\u75A1\u7F8A\u6D0B\u9633\u6C27\u4EF0\u75D2\u517B\u6837\u6F3E\u5F89\u600F\u6CF1\u7080\u70CA\u6059\u86D8\u9785",
        'yao': "\u9080\u8170\u5996\u7476\u6447\u5C27\u9065\u7A91\u8C23\u59DA\u54AC\u8200\u836F\u8981\u8000\u592D\u723B\u5406\u5D3E\u5FAD\u7039\u5E7A\u73E7\u6773\u66DC\u80B4\u9E5E\u7A88\u7E47\u9CD0",
        'ye': "\u6930\u564E\u8036\u7237\u91CE\u51B6\u4E5F\u9875\u6396\u4E1A\u53F6\u66F3\u814B\u591C\u6DB2\u8C12\u90BA\u63F6\u9980\u6654\u70E8\u94D8",
        'yi': "\u4E00\u58F9\u533B\u63D6\u94F1\u4F9D\u4F0A\u8863\u9890\u5937\u9057\u79FB\u4EEA\u80F0\u7591\u6C82\u5B9C\u59E8\u5F5D\u6905\u8681\u501A\u5DF2\u4E59\u77E3\u4EE5\u827A\u6291\u6613\u9091\u5C79\u4EBF\u5F79\u81C6\u9038\u8084\u75AB\u4EA6\u88D4\u610F\u6BC5\u5FC6\u4E49\u76CA\u6EA2\u8BE3\u8BAE\u8C0A\u8BD1\u5F02\u7FFC\u7FCC\u7ECE\u5208\u5293\u4F7E\u8BD2\u572A\u572F\u57F8\u61FF\u82E1\u858F\u5F08\u5955\u6339\u5F0B\u5453\u54A6\u54BF\u566B\u5CC4\u5DB7\u7317\u9974\u603F\u6021\u6092\u6F2A\u8FE4\u9A7F\u7F22\u6BAA\u8D3B\u65D6\u71A0\u9487\u9552\u9571\u75CD\u7617\u7654\u7FCA\u8864\u8734\u8223\u7FBF\u7FF3\u914F\u9EDF",
        'yin': "\u8335\u836B\u56E0\u6BB7\u97F3\u9634\u59FB\u541F\u94F6\u6DEB\u5BC5\u996E\u5C39\u5F15\u9690\u5370\u80E4\u911E\u5819\u831A\u5591\u72FA\u5924\u6C24\u94DF\u763E\u8693\u972A\u9F88",
        'ying': "\u82F1\u6A31\u5A74\u9E70\u5E94\u7F28\u83B9\u8424\u8425\u8367\u8747\u8FCE\u8D62\u76C8\u5F71\u9896\u786C\u6620\u5B34\u90E2\u8314\u83BA\u8426\u6484\u5624\u81BA\u6EE2\u6F46\u701B\u745B\u748E\u6979\u9E66\u763F\u988D\u7F42",
        'yo': "\u54DF\u5537",
        'yong': "\u62E5\u4F63\u81C3\u75C8\u5EB8\u96CD\u8E0A\u86F9\u548F\u6CF3\u6D8C\u6C38\u607F\u52C7\u7528\u4FD1\u58C5\u5889\u6175\u9095\u955B\u752C\u9CD9\u9954",
        'you': "\u5E7D\u4F18\u60A0\u5FE7\u5C24\u7531\u90AE\u94C0\u72B9\u6CB9\u6E38\u9149\u6709\u53CB\u53F3\u4F51\u91C9\u8BF1\u53C8\u5E7C\u5363\u6538\u4F91\u83B8\u5466\u56FF\u5BA5\u67DA\u7337\u7256\u94D5\u75A3\u8763\u9C7F\u9EDD\u9F2C",
        'yu': "\u8FC2\u6DE4\u4E8E\u76C2\u6986\u865E\u611A\u8206\u4F59\u4FDE\u903E\u9C7C\u6109\u6E1D\u6E14\u9685\u4E88\u5A31\u96E8\u4E0E\u5C7F\u79B9\u5B87\u8BED\u7FBD\u7389\u57DF\u828B\u90C1\u5401\u9047\u55BB\u5CEA\u5FA1\u6108\u6B32\u72F1\u80B2\u8A89\u6D74\u5BD3\u88D5\u9884\u8C6B\u9A6D\u79BA\u6BD3\u4F1B\u4FE3\u8C00\u8C15\u8438\u84E3\u63C4\u5581\u5704\u5709\u5D5B\u72F3\u996B\u5EBE\u9608\u59AA\u59A4\u7EA1\u745C\u6631\u89CE\u8174\u6B24\u65BC\u715C\u71E0\u807F\u94B0\u9E46\u7610\u7600\u7AB3\u8753\u7AFD\u8201\u96E9\u9F89",
        'yuan': "\u9E33\u6E0A\u51A4\u5143\u57A3\u8881\u539F\u63F4\u8F95\u56ED\u5458\u5706\u733F\u6E90\u7F18\u8FDC\u82D1\u613F\u6028\u9662\u586C\u6C85\u5A9B\u7457\u6A7C\u7230\u7722\u9E22\u8788\u9F0B",
        'yue': "\u66F0\u7EA6\u8D8A\u8DC3\u94A5\u5CB3\u7CA4\u6708\u60A6\u9605\u9FA0\u6A3E\u5216\u94BA",
        'yun': "\u8018\u4E91\u90E7\u5300\u9668\u5141\u8FD0\u8574\u915D\u6655\u97F5\u5B55\u90D3\u82B8\u72C1\u607D\u7EAD\u6B92\u6600\u6C32",
        'za': "\u531D\u7838\u6742\u62F6\u5482",
        'zai': "\u683D\u54C9\u707E\u5BB0\u8F7D\u518D\u5728\u54B1\u5D3D\u753E",
        'zan': "\u6512\u6682\u8D5E\u74D2\u661D\u7C2A\u7CCC\u8DB1\u933E",
        'zang': "\u8D43\u810F\u846C\u5958\u6215\u81E7",
        'zao': "\u906D\u7CDF\u51FF\u85FB\u67A3\u65E9\u6FA1\u86A4\u8E81\u566A\u9020\u7682\u7076\u71E5\u5523\u7F2B",
        'ze': "\u8D23\u62E9\u5219\u6CFD\u4EC4\u8D5C\u5567\u8FEE\u6603\u7B2E\u7BA6\u8234",
        'zei': "\u8D3C",
        'zen': "\u600E\u8C2E",
        'zeng': "\u589E\u618E\u66FE\u8D60\u7F2F\u7511\u7F7E\u9503",
        'zha': "\u624E\u55B3\u6E23\u672D\u8F67\u94E1\u95F8\u7728\u6805\u69A8\u548B\u4E4D\u70B8\u8BC8\u63F8\u5412\u54A4\u54F3\u600D\u781F\u75C4\u86B1\u9F44",
        'zhai': "\u6458\u658B\u5B85\u7A84\u503A\u5BE8\u7826",
        'zhan': "\u77BB\u6BE1\u8A79\u7C98\u6CBE\u76CF\u65A9\u8F97\u5D2D\u5C55\u8638\u6808\u5360\u6218\u7AD9\u6E5B\u7EFD\u8C35\u640C\u65C3",
        'zhang': "\u6A1F\u7AE0\u5F70\u6F33\u5F20\u638C\u6DA8\u6756\u4E08\u5E10\u8D26\u4ED7\u80C0\u7634\u969C\u4EC9\u9123\u5E5B\u5D82\u7350\u5ADC\u748B\u87D1",
        'zhao': "\u62DB\u662D\u627E\u6CBC\u8D75\u7167\u7F69\u5146\u8087\u53EC\u722A\u8BCF\u68F9\u948A\u7B0A",
        'zhe': "\u906E\u6298\u54F2\u86F0\u8F99\u8005\u9517\u8517\u8FD9\u6D59\u8C2A\u966C\u67D8\u8F84\u78D4\u9E67\u891A\u8707\u8D6D",
        'zhen': "\u73CD\u659F\u771F\u7504\u7827\u81FB\u8D1E\u9488\u4FA6\u6795\u75B9\u8BCA\u9707\u632F\u9547\u9635\u7F1C\u6862\u699B\u8F78\u8D48\u80D7\u6715\u796F\u755B\u9E29",
        'zheng': "\u84B8\u6323\u7741\u5F81\u72F0\u4E89\u6014\u6574\u62EF\u6B63\u653F\u5E27\u75C7\u90D1\u8BC1\u8BE4\u5CE5\u94B2\u94EE\u7B5D",
        'zhi': "\u829D\u679D\u652F\u5431\u8718\u77E5\u80A2\u8102\u6C41\u4E4B\u7EC7\u804C\u76F4\u690D\u6B96\u6267\u503C\u4F84\u5740\u6307\u6B62\u8DBE\u53EA\u65E8\u7EB8\u5FD7\u631A\u63B7\u81F3\u81F4\u7F6E\u5E1C\u5CD9\u5236\u667A\u79E9\u7A1A\u8D28\u7099\u75D4\u6EDE\u6CBB\u7A92\u536E\u965F\u90C5\u57F4\u82B7\u646D\u5E19\u5FEE\u5F58\u54AB\u9A98\u6809\u67B3\u6800\u684E\u8F75\u8F7E\u6534\u8D3D\u81A3\u7949\u7957\u9EF9\u96C9\u9E37\u75E3\u86ED\u7D77\u916F\u8DD6\u8E2C\u8E2F\u8C78\u89EF",
        'zhong': "\u4E2D\u76C5\u5FE0\u949F\u8877\u7EC8\u79CD\u80BF\u91CD\u4EF2\u4F17\u51A2\u953A\u87BD\u8202\u822F\u8E35",
        'zhou': "\u821F\u5468\u5DDE\u6D32\u8BCC\u7CA5\u8F74\u8098\u5E1A\u5492\u76B1\u5B99\u663C\u9AA4\u5544\u7740\u501C\u8BF9\u836E\u9B3B\u7EA3\u80C4\u78A1\u7C40\u8233\u914E\u9CB7",
        'zhu': "\u73E0\u682A\u86DB\u6731\u732A\u8BF8\u8BDB\u9010\u7AF9\u70DB\u716E\u62C4\u77A9\u5631\u4E3B\u8457\u67F1\u52A9\u86C0\u8D2E\u94F8\u7B51\u4F4F\u6CE8\u795D\u9A7B\u4F2B\u4F8F\u90BE\u82CE\u8331\u6D19\u6E1A\u6F74\u9A7A\u677C\u69E0\u6A65\u70B7\u94E2\u75B0\u7603\u86B0\u7AFA\u7BB8\u7FE5\u8E85\u9E88",
        'zhua': "\u6293",
        'zhuai': "\u62FD",
        'zhuan': "\u4E13\u7816\u8F6C\u64B0\u8D5A\u7BC6\u629F\u556D\u989B",
        'zhuang': "\u6869\u5E84\u88C5\u5986\u649E\u58EE\u72B6\u4E2C",
        'zhui': "\u690E\u9525\u8FFD\u8D58\u5760\u7F00\u8411\u9A93\u7F12",
        'zhun': "\u8C06\u51C6",
        'zhuo': "\u6349\u62D9\u5353\u684C\u7422\u8301\u914C\u707C\u6D4A\u502C\u8BFC\u5EF4\u855E\u64E2\u555C\u6D5E\u6DBF\u6753\u712F\u799A\u65AB",
        'zi': "\u5179\u54A8\u8D44\u59FF\u6ECB\u6DC4\u5B5C\u7D2B\u4ED4\u7C7D\u6ED3\u5B50\u81EA\u6E0D\u5B57\u8C18\u5D6B\u59CA\u5B73\u7F01\u6893\u8F8E\u8D40\u6063\u7726\u9531\u79ED\u8014\u7B2B\u7CA2\u89DC\u8A3E\u9CBB\u9AED",
        'zong': "\u9B03\u68D5\u8E2A\u5B97\u7EFC\u603B\u7EB5\u8159\u7CBD",
        'zou': "\u90B9\u8D70\u594F\u63CD\u9139\u9CB0",
        'zu': "\u79DF\u8DB3\u5352\u65CF\u7956\u8BC5\u963B\u7EC4\u4FCE\u83F9\u5550\u5F82\u9A75\u8E74",
        'zuan': "\u94BB\u7E82\u6525\u7F35",
        'zui': "\u5634\u9189\u6700\u7F6A",
        'zun': "\u5C0A\u9075\u6499\u6A3D\u9CDF",
        'zuo': "\u6628\u5DE6\u4F50\u67DE\u505A\u4F5C\u5750\u5EA7\u961D\u963C\u80D9\u795A\u9162",
        'cou': "\u85AE\u6971\u8F8F\u8160",
        'nang': "\u652E\u54DD\u56D4\u9995\u66E9",
        'o': "\u5594",
        'dia': "\u55F2",
        'chuai': "\u562C\u81AA\u8E39",
        'cen': "\u5C91\u6D94",
        'diu': "\u94E5",
        'nou': "\u8028",
        'fou': "\u7F36",
        'bia': "\u9ADF"
      };
      this.polyphone = {
        '19969': 'DZ',
        '19975': 'WM',
        '19988': 'QJ',
        '20048': 'YL',
        '20056': 'SC',
        '20060': 'NM',
        '20094': 'QG',
        '20127': 'QJ',
        '20167': 'QC',
        '20193': 'YG',
        '20250': 'KH',
        '20256': 'ZC',
        '20282': 'SC',
        '20285': 'QJG',
        '20291': 'TD',
        '20314': 'YD',
        '20340': 'NE',
        '20375': 'TD',
        '20389': 'YJ',
        '20391': 'CZ',
        '20415': 'PB',
        '20446': 'YS',
        '20447': 'SQ',
        '20504': 'TC',
        '20608': 'KG',
        '20854': 'QJ',
        '20857': 'ZC',
        '20911': 'PF',
        '20985': 'AW',
        '21032': 'PB',
        '21048': 'XQ',
        '21049': 'SC',
        '21089': 'YS',
        '21119': 'JC',
        '21242': 'SB',
        '21273': 'SC',
        '21305': 'YP',
        '21306': 'QO',
        '21330': 'ZC',
        '21333': 'SDC',
        '21345': 'QK',
        '21378': 'CA',
        '21397': 'SC',
        '21414': 'XS',
        '21442': 'SC',
        '21477': 'JG',
        '21480': 'TD',
        '21484': 'ZS',
        '21494': 'YX',
        '21505': 'YX',
        '21512': 'HG',
        '21523': 'XH',
        '21537': 'PB',
        '21542': 'PF',
        '21549': 'KH',
        '21571': 'E',
        '21574': 'DA',
        '21588': 'TD',
        '21589': 'O',
        '21618': 'ZC',
        '21621': 'KHA',
        '21632': 'ZJ',
        '21654': 'KG',
        '21679': 'LKG',
        '21683': 'KH',
        '21710': 'A',
        '21719': 'YH',
        '21734': 'WOE',
        '21769': 'A',
        '21780': 'WN',
        '21804': 'XH',
        '21834': 'A',
        '21899': 'ZD',
        '21903': 'RN',
        '21908': 'WO',
        '21939': 'ZC',
        '21956': 'SA',
        '21964': 'YA',
        '21970': 'TD',
        '22003': 'A',
        '22031': 'JG',
        '22040': 'XS',
        '22060': 'ZC',
        '22066': 'ZC',
        '22079': 'MH',
        '22129': 'XJ',
        '22179': 'XA',
        '22237': 'NJ',
        '22244': 'TD',
        '22280': 'JQ',
        '22300': 'YH',
        '22313': 'XW',
        '22331': 'YQ',
        '22343': 'YJ',
        '22351': 'PH',
        '22395': 'DC',
        '22412': 'TD',
        '22484': 'PB',
        '22500': 'PB',
        '22534': 'ZD',
        '22549': 'DH',
        '22561': 'PB',
        '22612': 'TD',
        '22771': 'KQ',
        '22831': 'HB',
        '22841': 'JG',
        '22855': 'QJ',
        '22865': 'XQ',
        '23013': 'ML',
        '23081': 'WM',
        '23487': 'SX',
        '23558': 'QJ',
        '23561': 'YW',
        '23586': 'YW',
        '23614': 'YW',
        '23615': 'SN',
        '23631': 'PB',
        '23646': 'ZS',
        '23663': 'ZT',
        '23673': 'YG',
        '23762': 'TD',
        '23769': 'ZS',
        '23780': 'QJ',
        '23884': 'QK',
        '24055': 'XH',
        '24113': 'DC',
        '24162': 'ZC',
        '24191': 'GA',
        '24273': 'QJ',
        '24324': 'NL',
        '24377': 'TD',
        '24378': 'QJ',
        '24439': 'PF',
        '24554': 'ZS',
        '24683': 'TD',
        '24694': 'WE',
        '24733': 'LK',
        '24925': 'TN',
        '25094': 'ZG',
        '25100': 'XQ',
        '25103': 'XH',
        '25153': 'PB',
        '25170': 'PB',
        '25179': 'KG',
        '25203': 'PB',
        '25240': 'ZS',
        '25282': 'FB',
        '25303': 'NA',
        '25324': 'KG',
        '25341': 'ZY',
        '25373': 'WZ',
        '25375': 'XJ',
        '25384': 'A',
        '25457': 'A',
        '25528': 'SD',
        '25530': 'SC',
        '25552': 'TD',
        '25774': 'ZC',
        '25874': 'ZC',
        '26044': 'YW',
        '26080': 'WM',
        '26292': 'PB',
        '26333': 'PB',
        '26355': 'ZY',
        '26366': 'CZ',
        '26397': 'ZC',
        '26399': 'QJ',
        '26415': 'ZS',
        '26451': 'SB',
        '26526': 'ZC',
        '26552': 'JG',
        '26561': 'TD',
        '26588': 'JG',
        '26597': 'CZ',
        '26629': 'ZS',
        '26638': 'YL',
        '26646': 'XQ',
        '26653': 'KG',
        '26657': 'XJ',
        '26727': 'HG',
        '26894': 'ZC',
        '26937': 'ZS',
        '26946': 'ZC',
        '26999': 'KJ',
        '27099': 'KJ',
        '27449': 'YQ',
        '27481': 'XS',
        '27542': 'ZS',
        '27663': 'ZS',
        '27748': 'TS',
        '27784': 'SC',
        '27788': 'ZD',
        '27795': 'TD',
        '27812': 'O',
        '27850': 'PB',
        '27852': 'MB',
        '27895': 'SL',
        '27898': 'PL',
        '27973': 'QJ',
        '27981': 'KH',
        '27986': 'HX',
        '27994': 'XJ',
        '28044': 'YC',
        '28065': 'WG',
        '28177': 'SM',
        '28267': 'QJ',
        '28291': 'KH',
        '28337': 'ZQ',
        '28463': 'TL',
        '28548': 'DC',
        '28601': 'TD',
        '28689': 'PB',
        '28805': 'JG',
        '28820': 'QG',
        '28846': 'PB',
        '28952': 'TD',
        '28975': 'ZC',
        '29100': 'A',
        '29325': 'QJ',
        '29575': 'SL',
        '29602': 'FB',
        '30010': 'TD',
        '30044': 'CX',
        '30058': 'PF',
        '30091': 'YSP',
        '30111': 'YN',
        '30229': 'XJ',
        '30427': 'SC',
        '30465': 'SX',
        '30631': 'YQ',
        '30655': 'QJ',
        '30684': 'QJG',
        '30707': 'SD',
        '30729': 'XH',
        '30796': 'LG',
        '30917': 'PB',
        '31074': 'NM',
        '31085': 'JZ',
        '31109': 'SC',
        '31181': 'ZC',
        '31192': 'MLB',
        '31293': 'JQ',
        '31400': 'YX',
        '31584': 'YJ',
        '31896': 'ZN',
        '31909': 'ZY',
        '31995': 'XJ',
        '32321': 'PF',
        '32327': 'ZY',
        '32418': 'HG',
        '32420': 'XQ',
        '32421': 'HG',
        '32438': 'LG',
        '32473': 'GJ',
        '32488': 'TD',
        '32521': 'QJ',
        '32527': 'PB',
        '32562': 'ZSQ',
        '32564': 'JZ',
        '32735': 'ZD',
        '32793': 'PB',
        '33071': 'PF',
        '33098': 'XL',
        '33100': 'YA',
        '33152': 'PB',
        '33261': 'CX',
        '33324': 'BP',
        '33333': 'TD',
        '33406': 'YA',
        '33426': 'WM',
        '33432': 'PB',
        '33445': 'JG',
        '33486': 'ZN',
        '33493': 'TS',
        '33507': 'QJ',
        '33540': 'QJ',
        '33544': 'ZC',
        '33564': 'XQ',
        '33617': 'YT',
        '33632': 'QJ',
        '33636': 'XH',
        '33637': 'YX',
        '33694': 'WG',
        '33705': 'PF',
        '33728': 'YW',
        '33882': 'SR',
        '34067': 'WM',
        '34074': 'YW',
        '34121': 'QJ',
        '34255': 'ZC',
        '34259': 'XL',
        '34425': 'JH',
        '34430': 'XH',
        '34485': 'KH',
        '34503': 'YS',
        '34532': 'HG',
        '34552': 'XS',
        '34558': 'YE',
        '34593': 'ZL',
        '34660': 'YQ',
        '34892': 'XH',
        '34928': 'SC',
        '34999': 'QJ',
        '35048': 'PB',
        '35059': 'SC',
        '35098': 'ZC',
        '35203': 'TQ',
        '35265': 'JX',
        '35299': 'JX',
        '35782': 'SZ',
        '35828': 'YS',
        '35830': 'E',
        '35843': 'TD',
        '35895': 'YG',
        '35977': 'MH',
        '36158': 'JG',
        '36228': 'QJ',
        '36426': 'XQ',
        '36466': 'DC',
        '36710': 'JC',
        '36711': 'ZYG',
        '36767': 'PB',
        '36866': 'SK',
        '36951': 'YW',
        '37034': 'YX',
        '37063': 'XH',
        '37218': 'ZC',
        '37325': 'ZC',
        '38063': 'PB',
        '38079': 'TD',
        '38085': 'QY',
        '38107': 'DC',
        '38116': 'TD',
        '38123': 'YD',
        '38224': 'HG',
        '38241': 'XTC',
        '38271': 'ZC',
        '38415': 'YE',
        '38426': 'KH',
        '38461': 'YD',
        '38463': 'AE',
        '38466': 'PB',
        '38477': 'XJ',
        '38518': 'YT',
        '38551': 'WK',
        '38585': 'ZC',
        '38704': 'XS',
        '38739': 'LJ',
        '38761': 'GJ',
        '38808': 'SQ',
        '39048': 'JG',
        '39049': 'XJ',
        '39052': 'HG',
        '39076': 'CZ',
        '39271': 'XT',
        '39534': 'TD',
        '39552': 'TD',
        '39584': 'PB',
        '39647': 'SB',
        '39730': 'LG',
        '39748': 'TPB',
        '40109': 'ZQ',
        '40479': 'ND',
        '40516': 'HG',
        '40536': 'HG',
        '40583': 'QJ',
        '40765': 'YQ',
        '40784': 'QJ',
        '40840': 'YK',
        '40863': 'QJG'
      };
    },
    // 提取拼音, 返回首字母大写形式
    getFullChars: function getFullChars(str) {
      var result = '',
          name;
      var reg = new RegExp('[a-zA-Z0-9\- ]');

      for (var i = 0, len = str.length; i < len; i++) {
        var ch = str.substr(i, 1),
            unicode = ch.charCodeAt(0);

        if (unicode > 40869 || unicode < 19968) {
          result += ch;
        } else {
          name = this._getFullChar(ch);

          if (name !== false) {
            result += name;
          }
        }
      }

      return result;
    },
    // 提取首字母，返回大写形式
    getCamelChars: function getCamelChars(str) {
      if (typeof str !== 'string') {
        throw new Error(-1, '函数getFisrt需要字符串类型参数!');
      }

      var chars = []; // 保存中间结果的数组

      for (var i = 0, len = str.length; i < len; i++) {
        // 获得unicode码
        var ch = str.charAt(i); // 检查该unicode码是否在处理范围之内,在则返回该码对映汉字的拼音首字母,不在则调用其它函数处理

        chars.push(this._getChar(ch));
      } // 处理arrResult,返回所有可能的拼音首字母串数组


      return this._getResult(chars);
    },
    // 提取拼音
    _getFullChar: function _getFullChar(str) {
      for (var key in this.full_dict) {
        if (this.full_dict[key].indexOf(str) !== -1) {
          return this._capitalize(key);
        }
      }

      return false;
    },
    // 首字母大写
    _capitalize: function _capitalize(str) {
      if (str.length > 0) {
        var first = str.substr(0, 1).toUpperCase();
        var spare = str.substr(1, str.length);
        return first + spare;
      }
    },
    _getChar: function _getChar(ch) {
      var unicode = ch.charCodeAt(0); // 如果不在汉字处理范围之内,返回原字符,也可以调用自己的处理函数

      if (unicode > 40869 || unicode < 19968) {
        return ch;
      } // dealWithOthers(ch);
      // 检查是否是多音字,是按多音字处理,不是就直接在strChineseFirstPY字符串中找对应的首字母


      if (!this.options.checkPolyphone) {
        return this.char_dict.charAt(unicode - 19968);
      }

      return this.polyphone[unicode] ? this.polyphone[unicode] : this.char_dict.charAt(unicode - 19968);
    },
    _getResult: function _getResult(chars) {
      if (!this.options.checkPolyphone) {
        return chars.join('');
      }

      var result = [''];

      for (var i = 0, len = chars.length; i < len; i++) {
        var str = chars[i],
            strlen = str.length;

        if (strlen == 1) {
          for (var j = 0; j < result.length; j++) {
            result[k] += str;
          }
        } else {
          var swap1 = result.slice(0);
          result = [];

          for (var _j = 0; _j < strlen; _j++) {
            // 复制一个相同的arrRslt
            var swap2 = swap1.slice(0); // 把当前字符str[k]添加到每个元素末尾

            for (var k = 0; k < swap2.length; k++) {
              swap2[k] += str.charAt(_j);
            } // 把复制并修改后的数组连接到arrRslt上


            result = result.concat(swap2);
          }
        }
      }

      return result;
    }
  };

  var extend = function extend(dst, src) {
    for (var property in src) {
      dst[property] = src[property];
    }

    return dst;
  };

  return new Pinyin(_arguments);
};

/* harmony default export */ var js_pinyin = (pinyin());
// CONCATENATED MODULE: ./src/utils/tool.util.js
 // 工具类的方法

var tool_util_Tool = function Tool() {
  // 方法类
  return {
    // 获取元素宽度
    getWidth: function getWidth(el) {
      var wd,
          rect = el.getBoundingClientRect();

      if (rect.width) {
        wd = rect.width;
      } else {
        wd = rect.right - rect.left;
      }

      return wd;
    },
    // 获取元素高度
    getHeight: function getHeight(el) {
      var ht,
          rect = el.getBoundingClientRect();

      if (rect.height) {
        ht = rect.height;
      } else {
        ht = rect.bottom - rect.top;
      }

      return ht;
    },
    // 设置cookie
    setCookie: function setCookie(name, value, seconds, path) {
      seconds = seconds || 0; // seconds有值就直接赋值，没有为0

      var expires = '';

      if (seconds != 0) {
        // 设置cookie生存时间
        var date = new Date();
        date.setTime(date.getTime() + seconds * 1000);
        expires = '; expires=' + date.toGMTString();
      }

      document.cookie = name + '=' + escape(value) + expires + '; path=' + path; // 转码并赋值
    },
    // 对象属性赋值,但不扩展属性
    objectAssign: function objectAssign(target) {
      for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        sources[_key - 1] = arguments[_key];
      }

      Object.keys(target).forEach(function (key) {
        sources.map(function (source) {
          if (typeof source[key] !== 'undefined') target[key] = source[key];
        });
      });
      return target;
    },

    /*
    * 汉字转拼音
    * 1.getFullChars(str)提取拼音, 返回首字母大写形式
    * 2.getCamelChars(str) 提取首字母，返回大写形式
    * */
    pinyin: js_pinyin
  };
};

/* harmony default export */ var tool_util = __webpack_exports__["a"] = (tool_util_Tool());

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(135);
/** Built-in value references. */


var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;

/***/ }),
/* 111 */
/***/ (function(module, exports) {

var core = module.exports = {
  version: '2.6.5'
};
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),
/* 112 */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function (it) {
  return _typeof(it) === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 113 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),
/* 114 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),
/* 115 */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
window._global_property_ = {};

function setProperty(key, value, defalut) {
  window._global_property_[key] = value || defalut;
}

function getProperty(key, defalut) {
  return window._global_property_[key] || defalut;
}

/* harmony default export */ __webpack_exports__["a"] = ({
  setProperty: setProperty,
  getProperty: getProperty
});

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(67)))

/***/ }),
/* 135 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(112);

module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 137 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(272);

var enumBugKeys = __webpack_require__(203);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 139 */
/***/ (function(module, exports) {

module.exports = true;

/***/ }),
/* 140 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();

module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 141 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(143),
    stackClear = __webpack_require__(528),
    stackDelete = __webpack_require__(529),
    stackGet = __webpack_require__(530),
    stackHas = __webpack_require__(531),
    stackSet = __webpack_require__(532);
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(523),
    listCacheDelete = __webpack_require__(524),
    listCacheGet = __webpack_require__(525),
    listCacheHas = __webpack_require__(526),
    listCacheSet = __webpack_require__(527);
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(114);
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

module.exports = assocIndexOf;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(76);
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(545);
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(280),
    baseKeys = __webpack_require__(555),
    isArrayLike = __webpack_require__(153);
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */


function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(552),
    isObjectLike = __webpack_require__(45);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var root = __webpack_require__(38),
    stubFalse = __webpack_require__(553);
/** Detect free variable `exports`. */


var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(115)(module)))

/***/ }),
/* 150 */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = _typeof(value);

  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),
/* 151 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var freeGlobal = __webpack_require__(134);
/** Detect free variable `exports`. */


var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(115)(module)))

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(206),
    isLength = __webpack_require__(211);
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(280),
    baseKeysIn = __webpack_require__(558),
    isArrayLike = __webpack_require__(153);
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */


function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(563),
    Map = __webpack_require__(205),
    Promise = __webpack_require__(564),
    Set = __webpack_require__(288),
    WeakMap = __webpack_require__(565),
    baseGetTag = __webpack_require__(58),
    toSource = __webpack_require__(278);
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function getTag(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;

        case mapCtorString:
          return mapTag;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag;

        case weakMapCtorString:
          return weakMapTag;
      }
    }

    return result;
  };
}

module.exports = getTag;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var baseGetTag = __webpack_require__(58),
    isObjectLike = __webpack_require__(45);
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(94),
    toKey = __webpack_require__(95);
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */


function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

module.exports = baseGet;

/***/ }),
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(259);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(405);
/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(qs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _tool_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(109);
/* harmony import */ var _global_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(133);
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(23);
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_5__);
// 引入axios





 // axios.defaults.withCredentials = true

vue__WEBPACK_IMPORTED_MODULE_0___default.a.prototype.$axios = axios__WEBPACK_IMPORTED_MODULE_1___default.a;
/**
 * @method submit
 * @param {Object} formObj 表单对象
 * @param {Object} submitParameter 提交参数
 * submitParameter:{
 *  url:XXX,//地址
 *  data:{},//提交参数
 *  method:'POST/GET',//提交方式   默认 'POST'
 *  responseType:'json/jsonp等'  默认 'json'
 *  autoValid:true/false        默认 false 提交前是否自动验证(有这个属性必须要填写formObj)
 *  showPageLoading:false/true   默认true,是否显示加载中这个状态
 *  autoQs:true/false          默认true,是否自动序列化处理
 *  isFormData:/true/false    默认false 是否使用formData方式传递参数，适用于带文件上传的提交
 * }
 *@param {object} callBack 回调函数
 * callBack:{
 *   successCallback:function(data){},//成功回调
 *   failCallback:function(data){},//失败回调
 *   serviceCallback :function(bool,data){},//业务成功/失败回调传入参数 true/false
 *   errorCallBack:function(err){}//请求出错回调
 * }
 * **/

function submit(formObj, submitParameter, callBack) {
  var baseURL = '/api';

  try {
    baseURL = faceConfig.basePath;
  } catch (e) {
    baseURL = '/api';
  } // 回调预处理


  var _callBack = {
    successCallback: null,
    failCallback: null,
    serviceCallback: function serviceCallback(type, data) {
      // 如果业务失败 弹出提示消息
      if (type === false) {
        if (data.errors && data.errors instanceof Array) {
          // 弹出消息
          for (var i = 0; i < data.errors.length; i++) {
            message.error(data.errors[i].msg, 0);
          }
        } else {
          message.error(data.errors || '业务失败', 0);
        }
      }
    },
    defaultCallback: function defaultCallback(type, data) {
      if (type === false) {
        // 处理417等问题
        if (data.errors && data.errors instanceof Array) {
          if (data.errors[0].errorCode == '302' && data.errors[0].msg == 'session失效' || data.errors[0].errorCode == '403' && data.errors[0].msg == '未登录') {
            var str = data.errors[0].parameter;
            var path = str.substr(0, str.lastIndexOf('/'));
            _tool_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].setCookie('JSESSIONID', '', -1, path);
            _tool_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].setCookie('JSESSIONID', '', -1, baseURL);

            if (window.location.pathname != '/login.html') {
              top.window.location.href = 'login.html';
            }
          }

          if (data.errors[0].errorCode == '304' && data.errors[0].msg == '未登录' && data.redirectUrl) {
            window.location.href = data.redirectUrl;
          }
        }
      }
    },
    errorCallBack: function errorCallBack(error) {
      console.log(error);
    } // 参数预处理

  };
  var _submitParameter = {
    method: 'POST',
    responseType: 'json',
    // 默认的
    // `withCredentials` 表示跨域请求时是否需要使用凭证
    withCredentials: true,
    // 默认的
    baseURL: baseURL,
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
    },
    data: {},
    isFormData: false // 合并参数

  };
  submitParameter = Object.assign(_submitParameter, submitParameter || {}); // 传递index参数

  var indexParam = _global_util__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getProperty('TA$indexParam', {});

  if (submitParameter.isFormData) {
    //文件上传时，FormData形式提交参数
    var formData = new FormData();
    Object.keys(submitParameter.data).forEach(function (key) {
      var param = submitParameter.data[key];

      if (param instanceof Array && param[0] instanceof File) {
        param.map(function (value, index) {
          formData.append(key, value);
        });
      } else {
        formData.append(key, param);
      }
    });
    Object.keys(indexParam).forEach(function (key) {
      formData.append(key, indexParam[key]);
    });
    formData.append("frontUrl", window.location.href);
    submitParameter.data = formData;
    submitParameter.headers = {
      "Content-Type": "multipart/form-data"
    };
  } else {
    //一般情况下提交参数
    if (!lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_5___default()(submitParameter.data)) submitParameter.data = {};
    Object.keys(indexParam).forEach(function (key) {
      submitParameter.data[key] = indexParam[key];
    }); // 单点参数

    submitParameter.data.frontUrl = window.location.href; // 是否自动序列化

    if (submitParameter.autoQs !== false) {
      submitParameter.data = qs__WEBPACK_IMPORTED_MODULE_2___default.a.stringify(submitParameter.data);
    }
  }

  callBack = Object.assign(_callBack, callBack || {}); // 验证

  if (formObj && submitParameter.autoValid) {
    var validState = false;
    formObj.validateFields(function (err, values) {
      if (!err) {
        validState = true;
      }
    });

    if (!validState) {
      return false;
    }
  } // 提交


  axiosSubmit(submitParameter, callBack);
}

;

function axiosSubmit(submitParameter, callBack) {
  if (submitParameter.showPageLoading !== false) {
    Base.pageMask({
      show: true,
      text: '加载中'
    });
  }

  axios__WEBPACK_IMPORTED_MODULE_1___default()(submitParameter).then(function (response) {
    // IE 可能存在不能解析application/json的情况，导致response.data为undefined
    if (!response.data) {
      // eslint-disable-next-line no-eval
      response.data = eval('(' + response.request.responseText + ')');
    } // 默认错误预处理


    callBack.defaultCallback(response.data.serviceSuccess, response.data); // 业务预处理(不管失败或者是成功都会调用)

    callBack.serviceCallback(response.data.serviceSuccess, response.data); // 成功处理

    if (callBack.successCallback && response.data.serviceSuccess) {
      callBack.successCallback(response.data);
    } // 失败处理


    if (callBack.failCallback && !response.data.serviceSuccess) {
      callBack.failCallback(response.data);
    }

    if (submitParameter.showPageLoading !== false) {
      Base.pageMask({
        show: false
      });
    }
  })["catch"](function (error) {
    if (submitParameter.showPageLoading !== false) {
      Base.pageMask({
        show: false
      });
    }

    if (callBack.errorCallBack) {
      callBack.errorCallBack(error);
    }
  });
}
/* 获取码值 */


function getCodeName(codeList, value) {
  if (codeList && codeList.length) {
    for (var i = 0; i < codeList.length; i++) {
      if (codeList[i].value == value) {
        return codeList[i].label;
      }
    }
  }
}

var formUtil = function formUtil() {
  return {
    submit: submit,
    axiosSubmit: axiosSubmit,
    getCodeName: getCodeName
  };
};

/* harmony default export */ __webpack_exports__["a"] = (formUtil());

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = addEventListener;

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _EventObject = __webpack_require__(510);

var _EventObject2 = _interopRequireDefault(_EventObject);

function addEventListener(target, eventType, callback, option) {
  function wrapCallback(e) {
    var ne = new _EventObject2['default'](e);
    callback.call(target, ne);
  }

  if (target.addEventListener) {
    var _ret = function () {
      var useCapture = false;

      if (_typeof(option) === 'object') {
        useCapture = option.capture || false;
      } else if (typeof option === 'boolean') {
        useCapture = option;
      }

      target.addEventListener(eventType, wrapCallback, option || false);
      return {
        v: {
          remove: function remove() {
            target.removeEventListener(eventType, wrapCallback, useCapture);
          }
        }
      };
    }();

    if (_typeof(_ret) === 'object') return _ret.v;
  } else if (target.attachEvent) {
    target.attachEvent('on' + eventType, wrapCallback);
    return {
      remove: function remove() {
        target.detachEvent('on' + eventType, wrapCallback);
      }
    };
  }
}

module.exports = exports['default'];

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(294),
    baseClone = __webpack_require__(277),
    baseUnset = __webpack_require__(585),
    castPath = __webpack_require__(94),
    copyObject = __webpack_require__(93),
    customOmitClone = __webpack_require__(594),
    flatRest = __webpack_require__(295),
    getAllKeysIn = __webpack_require__(287);
/** Used to compose bitmasks for cloning. */


var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;
/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */

var omit = flatRest(function (object, paths) {
  var result = {};

  if (object == null) {
    return result;
  }

  var isDeep = false;
  paths = arrayMap(paths, function (path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);

  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }

  var length = paths.length;

  while (length--) {
    baseUnset(result, paths[length]);
  }

  return result;
});
module.exports = omit;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var camel2hyphen = __webpack_require__(584);

var isDimension = function isDimension(feature) {
  var re = /[height|width]$/;
  return re.test(feature);
};

var obj2mq = function obj2mq(obj) {
  var mq = '';
  var features = Object.keys(obj);
  features.forEach(function (feature, index) {
    var value = obj[feature];
    feature = camel2hyphen(feature); // Add px to dimension features

    if (isDimension(feature) && typeof value === 'number') {
      value = value + 'px';
    }

    if (value === true) {
      mq += feature;
    } else if (value === false) {
      mq += 'not ' + feature;
    } else {
      mq += '(' + feature + ': ' + value + ')';
    }

    if (index < features.length - 1) {
      mq += ' and ';
    }
  });
  return mq;
};

var json2mq = function json2mq(query) {
  var mq = '';

  if (typeof query === 'string') {
    return query;
  } // Handling array of media queries


  if (query instanceof Array) {
    query.forEach(function (q, index) {
      mq += obj2mq(q);

      if (index < query.length - 1) {
        mq += ', ';
      }
    });
    return mq;
  } // Handling single media query


  return obj2mq(query);
};

module.exports = json2mq;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(59);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),
/* 194 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(46);

var normalizeHeaderName = __webpack_require__(443);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;

  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(263);
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(263);
  }

  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }

    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }

    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }

    return data;
  }],
  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        /* Ignore */
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(196)))

/***/ }),
/* 196 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(68);

var core = __webpack_require__(111);

var ctx = __webpack_require__(516);

var hide = __webpack_require__(89);

var has = __webpack_require__(75);

var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue; // export native or passed

    out = own ? target[key] : source[key]; // prevent global pollution for namespaces

    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global) // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? function (C) {
      var F = function F(a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0:
              return new C();

            case 1:
              return new C(a);

            case 2:
              return new C(a, b);
          }

          return new C(a, b, c);
        }

        return C.apply(this, arguments);
      };

      F[PROTOTYPE] = C[PROTOTYPE];
      return F; // make static versions for prototype methods
    }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%

    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%

      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
}; // type bitmap


$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library`

module.exports = $export;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(112); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 199 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 200 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;

module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(202)('keys');

var uid = __webpack_require__(140);

module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(111);

var global = __webpack_require__(68);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(139) ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

/***/ }),
/* 203 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),
/* 204 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(76),
    root = __webpack_require__(38);
/* Built-in method references that are verified to be native. */


var Map = getNative(root, 'Map');
module.exports = Map;

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(58),
    isObject = __webpack_require__(39);
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(537),
    mapCacheDelete = __webpack_require__(544),
    mapCacheGet = __webpack_require__(546),
    mapCacheHas = __webpack_require__(547),
    mapCacheSet = __webpack_require__(548);
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(209),
    eq = __webpack_require__(114);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(279);
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(554),
    baseUnary = __webpack_require__(151),
    nodeUtil = __webpack_require__(152);
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

/***/ }),
/* 211 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),
/* 212 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(561),
    stubArray = __webpack_require__(283);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
module.exports = getSymbols;

/***/ }),
/* 214 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

module.exports = arrayPush;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(289);
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */


function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var isArray = __webpack_require__(50),
    isSymbol = __webpack_require__(156);
/** Used to match property names within property paths. */


var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = _typeof(value);

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;

/***/ }),
/* 217 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),
/* 218 */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(90).f;

var has = __webpack_require__(75);

var TAG = __webpack_require__(96)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
    configurable: true,
    value: tag
  });
};

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(96);

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(68);

var core = __webpack_require__(111);

var LIBRARY = __webpack_require__(139);

var wksExt = __webpack_require__(220);

var defineProperty = __webpack_require__(90).f;

module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
    value: wksExt.f(name)
  });
};

/***/ }),
/* 222 */
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

/***/ }),
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(440);

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(628),
    createAssigner = __webpack_require__(634);
/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */


var merge = createAssigner(function (object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
module.exports = merge;

/***/ }),
/* 261 */,
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    return fn.apply(thisArg, args);
  };
};

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(46);

var settle = __webpack_require__(444);

var buildURL = __webpack_require__(446);

var parseHeaders = __webpack_require__(447);

var isURLSameOrigin = __webpack_require__(448);

var createError = __webpack_require__(264);

var btoa = typeof window !== 'undefined' && window.btoa && window.btoa.bind(window) || __webpack_require__(449);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false; // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.

    if ( true && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;

      request.onprogress = function handleProgress() {};

      request.ontimeout = function handleTimeout() {};
    } // HTTP basic authentication


    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout; // Listen for ready state

    request[loadEvent] = function handleLoad() {
      if (!request || request.readyState !== 4 && !xDomain) {
        return;
      } // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request


      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      } // Prepare the response


      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      settle(resolve, reject, response); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(450); // Add xsrf header


      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    } // Add headers to the request


    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    } // Add withCredentials to request if needed


    if (config.withCredentials) {
      request.withCredentials = true;
    } // Add responseType to request if needed


    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel); // Clean up request

        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    } // Send the request


    request.send(requestData);
  });
};

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(445);
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */


module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var has = Object.prototype.hasOwnProperty;

var hexTable = function () {
  var array = [];

  for (var i = 0; i < 256; ++i) {
    array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
  }

  return array;
}();

var compactQueue = function compactQueue(queue) {
  var obj;

  while (queue.length) {
    var item = queue.pop();
    obj = item.obj[item.prop];

    if (Array.isArray(obj)) {
      var compacted = [];

      for (var j = 0; j < obj.length; ++j) {
        if (typeof obj[j] !== 'undefined') {
          compacted.push(obj[j]);
        }
      }

      item.obj[item.prop] = compacted;
    }
  }

  return obj;
};

var arrayToObject = function arrayToObject(source, options) {
  var obj = options && options.plainObjects ? Object.create(null) : {};

  for (var i = 0; i < source.length; ++i) {
    if (typeof source[i] !== 'undefined') {
      obj[i] = source[i];
    }
  }

  return obj;
};

var merge = function merge(target, source, options) {
  if (!source) {
    return target;
  }

  if (_typeof(source) !== 'object') {
    if (Array.isArray(target)) {
      target.push(source);
    } else if (_typeof(target) === 'object') {
      if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }

    return target;
  }

  if (_typeof(target) !== 'object') {
    return [target].concat(source);
  }

  var mergeTarget = target;

  if (Array.isArray(target) && !Array.isArray(source)) {
    mergeTarget = arrayToObject(target, options);
  }

  if (Array.isArray(target) && Array.isArray(source)) {
    source.forEach(function (item, i) {
      if (has.call(target, i)) {
        if (target[i] && _typeof(target[i]) === 'object') {
          target[i] = merge(target[i], item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i] = item;
      }
    });
    return target;
  }

  return Object.keys(source).reduce(function (acc, key) {
    var value = source[key];

    if (has.call(acc, key)) {
      acc[key] = merge(acc[key], value, options);
    } else {
      acc[key] = value;
    }

    return acc;
  }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function (acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};

var decode = function decode(str) {
  try {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  } catch (e) {
    return str;
  }
};

var encode = function encode(str) {
  // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
  // It has been adapted here for stricter adherence to RFC 3986
  if (str.length === 0) {
    return str;
  }

  var string = typeof str === 'string' ? str : String(str);
  var out = '';

  for (var i = 0; i < string.length; ++i) {
    var c = string.charCodeAt(i);

    if (c === 0x2D // -
    || c === 0x2E // .
    || c === 0x5F // _
    || c === 0x7E // ~
    || c >= 0x30 && c <= 0x39 // 0-9
    || c >= 0x41 && c <= 0x5A // a-z
    || c >= 0x61 && c <= 0x7A // A-Z
    ) {
        out += string.charAt(i);
        continue;
      }

    if (c < 0x80) {
      out = out + hexTable[c];
      continue;
    }

    if (c < 0x800) {
      out = out + (hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F]);
      continue;
    }

    if (c < 0xD800 || c >= 0xE000) {
      out = out + (hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F]);
      continue;
    }

    i += 1;
    c = 0x10000 + ((c & 0x3FF) << 10 | string.charCodeAt(i) & 0x3FF);
    out += hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
  }

  return out;
};

var compact = function compact(value) {
  var queue = [{
    obj: {
      o: value
    },
    prop: 'o'
  }];
  var refs = [];

  for (var i = 0; i < queue.length; ++i) {
    var item = queue[i];
    var obj = item.obj[item.prop];
    var keys = Object.keys(obj);

    for (var j = 0; j < keys.length; ++j) {
      var key = keys[j];
      var val = obj[key];

      if (_typeof(val) === 'object' && val !== null && refs.indexOf(val) === -1) {
        queue.push({
          obj: obj,
          prop: key
        });
        refs.push(val);
      }
    }
  }

  return compactQueue(queue);
};

var isRegExp = function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
  if (obj === null || typeof obj === 'undefined') {
    return false;
  }

  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

module.exports = {
  arrayToObject: arrayToObject,
  assign: assign,
  compact: compact,
  decode: decode,
  encode: encode,
  isBuffer: isBuffer,
  isRegExp: isRegExp,
  merge: merge
};

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;
module.exports = {
  'default': 'RFC3986',
  formatters: {
    RFC1738: function RFC1738(value) {
      return replace.call(value, percentTwenties, '+');
    },
    RFC3986: function RFC3986(value) {
      return value;
    }
  },
  RFC1738: 'RFC1738',
  RFC3986: 'RFC3986'
};

/***/ }),
/* 269 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(91) && !__webpack_require__(113)(function () {
  return Object.defineProperty(__webpack_require__(271)('div'), 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(112);

var document = __webpack_require__(68).document; // typeof document.createElement is 'object' in old IE


var is = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(75);

var toIObject = __webpack_require__(92);

var arrayIndexOf = __webpack_require__(519)(false);

var IE_PROTO = __webpack_require__(201)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) {
    if (key != IE_PROTO) has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys


  while (names.length > i) {
    if (has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
  }

  return result;
};

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(274); // eslint-disable-next-line no-prototype-builtins


module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 274 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(199);

module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),
/* 276 */
/***/ (function(module, exports) {

module.exports = function (arr, obj) {
  if (arr.indexOf) return arr.indexOf(obj);

  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }

  return -1;
};

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(142),
    arrayEach = __webpack_require__(549),
    assignValue = __webpack_require__(208),
    baseAssign = __webpack_require__(550),
    baseAssignIn = __webpack_require__(557),
    cloneBuffer = __webpack_require__(281),
    copyArray = __webpack_require__(282),
    copySymbols = __webpack_require__(560),
    copySymbolsIn = __webpack_require__(562),
    getAllKeys = __webpack_require__(285),
    getAllKeysIn = __webpack_require__(287),
    getTag = __webpack_require__(155),
    initCloneArray = __webpack_require__(566),
    initCloneByTag = __webpack_require__(567),
    initCloneObject = __webpack_require__(291),
    isArray = __webpack_require__(50),
    isBuffer = __webpack_require__(149),
    isMap = __webpack_require__(572),
    isObject = __webpack_require__(39),
    isSet = __webpack_require__(574),
    keys = __webpack_require__(147);
/** Used to compose bitmasks for cloning. */


var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values supported by `_.clone`. */

var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */

function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }

  if (result !== undefined) {
    return result;
  }

  if (!isObject(value)) {
    return value;
  }

  var isArr = isArray(value);

  if (isArr) {
    result = initCloneArray(value);

    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }

    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);

      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }

      result = initCloneByTag(value, tag, isDeep);
    }
  } // Check for circular references and return its corresponding clone.


  stack || (stack = new Stack());
  var stacked = stack.get(value);

  if (stacked) {
    return stacked;
  }

  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function (subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
    return result;
  }

  if (isMap(value)) {
    value.forEach(function (subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    } // Recursively populate clone (susceptible to call stack limits).


    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

/***/ }),
/* 278 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

module.exports = toSource;

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(76);

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(551),
    isArguments = __webpack_require__(148),
    isArray = __webpack_require__(50),
    isBuffer = __webpack_require__(149),
    isIndex = __webpack_require__(150),
    isTypedArray = __webpack_require__(210);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var root = __webpack_require__(38);
/** Detect free variable `exports`. */


var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(115)(module)))

/***/ }),
/* 282 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

module.exports = copyArray;

/***/ }),
/* 283 */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(214),
    getPrototype = __webpack_require__(110),
    getSymbols = __webpack_require__(213),
    stubArray = __webpack_require__(283);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
  var result = [];

  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }

  return result;
};
module.exports = getSymbolsIn;

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(286),
    getSymbols = __webpack_require__(213),
    keys = __webpack_require__(147);
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(214),
    isArray = __webpack_require__(50);
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */


function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(286),
    getSymbolsIn = __webpack_require__(284),
    keysIn = __webpack_require__(154);
/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(76),
    root = __webpack_require__(38);
/* Built-in method references that are verified to be native. */


var Set = getNative(root, 'Set');
module.exports = Set;

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(38);
/** Built-in value references. */


var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(215);
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(571),
    getPrototype = __webpack_require__(110),
    isPrototype = __webpack_require__(212);
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

module.exports = initCloneObject;

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

var MediaQueryDispatch = __webpack_require__(580);

module.exports = new MediaQueryDispatch();

/***/ }),
/* 293 */
/***/ (function(module, exports) {

/**
 * Helper function for iterating over a collection
 *
 * @param collection
 * @param fn
 */
function each(collection, fn) {
  var i = 0,
      length = collection.length,
      cont;

  for (i; i < length; i++) {
    cont = fn(collection[i], i);

    if (cont === false) {
      break; //allow early exit
    }
  }
}
/**
 * Helper function for determining whether target object is an array
 *
 * @param target the object under test
 * @return {Boolean} true if array, false otherwise
 */


function isArray(target) {
  return Object.prototype.toString.apply(target) === '[object Array]';
}
/**
 * Helper function for determining whether target object is a function
 *
 * @param target the object under test
 * @return {Boolean} true if function, false otherwise
 */


function isFunction(target) {
  return typeof target === 'function';
}

module.exports = {
  isFunction: isFunction,
  isArray: isArray,
  each: each
};

/***/ }),
/* 294 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

module.exports = arrayMap;

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__(595),
    overRest = __webpack_require__(296),
    setToString = __webpack_require__(297);
/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */


function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(598);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(599),
    shortOut = __webpack_require__(601);
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var setToString = shortOut(baseSetToString);
module.exports = setToString;

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(94),
    isArguments = __webpack_require__(148),
    isArray = __webpack_require__(50),
    isIndex = __webpack_require__(150),
    isLength = __webpack_require__(211),
    toKey = __webpack_require__(95);
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */


function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(139);

var $export = __webpack_require__(197);

var redefine = __webpack_require__(300);

var hide = __webpack_require__(89);

var Iterators = __webpack_require__(218);

var $iterCreate = __webpack_require__(609);

var setToStringTag = __webpack_require__(219);

var getPrototypeOf = __webpack_require__(612);

var ITERATOR = __webpack_require__(96)('iterator');

var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function returnThis() {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);

  var getMethod = function getMethod(kind) {
    if (!BUGGY && kind in proto) return proto[kind];

    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };

      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }

    return function entries() {
      return new Constructor(this, kind);
    };
  };

  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype; // Fix native

  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;

    $default = function values() {
      return $native.call(this);
    };
  } // Define iterator


  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  } // Plug for library


  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;

  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }

  return methods;
};

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(89);

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(136);

var dPs = __webpack_require__(610);

var enumBugKeys = __webpack_require__(203);

var IE_PROTO = __webpack_require__(201)('IE_PROTO');

var Empty = function Empty() {
  /* empty */
};

var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

var _createDict = function createDict() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(271)('iframe');

  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';

  __webpack_require__(611).appendChild(iframe);

  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);

  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;

  while (i--) {
    delete _createDict[PROTOTYPE][enumBugKeys[i]];
  }

  return _createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = _createDict();

  return Properties === undefined ? result : dPs(result, Properties);
};

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(272);

var hiddenKeys = __webpack_require__(203).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(208),
    castPath = __webpack_require__(94),
    isIndex = __webpack_require__(150),
    isObject = __webpack_require__(39),
    toKey = __webpack_require__(95);
/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */


function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }

  path = castPath(path, object);
  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;

      if (newValue === undefined) {
        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }

    assignValue(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}

module.exports = baseSet;

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(209),
    eq = __webpack_require__(114);
/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function assignMergeValue(object, key, value) {
  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;

/***/ }),
/* 305 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key`, unless `key` is "__proto__".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(640),
    hasPath = __webpack_require__(298);
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */


function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(644),
    isObjectLike = __webpack_require__(45);
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */


function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(309),
    arraySome = __webpack_require__(647),
    cacheHas = __webpack_require__(310);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Assume cyclic values are equal.


  var stacked = stack.get(array);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(207),
    setCacheAdd = __webpack_require__(645),
    setCacheHas = __webpack_require__(646);
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */


function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
module.exports = SetCache;

/***/ }),
/* 310 */
/***/ (function(module, exports) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(39);
/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */


function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

/***/ }),
/* 312 */
/***/ (function(module, exports) {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

module.exports = matchesStrictComparable;

/***/ }),
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */,
/* 393 */,
/* 394 */,
/* 395 */,
/* 396 */,
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */,
/* 402 */,
/* 403 */,
/* 404 */,
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(458);

var parse = __webpack_require__(459);

var formats = __webpack_require__(268);

module.exports = {
  formats: formats,
  parse: parse,
  stringify: stringify
};

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(277);
/** Used to compose bitmasks for cloning. */


var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;
/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */

function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

/***/ }),
/* 407 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */

/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = function () {
  if (typeof Map !== 'undefined') {
    return Map;
  }
  /**
   * Returns index in provided array that matches the specified key.
   *
   * @param {Array<Array>} arr
   * @param {*} key
   * @returns {number}
   */


  function getIndex(arr, key) {
    var result = -1;
    arr.some(function (entry, index) {
      if (entry[0] === key) {
        result = index;
        return true;
      }

      return false;
    });
    return result;
  }

  return (
    /** @class */
    function () {
      function class_1() {
        this.__entries__ = [];
      }

      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function get() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      /**
       * @param {*} key
       * @returns {*}
       */

      class_1.prototype.get = function (key) {
        var index = getIndex(this.__entries__, key);
        var entry = this.__entries__[index];
        return entry && entry[1];
      };
      /**
       * @param {*} key
       * @param {*} value
       * @returns {void}
       */


      class_1.prototype.set = function (key, value) {
        var index = getIndex(this.__entries__, key);

        if (~index) {
          this.__entries__[index][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */


      class_1.prototype["delete"] = function (key) {
        var entries = this.__entries__;
        var index = getIndex(entries, key);

        if (~index) {
          entries.splice(index, 1);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */


      class_1.prototype.has = function (key) {
        return !!~getIndex(this.__entries__, key);
      };
      /**
       * @returns {void}
       */


      class_1.prototype.clear = function () {
        this.__entries__.splice(0);
      };
      /**
       * @param {Function} callback
       * @param {*} [ctx=null]
       * @returns {void}
       */


      class_1.prototype.forEach = function (callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }

        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };

      return class_1;
    }()
  );
}();
/**
 * Detects whether window and document objects are available in current environment.
 */


var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document; // Returns global object of a current environment.

var global$1 = function () {
  if (typeof global !== 'undefined' && global.Math === Math) {
    return global;
  }

  if (typeof self !== 'undefined' && self.Math === Math) {
    return self;
  }

  if (typeof window !== 'undefined' && window.Math === Math) {
    return window;
  } // eslint-disable-next-line no-new-func


  return Function('return this')();
}();
/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */


var requestAnimationFrame$1 = function () {
  if (typeof requestAnimationFrame === 'function') {
    // It's required to use a bounded function because IE sometimes throws
    // an "Invalid calling object" error if rAF is invoked without the global
    // object on the left hand side.
    return requestAnimationFrame.bind(global$1);
  }

  return function (callback) {
    return setTimeout(function () {
      return callback(Date.now());
    }, 1000 / 60);
  };
}(); // Defines minimum timeout before adding a trailing call.


var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */

function throttle(callback, delay) {
  var leadingCall = false,
      trailingCall = false,
      lastCallTime = 0;
  /**
   * Invokes the original callback function and schedules new invocation if
   * the "proxy" was called during current request.
   *
   * @returns {void}
   */

  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }

    if (trailingCall) {
      proxy();
    }
  }
  /**
   * Callback invoked after the specified delay. It will further postpone
   * invocation of the original function delegating it to the
   * requestAnimationFrame.
   *
   * @returns {void}
   */


  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  /**
   * Schedules invocation of the original function.
   *
   * @returns {void}
   */


  function proxy() {
    var timeStamp = Date.now();

    if (leadingCall) {
      // Reject immediately following calls.
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      } // Schedule new call to be in invoked when the pending one is resolved.
      // This is important for "transitions" which never actually start
      // immediately so there is a chance that we might miss one if change
      // happens amids the pending invocation.


      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }

    lastCallTime = timeStamp;
  }

  return proxy;
} // Minimum delay before invoking the update of observers.


var REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.

var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight']; // Check if MutationObserver is available.

var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */

var ResizeObserverController =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserverController.
   *
   * @private
   */
  function ResizeObserverController() {
    /**
     * Indicates whether DOM listeners have been added.
     *
     * @private {boolean}
     */
    this.connected_ = false;
    /**
     * Tells that controller has subscribed for Mutation Events.
     *
     * @private {boolean}
     */

    this.mutationEventsAdded_ = false;
    /**
     * Keeps reference to the instance of MutationObserver.
     *
     * @private {MutationObserver}
     */

    this.mutationsObserver_ = null;
    /**
     * A list of connected observers.
     *
     * @private {Array<ResizeObserverSPI>}
     */

    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  /**
   * Adds observer to observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be added.
   * @returns {void}
   */


  ResizeObserverController.prototype.addObserver = function (observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    } // Add listeners if they haven't been added yet.


    if (!this.connected_) {
      this.connect_();
    }
  };
  /**
   * Removes observer from observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be removed.
   * @returns {void}
   */


  ResizeObserverController.prototype.removeObserver = function (observer) {
    var observers = this.observers_;
    var index = observers.indexOf(observer); // Remove observer if it's present in registry.

    if (~index) {
      observers.splice(index, 1);
    } // Remove listeners if controller has no connected observers.


    if (!observers.length && this.connected_) {
      this.disconnect_();
    }
  };
  /**
   * Invokes the update of observers. It will continue running updates insofar
   * it detects changes.
   *
   * @returns {void}
   */


  ResizeObserverController.prototype.refresh = function () {
    var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might
    // be future ones caused by CSS transitions.

    if (changesDetected) {
      this.refresh();
    }
  };
  /**
   * Updates every observer from observers list and notifies them of queued
   * entries.
   *
   * @private
   * @returns {boolean} Returns "true" if any observer has detected changes in
   *      dimensions of it's elements.
   */


  ResizeObserverController.prototype.updateObservers_ = function () {
    // Collect observers that have active observations.
    var activeObservers = this.observers_.filter(function (observer) {
      return observer.gatherActive(), observer.hasActive();
    }); // Deliver notifications in a separate cycle in order to avoid any
    // collisions between observers, e.g. when multiple instances of
    // ResizeObserver are tracking the same element and the callback of one
    // of them changes content dimensions of the observed target. Sometimes
    // this may result in notifications being blocked for the rest of observers.

    activeObservers.forEach(function (observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  /**
   * Initializes DOM listeners.
   *
   * @private
   * @returns {void}
   */


  ResizeObserverController.prototype.connect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already added.
    if (!isBrowser || this.connected_) {
      return;
    } // Subscription to the "Transitionend" event is used as a workaround for
    // delayed transitions. This way it's possible to capture at least the
    // final state of an element.


    document.addEventListener('transitionend', this.onTransitionEnd_);
    window.addEventListener('resize', this.refresh);

    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener('DOMSubtreeModified', this.refresh);
      this.mutationEventsAdded_ = true;
    }

    this.connected_ = true;
  };
  /**
   * Removes DOM listeners.
   *
   * @private
   * @returns {void}
   */


  ResizeObserverController.prototype.disconnect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already removed.
    if (!isBrowser || !this.connected_) {
      return;
    }

    document.removeEventListener('transitionend', this.onTransitionEnd_);
    window.removeEventListener('resize', this.refresh);

    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }

    if (this.mutationEventsAdded_) {
      document.removeEventListener('DOMSubtreeModified', this.refresh);
    }

    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  /**
   * "Transitionend" event handler.
   *
   * @private
   * @param {TransitionEvent} event
   * @returns {void}
   */


  ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
    var _b = _a.propertyName,
        propertyName = _b === void 0 ? '' : _b; // Detect whether transition may affect dimensions of an element.

    var isReflowProperty = transitionKeys.some(function (key) {
      return !!~propertyName.indexOf(key);
    });

    if (isReflowProperty) {
      this.refresh();
    }
  };
  /**
   * Returns instance of the ResizeObserverController.
   *
   * @returns {ResizeObserverController}
   */


  ResizeObserverController.getInstance = function () {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController();
    }

    return this.instance_;
  };
  /**
   * Holds reference to the controller's instance.
   *
   * @private {ResizeObserverController}
   */


  ResizeObserverController.instance_ = null;
  return ResizeObserverController;
}();
/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */


var defineConfigurable = function defineConfigurable(target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }

  return target;
};
/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */


var getWindowOf = function getWindowOf(target) {
  // Assume that the element is an instance of Node, which means that it
  // has the "ownerDocument" property from which we can retrieve a
  // corresponding global object.
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it's not possible extract one from
  // provided element.

  return ownerGlobal || global$1;
}; // Placeholder of an empty content rectangle.


var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */

function toFloat(value) {
  return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */


function getBordersSize(styles) {
  var positions = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }

  return positions.reduce(function (size, position) {
    var value = styles['border-' + position + '-width'];
    return size + toFloat(value);
  }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */


function getPaddings(styles) {
  var positions = ['top', 'right', 'bottom', 'left'];
  var paddings = {};

  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles['padding-' + position];
    paddings[position] = toFloat(value);
  }

  return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */


function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */


function getHTMLElementContentRect(target) {
  // Client width & height properties can't be
  // used exclusively as they provide rounded values.
  var clientWidth = target.clientWidth,
      clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and
  // detached elements. Though elements with width & height properties less
  // than 0.5 will be discarded as well.
  //
  // Without it we would need to implement separate methods for each of
  // those cases and it's not possible to perform a precise and performance
  // effective test for hidden elements. E.g. even jQuery's ':visible' filter
  // gives wrong results for elements with width & height less than 0.5.

  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }

  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the
  // only dimensions available to JS that contain non-rounded values. It could
  // be possible to utilize the getBoundingClientRect if only it's data wasn't
  // affected by CSS transformations let alone paddings, borders and scroll bars.

  var width = toFloat(styles.width),
      height = toFloat(styles.height); // Width & height include paddings and borders when the 'border-box' box
  // model is applied (except for IE).

  if (styles.boxSizing === 'border-box') {
    // Following conditions are required to handle Internet Explorer which
    // doesn't include paddings and borders to computed CSS dimensions.
    //
    // We can say that if CSS dimensions + paddings are equal to the "client"
    // properties then it's either IE, and thus we don't need to subtract
    // anything, or an element merely doesn't have paddings/borders styles.
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, 'left', 'right') + horizPad;
    }

    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
    }
  } // Following steps can't be applied to the document's root element as its
  // client[Width/Height] properties represent viewport area of the window.
  // Besides, it's as well not necessary as the <html> itself neither has
  // rendered scroll bars nor it can be clipped.


  if (!isDocumentElement(target)) {
    // In some browsers (only in Firefox, actually) CSS width & height
    // include scroll bars size which can be removed at this step as scroll
    // bars are the only difference between rounded dimensions + paddings
    // and "client" properties, though that is not always true in Chrome.
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of "client" properties.
    // E.g. for an element with content width of 314.2px it sometimes gives
    // the client width of 315px and for the width of 314.7px it may give
    // 314px. And it doesn't happen all the time. So just ignore this delta
    // as a non-relevant.

    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }

    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }

  return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */


var isSVGGraphicsElement = function () {
  // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
  // interface.
  if (typeof SVGGraphicsElement !== 'undefined') {
    return function (target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  } // If it's so, then check that element is at least an instance of the
  // SVGElement and that it has the "getBBox" method.
  // eslint-disable-next-line no-extra-parens


  return function (target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
  };
}();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */


function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */


function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }

  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }

  return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */


function createReadOnlyRect(_a) {
  var x = _a.x,
      y = _a.y,
      width = _a.width,
      height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.

  var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype); // Rectangle's properties are not writable and non-enumerable.

  defineConfigurable(rect, {
    x: x,
    y: y,
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */


function createRectInit(x, y, width, height) {
  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
}
/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */


var ResizeObservation =
/** @class */
function () {
  /**
   * Creates an instance of ResizeObservation.
   *
   * @param {Element} target - Element to be observed.
   */
  function ResizeObservation(target) {
    /**
     * Broadcasted width of content rectangle.
     *
     * @type {number}
     */
    this.broadcastWidth = 0;
    /**
     * Broadcasted height of content rectangle.
     *
     * @type {number}
     */

    this.broadcastHeight = 0;
    /**
     * Reference to the last observed content rectangle.
     *
     * @private {DOMRectInit}
     */

    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  /**
   * Updates content rectangle and tells whether it's width or height properties
   * have changed since the last broadcast.
   *
   * @returns {boolean}
   */


  ResizeObservation.prototype.isActive = function () {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  /**
   * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
   * from the corresponding properties of the last observed content rectangle.
   *
   * @returns {DOMRectInit} Last observed content rectangle.
   */


  ResizeObservation.prototype.broadcastRect = function () {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };

  return ResizeObservation;
}();

var ResizeObserverEntry =
/** @class */
function () {
  /**
   * Creates an instance of ResizeObserverEntry.
   *
   * @param {Element} target - Element that is being observed.
   * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
   */
  function ResizeObserverEntry(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable
    // and are also not enumerable in the native implementation.
    //
    // Property accessors are not being used as they'd require to define a
    // private WeakMap storage which may cause memory leaks in browsers that
    // don't support this type of collections.

    defineConfigurable(this, {
      target: target,
      contentRect: contentRect
    });
  }

  return ResizeObserverEntry;
}();

var ResizeObserverSPI =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback function that is invoked
   *      when one of the observed elements changes it's content dimensions.
   * @param {ResizeObserverController} controller - Controller instance which
   *      is responsible for the updates of observer.
   * @param {ResizeObserver} callbackCtx - Reference to the public
   *      ResizeObserver instance which will be passed to callback function.
   */
  function ResizeObserverSPI(callback, controller, callbackCtx) {
    /**
     * Collection of resize observations that have detected changes in dimensions
     * of elements.
     *
     * @private {Array<ResizeObservation>}
     */
    this.activeObservations_ = [];
    /**
     * Registry of the ResizeObservation instances.
     *
     * @private {Map<Element, ResizeObservation>}
     */

    this.observations_ = new MapShim();

    if (typeof callback !== 'function') {
      throw new TypeError('The callback provided as parameter 1 is not a function.');
    }

    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  /**
   * Starts observing provided element.
   *
   * @param {Element} target - Element to be observed.
   * @returns {void}
   */


  ResizeObserverSPI.prototype.observe = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    } // Do nothing if current environment doesn't have the Element interface.


    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_; // Do nothing if element is already being observed.

    if (observations.has(target)) {
      return;
    }

    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this); // Force the update of observations.

    this.controller_.refresh();
  };
  /**
   * Stops observing provided element.
   *
   * @param {Element} target - Element to stop observing.
   * @returns {void}
   */


  ResizeObserverSPI.prototype.unobserve = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    } // Do nothing if current environment doesn't have the Element interface.


    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_; // Do nothing if element is not being observed.

    if (!observations.has(target)) {
      return;
    }

    observations["delete"](target);

    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  /**
   * Stops observing all elements.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.disconnect = function () {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  /**
   * Collects observation instances the associated element of which has changed
   * it's content rectangle.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.gatherActive = function () {
    var _this = this;

    this.clearActive();
    this.observations_.forEach(function (observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  /**
   * Invokes initial callback function with a list of ResizeObserverEntry
   * instances collected from active resize observations.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.broadcastActive = function () {
    // Do nothing if observer doesn't have active observations.
    if (!this.hasActive()) {
      return;
    }

    var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.

    var entries = this.activeObservations_.map(function (observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  /**
   * Clears the collection of active observations.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.clearActive = function () {
    this.activeObservations_.splice(0);
  };
  /**
   * Tells whether observer has active observations.
   *
   * @returns {boolean}
   */


  ResizeObserverSPI.prototype.hasActive = function () {
    return this.activeObservations_.length > 0;
  };

  return ResizeObserverSPI;
}(); // Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.


var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */

var ResizeObserver =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback that is invoked when
   *      dimensions of the observed elements change.
   */
  function ResizeObserver(callback) {
    if (!(this instanceof ResizeObserver)) {
      throw new TypeError('Cannot call a class as a function.');
    }

    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    }

    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }

  return ResizeObserver;
}(); // Expose public methods of ResizeObserver.


['observe', 'unobserve', 'disconnect'].forEach(function (method) {
  ResizeObserver.prototype[method] = function () {
    var _a;

    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});

var index = function () {
  // Export existing implementation if available.
  if (typeof global$1.ResizeObserver !== 'undefined') {
    return global$1.ResizeObserver;
  }

  return ResizeObserver;
}();

/* harmony default export */ __webpack_exports__["a"] = (index);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(67)))

/***/ }),
/* 408 */
/***/ (function(module, exports) {

module.exports = function shallowEqualArrays(arrA, arrB) {
  if (arrA === arrB) {
    return true;
  }

  if (!arrA || !arrB) {
    return false;
  }

  var len = arrA.length;

  if (arrB.length !== len) {
    return false;
  }

  for (var i = 0; i < len; i++) {
    if (arrA[i] !== arrB[i]) {
      return false;
    }
  }

  return true;
};

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(602); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(67)))

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsRegExp = __webpack_require__(603),
    baseUnary = __webpack_require__(151),
    nodeUtil = __webpack_require__(152);
/* Node.js helper references. */


var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */

var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
module.exports = isRegExp;

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

var baseHas = __webpack_require__(604),
    hasPath = __webpack_require__(298);
/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */


function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;

/***/ }),
/* 412 */
/***/ (function(module, exports) {

module.exports = intersperse;

function intersperse(arr, obj) {
  if (!arr.length) return [];
  if (arr.length === 1) return arr.slice(0);
  var items = [arr[0]];

  for (var i = 1, len = arr.length; i < len; ++i) {
    items.push(obj, arr[i]);
  }

  return items;
}

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isNegativeZero(number) {
  return number === 0 && 1 / number === -Infinity;
};

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies
 */
var matches = __webpack_require__(637);
/**
 * @param element {Element}
 * @param selector {String}
 * @param context {Element}
 * @return {Element}
 */


module.exports = function (element, selector, context) {
  context = context || document; // guard against orphans

  element = {
    parentNode: element
  };

  while ((element = element.parentNode) && element !== context) {
    if (matches(element, selector)) {
      return element;
    }
  }
};

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

var debounce = __webpack_require__(42),
    isObject = __webpack_require__(39);
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */

function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

var basePick = __webpack_require__(638),
    flatRest = __webpack_require__(295);
/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */


var pick = flatRest(function (object, paths) {
  return object == null ? {} : basePick(object, paths);
});
module.exports = pick;

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee = __webpack_require__(641),
    baseUniq = __webpack_require__(656);
/**
 * This method is like `_.uniq` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * uniqueness is computed. The order of result values is determined by the
 * order they occur in the array. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */


function uniqBy(array, iteratee) {
  return array && array.length ? baseUniq(array, baseIteratee(iteratee, 2)) : [];
}

module.exports = uniqBy;

/***/ }),
/* 418 */
/***/ (function(module) {

module.exports = {"a":"1.0.68"};

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var isMergeableObject = function isMergeableObject(value) {
  return isNonNullObject(value) && !isSpecial(value);
};

function isNonNullObject(value) {
  return !!value && _typeof(value) === 'object';
}

function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
} // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25


var canUseSymbol = typeof Symbol === 'function' && Symbol["for"];
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol["for"]('react.element') : 0xeac7;

function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}

function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}

function cloneIfNecessary(value, optionsArgument) {
  var clone = optionsArgument && optionsArgument.clone === true;
  return clone && isMergeableObject(value) ? deepmerge(emptyTarget(value), value, optionsArgument) : value;
}

function defaultArrayMerge(target, source, optionsArgument) {
  var destination = target.slice();
  source.forEach(function (e, i) {
    if (typeof destination[i] === 'undefined') {
      destination[i] = cloneIfNecessary(e, optionsArgument);
    } else if (isMergeableObject(e)) {
      destination[i] = deepmerge(target[i], e, optionsArgument);
    } else if (target.indexOf(e) === -1) {
      destination.push(cloneIfNecessary(e, optionsArgument));
    }
  });
  return destination;
}

function mergeObject(target, source, optionsArgument) {
  var destination = {};

  if (isMergeableObject(target)) {
    Object.keys(target).forEach(function (key) {
      destination[key] = cloneIfNecessary(target[key], optionsArgument);
    });
  }

  Object.keys(source).forEach(function (key) {
    if (!isMergeableObject(source[key]) || !target[key]) {
      destination[key] = cloneIfNecessary(source[key], optionsArgument);
    } else {
      destination[key] = deepmerge(target[key], source[key], optionsArgument);
    }
  });
  return destination;
}

function deepmerge(target, source, optionsArgument) {
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var options = optionsArgument || {
    arrayMerge: defaultArrayMerge
  };
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

  if (!sourceAndTargetTypesMatch) {
    return cloneIfNecessary(source, optionsArgument);
  } else if (sourceIsArray) {
    var arrayMerge = options.arrayMerge || defaultArrayMerge;
    return arrayMerge(target, source, optionsArgument);
  } else {
    return mergeObject(target, source, optionsArgument);
  }
}

deepmerge.all = function deepmergeAll(array, optionsArgument) {
  if (!Array.isArray(array) || array.length < 2) {
    throw new Error('first argument should be an array with at least two elements');
  } // we are sure there are at least 2 values, so it is safe to have no initial value


  return array.reduce(function (prev, next) {
    return deepmerge(prev, next, optionsArgument);
  });
};

var deepmerge_1 = deepmerge;
module.exports = deepmerge_1;

/***/ }),
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */,
/* 432 */,
/* 433 */,
/* 434 */,
/* 435 */,
/* 436 */,
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(46);

var bind = __webpack_require__(262);

var Axios = __webpack_require__(442);

var defaults = __webpack_require__(195);
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */


function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance

  utils.extend(instance, Axios.prototype, context); // Copy context to instance

  utils.extend(instance, context);
  return instance;
} // Create the default instance to be exported


var axios = createInstance(defaults); // Expose Axios class to allow class inheritance

axios.Axios = Axios; // Factory for creating new instances

axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
}; // Expose Cancel & CancelToken


axios.Cancel = __webpack_require__(266);
axios.CancelToken = __webpack_require__(456);
axios.isCancel = __webpack_require__(265); // Expose all/spread

axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = __webpack_require__(457);
module.exports = axios; // Allow use of default import syntax in TypeScript

module.exports["default"] = axios;

/***/ }),
/* 441 */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(195);

var utils = __webpack_require__(46);

var InterceptorManager = __webpack_require__(451);

var dispatchRequest = __webpack_require__(452);
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */


function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */


Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, {
    method: 'get'
  }, this.defaults, config);
  config.method = config.method.toLowerCase(); // Hook up interceptors middleware

  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
}; // Provide aliases for supported request methods


utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});
module.exports = Axios;

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(46);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(264);
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */


module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus; // Note: status is not exposed by XDomainRequest

  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;

  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  return error;
};

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(46);

function encode(val) {
  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */


module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;

  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }

        parts.push(encode(key) + '=' + encode(v));
      });
    });
    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(46); // Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers


var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */

module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }

      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });
  return parsed;
};

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(46);

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;
  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */

  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);
  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */

  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}

E.prototype = new Error();
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';

  for ( // initialize result and counter
  var block, charCode, idx = 0, map = chars; // if the next str index does not exist:
  //   change the mapping table to "="
  //   check if d has no fractional digits
  str.charAt(idx | 0) || (map = '=', idx % 1); // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
    charCode = str.charCodeAt(idx += 3 / 4);

    if (charCode > 0xFF) {
      throw new E();
    }

    block = block << 8 | charCode;
  }

  return output;
}

module.exports = btoa;

/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(46);

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(46);

function InterceptorManager() {
  this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */


InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */


InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */


InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(46);

var transformData = __webpack_require__(453);

var isCancel = __webpack_require__(265);

var defaults = __webpack_require__(195);

var isAbsoluteURL = __webpack_require__(454);

var combineURLs = __webpack_require__(455);
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */


module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config); // Support baseURL config

  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  } // Ensure headers exist


  config.headers = config.headers || {}; // Transform request data

  config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});
  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config); // Transform response data

    response.data = transformData(response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config); // Transform response data

      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(46);
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */


module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });
  return data;
};

/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(266);
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */


function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */


CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var utils = __webpack_require__(267);

var formats = __webpack_require__(268);

var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    // eslint-disable-line func-name-matching
    return prefix + '[]';
  },
  indices: function indices(prefix, key) {
    // eslint-disable-line func-name-matching
    return prefix + '[' + key + ']';
  },
  repeat: function repeat(prefix) {
    // eslint-disable-line func-name-matching
    return prefix;
  }
};
var toISO = Date.prototype.toISOString;
var defaults = {
  delimiter: '&',
  encode: true,
  encoder: utils.encode,
  encodeValuesOnly: false,
  serializeDate: function serializeDate(date) {
    // eslint-disable-line func-name-matching
    return toISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly) {
  var obj = object;

  if (typeof filter === 'function') {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate(obj);
  } else if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
    }

    obj = '';
  }

  if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
      return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];
    }

    return [formatter(prefix) + '=' + formatter(String(obj))];
  }

  var values = [];

  if (typeof obj === 'undefined') {
    return values;
  }

  var objKeys;

  if (Array.isArray(filter)) {
    objKeys = filter;
  } else {
    var keys = Object.keys(obj);
    objKeys = sort ? keys.sort(sort) : keys;
  }

  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];

    if (skipNulls && obj[key] === null) {
      continue;
    }

    if (Array.isArray(obj)) {
      values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
    } else {
      values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
    }
  }

  return values;
};

module.exports = function (object, opts) {
  var obj = object;
  var options = opts ? utils.assign({}, opts) : {};

  if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
    throw new TypeError('Encoder has to be a function.');
  }

  var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
  var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
  var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
  var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
  var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;
  var sort = typeof options.sort === 'function' ? options.sort : null;
  var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
  var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
  var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;

  if (typeof options.format === 'undefined') {
    options.format = formats['default'];
  } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
    throw new TypeError('Unknown format option provided.');
  }

  var formatter = formats.formatters[options.format];
  var objKeys;
  var filter;

  if (typeof options.filter === 'function') {
    filter = options.filter;
    obj = filter('', obj);
  } else if (Array.isArray(options.filter)) {
    filter = options.filter;
    objKeys = filter;
  }

  var keys = [];

  if (_typeof(obj) !== 'object' || obj === null) {
    return '';
  }

  var arrayFormat;

  if (options.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = options.arrayFormat;
  } else if ('indices' in options) {
    arrayFormat = options.indices ? 'indices' : 'repeat';
  } else {
    arrayFormat = 'indices';
  }

  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

  if (!objKeys) {
    objKeys = Object.keys(obj);
  }

  if (sort) {
    objKeys.sort(sort);
  }

  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];

    if (skipNulls && obj[key] === null) {
      continue;
    }

    keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode ? encoder : null, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
  }

  var joined = keys.join(delimiter);
  var prefix = options.addQueryPrefix === true ? '?' : '';
  return joined.length > 0 ? prefix + joined : '';
};

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(267);

var has = Object.prototype.hasOwnProperty;
var defaults = {
  allowDots: false,
  allowPrototypes: false,
  arrayLimit: 20,
  decoder: utils.decode,
  delimiter: '&',
  depth: 5,
  parameterLimit: 1000,
  plainObjects: false,
  strictNullHandling: false
};

var parseValues = function parseQueryStringValues(str, options) {
  var obj = {};
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
  var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);

  for (var i = 0; i < parts.length; ++i) {
    var part = parts[i];
    var bracketEqualsPos = part.indexOf(']=');
    var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
    var key, val;

    if (pos === -1) {
      key = options.decoder(part, defaults.decoder);
      val = options.strictNullHandling ? null : '';
    } else {
      key = options.decoder(part.slice(0, pos), defaults.decoder);
      val = options.decoder(part.slice(pos + 1), defaults.decoder);
    }

    if (has.call(obj, key)) {
      obj[key] = [].concat(obj[key]).concat(val);
    } else {
      obj[key] = val;
    }
  }

  return obj;
};

var parseObject = function parseObject(chain, val, options) {
  var leaf = val;

  for (var i = chain.length - 1; i >= 0; --i) {
    var obj;
    var root = chain[i];

    if (root === '[]') {
      obj = [];
      obj = obj.concat(leaf);
    } else {
      obj = options.plainObjects ? Object.create(null) : {};
      var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
      var index = parseInt(cleanRoot, 10);

      if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
        obj = [];
        obj[index] = leaf;
      } else {
        obj[cleanRoot] = leaf;
      }
    }

    leaf = obj;
  }

  return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
  if (!givenKey) {
    return;
  } // Transform dot notation to bracket notation


  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey; // The regex chunks

  var brackets = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g; // Get the parent

  var segment = brackets.exec(key);
  var parent = segment ? key.slice(0, segment.index) : key; // Stash the parent if it exists

  var keys = [];

  if (parent) {
    // If we aren't using plain objects, optionally prefix keys
    // that would overwrite object prototype properties
    if (!options.plainObjects && has.call(Object.prototype, parent)) {
      if (!options.allowPrototypes) {
        return;
      }
    }

    keys.push(parent);
  } // Loop through children appending to the array until we hit depth


  var i = 0;

  while ((segment = child.exec(key)) !== null && i < options.depth) {
    i += 1;

    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }

    keys.push(segment[1]);
  } // If there's a remainder, just add whatever is left


  if (segment) {
    keys.push('[' + key.slice(segment.index) + ']');
  }

  return parseObject(keys, val, options);
};

module.exports = function (str, opts) {
  var options = opts ? utils.assign({}, opts) : {};

  if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
    throw new TypeError('Decoder has to be a function.');
  }

  options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
  options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
  options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
  options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
  options.parseArrays = options.parseArrays !== false;
  options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
  options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
  options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
  options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
  options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
  options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

  if (str === '' || str === null || typeof str === 'undefined') {
    return options.plainObjects ? Object.create(null) : {};
  }

  var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
  var obj = options.plainObjects ? Object.create(null) : {}; // Iterate over the keys and setup the new object

  var keys = Object.keys(tempObj);

  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];
    var newObj = parseKeys(key, tempObj[key], options);
    obj = utils.merge(obj, newObj, options);
  }

  return utils.compact(obj);
};

/***/ }),
/* 460 */
/***/ (function(module, exports) {

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

var _receiveMessage = function _receiveMessage(e) {
  var obj = e.data; //消息字符串结构:消息头 分隔字符串 消息体

  if (!obj.crossDomain) {
    return;
  } //如果是请求消息


  if (obj.call) {
    try {
      var callFun = eval(obj.callFun); //消息请求的函数

      var arg = obj.arg;

      if (typeof callFun != "function") {
        return;
      } //请求的函数不存在


      var resultArg = callFun.call(callFun, arg); //请求执行

      var callBack = obj.callBackFun; //是否反馈结果

      if (callBack) {
        window.sendMessage(e.source, callBack, resultArg);
      }
    } catch (e) {}
  }
};
/**
 * sendMessage主动发送广播消息
 * target string（iframe控件的ID）/object（iframe window,eq:如果是向父页面发送消息,则传window.parent）
 * callFun string 要访问目标iframe的方法名
 * arg 要访问目标iframe的方法的参数
 * callBackFun 消息反馈时调用的方法名
 */


var _sendMessage = function _sendMessage(target, callFun, arg, callBackFun) {
  try {
    var source;

    if (typeof target == "string") {
      source = document.getElementById(target).contentWindow;
    } else if (_typeof(target) == "object" && target != null) {
      source = target;
    } else {
      source = window.top;
    }

    var callMessage = {};
    callMessage["callFun"] = callFun;
    callMessage["arg"] = arg || "";
    callMessage["callBackFun"] = callBackFun; //let msgStr = "call|cross-domain|" + JSON.stringify(callMessage);

    callMessage["crossDomain"] = true;
    callMessage["call"] = true;
    source.postMessage(callMessage, "*");
  } catch (e) {}
};

if (!window.receiveMessage) {
  window.receiveMessage = _receiveMessage;

  if (window.attachEvent) {
    window.attachEvent("onmessage", receiveMessage);
  } else {
    window.addEventListener("message", receiveMessage, true);
  }
}

if (!window.sendMessage) {
  window.sendMessage = _sendMessage;
}

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @ignore
 * event object for dom
 * @author yiminghe@gmail.com
 */


Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

var _EventBaseObject = __webpack_require__(511);

var _EventBaseObject2 = _interopRequireDefault(_EventBaseObject);

var _objectAssign = __webpack_require__(512);

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var TRUE = true;
var FALSE = false;
var commonProps = ['altKey', 'bubbles', 'cancelable', 'ctrlKey', 'currentTarget', 'eventPhase', 'metaKey', 'shiftKey', 'target', 'timeStamp', 'view', 'type'];

function isNullOrUndefined(w) {
  return w === null || w === undefined;
}

var eventNormalizers = [{
  reg: /^key/,
  props: ['char', 'charCode', 'key', 'keyCode', 'which'],
  fix: function fix(event, nativeEvent) {
    if (isNullOrUndefined(event.which)) {
      event.which = !isNullOrUndefined(nativeEvent.charCode) ? nativeEvent.charCode : nativeEvent.keyCode;
    } // add metaKey to non-Mac browsers (use ctrl for PC 's and Meta for Macs)


    if (event.metaKey === undefined) {
      event.metaKey = event.ctrlKey;
    }
  }
}, {
  reg: /^touch/,
  props: ['touches', 'changedTouches', 'targetTouches']
}, {
  reg: /^hashchange$/,
  props: ['newURL', 'oldURL']
}, {
  reg: /^gesturechange$/i,
  props: ['rotation', 'scale']
}, {
  reg: /^(mousewheel|DOMMouseScroll)$/,
  props: [],
  fix: function fix(event, nativeEvent) {
    var deltaX = undefined;
    var deltaY = undefined;
    var delta = undefined;
    var wheelDelta = nativeEvent.wheelDelta;
    var axis = nativeEvent.axis;
    var wheelDeltaY = nativeEvent.wheelDeltaY;
    var wheelDeltaX = nativeEvent.wheelDeltaX;
    var detail = nativeEvent.detail; // ie/webkit

    if (wheelDelta) {
      delta = wheelDelta / 120;
    } // gecko


    if (detail) {
      // press control e.detail == 1 else e.detail == 3
      delta = 0 - (detail % 3 === 0 ? detail / 3 : detail);
    } // Gecko


    if (axis !== undefined) {
      if (axis === event.HORIZONTAL_AXIS) {
        deltaY = 0;
        deltaX = 0 - delta;
      } else if (axis === event.VERTICAL_AXIS) {
        deltaX = 0;
        deltaY = delta;
      }
    } // Webkit


    if (wheelDeltaY !== undefined) {
      deltaY = wheelDeltaY / 120;
    }

    if (wheelDeltaX !== undefined) {
      deltaX = -1 * wheelDeltaX / 120;
    } // 默认 deltaY (ie)


    if (!deltaX && !deltaY) {
      deltaY = delta;
    }

    if (deltaX !== undefined) {
      /**
       * deltaX of mousewheel event
       * @property deltaX
       * @member Event.DomEvent.Object
       */
      event.deltaX = deltaX;
    }

    if (deltaY !== undefined) {
      /**
       * deltaY of mousewheel event
       * @property deltaY
       * @member Event.DomEvent.Object
       */
      event.deltaY = deltaY;
    }

    if (delta !== undefined) {
      /**
       * delta of mousewheel event
       * @property delta
       * @member Event.DomEvent.Object
       */
      event.delta = delta;
    }
  }
}, {
  reg: /^mouse|contextmenu|click|mspointer|(^DOMMouseScroll$)/i,
  props: ['buttons', 'clientX', 'clientY', 'button', 'offsetX', 'relatedTarget', 'which', 'fromElement', 'toElement', 'offsetY', 'pageX', 'pageY', 'screenX', 'screenY'],
  fix: function fix(event, nativeEvent) {
    var eventDoc = undefined;
    var doc = undefined;
    var body = undefined;
    var target = event.target;
    var button = nativeEvent.button; // Calculate pageX/Y if missing and clientX/Y available

    if (target && isNullOrUndefined(event.pageX) && !isNullOrUndefined(nativeEvent.clientX)) {
      eventDoc = target.ownerDocument || document;
      doc = eventDoc.documentElement;
      body = eventDoc.body;
      event.pageX = nativeEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = nativeEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    } // which for click: 1 === left; 2 === middle; 3 === right
    // do not use button


    if (!event.which && button !== undefined) {
      if (button & 1) {
        event.which = 1;
      } else if (button & 2) {
        event.which = 3;
      } else if (button & 4) {
        event.which = 2;
      } else {
        event.which = 0;
      }
    } // add relatedTarget, if necessary


    if (!event.relatedTarget && event.fromElement) {
      event.relatedTarget = event.fromElement === target ? event.toElement : event.fromElement;
    }

    return event;
  }
}];

function retTrue() {
  return TRUE;
}

function retFalse() {
  return FALSE;
}

function DomEventObject(nativeEvent) {
  var type = nativeEvent.type;
  var isNative = typeof nativeEvent.stopPropagation === 'function' || typeof nativeEvent.cancelBubble === 'boolean';

  _EventBaseObject2['default'].call(this);

  this.nativeEvent = nativeEvent; // in case dom event has been mark as default prevented by lower dom node

  var isDefaultPrevented = retFalse;

  if ('defaultPrevented' in nativeEvent) {
    isDefaultPrevented = nativeEvent.defaultPrevented ? retTrue : retFalse;
  } else if ('getPreventDefault' in nativeEvent) {
    // https://bugzilla.mozilla.org/show_bug.cgi?id=691151
    isDefaultPrevented = nativeEvent.getPreventDefault() ? retTrue : retFalse;
  } else if ('returnValue' in nativeEvent) {
    isDefaultPrevented = nativeEvent.returnValue === FALSE ? retTrue : retFalse;
  }

  this.isDefaultPrevented = isDefaultPrevented;
  var fixFns = [];
  var fixFn = undefined;
  var l = undefined;
  var prop = undefined;
  var props = commonProps.concat();
  eventNormalizers.forEach(function (normalizer) {
    if (type.match(normalizer.reg)) {
      props = props.concat(normalizer.props);

      if (normalizer.fix) {
        fixFns.push(normalizer.fix);
      }
    }
  });
  l = props.length; // clone properties of the original event object

  while (l) {
    prop = props[--l];
    this[prop] = nativeEvent[prop];
  } // fix target property, if necessary


  if (!this.target && isNative) {
    this.target = nativeEvent.srcElement || document; // srcElement might not be defined either
  } // check if target is a text node (safari)


  if (this.target && this.target.nodeType === 3) {
    this.target = this.target.parentNode;
  }

  l = fixFns.length;

  while (l) {
    fixFn = fixFns[--l];
    fixFn(this, nativeEvent);
  }

  this.timeStamp = nativeEvent.timeStamp || Date.now();
}

var EventBaseObjectProto = _EventBaseObject2['default'].prototype;
(0, _objectAssign2['default'])(DomEventObject.prototype, EventBaseObjectProto, {
  constructor: DomEventObject,
  preventDefault: function preventDefault() {
    var e = this.nativeEvent; // if preventDefault exists run it on the original event

    if (e.preventDefault) {
      e.preventDefault();
    } else {
      // otherwise set the returnValue property of the original event to FALSE (IE)
      e.returnValue = FALSE;
    }

    EventBaseObjectProto.preventDefault.call(this);
  },
  stopPropagation: function stopPropagation() {
    var e = this.nativeEvent; // if stopPropagation exists run it on the original event

    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      // otherwise set the cancelBubble property of the original event to TRUE (IE)
      e.cancelBubble = TRUE;
    }

    EventBaseObjectProto.stopPropagation.call(this);
  }
});
exports['default'] = DomEventObject;
module.exports = exports['default'];

/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @ignore
 * base event object for custom and dom event.
 * @author yiminghe@gmail.com
 */


Object.defineProperty(exports, "__esModule", {
  value: true
});

function returnFalse() {
  return false;
}

function returnTrue() {
  return true;
}

function EventBaseObject() {
  this.timeStamp = Date.now();
  this.target = undefined;
  this.currentTarget = undefined;
}

EventBaseObject.prototype = {
  isEventObject: 1,
  constructor: EventBaseObject,
  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse,
  preventDefault: function preventDefault() {
    this.isDefaultPrevented = returnTrue;
  },
  stopPropagation: function stopPropagation() {
    this.isPropagationStopped = returnTrue;
  },
  stopImmediatePropagation: function stopImmediatePropagation() {
    this.isImmediatePropagationStopped = returnTrue; // fixed 1.2
    // call stopPropagation implicitly

    this.stopPropagation();
  },
  halt: function halt(immediate) {
    if (immediate) {
      this.stopImmediatePropagation();
    } else {
      this.stopPropagation();
    }

    this.preventDefault();
  }
};
exports["default"] = EventBaseObject;
module.exports = exports["default"];

/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/***/ }),
/* 513 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  "default": __webpack_require__(514),
  __esModule: true
};

/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(515);

module.exports = __webpack_require__(111).Object.assign;

/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(197);

$export($export.S + $export.F, 'Object', {
  assign: __webpack_require__(518)
});

/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(517);

module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 517 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.2.1 Object.assign(target, source, ...)

var getKeys = __webpack_require__(138);

var gOPS = __webpack_require__(204);

var pIE = __webpack_require__(141);

var toObject = __webpack_require__(275);

var IObject = __webpack_require__(273);

var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

module.exports = !$assign || __webpack_require__(113)(function () {
  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;

  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }
  }

  return T;
} : $assign;

/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(92);

var toLength = __webpack_require__(520);

var toAbsoluteIndex = __webpack_require__(521);

module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }
    }
    return !IS_INCLUDES && -1;
  };
};

/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(200);

var min = Math.min;

module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 521 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(200);

var max = Math.max;
var min = Math.min;

module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.12.2
(function () {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if (typeof performance !== "undefined" && performance !== null && performance.now) {
    module.exports = function () {
      return performance.now();
    };
  } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
    module.exports = function () {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };

    hrtime = process.hrtime;

    getNanoSeconds = function getNanoSeconds() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };

    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function () {
      return Date.now() - loadTime;
    };

    loadTime = Date.now();
  } else {
    module.exports = function () {
      return new Date().getTime() - loadTime;
    };

    loadTime = new Date().getTime();
  }
}).call(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(196)))

/***/ }),
/* 523 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(144);
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(144);
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(144);
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(144);
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

module.exports = listCacheSet;

/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(143);
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),
/* 529 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),
/* 530 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),
/* 531 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(143),
    Map = __webpack_require__(205),
    MapCache = __webpack_require__(207);
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(206),
    isMasked = __webpack_require__(534),
    isObject = __webpack_require__(39),
    toSource = __webpack_require__(278);
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(535);
/** Used to detect methods masquerading as native. */


var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(38);
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;

/***/ }),
/* 536 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(538),
    ListCache = __webpack_require__(143),
    Map = __webpack_require__(205);
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(539),
    hashDelete = __webpack_require__(540),
    hashGet = __webpack_require__(541),
    hashHas = __webpack_require__(542),
    hashSet = __webpack_require__(543);
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(145);
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),
/* 540 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(145);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(145);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(145);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(146);
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),
/* 545 */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = _typeof(value);

  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(146);
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(146);
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),
/* 548 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(146);
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),
/* 549 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

module.exports = arrayEach;

/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(93),
    keys = __webpack_require__(147);
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

/***/ }),
/* 551 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(58),
    isObjectLike = __webpack_require__(45);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),
/* 553 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),
/* 554 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(58),
    isLength = __webpack_require__(211),
    isObjectLike = __webpack_require__(45);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(212),
    nativeKeys = __webpack_require__(556);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeys;

/***/ }),
/* 556 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(135);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;

/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(93),
    keysIn = __webpack_require__(154);
/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

/***/ }),
/* 558 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(39),
    isPrototype = __webpack_require__(212),
    nativeKeysIn = __webpack_require__(559);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeysIn;

/***/ }),
/* 559 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

module.exports = nativeKeysIn;

/***/ }),
/* 560 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(93),
    getSymbols = __webpack_require__(213);
/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

/***/ }),
/* 561 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

module.exports = arrayFilter;

/***/ }),
/* 562 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(93),
    getSymbolsIn = __webpack_require__(284);
/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(76),
    root = __webpack_require__(38);
/* Built-in method references that are verified to be native. */


var DataView = getNative(root, 'DataView');
module.exports = DataView;

/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(76),
    root = __webpack_require__(38);
/* Built-in method references that are verified to be native. */


var Promise = getNative(root, 'Promise');
module.exports = Promise;

/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(76),
    root = __webpack_require__(38);
/* Built-in method references that are verified to be native. */


var WeakMap = getNative(root, 'WeakMap');
module.exports = WeakMap;

/***/ }),
/* 566 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */

function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }

  return result;
}

module.exports = initCloneArray;

/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(215),
    cloneDataView = __webpack_require__(568),
    cloneRegExp = __webpack_require__(569),
    cloneSymbol = __webpack_require__(570),
    cloneTypedArray = __webpack_require__(290);
/** `Object#toString` result references. */


var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;

  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag:
    case float64Tag:
    case int8Tag:
    case int16Tag:
    case int32Tag:
    case uint8Tag:
    case uint8ClampedTag:
    case uint16Tag:
    case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor();

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor();

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(215);
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */


function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

/***/ }),
/* 569 */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */

function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(59);
/** Used to convert symbols to primitives and strings. */


var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */

function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

/***/ }),
/* 571 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(39);
/** Built-in value references. */


var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

module.exports = baseCreate;

/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMap = __webpack_require__(573),
    baseUnary = __webpack_require__(151),
    nodeUtil = __webpack_require__(152);
/* Node.js helper references. */


var nodeIsMap = nodeUtil && nodeUtil.isMap;
/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */

var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
module.exports = isMap;

/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(155),
    isObjectLike = __webpack_require__(45);
/** `Object#toString` result references. */


var mapTag = '[object Map]';
/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */

function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;

/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsSet = __webpack_require__(575),
    baseUnary = __webpack_require__(151),
    nodeUtil = __webpack_require__(152);
/* Node.js helper references. */


var nodeIsSet = nodeUtil && nodeUtil.isSet;
/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */

var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
module.exports = isSet;

/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(155),
    isObjectLike = __webpack_require__(45);
/** `Object#toString` result references. */


var setTag = '[object Set]';
/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */

function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;

/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(577);

function scrollIntoView(elem, container, config) {
  config = config || {}; // document 归一化到 window

  if (container.nodeType === 9) {
    container = util.getWindow(container);
  }

  var allowHorizontalScroll = config.allowHorizontalScroll;
  var onlyScrollIfNeeded = config.onlyScrollIfNeeded;
  var alignWithTop = config.alignWithTop;
  var alignWithLeft = config.alignWithLeft;
  var offsetTop = config.offsetTop || 0;
  var offsetLeft = config.offsetLeft || 0;
  var offsetBottom = config.offsetBottom || 0;
  var offsetRight = config.offsetRight || 0;
  allowHorizontalScroll = allowHorizontalScroll === undefined ? true : allowHorizontalScroll;
  var isWin = util.isWindow(container);
  var elemOffset = util.offset(elem);
  var eh = util.outerHeight(elem);
  var ew = util.outerWidth(elem);
  var containerOffset = undefined;
  var ch = undefined;
  var cw = undefined;
  var containerScroll = undefined;
  var diffTop = undefined;
  var diffBottom = undefined;
  var win = undefined;
  var winScroll = undefined;
  var ww = undefined;
  var wh = undefined;

  if (isWin) {
    win = container;
    wh = util.height(win);
    ww = util.width(win);
    winScroll = {
      left: util.scrollLeft(win),
      top: util.scrollTop(win)
    }; // elem 相对 container 可视视窗的距离

    diffTop = {
      left: elemOffset.left - winScroll.left - offsetLeft,
      top: elemOffset.top - winScroll.top - offsetTop
    };
    diffBottom = {
      left: elemOffset.left + ew - (winScroll.left + ww) + offsetRight,
      top: elemOffset.top + eh - (winScroll.top + wh) + offsetBottom
    };
    containerScroll = winScroll;
  } else {
    containerOffset = util.offset(container);
    ch = container.clientHeight;
    cw = container.clientWidth;
    containerScroll = {
      left: container.scrollLeft,
      top: container.scrollTop
    }; // elem 相对 container 可视视窗的距离
    // 注意边框, offset 是边框到根节点

    diffTop = {
      left: elemOffset.left - (containerOffset.left + (parseFloat(util.css(container, 'borderLeftWidth')) || 0)) - offsetLeft,
      top: elemOffset.top - (containerOffset.top + (parseFloat(util.css(container, 'borderTopWidth')) || 0)) - offsetTop
    };
    diffBottom = {
      left: elemOffset.left + ew - (containerOffset.left + cw + (parseFloat(util.css(container, 'borderRightWidth')) || 0)) + offsetRight,
      top: elemOffset.top + eh - (containerOffset.top + ch + (parseFloat(util.css(container, 'borderBottomWidth')) || 0)) + offsetBottom
    };
  }

  if (diffTop.top < 0 || diffBottom.top > 0) {
    // 强制向上
    if (alignWithTop === true) {
      util.scrollTop(container, containerScroll.top + diffTop.top);
    } else if (alignWithTop === false) {
      util.scrollTop(container, containerScroll.top + diffBottom.top);
    } else {
      // 自动调整
      if (diffTop.top < 0) {
        util.scrollTop(container, containerScroll.top + diffTop.top);
      } else {
        util.scrollTop(container, containerScroll.top + diffBottom.top);
      }
    }
  } else {
    if (!onlyScrollIfNeeded) {
      alignWithTop = alignWithTop === undefined ? true : !!alignWithTop;

      if (alignWithTop) {
        util.scrollTop(container, containerScroll.top + diffTop.top);
      } else {
        util.scrollTop(container, containerScroll.top + diffBottom.top);
      }
    }
  }

  if (allowHorizontalScroll) {
    if (diffTop.left < 0 || diffBottom.left > 0) {
      // 强制向上
      if (alignWithLeft === true) {
        util.scrollLeft(container, containerScroll.left + diffTop.left);
      } else if (alignWithLeft === false) {
        util.scrollLeft(container, containerScroll.left + diffBottom.left);
      } else {
        // 自动调整
        if (diffTop.left < 0) {
          util.scrollLeft(container, containerScroll.left + diffTop.left);
        } else {
          util.scrollLeft(container, containerScroll.left + diffBottom.left);
        }
      }
    } else {
      if (!onlyScrollIfNeeded) {
        alignWithLeft = alignWithLeft === undefined ? true : !!alignWithLeft;

        if (alignWithLeft) {
          util.scrollLeft(container, containerScroll.left + diffTop.left);
        } else {
          util.scrollLeft(container, containerScroll.left + diffBottom.left);
        }
      }
    }
  }
}

module.exports = scrollIntoView;

/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : _typeof2(obj);
};

var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;

function getClientPosition(elem) {
  var box = undefined;
  var x = undefined;
  var y = undefined;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement; // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式

  box = elem.getBoundingClientRect(); // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

  x = box.left;
  y = box.top; // In IE, most of the time, 2 extra pixels are added to the top and left
  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
  // IE6 standards mode, this border can be overridden by setting the
  // document element's border to zero -- thus, we cannot rely on the
  // offset always being 2 pixels.
  // In quirks mode, the offset can be determined by querying the body's
  // clientLeft/clientTop, but in standards mode, it is found by querying
  // the document element's clientLeft/clientTop.  Since we already called
  // getClientBoundingRect we have already forced a reflow, so it is not
  // too expensive just to query them all.
  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
  // 窗口边框标准是设 documentElement ,quirks 时设置 body
  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
  // 标准 ie 下 docElem.clientTop 就是 border-top
  // ie7 html 即窗口边框改变不了。永远为 2
  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x,
    top: y
  };
}

function getScroll(w, top) {
  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
  var method = 'scroll' + (top ? 'Top' : 'Left');

  if (typeof ret !== 'number') {
    var d = w.document; // ie6,7,8 standard mode

    ret = d.documentElement[method];

    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }

  return ret;
}

function getScrollLeft(w) {
  return getScroll(w);
}

function getScrollTop(w) {
  return getScroll(w, true);
}

function getOffset(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w);
  pos.top += getScrollTop(w);
  return pos;
}

function _getComputedStyle(elem, name, computedStyle_) {
  var val = '';
  var d = elem.ownerDocument;
  var computedStyle = computedStyle_ || d.defaultView.getComputedStyle(elem, null); // https://github.com/kissyteam/kissy/issues/61

  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }

  return val;
}

var _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');

var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = 'currentStyle';
var RUNTIME_STYLE = 'runtimeStyle';
var LEFT = 'left';
var PX = 'px';

function _getComputedStyleIE(elem, name) {
  // currentStyle maybe null
  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name]; // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
  // 在 ie 下不对，需要直接用 offset 方式
  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了
  // From the awesome hack by Dean Edwards
  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
  // If we're not dealing with a regular pixel number
  // but a number that has a weird ending, we need to convert it to pixels
  // exclude left right for relativity

  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    // Remember the original values
    var style = elem.style;
    var left = style[LEFT];
    var rsLeft = elem[RUNTIME_STYLE][LEFT]; // prevent flashing of content

    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT]; // Put in the new values to get a computed value out

    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
    ret = style.pixelLeft + PX; // Revert the changed values

    style[LEFT] = left;
    elem[RUNTIME_STYLE][LEFT] = rsLeft;
  }

  return ret === '' ? 'auto' : ret;
}

var getComputedStyleX = undefined;

if (typeof window !== 'undefined') {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}

function each(arr, fn) {
  for (var i = 0; i < arr.length; i++) {
    fn(arr[i]);
  }
}

function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
}

var BOX_MODELS = ['margin', 'border', 'padding'];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;

function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name = undefined; // Remember the old values, and insert the new ones

  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }

  callback.call(elem); // Revert the old values

  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}

function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop = undefined;
  var j = undefined;
  var i = undefined;

  for (j = 0; j < props.length; j++) {
    prop = props[j];

    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = undefined;

        if (prop === 'border') {
          cssProp = prop + which[i] + 'Width';
        } else {
          cssProp = prop + which[i];
        }

        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }

  return value;
}
/**
 * A crude way of determining if an object is a window
 * @member util
 */


function isWindow(obj) {
  // must use == for ie8

  /* eslint eqeqeq:0 */
  return obj != null && obj == obj.window;
}

var domUtils = {};
each(['Width', 'Height'], function (name) {
  domUtils['doc' + name] = function (refWin) {
    var d = refWin.document;
    return Math.max( // firefox chrome documentElement.scrollHeight< body.scrollHeight
    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
    d.documentElement['scroll' + name], // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
    d.body['scroll' + name], domUtils['viewport' + name](d));
  };

  domUtils['viewport' + name] = function (win) {
    // pc browser includes scrollbar in window.innerWidth
    var prop = 'client' + name;
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop]; // 标准模式取 documentElement
    // backcompat 取 body

    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  };
});
/*
 得到元素的大小信息
 @param elem
 @param name
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */

function getWH(elem, name, extra) {
  if (isWindow(elem)) {
    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }

  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  var borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;
  var computedStyle = getComputedStyleX(elem);
  var isBorderBox = isBorderBoxFn(elem, computedStyle);
  var cssBoxValue = 0;

  if (borderBoxValue == null || borderBoxValue <= 0) {
    borderBoxValue = undefined; // Fall back to computed then un computed css if necessary

    cssBoxValue = getComputedStyleX(elem, name);

    if (cssBoxValue == null || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    } // Normalize '', auto, and prepare for extra


    cssBoxValue = parseFloat(cssBoxValue) || 0;
  }

  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }

  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  var val = borderBoxValue || cssBoxValue;

  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which, computedStyle);
    }

    return cssBoxValue;
  }

  if (borderBoxValueOrIsBorderBox) {
    var padding = extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle);
    return val + (extra === BORDER_INDEX ? 0 : padding);
  }

  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
}

var cssShow = {
  position: 'absolute',
  visibility: 'hidden',
  display: 'block'
}; // fix #119 : https://github.com/kissyteam/kissy/issues/119

function getWHIgnoreDisplay(elem) {
  var val = undefined;
  var args = arguments; // in case elem is window
  // elem.offsetWidth === undefined

  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    swap(elem, cssShow, function () {
      val = getWH.apply(undefined, args);
    });
  }

  return val;
}

function css(el, name, v) {
  var value = v;

  if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
    for (var i in name) {
      if (name.hasOwnProperty(i)) {
        css(el, i, name[i]);
      }
    }

    return undefined;
  }

  if (typeof value !== 'undefined') {
    if (typeof value === 'number') {
      value += 'px';
    }

    el.style[name] = value;
    return undefined;
  }

  return getComputedStyleX(el, name);
}

each(['width', 'height'], function (name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);

  domUtils['outer' + first] = function (el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };

  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

  domUtils[name] = function (elem, val) {
    if (val !== undefined) {
      if (elem) {
        var computedStyle = getComputedStyleX(elem);
        var isBorderBox = isBorderBoxFn(elem);

        if (isBorderBox) {
          val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);
        }

        return css(elem, name, val);
      }

      return undefined;
    }

    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
}); // 设置 elem 相对 elem.ownerDocument 的坐标

function setOffset(elem, offset) {
  // set position first, in-case top/left are set even on static elem
  if (css(elem, 'position') === 'static') {
    elem.style.position = 'relative';
  }

  var old = getOffset(elem);
  var ret = {};
  var current = undefined;
  var key = undefined;

  for (key in offset) {
    if (offset.hasOwnProperty(key)) {
      current = parseFloat(css(elem, key)) || 0;
      ret[key] = current + offset[key] - old[key];
    }
  }

  css(elem, ret);
}

module.exports = _extends({
  getWindow: function getWindow(node) {
    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  offset: function offset(el, value) {
    if (typeof value !== 'undefined') {
      setOffset(el, value);
    } else {
      return getOffset(el);
    }
  },
  isWindow: isWindow,
  each: each,
  css: css,
  clone: function clone(obj) {
    var ret = {};

    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }

    var overflow = obj.overflow;

    if (overflow) {
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }

    return ret;
  },
  scrollLeft: function scrollLeft(w, v) {
    if (isWindow(w)) {
      if (v === undefined) {
        return getScrollLeft(w);
      }

      window.scrollTo(v, getScrollTop(w));
    } else {
      if (v === undefined) {
        return w.scrollLeft;
      }

      w.scrollLeft = v;
    }
  },
  scrollTop: function scrollTop(w, v) {
    if (isWindow(w)) {
      if (v === undefined) {
        return getScrollTop(w);
      }

      window.scrollTo(getScrollLeft(w), v);
    } else {
      if (v === undefined) {
        return w.scrollTop;
      }

      w.scrollTop = v;
    }
  },
  viewportWidth: 0,
  viewportHeight: 0
}, domUtils);

/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(38);
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */


var now = function now() {
  return root.Date.now();
};

module.exports = now;

/***/ }),
/* 579 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(39),
    isSymbol = __webpack_require__(156);
/** Used as references for various `Number` constants. */


var NAN = 0 / 0;
/** Used to match leading and trailing whitespace. */

var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */

function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = toNumber;

/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

var MediaQuery = __webpack_require__(581);

var Util = __webpack_require__(293);

var each = Util.each;
var isFunction = Util.isFunction;
var isArray = Util.isArray;
/**
 * Allows for registration of query handlers.
 * Manages the query handler's state and is responsible for wiring up browser events
 *
 * @constructor
 */

function MediaQueryDispatch() {
  if (!window.matchMedia) {
    throw new Error('matchMedia not present, legacy browsers require a polyfill');
  }

  this.queries = {};
  this.browserIsIncapable = !window.matchMedia('only all').matches;
}

MediaQueryDispatch.prototype = {
  constructor: MediaQueryDispatch,

  /**
   * Registers a handler for the given media query
   *
   * @param {string} q the media query
   * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers
   * @param {function} options.match fired when query matched
   * @param {function} [options.unmatch] fired when a query is no longer matched
   * @param {function} [options.setup] fired when handler first triggered
   * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched
   * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers
   */
  register: function register(q, options, shouldDegrade) {
    var queries = this.queries,
        isUnconditional = shouldDegrade && this.browserIsIncapable;

    if (!queries[q]) {
      queries[q] = new MediaQuery(q, isUnconditional);
    } //normalise to object in an array


    if (isFunction(options)) {
      options = {
        match: options
      };
    }

    if (!isArray(options)) {
      options = [options];
    }

    each(options, function (handler) {
      if (isFunction(handler)) {
        handler = {
          match: handler
        };
      }

      queries[q].addHandler(handler);
    });
    return this;
  },

  /**
   * unregisters a query and all it's handlers, or a specific handler for a query
   *
   * @param {string} q the media query to target
   * @param {object || function} [handler] specific handler to unregister
   */
  unregister: function unregister(q, handler) {
    var query = this.queries[q];

    if (query) {
      if (handler) {
        query.removeHandler(handler);
      } else {
        query.clear();
        delete this.queries[q];
      }
    }

    return this;
  }
};
module.exports = MediaQueryDispatch;

/***/ }),
/* 581 */
/***/ (function(module, exports, __webpack_require__) {

var QueryHandler = __webpack_require__(582);

var each = __webpack_require__(293).each;
/**
 * Represents a single media query, manages it's state and registered handlers for this query
 *
 * @constructor
 * @param {string} query the media query string
 * @param {boolean} [isUnconditional=false] whether the media query should run regardless of whether the conditions are met. Primarily for helping older browsers deal with mobile-first design
 */


function MediaQuery(query, isUnconditional) {
  this.query = query;
  this.isUnconditional = isUnconditional;
  this.handlers = [];
  this.mql = window.matchMedia(query);
  var self = this;

  this.listener = function (mql) {
    // Chrome passes an MediaQueryListEvent object, while other browsers pass MediaQueryList directly
    self.mql = mql.currentTarget || mql;
    self.assess();
  };

  this.mql.addListener(this.listener);
}

MediaQuery.prototype = {
  constuctor: MediaQuery,

  /**
   * add a handler for this query, triggering if already active
   *
   * @param {object} handler
   * @param {function} handler.match callback for when query is activated
   * @param {function} [handler.unmatch] callback for when query is deactivated
   * @param {function} [handler.setup] callback for immediate execution when a query handler is registered
   * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?
   */
  addHandler: function addHandler(handler) {
    var qh = new QueryHandler(handler);
    this.handlers.push(qh);
    this.matches() && qh.on();
  },

  /**
   * removes the given handler from the collection, and calls it's destroy methods
   *
   * @param {object || function} handler the handler to remove
   */
  removeHandler: function removeHandler(handler) {
    var handlers = this.handlers;
    each(handlers, function (h, i) {
      if (h.equals(handler)) {
        h.destroy();
        return !handlers.splice(i, 1); //remove from array and exit each early
      }
    });
  },

  /**
   * Determine whether the media query should be considered a match
   *
   * @return {Boolean} true if media query can be considered a match, false otherwise
   */
  matches: function matches() {
    return this.mql.matches || this.isUnconditional;
  },

  /**
   * Clears all handlers and unbinds events
   */
  clear: function clear() {
    each(this.handlers, function (handler) {
      handler.destroy();
    });
    this.mql.removeListener(this.listener);
    this.handlers.length = 0; //clear array
  },

  /*
      * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match
      */
  assess: function assess() {
    var action = this.matches() ? 'on' : 'off';
    each(this.handlers, function (handler) {
      handler[action]();
    });
  }
};
module.exports = MediaQuery;

/***/ }),
/* 582 */
/***/ (function(module, exports) {

/**
 * Delegate to handle a media query being matched and unmatched.
 *
 * @param {object} options
 * @param {function} options.match callback for when the media query is matched
 * @param {function} [options.unmatch] callback for when the media query is unmatched
 * @param {function} [options.setup] one-time callback triggered the first time a query is matched
 * @param {boolean} [options.deferSetup=false] should the setup callback be run immediately, rather than first time query is matched?
 * @constructor
 */
function QueryHandler(options) {
  this.options = options;
  !options.deferSetup && this.setup();
}

QueryHandler.prototype = {
  constructor: QueryHandler,

  /**
   * coordinates setup of the handler
   *
   * @function
   */
  setup: function setup() {
    if (this.options.setup) {
      this.options.setup();
    }

    this.initialised = true;
  },

  /**
   * coordinates setup and triggering of the handler
   *
   * @function
   */
  on: function on() {
    !this.initialised && this.setup();
    this.options.match && this.options.match();
  },

  /**
   * coordinates the unmatch event for the handler
   *
   * @function
   */
  off: function off() {
    this.options.unmatch && this.options.unmatch();
  },

  /**
   * called when a handler is to be destroyed.
   * delegates to the destroy or unmatch callbacks, depending on availability.
   *
   * @function
   */
  destroy: function destroy() {
    this.options.destroy ? this.options.destroy() : this.off();
  },

  /**
   * determines equality by reference.
   * if object is supplied compare options, if function, compare match callback
   *
   * @function
   * @param {object || function} [target] the target for comparison
   */
  equals: function equals(target) {
    return this.options === target || this.options.match === target;
  }
};
module.exports = QueryHandler;

/***/ }),
/* 583 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_9_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_node_modules_sass_resources_loader_lib_loader_js_ref_9_3_node_modules_vue_loader_lib_index_js_vue_loader_options_colorPicker_vue_vue_type_style_index_0_id_715cc45a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(178);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_9_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_node_modules_sass_resources_loader_lib_loader_js_ref_9_3_node_modules_vue_loader_lib_index_js_vue_loader_options_colorPicker_vue_vue_type_style_index_0_id_715cc45a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_9_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_node_modules_sass_resources_loader_lib_loader_js_ref_9_3_node_modules_vue_loader_lib_index_js_vue_loader_options_colorPicker_vue_vue_type_style_index_0_id_715cc45a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */
 /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_9_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_node_modules_sass_resources_loader_lib_loader_js_ref_9_3_node_modules_vue_loader_lib_index_js_vue_loader_options_colorPicker_vue_vue_type_style_index_0_id_715cc45a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),
/* 584 */
/***/ (function(module, exports) {

var camel2hyphen = function camel2hyphen(str) {
  return str.replace(/[A-Z]/g, function (match) {
    return '-' + match.toLowerCase();
  }).toLowerCase();
};

module.exports = camel2hyphen;

/***/ }),
/* 585 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(94),
    last = __webpack_require__(591),
    parent = __webpack_require__(592),
    toKey = __webpack_require__(95);
/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */


function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;

/***/ }),
/* 586 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(587);
/** Used to match property names within property paths. */


var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
      result.push('');
    }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
module.exports = stringToPath;

/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(588);
/** Used as the maximum memoize cache size. */


var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

/***/ }),
/* 588 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(207);
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;
module.exports = memoize;

/***/ }),
/* 589 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(590);
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */


function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

/***/ }),
/* 590 */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(59),
    arrayMap = __webpack_require__(294),
    isArray = __webpack_require__(50),
    isSymbol = __webpack_require__(156);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;

/***/ }),
/* 591 */
/***/ (function(module, exports) {

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

/***/ }),
/* 592 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(157),
    baseSlice = __webpack_require__(593);
/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */


function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;

/***/ }),
/* 593 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }

  end = end > length ? length : end;

  if (end < 0) {
    end += length;
  }

  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);

  while (++index < length) {
    result[index] = array[index + start];
  }

  return result;
}

module.exports = baseSlice;

/***/ }),
/* 594 */
/***/ (function(module, exports, __webpack_require__) {

var isPlainObject = __webpack_require__(23);
/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */


function customOmitClone(value) {
  return isPlainObject(value) ? undefined : value;
}

module.exports = customOmitClone;

/***/ }),
/* 595 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(596);
/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */


function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;

/***/ }),
/* 596 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(214),
    isFlattenable = __webpack_require__(597);
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */


function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];

    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }

  return result;
}

module.exports = baseFlatten;

/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(59),
    isArguments = __webpack_require__(148),
    isArray = __webpack_require__(50);
/** Built-in value references. */


var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */

function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

/***/ }),
/* 598 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

module.exports = apply;

/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(600),
    defineProperty = __webpack_require__(279),
    identity = __webpack_require__(217);
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
module.exports = baseSetToString;

/***/ }),
/* 600 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

module.exports = constant;

/***/ }),
/* 601 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

/***/ }),
/* 602 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function registerImmediate(handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function onGlobalMessage(event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function registerImmediate(handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function registerImmediate(handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function registerImmediate(handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function registerImmediate(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(67), __webpack_require__(196)))

/***/ }),
/* 603 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(58),
    isObjectLike = __webpack_require__(45);
/** `Object#toString` result references. */


var regexpTag = '[object RegExp]';
/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */

function baseIsRegExp(value) {
  return isObjectLike(value) && baseGetTag(value) == regexpTag;
}

module.exports = baseIsRegExp;

/***/ }),
/* 604 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */

function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;

/***/ }),
/* 605 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  "default": __webpack_require__(606),
  __esModule: true
};

/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(607);

__webpack_require__(613);

module.exports = __webpack_require__(220).f('iterator');

/***/ }),
/* 607 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $at = __webpack_require__(608)(true); // 21.1.3.27 String.prototype[@@iterator]()


__webpack_require__(299)(String, 'String', function (iterated) {
  this._t = String(iterated); // target

  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return {
    value: undefined,
    done: true
  };
  point = $at(O, index);
  this._i += point.length;
  return {
    value: point,
    done: false
  };
});

/***/ }),
/* 608 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(200);

var defined = __webpack_require__(199); // true  -> String#at
// false -> String#codePointAt


module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),
/* 609 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = __webpack_require__(301);

var descriptor = __webpack_require__(137);

var setToStringTag = __webpack_require__(219);

var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

__webpack_require__(89)(IteratorPrototype, __webpack_require__(96)('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, {
    next: descriptor(1, next)
  });
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),
/* 610 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(90);

var anObject = __webpack_require__(136);

var getKeys = __webpack_require__(138);

module.exports = __webpack_require__(91) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;

  while (length > i) {
    dP.f(O, P = keys[i++], Properties[P]);
  }

  return O;
};

/***/ }),
/* 611 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(68).document;

module.exports = document && document.documentElement;

/***/ }),
/* 612 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(75);

var toObject = __webpack_require__(275);

var IE_PROTO = __webpack_require__(201)('IE_PROTO');

var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectProto : null;
};

/***/ }),
/* 613 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(614);

var global = __webpack_require__(68);

var hide = __webpack_require__(89);

var Iterators = __webpack_require__(218);

var TO_STRING_TAG = __webpack_require__(96)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' + 'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' + 'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' + 'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' + 'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

/***/ }),
/* 614 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var addToUnscopables = __webpack_require__(615);

var step = __webpack_require__(616);

var Iterators = __webpack_require__(218);

var toIObject = __webpack_require__(92); // 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()


module.exports = __webpack_require__(299)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target

  this._i = 0; // next index

  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;

  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }

  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

Iterators.Arguments = Iterators.Array;
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),
/* 615 */
/***/ (function(module, exports) {

module.exports = function () {
  /* empty */
};

/***/ }),
/* 616 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return {
    value: value,
    done: !!done
  };
};

/***/ }),
/* 617 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  "default": __webpack_require__(618),
  __esModule: true
};

/***/ }),
/* 618 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(619);

__webpack_require__(625);

__webpack_require__(626);

__webpack_require__(627);

module.exports = __webpack_require__(111).Symbol;

/***/ }),
/* 619 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // ECMAScript 6 symbols shim

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var global = __webpack_require__(68);

var has = __webpack_require__(75);

var DESCRIPTORS = __webpack_require__(91);

var $export = __webpack_require__(197);

var redefine = __webpack_require__(300);

var META = __webpack_require__(620).KEY;

var $fails = __webpack_require__(113);

var shared = __webpack_require__(202);

var setToStringTag = __webpack_require__(219);

var uid = __webpack_require__(140);

var wks = __webpack_require__(96);

var wksExt = __webpack_require__(220);

var wksDefine = __webpack_require__(221);

var enumKeys = __webpack_require__(621);

var isArray = __webpack_require__(622);

var anObject = __webpack_require__(136);

var isObject = __webpack_require__(112);

var toIObject = __webpack_require__(92);

var toPrimitive = __webpack_require__(198);

var createDesc = __webpack_require__(137);

var _create = __webpack_require__(301);

var gOPNExt = __webpack_require__(623);

var $GOPD = __webpack_require__(624);

var $DP = __webpack_require__(90);

var $keys = __webpack_require__(138);

var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;

var _stringify = $JSON && $JSON.stringify;

var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function get() {
      return dP(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function wrap(tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);

  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && _typeof($Symbol.iterator) == 'symbol' ? function (it) {
  return _typeof(it) == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);

  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, {
        enumerable: createDesc(0, false)
      });
    }

    return setSymbolDesc(it, key, D);
  }

  return dP(it, key, D);
};

var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;

  while (l > i) {
    $defineProperty(it, key = keys[i++], P[key]);
  }

  return it;
};

var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};

var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};

var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }

  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }

  return result;
}; // 19.4.1.1 Symbol([description])


if (!USE_NATIVE) {
  $Symbol = function _Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);

    var $set = function $set(value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };

    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: $set
    });
    return wrap(tag);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });
  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(302).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(141).f = $propertyIsEnumerable;
  __webpack_require__(204).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(139)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Symbol: $Symbol
});

for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
  wks(es6Symbols[j++]);
}

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) {
  wksDefine(wellKnownSymbols[k++]);
}

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function _for(key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

    for (var key in SymbolRegistry) {
      if (SymbolRegistry[key] === sym) return key;
    }
  },
  useSetter: function useSetter() {
    setter = true;
  },
  useSimple: function useSimple() {
    setter = false;
  }
});
$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // 24.3.2 JSON.stringify(value [, replacer [, space]])

$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols

  return _stringify([S]) != '[null]' || _stringify({
    a: S
  }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;

    while (arguments.length > i) {
      args.push(arguments[i++]);
    }

    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

    if (!isArray(replacer)) replacer = function replacer(key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
}); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(89)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 620 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var META = __webpack_require__(140)('meta');

var isObject = __webpack_require__(112);

var has = __webpack_require__(75);

var setDesc = __webpack_require__(90).f;

var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var FREEZE = !__webpack_require__(113)(function () {
  return isExtensible(Object.preventExtensions({}));
});

var setMeta = function setMeta(it) {
  setDesc(it, META, {
    value: {
      i: 'O' + ++id,
      // object ID
      w: {} // weak collections IDs

    }
  });
};

var fastKey = function fastKey(it, create) {
  // return primitive with prefix
  if (!isObject(it)) return _typeof(it) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F'; // not necessary to add metadata

    if (!create) return 'E'; // add missing metadata

    setMeta(it); // return object ID
  }

  return it[META].i;
};

var getWeak = function getWeak(it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true; // not necessary to add metadata

    if (!create) return false; // add missing metadata

    setMeta(it); // return hash weak collections IDs
  }

  return it[META].w;
}; // add metadata on freeze-family methods calling


var onFreeze = function onFreeze(it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};

var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 621 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(138);

var gOPS = __webpack_require__(204);

var pIE = __webpack_require__(141);

module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;

  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;

    while (symbols.length > i) {
      if (isEnum.call(it, key = symbols[i++])) result.push(key);
    }
  }

  return result;
};

/***/ }),
/* 622 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(274);

module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

/***/ }),
/* 623 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(92);

var gOPN = __webpack_require__(302).f;

var toString = {}.toString;
var windowNames = (typeof window === "undefined" ? "undefined" : _typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function getWindowNames(it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

/***/ }),
/* 624 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(141);

var createDesc = __webpack_require__(137);

var toIObject = __webpack_require__(92);

var toPrimitive = __webpack_require__(198);

var has = __webpack_require__(75);

var IE8_DOM_DEFINE = __webpack_require__(270);

var gOPD = Object.getOwnPropertyDescriptor;
exports.f = __webpack_require__(91) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {
    /* empty */
  }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),
/* 625 */
/***/ (function(module, exports) {



/***/ }),
/* 626 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(221)('asyncIterator');

/***/ }),
/* 627 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(221)('observable');

/***/ }),
/* 628 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(142),
    assignMergeValue = __webpack_require__(304),
    baseFor = __webpack_require__(629),
    baseMergeDeep = __webpack_require__(631),
    isObject = __webpack_require__(39),
    keysIn = __webpack_require__(154),
    safeGet = __webpack_require__(305);
/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */


function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack());
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;

/***/ }),
/* 629 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(630);
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */


var baseFor = createBaseFor();
module.exports = baseFor;

/***/ }),
/* 630 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

module.exports = createBaseFor;

/***/ }),
/* 631 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(304),
    cloneBuffer = __webpack_require__(281),
    cloneTypedArray = __webpack_require__(290),
    copyArray = __webpack_require__(282),
    initCloneObject = __webpack_require__(291),
    isArguments = __webpack_require__(148),
    isArray = __webpack_require__(50),
    isArrayLikeObject = __webpack_require__(632),
    isBuffer = __webpack_require__(149),
    isFunction = __webpack_require__(206),
    isObject = __webpack_require__(39),
    isPlainObject = __webpack_require__(23),
    isTypedArray = __webpack_require__(210),
    safeGet = __webpack_require__(305),
    toPlainObject = __webpack_require__(633);
/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */


function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;

      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;

/***/ }),
/* 632 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(153),
    isObjectLike = __webpack_require__(45);
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */


function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

/***/ }),
/* 633 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(93),
    keysIn = __webpack_require__(154);
/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */


function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;

/***/ }),
/* 634 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(635),
    isIterateeCall = __webpack_require__(636);
/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */


function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

module.exports = createAssigner;

/***/ }),
/* 635 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(217),
    overRest = __webpack_require__(296),
    setToString = __webpack_require__(297);
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */


function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

/***/ }),
/* 636 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var eq = __webpack_require__(114),
    isArrayLike = __webpack_require__(153),
    isIndex = __webpack_require__(150),
    isObject = __webpack_require__(39);
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */


function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = _typeof(index);

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

module.exports = isIterateeCall;

/***/ }),
/* 637 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Determine if a DOM element matches a CSS selector
 *
 * @param {Element} elem
 * @param {String} selector
 * @return {Boolean}
 * @api public
 */

function matches(elem, selector) {
  // Vendor-specific implementations of `Element.prototype.matches()`.
  var proto = window.Element.prototype;
  var nativeMatches = proto.matches || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;

  if (!elem || elem.nodeType !== 1) {
    return false;
  }

  var parentElem = elem.parentNode; // use native 'matches'

  if (nativeMatches) {
    return nativeMatches.call(elem, selector);
  } // native support for `matches` is missing and a fallback is required


  var nodes = parentElem.querySelectorAll(selector);
  var len = nodes.length;

  for (var i = 0; i < len; i++) {
    if (nodes[i] === elem) {
      return true;
    }
  }

  return false;
}
/**
 * Expose `matches`
 */


module.exports = matches;

/***/ }),
/* 638 */
/***/ (function(module, exports, __webpack_require__) {

var basePickBy = __webpack_require__(639),
    hasIn = __webpack_require__(306);
/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */


function basePick(object, paths) {
  return basePickBy(object, paths, function (value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;

/***/ }),
/* 639 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(157),
    baseSet = __webpack_require__(303),
    castPath = __webpack_require__(94);
/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */


function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }

  return result;
}

module.exports = basePickBy;

/***/ }),
/* 640 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

/***/ }),
/* 641 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var baseMatches = __webpack_require__(642),
    baseMatchesProperty = __webpack_require__(652),
    identity = __webpack_require__(217),
    isArray = __webpack_require__(50),
    property = __webpack_require__(653);
/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */


function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (_typeof(value) == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

module.exports = baseIteratee;

/***/ }),
/* 642 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMatch = __webpack_require__(643),
    getMatchData = __webpack_require__(651),
    matchesStrictComparable = __webpack_require__(312);
/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */


function baseMatches(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

/***/ }),
/* 643 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(142),
    baseIsEqual = __webpack_require__(307);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

module.exports = baseIsMatch;

/***/ }),
/* 644 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(142),
    equalArrays = __webpack_require__(308),
    equalByTag = __webpack_require__(648),
    equalObjects = __webpack_require__(650),
    getTag = __webpack_require__(155),
    isArray = __webpack_require__(50),
    isBuffer = __webpack_require__(149),
    isTypedArray = __webpack_require__(210);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

/***/ }),
/* 645 */
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);

  return this;
}

module.exports = setCacheAdd;

/***/ }),
/* 646 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

/***/ }),
/* 647 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

module.exports = arraySome;

/***/ }),
/* 648 */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(59),
    Uint8Array = __webpack_require__(289),
    eq = __webpack_require__(114),
    equalArrays = __webpack_require__(308),
    mapToArray = __webpack_require__(649),
    setToArray = __webpack_require__(222);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

module.exports = equalByTag;

/***/ }),
/* 649 */
/***/ (function(module, exports) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

/***/ }),
/* 650 */
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys = __webpack_require__(285);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  } // Assume cyclic values are equal.


  var stacked = stack.get(object);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

/***/ }),
/* 651 */
/***/ (function(module, exports, __webpack_require__) {

var isStrictComparable = __webpack_require__(311),
    keys = __webpack_require__(147);
/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */


function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }

  return result;
}

module.exports = getMatchData;

/***/ }),
/* 652 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(307),
    get = __webpack_require__(74),
    hasIn = __webpack_require__(306),
    isKey = __webpack_require__(216),
    isStrictComparable = __webpack_require__(311),
    matchesStrictComparable = __webpack_require__(312),
    toKey = __webpack_require__(95);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

/***/ }),
/* 653 */
/***/ (function(module, exports, __webpack_require__) {

var baseProperty = __webpack_require__(654),
    basePropertyDeep = __webpack_require__(655),
    isKey = __webpack_require__(216),
    toKey = __webpack_require__(95);
/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */


function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

/***/ }),
/* 654 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

/***/ }),
/* 655 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(157);
/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */


function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

/***/ }),
/* 656 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(309),
    arrayIncludes = __webpack_require__(657),
    arrayIncludesWith = __webpack_require__(662),
    cacheHas = __webpack_require__(310),
    createSet = __webpack_require__(663),
    setToArray = __webpack_require__(222);
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */

function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);

    if (set) {
      return setToArray(set);
    }

    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }

  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;
    value = comparator || value !== 0 ? value : 0;

    if (isCommon && computed === computed) {
      var seenIndex = seen.length;

      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }

      if (iteratee) {
        seen.push(computed);
      }

      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }

      result.push(value);
    }
  }

  return result;
}

module.exports = baseUniq;

/***/ }),
/* 657 */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf = __webpack_require__(658);
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */


function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

/***/ }),
/* 658 */
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__(659),
    baseIsNaN = __webpack_require__(660),
    strictIndexOf = __webpack_require__(661);
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

/***/ }),
/* 659 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }

  return -1;
}

module.exports = baseFindIndex;

/***/ }),
/* 660 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

/***/ }),
/* 661 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }

  return -1;
}

module.exports = strictIndexOf;

/***/ }),
/* 662 */
/***/ (function(module, exports) {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }

  return false;
}

module.exports = arrayIncludesWith;

/***/ }),
/* 663 */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(288),
    noop = __webpack_require__(664),
    setToArray = __webpack_require__(222);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */

var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
  return new Set(values);
};
module.exports = createSet;

/***/ }),
/* 664 */
/***/ (function(module, exports) {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {// No operation performed.
}

module.exports = noop;

/***/ }),
/* 665 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 666 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_9_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_node_modules_sass_resources_loader_lib_loader_js_ref_9_3_node_modules_vue_loader_lib_index_js_vue_loader_options_containerMask_vue_vue_type_style_index_0_id_26a776a4_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(179);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_9_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_node_modules_sass_resources_loader_lib_loader_js_ref_9_3_node_modules_vue_loader_lib_index_js_vue_loader_options_containerMask_vue_vue_type_style_index_0_id_26a776a4_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_9_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_node_modules_sass_resources_loader_lib_loader_js_ref_9_3_node_modules_vue_loader_lib_index_js_vue_loader_options_containerMask_vue_vue_type_style_index_0_id_26a776a4_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */
 /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_9_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_node_modules_sass_resources_loader_lib_loader_js_ref_9_3_node_modules_vue_loader_lib_index_js_vue_loader_options_containerMask_vue_vue_type_style_index_0_id_26a776a4_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),
/* 667 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_9_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_node_modules_sass_resources_loader_lib_loader_js_ref_9_3_node_modules_vue_loader_lib_index_js_vue_loader_options_borderLayout_vue_vue_type_style_index_0_id_6be49762_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(180);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_9_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_node_modules_sass_resources_loader_lib_loader_js_ref_9_3_node_modules_vue_loader_lib_index_js_vue_loader_options_borderLayout_vue_vue_type_style_index_0_id_6be49762_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_9_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_node_modules_sass_resources_loader_lib_loader_js_ref_9_3_node_modules_vue_loader_lib_index_js_vue_loader_options_borderLayout_vue_vue_type_style_index_0_id_6be49762_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */
 /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_9_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_lib_loader_js_node_modules_sass_resources_loader_lib_loader_js_ref_9_3_node_modules_vue_loader_lib_index_js_vue_loader_options_borderLayout_vue_vue_type_style_index_0_id_6be49762_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),
/* 668 */,
/* 669 */,
/* 670 */,
/* 671 */,
/* 672 */,
/* 673 */,
/* 674 */,
/* 675 */,
/* 676 */,
/* 677 */,
/* 678 */,
/* 679 */,
/* 680 */,
/* 681 */,
/* 682 */,
/* 683 */,
/* 684 */,
/* 685 */,
/* 686 */,
/* 687 */,
/* 688 */,
/* 689 */,
/* 690 */,
/* 691 */,
/* 692 */,
/* 693 */,
/* 694 */,
/* 695 */,
/* 696 */,
/* 697 */,
/* 698 */,
/* 699 */,
/* 700 */,
/* 701 */,
/* 702 */,
/* 703 */,
/* 704 */,
/* 705 */,
/* 706 */,
/* 707 */,
/* 708 */,
/* 709 */,
/* 710 */,
/* 711 */,
/* 712 */,
/* 713 */,
/* 714 */,
/* 715 */,
/* 716 */,
/* 717 */,
/* 718 */,
/* 719 */,
/* 720 */,
/* 721 */,
/* 722 */,
/* 723 */,
/* 724 */,
/* 725 */,
/* 726 */,
/* 727 */,
/* 728 */,
/* 729 */,
/* 730 */,
/* 731 */,
/* 732 */,
/* 733 */,
/* 734 */,
/* 735 */,
/* 736 */,
/* 737 */,
/* 738 */,
/* 739 */,
/* 740 */,
/* 741 */,
/* 742 */,
/* 743 */,
/* 744 */,
/* 745 */,
/* 746 */,
/* 747 */,
/* 748 */,
/* 749 */,
/* 750 */,
/* 751 */,
/* 752 */,
/* 753 */,
/* 754 */,
/* 755 */,
/* 756 */,
/* 757 */,
/* 758 */,
/* 759 */,
/* 760 */,
/* 761 */,
/* 762 */,
/* 763 */,
/* 764 */,
/* 765 */,
/* 766 */,
/* 767 */,
/* 768 */,
/* 769 */,
/* 770 */,
/* 771 */,
/* 772 */,
/* 773 */,
/* 774 */,
/* 775 */,
/* 776 */,
/* 777 */,
/* 778 */,
/* 779 */,
/* 780 */,
/* 781 */,
/* 782 */,
/* 783 */,
/* 784 */,
/* 785 */,
/* 786 */,
/* 787 */,
/* 788 */,
/* 789 */,
/* 790 */,
/* 791 */,
/* 792 */,
/* 793 */,
/* 794 */,
/* 795 */,
/* 796 */,
/* 797 */,
/* 798 */,
/* 799 */,
/* 800 */,
/* 801 */,
/* 802 */,
/* 803 */,
/* 804 */,
/* 805 */,
/* 806 */,
/* 807 */,
/* 808 */,
/* 809 */,
/* 810 */,
/* 811 */,
/* 812 */,
/* 813 */,
/* 814 */,
/* 815 */,
/* 816 */,
/* 817 */,
/* 818 */,
/* 819 */,
/* 820 */,
/* 821 */,
/* 822 */,
/* 823 */,
/* 824 */,
/* 825 */,
/* 826 */,
/* 827 */,
/* 828 */,
/* 829 */,
/* 830 */,
/* 831 */,
/* 832 */,
/* 833 */,
/* 834 */,
/* 835 */,
/* 836 */,
/* 837 */,
/* 838 */,
/* 839 */,
/* 840 */,
/* 841 */,
/* 842 */,
/* 843 */,
/* 844 */,
/* 845 */,
/* 846 */,
/* 847 */,
/* 848 */,
/* 849 */,
/* 850 */,
/* 851 */,
/* 852 */,
/* 853 */,
/* 854 */,
/* 855 */,
/* 856 */,
/* 857 */,
/* 858 */,
/* 859 */,
/* 860 */,
/* 861 */,
/* 862 */,
/* 863 */,
/* 864 */,
/* 865 */,
/* 866 */,
/* 867 */,
/* 868 */,
/* 869 */,
/* 870 */,
/* 871 */,
/* 872 */,
/* 873 */,
/* 874 */,
/* 875 */,
/* 876 */,
/* 877 */,
/* 878 */,
/* 879 */,
/* 880 */,
/* 881 */,
/* 882 */,
/* 883 */,
/* 884 */,
/* 885 */,
/* 886 */,
/* 887 */,
/* 888 */,
/* 889 */,
/* 890 */,
/* 891 */,
/* 892 */,
/* 893 */,
/* 894 */,
/* 895 */,
/* 896 */,
/* 897 */,
/* 898 */,
/* 899 */,
/* 900 */,
/* 901 */,
/* 902 */,
/* 903 */,
/* 904 */,
/* 905 */,
/* 906 */,
/* 907 */,
/* 908 */,
/* 909 */,
/* 910 */,
/* 911 */,
/* 912 */,
/* 913 */,
/* 914 */,
/* 915 */,
/* 916 */,
/* 917 */,
/* 918 */,
/* 919 */,
/* 920 */,
/* 921 */,
/* 922 */,
/* 923 */,
/* 924 */,
/* 925 */,
/* 926 */,
/* 927 */,
/* 928 */,
/* 929 */,
/* 930 */,
/* 931 */,
/* 932 */,
/* 933 */,
/* 934 */,
/* 935 */,
/* 936 */,
/* 937 */,
/* 938 */,
/* 939 */,
/* 940 */,
/* 941 */,
/* 942 */,
/* 943 */,
/* 944 */,
/* 945 */,
/* 946 */,
/* 947 */,
/* 948 */,
/* 949 */,
/* 950 */,
/* 951 */,
/* 952 */,
/* 953 */,
/* 954 */,
/* 955 */,
/* 956 */,
/* 957 */,
/* 958 */,
/* 959 */,
/* 960 */,
/* 961 */,
/* 962 */,
/* 963 */,
/* 964 */,
/* 965 */,
/* 966 */,
/* 967 */,
/* 968 */,
/* 969 */,
/* 970 */,
/* 971 */,
/* 972 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/lodash/isPlainObject.js
var isPlainObject = __webpack_require__(23);

// EXTERNAL MODULE: ./src/utils/form.util.js
var form_util = __webpack_require__(177);

// EXTERNAL MODULE: ./src/utils/tool.util.js + 1 modules
var tool_util = __webpack_require__(109);

// EXTERNAL MODULE: ./src/utils/js/crossDomain.js
var crossDomain = __webpack_require__(460);

// CONCATENATED MODULE: ./src/utils/window.util.js
//add by cy

/**
 * openTabMenu打开一个tab页
 *
 * **/

var openTabMenu = function openTabMenu(item) {
  sendMessage(top, 'indexTool.openTabMenu', item);
};
/**
 * closeTabMenu关闭一个tab页
 *
 * **/


var closeTabMenu = function closeTabMenu(id) {
  sendMessage(top, 'indexTool.closeTabMenu', id);
};
/**
 * pageMask显示或者关闭一个窗口内的mask
 * show {Boolean} 默认false 是显示还是关闭mask
 * isTop {Boolean} 默认false 在本iframe中显示mask,true 在顶层框架显示mask
 * **/


var pageMask = function pageMask(_ref) {
  var show = _ref.show,
      isTop = _ref.isTop,
      text = _ref.text;

  if (isTop) {
    sendMessage(window.top, 'Base.showMask', {
      text: text,
      show: show
    });
  } else {
    Base.showMask({
      text: text,
      show: show
    });
  }
};

var windowUtil = function windowUtil() {
  return {
    openTabMenu: openTabMenu,
    closeTabMenu: closeTabMenu,
    pageMask: pageMask
  };
};

/* harmony default export */ var window_util = (windowUtil());
// EXTERNAL MODULE: ./src/utils/global.util.js
var global_util = __webpack_require__(133);

// EXTERNAL MODULE: ./src/components/style/index.less
var components_style = __webpack_require__(13);

// EXTERNAL MODULE: ./src/components/button/style/index.less
var button_style = __webpack_require__(461);

// CONCATENATED MODULE: ./src/components/button/style/index.js


// CONCATENATED MODULE: ./src/components/icon/style/index.js

// EXTERNAL MODULE: ./src/components/radio/style/index.less
var radio_style = __webpack_require__(462);

// CONCATENATED MODULE: ./src/components/radio/style/index.js


// EXTERNAL MODULE: ./src/components/checkbox/style/index.less
var checkbox_style = __webpack_require__(463);

// CONCATENATED MODULE: ./src/components/checkbox/style/index.js


// EXTERNAL MODULE: ./src/components/grid/style/index.less
var grid_style = __webpack_require__(464);

// CONCATENATED MODULE: ./src/components/grid/style/index.js


// EXTERNAL MODULE: ./src/components/tag/style/index.less
var tag_style = __webpack_require__(465);

// CONCATENATED MODULE: ./src/components/tag/style/index.js


// EXTERNAL MODULE: ./src/components/rate/style/index.less
var rate_style = __webpack_require__(466);

// CONCATENATED MODULE: ./src/components/rate/style/index.js


// EXTERNAL MODULE: ./src/components/pagination/style/index.less
var pagination_style = __webpack_require__(467);

// EXTERNAL MODULE: ./src/components/select/style/index.less
var select_style = __webpack_require__(468);

// EXTERNAL MODULE: ./src/components/input/style/index.less
var input_style = __webpack_require__(469);

// CONCATENATED MODULE: ./src/components/input/style/index.js

 // style dependencies


// CONCATENATED MODULE: ./src/components/select/style/index.js

 // style dependencies


// CONCATENATED MODULE: ./src/components/pagination/style/index.js

 // style dependencies



// EXTERNAL MODULE: ./src/components/avatar/style/index.less
var avatar_style = __webpack_require__(470);

// CONCATENATED MODULE: ./src/components/avatar/style/index.js


// EXTERNAL MODULE: ./src/components/badge/style/index.less
var badge_style = __webpack_require__(471);

// CONCATENATED MODULE: ./src/components/badge/style/index.js


// EXTERNAL MODULE: ./src/components/tabs/style/index.less
var tabs_style = __webpack_require__(472);

// CONCATENATED MODULE: ./src/components/tabs/style/index.js


// EXTERNAL MODULE: ./src/components/tooltip/style/index.less
var tooltip_style = __webpack_require__(473);

// CONCATENATED MODULE: ./src/components/tooltip/style/index.js


// EXTERNAL MODULE: ./src/components/popover/style/index.less
var popover_style = __webpack_require__(474);

// CONCATENATED MODULE: ./src/components/popover/style/index.js


// CONCATENATED MODULE: ./src/components/popconfirm/style/index.js
 // style dependencies



// EXTERNAL MODULE: ./src/components/menu/style/index.less
var menu_style = __webpack_require__(475);

// CONCATENATED MODULE: ./src/components/menu/style/index.js

 // style dependencies


// EXTERNAL MODULE: ./src/components/dropdown/style/index.less
var dropdown_style = __webpack_require__(476);

// CONCATENATED MODULE: ./src/components/dropdown/style/index.js

 // style dependencies


// EXTERNAL MODULE: ./src/components/divider/style/index.less
var divider_style = __webpack_require__(477);

// CONCATENATED MODULE: ./src/components/divider/style/index.js


// EXTERNAL MODULE: ./src/components/card/style/index.less
var card_style = __webpack_require__(478);

// CONCATENATED MODULE: ./src/components/card/style/index.js

 // style dependencies


// EXTERNAL MODULE: ./src/components/collapse/style/index.less
var collapse_style = __webpack_require__(479);

// CONCATENATED MODULE: ./src/components/collapse/style/index.js


// EXTERNAL MODULE: ./src/components/notification/style/index.less
var notification_style = __webpack_require__(480);

// CONCATENATED MODULE: ./src/components/notification/style/index.js


// EXTERNAL MODULE: ./src/components/message/style/index.less
var message_style = __webpack_require__(481);

// CONCATENATED MODULE: ./src/components/message/style/index.js


// EXTERNAL MODULE: ./src/components/spin/style/index.less
var spin_style = __webpack_require__(482);

// CONCATENATED MODULE: ./src/components/spin/style/index.js


// EXTERNAL MODULE: ./src/components/switch/style/index.less
var switch_style = __webpack_require__(483);

// CONCATENATED MODULE: ./src/components/switch/style/index.js


// EXTERNAL MODULE: ./src/components/auto-complete/style/index.less
var auto_complete_style = __webpack_require__(484);

// CONCATENATED MODULE: ./src/components/auto-complete/style/index.js



// EXTERNAL MODULE: ./src/components/affix/style/index.less
var affix_style = __webpack_require__(485);

// CONCATENATED MODULE: ./src/components/affix/style/index.js


// EXTERNAL MODULE: ./src/components/cascader/style/index.less
var cascader_style = __webpack_require__(486);

// CONCATENATED MODULE: ./src/components/cascader/style/index.js

 // style dependencies


// EXTERNAL MODULE: ./src/components/back-top/style/index.less
var back_top_style = __webpack_require__(487);

// CONCATENATED MODULE: ./src/components/back-top/style/index.js


// EXTERNAL MODULE: ./src/components/modal/style/index.less
var modal_style = __webpack_require__(488);

// CONCATENATED MODULE: ./src/components/modal/style/index.js

 // style dependencies


// EXTERNAL MODULE: ./src/components/alert/style/index.less
var alert_style = __webpack_require__(489);

// CONCATENATED MODULE: ./src/components/alert/style/index.js


// EXTERNAL MODULE: ./src/components/time-picker/style/index.less
var time_picker_style = __webpack_require__(490);

// CONCATENATED MODULE: ./src/components/time-picker/style/index.js

 // style dependencies


// EXTERNAL MODULE: ./src/components/steps/style/index.less
var steps_style = __webpack_require__(491);

// CONCATENATED MODULE: ./src/components/steps/style/index.js


// EXTERNAL MODULE: ./src/components/breadcrumb/style/index.less
var breadcrumb_style = __webpack_require__(492);

// CONCATENATED MODULE: ./src/components/breadcrumb/style/index.js


// EXTERNAL MODULE: ./src/components/calendar/style/index.less
var calendar_style = __webpack_require__(493);

// CONCATENATED MODULE: ./src/components/calendar/style/index.js

 // style dependencies



// EXTERNAL MODULE: ./src/components/date-picker/style/index.less
var date_picker_style = __webpack_require__(494);

// CONCATENATED MODULE: ./src/components/date-picker/style/index.js

 // style dependencies




// EXTERNAL MODULE: ./src/components/slider/style/index.less
var slider_style = __webpack_require__(495);

// CONCATENATED MODULE: ./src/components/slider/style/index.js

 // style dependencies


// EXTERNAL MODULE: ./src/components/table/style/index.less
var table_style = __webpack_require__(496);

// CONCATENATED MODULE: ./src/components/table/style/index.js

 // style dependencies






// EXTERNAL MODULE: ./src/components/progress/style/index.less
var progress_style = __webpack_require__(497);

// CONCATENATED MODULE: ./src/components/progress/style/index.js


// EXTERNAL MODULE: ./src/components/timeline/style/index.less
var timeline_style = __webpack_require__(498);

// CONCATENATED MODULE: ./src/components/timeline/style/index.js


// EXTERNAL MODULE: ./src/components/input-number/style/index.less
var input_number_style = __webpack_require__(499);

// CONCATENATED MODULE: ./src/components/input-number/style/index.js


// EXTERNAL MODULE: ./src/components/transfer/style/index.less
var transfer_style = __webpack_require__(500);

// CONCATENATED MODULE: ./src/components/transfer/style/index.js

 // style dependencies




// EXTERNAL MODULE: ./src/components/tree/style/index.less
var tree_style = __webpack_require__(501);

// CONCATENATED MODULE: ./src/components/tree/style/index.js

 // style dependencies


// EXTERNAL MODULE: ./src/components/upload/style/index.less
var upload_style = __webpack_require__(502);

// CONCATENATED MODULE: ./src/components/upload/style/index.js

 // style dependencies



// EXTERNAL MODULE: ./src/components/layout/style/index.less
var layout_style = __webpack_require__(503);

// CONCATENATED MODULE: ./src/components/layout/style/index.js


// EXTERNAL MODULE: ./src/components/form/style/index.less
var form_style = __webpack_require__(504);

// CONCATENATED MODULE: ./src/components/form/style/index.js

 // style dependencies


// EXTERNAL MODULE: ./src/components/anchor/style/index.less
var anchor_style = __webpack_require__(505);

// CONCATENATED MODULE: ./src/components/anchor/style/index.js


// EXTERNAL MODULE: ./src/components/list/style/index.less
var list_style = __webpack_require__(506);

// CONCATENATED MODULE: ./src/components/list/style/index.js

 // style dependencies




// EXTERNAL MODULE: ./src/components/carousel/style/index.less
var carousel_style = __webpack_require__(507);

// CONCATENATED MODULE: ./src/components/carousel/style/index.js


// EXTERNAL MODULE: ./src/components/tree-select/style/index.less
var tree_select_style = __webpack_require__(508);

// CONCATENATED MODULE: ./src/components/tree-select/style/index.js

 // style dependencies



// EXTERNAL MODULE: ./src/components/drawer/style/index.less
var drawer_style = __webpack_require__(509);

// CONCATENATED MODULE: ./src/components/drawer/style/index.js

 // style dependencies


// CONCATENATED MODULE: ./src/components/style.js



















































// EXTERNAL MODULE: ./node_modules/babel-helper-vue-jsx-merge-props/index.js
var babel_helper_vue_jsx_merge_props = __webpack_require__(5);
var babel_helper_vue_jsx_merge_props_default = /*#__PURE__*/__webpack_require__.n(babel_helper_vue_jsx_merge_props);

// EXTERNAL MODULE: ./src/components/_util/vue-types/index.js
var vue_types = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/add-dom-event-listener/lib/index.js
var lib = __webpack_require__(190);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);

// CONCATENATED MODULE: ./src/components/_util/Dom/addEventListener.js

function addEventListenerWrap(target, eventType, cb) {
  return lib_default()(target, eventType, cb);
}
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(4);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: ./node_modules/shallowequal/index.js
var shallowequal = __webpack_require__(43);
var shallowequal_default = /*#__PURE__*/__webpack_require__.n(shallowequal);

// EXTERNAL MODULE: ./node_modules/omit.js/es/index.js
var es = __webpack_require__(17);

// CONCATENATED MODULE: ./src/components/_util/getScroll.js
function getScroll(target, top) {
  if (typeof window === 'undefined') {
    return 0;
  }

  var prop = top ? 'pageYOffset' : 'pageXOffset';
  var method = top ? 'scrollTop' : 'scrollLeft';
  var isWindow = target === window;
  var ret = isWindow ? target[prop] : target[method]; // ie6,7,8 standard mode

  if (isWindow && typeof ret !== 'number') {
    ret = window.document.documentElement[method];
  }

  return ret;
}
// EXTERNAL MODULE: ./src/components/_util/BaseMixin.js
var BaseMixin = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/raf/index.js
var raf = __webpack_require__(35);
var raf_default = /*#__PURE__*/__webpack_require__.n(raf);

// CONCATENATED MODULE: ./src/components/_util/throttleByAnimationFrame.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}


function throttleByAnimationFrame(fn) {
  var requestId;

  var later = function later(args) {
    return function () {
      requestId = null;
      fn.apply(void 0, _toConsumableArray(args));
    };
  };

  var throttled = function throttled() {
    if (requestId == null) {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      requestId = raf_default()(later(args));
    }
  };

  throttled.cancel = function () {
    return raf_default.a.cancel(requestId);
  };

  return throttled;
}
function throttleByAnimationFrameDecorator() {
  return function (target, key, descriptor) {
    var fn = descriptor.value;
    var definingProperty = false;
    return {
      configurable: true,
      get: function get() {
        if (definingProperty || this === target.prototype || this.hasOwnProperty(key)) {
          return fn;
        }

        var boundFn = throttleByAnimationFrame(fn.bind(this));
        definingProperty = true;
        Object.defineProperty(this, key, {
          value: boundFn,
          configurable: true,
          writable: true
        });
        definingProperty = false;
        return boundFn;
      }
    };
  };
}
// CONCATENATED MODULE: ./src/components/affix/index.jsx


function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










function getTargetRect(target) {
  return target !== window ? target.getBoundingClientRect() : {
    top: 0,
    left: 0,
    bottom: 0
  };
}

function getOffset(element, target) {
  var elemRect = element.getBoundingClientRect();
  var targetRect = getTargetRect(target);
  var scrollTop = getScroll(target, true);
  var scrollLeft = getScroll(target, false);
  var docElem = window.document.body;
  var clientTop = docElem.clientTop || 0;
  var clientLeft = docElem.clientLeft || 0;
  return {
    top: elemRect.top - targetRect.top + scrollTop - clientTop,
    left: elemRect.left - targetRect.left + scrollLeft - clientLeft,
    width: elemRect.width,
    height: elemRect.height
  };
}

function getDefaultTarget() {
  return typeof window !== 'undefined' ? window : null;
} // Affix


var AffixProps = {
  /**
   * 距离窗口顶部达到指定偏移量后触发
   */
  offsetTop: vue_types["a" /* default */].number,
  offset: vue_types["a" /* default */].number,

  /** 距离窗口底部达到指定偏移量后触发 */
  offsetBottom: vue_types["a" /* default */].number,

  /** 固定状态改变时触发的回调函数 */
  // onChange?: (affixed?: boolean) => void;

  /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */
  target: vue_types["a" /* default */].func,
  prefixCls: vue_types["a" /* default */].string
};
var Affix = {
  name: 'TaAffix',
  props: AffixProps,
  mixins: [BaseMixin["a" /* default */]],
  data: function data() {
    this.events = ['resize', 'scroll', 'touchstart', 'touchmove', 'touchend', 'pageshow', 'load'];
    this.eventHandlers = {};
    return {
      affixStyle: undefined,
      placeholderStyle: undefined
    };
  },
  beforeMount: function beforeMount() {
    this.updatePosition = throttleByAnimationFrame(this.updatePosition);
  },
  mounted: function mounted() {
    var _this = this;

    var target = this.target || getDefaultTarget; // Wait for parent component ref has its value

    this.timeout = setTimeout(function () {
      _this.setTargetEventListeners(target);
    });
  },
  watch: {
    target: function target(val) {
      this.clearEventListeners();
      this.setTargetEventListeners(val); // Mock Event object.

      this.updatePosition({});
    },
    offsetTop: function offsetTop(val) {
      this.updatePosition({});
    },
    offsetBottom: function offsetBottom(val) {
      this.updatePosition({});
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.clearEventListeners();
    clearTimeout(this.timeout);
    this.updatePosition.cancel();
  },
  methods: {
    setAffixStyle: function setAffixStyle(e, affixStyle) {
      var _this2 = this;

      var _this$target = this.target,
          target = _this$target === void 0 ? getDefaultTarget : _this$target;
      var originalAffixStyle = this.affixStyle;
      var isWindow = target() === window;

      if (e.type === 'scroll' && originalAffixStyle && affixStyle && isWindow) {
        return;
      }

      if (shallowequal_default()(affixStyle, originalAffixStyle)) {
        return;
      }

      this.setState({
        affixStyle: affixStyle
      }, function () {
        var affixed = !!_this2.affixStyle;

        if (affixStyle && !originalAffixStyle || !affixStyle && originalAffixStyle) {
          _this2.$emit('change', affixed);
        }
      });
    },
    setPlaceholderStyle: function setPlaceholderStyle(placeholderStyle) {
      var originalPlaceholderStyle = this.placeholderStyle;

      if (shallowequal_default()(placeholderStyle, originalPlaceholderStyle)) {
        return;
      }

      this.setState({
        placeholderStyle: placeholderStyle
      });
    },
    syncPlaceholderStyle: function syncPlaceholderStyle(e) {
      var affixStyle = this.affixStyle;

      if (!affixStyle) {
        return;
      }

      this.$refs.placeholderNode.style.cssText = '';
      this.setAffixStyle(e, _objectSpread({}, affixStyle, {
        width: this.$refs.placeholderNode.offsetWidth + 'px'
      }));
      this.setPlaceholderStyle({
        width: this.$refs.placeholderNode.offsetWidth + 'px'
      });
    },
    updatePosition: function updatePosition(e) {
      var offsetTop = this.offsetTop;
      var offsetBottom = this.offsetBottom,
          offset = this.offset,
          _this$target2 = this.target,
          target = _this$target2 === void 0 ? getDefaultTarget : _this$target2;
      var targetNode = target(); // Backwards support
      // Fix: if offsetTop === 0, it will get undefined,
      //   if offsetBottom is type of number, offsetMode will be { top: false, ... }

      offsetTop = typeof offsetTop === 'undefined' ? offset : offsetTop;
      var scrollTop = getScroll(targetNode, true);
      var affixNode = this.$el;
      var elemOffset = getOffset(affixNode, targetNode);
      var elemSize = {
        width: this.$refs.fixedNode.offsetWidth,
        height: this.$refs.fixedNode.offsetHeight
      };
      var offsetMode = {
        top: false,
        bottom: false // Default to `offsetTop=0`.

      };

      if (typeof offsetTop !== 'number' && typeof offsetBottom !== 'number') {
        offsetMode.top = true;
        offsetTop = 0;
      } else {
        offsetMode.top = typeof offsetTop === 'number';
        offsetMode.bottom = typeof offsetBottom === 'number';
      }

      var targetRect = getTargetRect(targetNode);
      var targetInnerHeight = targetNode.innerHeight || targetNode.clientHeight;

      if (scrollTop > elemOffset.top - offsetTop && offsetMode.top) {
        // Fixed Top
        var width = "".concat(elemOffset.width, "px");
        var top = "".concat(targetRect.top + offsetTop, "px");
        this.setAffixStyle(e, {
          position: 'fixed',
          top: top,
          left: "".concat(targetRect.left + elemOffset.left, "px"),
          width: width
        });
        this.setPlaceholderStyle({
          width: width,
          height: "".concat(elemSize.height, "px")
        });
      } else if (scrollTop < elemOffset.top + elemSize.height + offsetBottom - targetInnerHeight && offsetMode.bottom) {
        // Fixed Bottom
        var targetBottomOffet = targetNode === window ? 0 : window.innerHeight - targetRect.bottom;

        var _width = "".concat(elemOffset.width, "px");

        this.setAffixStyle(e, {
          position: 'fixed',
          bottom: targetBottomOffet + offsetBottom + 'px',
          left: targetRect.left + elemOffset.left + 'px',
          width: _width
        });
        this.setPlaceholderStyle({
          width: _width,
          height: elemOffset.height + 'px'
        });
      } else {
        var affixStyle = this.affixStyle;

        if (e.type === 'resize' && affixStyle && affixStyle.position === 'fixed' && affixNode.offsetWidth) {
          this.setAffixStyle(e, _objectSpread({}, affixStyle, {
            width: affixNode.offsetWidth + 'px'
          }));
        } else {
          this.setAffixStyle(e, null);
        }

        this.setPlaceholderStyle(null);
      }

      if (e.type === 'resize') {
        this.syncPlaceholderStyle(e);
      }
    },
    setTargetEventListeners: function setTargetEventListeners(getTarget) {
      var _this3 = this;

      var target = getTarget();

      if (!target) {
        return;
      }

      this.clearEventListeners();
      this.events.forEach(function (eventName) {
        _this3.eventHandlers[eventName] = addEventListenerWrap(target, eventName, _this3.updatePosition);
      });
    },
    clearEventListeners: function clearEventListeners() {
      var _this4 = this;

      this.events.forEach(function (eventName) {
        var handler = _this4.eventHandlers[eventName];

        if (handler && handler.remove) {
          handler.remove();
        }
      });
    }
  },
  render: function render() {
    var h = arguments[0];
    var prefixCls = this.prefixCls,
        affixStyle = this.affixStyle,
        placeholderStyle = this.placeholderStyle,
        $slots = this.$slots,
        $props = this.$props;
    var className = classnames_default()(_defineProperty({}, prefixCls || 'ant-affix', affixStyle));
    var props = {
      attrs: Object(es["a" /* default */])($props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target'])
    };
    return h("div", babel_helper_vue_jsx_merge_props_default()([props, {
      style: placeholderStyle,
      ref: 'placeholderNode'
    }]), [h("div", {
      "class": className,
      ref: 'fixedNode',
      style: affixStyle
    }, [$slots["default"]])]);
  }
};
/* istanbul ignore next */

Affix.install = function (Vue) {
  Vue.component(Affix.name, Affix);
};

/* harmony default export */ var components_affix = (Affix);
// EXTERNAL MODULE: ./src/components/_util/props-util.js
var props_util = __webpack_require__(1);

// CONCATENATED MODULE: ./src/components/anchor/Anchor.jsx









function getDefaultContainer() {
  return window;
}

function getOffsetTop(element, container) {
  if (!element) {
    return 0;
  }

  if (!element.getClientRects().length) {
    return 0;
  }

  var rect = element.getBoundingClientRect();

  if (rect.width || rect.height) {
    if (container === window) {
      container = element.ownerDocument.documentElement;
      return rect.top - container.clientTop;
    }

    return rect.top - container.getBoundingClientRect().top;
  }

  return rect.top;
}

function easeInOutCubic(t, b, c, d) {
  var cc = c - b;
  t /= d / 2;

  if (t < 1) {
    return cc / 2 * t * t * t + b;
  }

  return cc / 2 * ((t -= 2) * t * t + 2) + b;
}

var sharpMatcherRegx = /#([^#]+)$/;

function scrollTo(href) {
  var offsetTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var getContainer = arguments.length > 2 ? arguments[2] : undefined;
  var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};
  var container = getContainer();
  var scrollTop = getScroll(container, true);
  var sharpLinkMatch = sharpMatcherRegx.exec(href);

  if (!sharpLinkMatch) {
    return;
  }

  var targetElement = document.getElementById(sharpLinkMatch[1]);

  if (!targetElement) {
    return;
  }

  var eleOffsetTop = getOffsetTop(targetElement, container);
  var targetScrollTop = scrollTop + eleOffsetTop - offsetTop;
  var startTime = Date.now();

  var frameFunc = function frameFunc() {
    var timestamp = Date.now();
    var time = timestamp - startTime;
    var nextScrollTop = easeInOutCubic(time, scrollTop, targetScrollTop, 450);

    if (container === window) {
      window.scrollTo(window.pageXOffset, nextScrollTop);
    } else {
      container.scrollTop = nextScrollTop;
    }

    if (time < 450) {
      raf_default()(frameFunc);
    } else {
      callback();
    }
  };

  raf_default()(frameFunc);
  history.pushState(null, '', href);
}

var AnchorProps = {
  prefixCls: vue_types["a" /* default */].string,
  offsetTop: vue_types["a" /* default */].number,
  bounds: vue_types["a" /* default */].number,
  affix: vue_types["a" /* default */].bool,
  showInkInFixed: vue_types["a" /* default */].bool,
  getContainer: vue_types["a" /* default */].func
};
/* harmony default export */ var Anchor = ({
  name: 'TaAnchor',
  mixins: [BaseMixin["a" /* default */]],
  inheritAttrs: false,
  props: Object(props_util["q" /* initDefaultProps */])(AnchorProps, {
    prefixCls: 'ant-anchor',
    affix: true,
    showInkInFixed: false,
    getContainer: getDefaultContainer
  }),
  data: function data() {
    this.links = [];
    return {
      activeLink: null
    };
  },
  provide: function provide() {
    var _this = this;

    return {
      antAnchor: {
        registerLink: function registerLink(link) {
          if (!_this.links.includes(link)) {
            _this.links.push(link);
          }
        },
        unregisterLink: function unregisterLink(link) {
          var index = _this.links.indexOf(link);

          if (index !== -1) {
            _this.links.splice(index, 1);
          }
        },
        $data: this.$data,
        scrollTo: this.handleScrollTo
      }
    };
  },
  mounted: function mounted() {
    var _this2 = this;

    this.$nextTick(function () {
      var getContainer = _this2.getContainer;
      _this2.scrollEvent = addEventListenerWrap(getContainer(), 'scroll', _this2.handleScroll);

      _this2.handleScroll();
    });
  },
  beforeDestroy: function beforeDestroy() {
    if (this.scrollEvent) {
      this.scrollEvent.remove();
    }
  },
  updated: function updated() {
    var _this3 = this;

    this.$nextTick(function () {
      _this3.updateInk();
    });
  },
  methods: {
    handleScroll: function handleScroll() {
      if (this.animating) {
        return;
      }

      var offsetTop = this.offsetTop,
          bounds = this.bounds;
      this.setState({
        activeLink: this.getCurrentAnchor(offsetTop, bounds)
      });
    },
    handleScrollTo: function handleScrollTo(link) {
      var _this4 = this;

      var offsetTop = this.offsetTop,
          getContainer = this.getContainer;
      this.animating = true;
      this.setState({
        activeLink: link
      });
      scrollTo(link, offsetTop, getContainer, function () {
        _this4.animating = false;
      });
    },
    getCurrentAnchor: function getCurrentAnchor() {
      var offsetTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var bounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
      var activeLink = '';

      if (typeof document === 'undefined') {
        return activeLink;
      }

      var linkSections = [];
      var getContainer = this.getContainer;
      var container = getContainer();
      this.links.forEach(function (link) {
        var sharpLinkMatch = sharpMatcherRegx.exec(link.toString());

        if (!sharpLinkMatch) {
          return;
        }

        var target = document.getElementById(sharpLinkMatch[1]);

        if (target) {
          var top = getOffsetTop(target, container);

          if (top < offsetTop + bounds) {
            linkSections.push({
              link: link,
              top: top
            });
          }
        }
      });

      if (linkSections.length) {
        var maxSection = linkSections.reduce(function (prev, curr) {
          return curr.top > prev.top ? curr : prev;
        });
        return maxSection.link;
      }

      return '';
    },
    updateInk: function updateInk() {
      if (typeof document === 'undefined') {
        return;
      }

      var prefixCls = this.prefixCls;
      var linkNode = this.$el.getElementsByClassName("".concat(prefixCls, "-link-title-active"))[0];

      if (linkNode) {
        this.$refs.linkNode.style.top = "".concat(linkNode.offsetTop + linkNode.clientHeight / 2 - 4.5, "px");
      }
    }
  },
  render: function render() {
    var h = arguments[0];
    var prefixCls = this.prefixCls,
        offsetTop = this.offsetTop,
        affix = this.affix,
        showInkInFixed = this.showInkInFixed,
        activeLink = this.activeLink,
        $slots = this.$slots,
        getContainer = this.getContainer;
    var inkClass = classnames_default()("".concat(prefixCls, "-ink-ball"), {
      visible: activeLink
    });
    var wrapperClass = classnames_default()(Object(props_util["f" /* getClass */])(this), "".concat(prefixCls, "-wrapper"));
    var anchorClass = classnames_default()(prefixCls, {
      'fixed': !affix && !showInkInFixed
    });
    var wrapperStyle = {
      maxHeight: offsetTop ? "calc(100vh - ".concat(offsetTop, "px)") : '100vh' // ...getStyle(this, true),

    };
    var anchorContent = h("div", {
      "class": wrapperClass,
      style: wrapperStyle
    }, [h("div", {
      "class": anchorClass
    }, [h("div", {
      "class": "".concat(prefixCls, "-ink")
    }, [h("span", {
      "class": inkClass,
      ref: 'linkNode'
    })]), $slots["default"]])]);
    return !affix ? anchorContent : h(components_affix, {
      attrs: {
        offsetTop: offsetTop,
        target: getContainer
      }
    }, [anchorContent]);
  }
});
// CONCATENATED MODULE: ./src/components/anchor/AnchorLink.jsx
function AnchorLink_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var AnchorLinkProps = {
  prefixCls: vue_types["a" /* default */].string,
  href: vue_types["a" /* default */].string,
  title: vue_types["a" /* default */].any
};
/* harmony default export */ var AnchorLink = ({
  name: 'TaAnchorLink',
  props: Object(props_util["q" /* initDefaultProps */])(AnchorLinkProps, {
    prefixCls: 'ant-anchor',
    href: '#'
  }),
  inject: {
    antAnchor: {
      "default": {}
    }
  },
  mounted: function mounted() {
    this.antAnchor.registerLink(this.href);
  },
  beforeDestroy: function beforeDestroy() {
    this.antAnchor.unregisterLink(this.href);
  },
  watch: {
    href: function href(val, oldVal) {
      this.antAnchor.unregisterLink(oldVal);
      this.antAnchor.registerLink(val);
    }
  },
  methods: {
    handleClick: function handleClick() {
      this.antAnchor.scrollTo(this.href);
    }
  },
  render: function render() {
    var h = arguments[0];
    var prefixCls = this.prefixCls,
        href = this.href,
        $slots = this.$slots;
    var title = Object(props_util["g" /* getComponentFromProp */])(this, 'title');
    var active = this.antAnchor.$data.activeLink === href;
    var wrapperClassName = classnames_default()("".concat(prefixCls, "-link"), AnchorLink_defineProperty({}, "".concat(prefixCls, "-link-active"), active));
    var titleClassName = classnames_default()("".concat(prefixCls, "-link-title"), AnchorLink_defineProperty({}, "".concat(prefixCls, "-link-title-active"), active));
    return h("div", {
      "class": wrapperClassName
    }, [h("a", {
      "class": titleClassName,
      attrs: {
        href: href,
        title: typeof title === 'string' ? title : ''
      },
      on: {
        "click": this.handleClick
      }
    }, [title]), $slots["default"]]);
  }
});
// CONCATENATED MODULE: ./src/components/anchor/index.jsx




Anchor.Link = AnchorLink;
/* istanbul ignore next */

Anchor.install = function (Vue) {
  Vue.component(Anchor.name, Anchor);
  Vue.component(Anchor.Link.name, Anchor.Link);
};

/* harmony default export */ var components_anchor = (Anchor);
// CONCATENATED MODULE: ./src/components/_util/KeyCode.js
/**
 * @ignore
 * some key-codes definition and utils from closure-library
 * @author yiminghe@gmail.com
 */
var KeyCode = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,

  /**
   * BACKSPACE
   */
  BACKSPACE: 8,

  /**
   * TAB
   */
  TAB: 9,

  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  // NUMLOCK on FF/Safari Mac

  /**
   * ENTER
   */
  ENTER: 13,

  /**
   * SHIFT
   */
  SHIFT: 16,

  /**
   * CTRL
   */
  CTRL: 17,

  /**
   * ALT
   */
  ALT: 18,

  /**
   * PAUSE
   */
  PAUSE: 19,

  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,

  /**
   * ESC
   */
  ESC: 27,

  /**
   * SPACE
   */
  SPACE: 32,

  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  // also NUM_NORTH_EAST

  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  // also NUM_SOUTH_EAST

  /**
   * END
   */
  END: 35,
  // also NUM_SOUTH_WEST

  /**
   * HOME
   */
  HOME: 36,
  // also NUM_NORTH_WEST

  /**
   * LEFT
   */
  LEFT: 37,
  // also NUM_WEST

  /**
   * UP
   */
  UP: 38,
  // also NUM_NORTH

  /**
   * RIGHT
   */
  RIGHT: 39,
  // also NUM_EAST

  /**
   * DOWN
   */
  DOWN: 40,
  // also NUM_SOUTH

  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,

  /**
   * INSERT
   */
  INSERT: 45,
  // also NUM_INSERT

  /**
   * DELETE
   */
  DELETE: 46,
  // also NUM_DELETE

  /**
   * ZERO
   */
  ZERO: 48,

  /**
   * ONE
   */
  ONE: 49,

  /**
   * TWO
   */
  TWO: 50,

  /**
   * THREE
   */
  THREE: 51,

  /**
   * FOUR
   */
  FOUR: 52,

  /**
   * FIVE
   */
  FIVE: 53,

  /**
   * SIX
   */
  SIX: 54,

  /**
   * SEVEN
   */
  SEVEN: 55,

  /**
   * EIGHT
   */
  EIGHT: 56,

  /**
   * NINE
   */
  NINE: 57,

  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  // needs localization

  /**
   * A
   */
  A: 65,

  /**
   * B
   */
  B: 66,

  /**
   * C
   */
  C: 67,

  /**
   * D
   */
  D: 68,

  /**
   * E
   */
  E: 69,

  /**
   * F
   */
  F: 70,

  /**
   * G
   */
  G: 71,

  /**
   * H
   */
  H: 72,

  /**
   * I
   */
  I: 73,

  /**
   * J
   */
  J: 74,

  /**
   * K
   */
  K: 75,

  /**
   * L
   */
  L: 76,

  /**
   * M
   */
  M: 77,

  /**
   * N
   */
  N: 78,

  /**
   * O
   */
  O: 79,

  /**
   * P
   */
  P: 80,

  /**
   * Q
   */
  Q: 81,

  /**
   * R
   */
  R: 82,

  /**
   * S
   */
  S: 83,

  /**
   * T
   */
  T: 84,

  /**
   * U
   */
  U: 85,

  /**
   * V
   */
  V: 86,

  /**
   * W
   */
  W: 87,

  /**
   * X
   */
  X: 88,

  /**
   * Y
   */
  Y: 89,

  /**
   * Z
   */
  Z: 90,

  /**
   * META
   */
  META: 91,
  // WIN_KEY_LEFT

  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,

  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,

  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,

  /**
   * NUM_ONE
   */
  NUM_ONE: 97,

  /**
   * NUM_TWO
   */
  NUM_TWO: 98,

  /**
   * NUM_THREE
   */
  NUM_THREE: 99,

  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,

  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,

  /**
   * NUM_SIX
   */
  NUM_SIX: 102,

  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,

  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,

  /**
   * NUM_NINE
   */
  NUM_NINE: 105,

  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,

  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,

  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,

  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,

  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,

  /**
   * F1
   */
  F1: 112,

  /**
   * F2
   */
  F2: 113,

  /**
   * F3
   */
  F3: 114,

  /**
   * F4
   */
  F4: 115,

  /**
   * F5
   */
  F5: 116,

  /**
   * F6
   */
  F6: 117,

  /**
   * F7
   */
  F7: 118,

  /**
   * F8
   */
  F8: 119,

  /**
   * F9
   */
  F9: 120,

  /**
   * F10
   */
  F10: 121,

  /**
   * F11
   */
  F11: 122,

  /**
   * F12
   */
  F12: 123,

  /**
   * NUMLOCK
   */
  NUMLOCK: 144,

  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  // needs localization

  /**
   * DASH
   */
  DASH: 189,
  // needs localization

  /**
   * EQUALS
   */
  EQUALS: 187,
  // needs localization

  /**
   * COMMA
   */
  COMMA: 188,
  // needs localization

  /**
   * PERIOD
   */
  PERIOD: 190,
  // needs localization

  /**
   * SLASH
   */
  SLASH: 191,
  // needs localization

  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  // needs localization

  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  // needs localization

  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  // needs localization

  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  // needs localization

  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  // needs localization

  /**
   * WIN_KEY
   */
  WIN_KEY: 224,

  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  // Firefox (Gecko) fires this for the meta key instead of 91

  /**
   * WIN_IME
   */
  WIN_IME: 229
  /*
   whether text and modified key is entered at the same time.
   */

};

KeyCode.isTextModifyingKeyEvent = function isTextModifyingKeyEvent(e) {
  var keyCode = e.keyCode;

  if (e.altKey && !e.ctrlKey || e.metaKey || // Function keys don't generate text
  keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
    return false;
  } // The following keys are quite harmless, even in combination with
  // CTRL, ALT or SHIFT.


  switch (keyCode) {
    case KeyCode.ALT:
    case KeyCode.CAPS_LOCK:
    case KeyCode.CONTEXT_MENU:
    case KeyCode.CTRL:
    case KeyCode.DOWN:
    case KeyCode.END:
    case KeyCode.ESC:
    case KeyCode.HOME:
    case KeyCode.INSERT:
    case KeyCode.LEFT:
    case KeyCode.MAC_FF_META:
    case KeyCode.META:
    case KeyCode.NUMLOCK:
    case KeyCode.NUM_CENTER:
    case KeyCode.PAGE_DOWN:
    case KeyCode.PAGE_UP:
    case KeyCode.PAUSE:
    case KeyCode.PRINT_SCREEN:
    case KeyCode.RIGHT:
    case KeyCode.SHIFT:
    case KeyCode.UP:
    case KeyCode.WIN_KEY:
    case KeyCode.WIN_KEY_RIGHT:
      return false;

    default:
      return true;
  }
};
/*
 whether character is entered.
 */


KeyCode.isCharacterKey = function isCharacterKey(keyCode) {
  if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
    return true;
  }

  if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
    return true;
  }

  if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
    return true;
  } // Safari sends zero key code for non-latin characters.


  if (window.navigation.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) {
    return true;
  }

  switch (keyCode) {
    case KeyCode.SPACE:
    case KeyCode.QUESTION_MARK:
    case KeyCode.NUM_PLUS:
    case KeyCode.NUM_MINUS:
    case KeyCode.NUM_PERIOD:
    case KeyCode.NUM_DIVISION:
    case KeyCode.SEMICOLON:
    case KeyCode.DASH:
    case KeyCode.EQUALS:
    case KeyCode.COMMA:
    case KeyCode.PERIOD:
    case KeyCode.SLASH:
    case KeyCode.APOSTROPHE:
    case KeyCode.SINGLE_QUOTE:
    case KeyCode.OPEN_SQUARE_BRACKET:
    case KeyCode.BACKSLASH:
    case KeyCode.CLOSE_SQUARE_BRACKET:
      return true;

    default:
      return false;
  }
};

/* harmony default export */ var _util_KeyCode = (KeyCode);
// EXTERNAL MODULE: ./node_modules/component-classes/index.js
var component_classes = __webpack_require__(73);
var component_classes_default = /*#__PURE__*/__webpack_require__.n(component_classes);

// CONCATENATED MODULE: ./src/components/_util/store/PropTypes.js

var storeShape = vue_types["a" /* default */].shape({
  subscribe: vue_types["a" /* default */].func.isRequired,
  setState: vue_types["a" /* default */].func.isRequired,
  getState: vue_types["a" /* default */].func.isRequired
});
// CONCATENATED MODULE: ./src/components/_util/store/Provider.jsx

/* harmony default export */ var Provider = ({
  name: 'StoreProvider',
  props: {
    store: storeShape.isRequired
  },
  provide: function provide() {
    return {
      storeContext: this.$props
    };
  },
  render: function render() {
    return this.$slots["default"][0];
  }
});
// EXTERNAL MODULE: ./src/components/_util/proxyComponent.jsx
var proxyComponent = __webpack_require__(106);

// CONCATENATED MODULE: ./src/components/_util/store/connect.jsx


function connect_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { connect_defineProperty(target, key, source[key]); }); } return target; }

function connect_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







function getDisplayName(WrappedComponent) {
  return WrappedComponent.name || 'Component';
}

var defaultMapStateToProps = function defaultMapStateToProps() {
  return {};
};

function connect(mapStateToProps) {
  var shouldSubscribe = !!mapStateToProps;
  var finnalMapStateToProps = mapStateToProps || defaultMapStateToProps;
  return function wrapWithConnect(WrappedComponent) {
    var tempProps = Object(es["a" /* default */])(WrappedComponent.props || {}, ['store']);
    var props = {
      __propsSymbol__: vue_types["a" /* default */].any
    };
    Object.keys(tempProps).forEach(function (k) {
      props[k] = connect_objectSpread({}, k, {
        required: false
      });
    });
    var Connect = {
      name: "Connect_".concat(getDisplayName(WrappedComponent)),
      props: props,
      inject: {
        storeContext: {
          "default": {}
        }
      },
      data: function data() {
        this.store = this.storeContext.store;
        return {
          subscribed: finnalMapStateToProps(this.store.getState(), this.$props)
        };
      },
      watch: {
        __propsSymbol__: function __propsSymbol__() {
          if (mapStateToProps && mapStateToProps.length === 2) {
            this.subscribed = finnalMapStateToProps(this.store.getState(), this.$props);
          }
        }
      },
      mounted: function mounted() {
        this.trySubscribe();
      },
      beforeDestroy: function beforeDestroy() {
        this.tryUnsubscribe();
      },
      methods: {
        handleChange: function handleChange() {
          if (!this.unsubscribe) {
            return;
          }

          var nextState = finnalMapStateToProps(this.store.getState(), this.$props);

          if (!shallowequal_default()(this.subscribed, nextState)) {
            this.subscribed = nextState;
          }
        },
        trySubscribe: function trySubscribe() {
          if (shouldSubscribe) {
            this.unsubscribe = this.store.subscribe(this.handleChange);
            this.handleChange();
          }
        },
        tryUnsubscribe: function tryUnsubscribe() {
          if (this.unsubscribe) {
            this.unsubscribe();
            this.unsubscribe = null;
          }
        },
        getWrappedInstance: function getWrappedInstance() {
          return this.$refs.wrappedInstance;
        }
      },
      render: function render() {
        var h = arguments[0];
        var $listeners = this.$listeners,
            _this$$slots = this.$slots,
            $slots = _this$$slots === void 0 ? {} : _this$$slots,
            $attrs = this.$attrs,
            $scopedSlots = this.$scopedSlots,
            subscribed = this.subscribed,
            store = this.store;
        var props = Object(props_util["j" /* getOptionProps */])(this);
        var wrapProps = {
          props: connect_objectSpread({}, props, subscribed, {
            store: store
          }),
          on: $listeners,
          attrs: $attrs,
          scopedSlots: $scopedSlots
        };
        return h(WrappedComponent, babel_helper_vue_jsx_merge_props_default()([wrapProps, {
          ref: 'wrappedInstance'
        }]), [Object.keys($slots).map(function (name) {
          return h("template", {
            slot: name
          }, [$slots[name]]);
        })]);
      }
    };
    return Object(proxyComponent["a" /* default */])(Connect);
  };
}
// CONCATENATED MODULE: ./src/components/_util/store/create.js
function create_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      create_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function create_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function create_create(initialState) {
  var state = initialState;
  var listeners = [];

  function setState(partial) {
    state = create_objectSpread({}, state, partial);

    for (var i = 0; i < listeners.length; i++) {
      listeners[i]();
    }
  }

  function getState() {
    return state;
  }

  function subscribe(listener) {
    listeners.push(listener);
    return function unsubscribe() {
      var index = listeners.indexOf(listener);
      listeners.splice(index, 1);
    };
  }

  return {
    setState: setState,
    getState: getState,
    subscribe: subscribe
  };
}
// CONCATENATED MODULE: ./src/components/_util/store/index.js



// CONCATENATED MODULE: ./src/components/vc-menu/util.js
function noop() {}
function getKeyFromChildrenIndex(child, menuEventKey, index) {
  var prefix = menuEventKey || '';
  return child.key === undefined ? "".concat(prefix, "item_").concat(index) : child.key;
}
function getMenuIdFromSubMenuEventKey(eventKey) {
  return "".concat(eventKey, "-menu-");
}
function loopMenuItem(children, cb) {
  var index = -1;
  children.forEach(function (c) {
    index++;

    if (c && c.type && c.type.isMenuItemGroup) {
      c.$slots["default"].forEach(function (c2) {
        index++;
        c.componentOptions && cb(c2, index);
      });
    } else {
      c.componentOptions && cb(c, index);
    }
  });
}
function loopMenuItemRecursively(children, keys, ret) {
  if (!children || ret.find) {
    return;
  }

  children.forEach(function (c) {
    if (ret.find) {
      return;
    }

    if (c.data && c.data.slot && c.data.slot !== 'default') {
      return;
    }

    if (c && c.componentOptions) {
      var options = c.componentOptions.Ctor.options;

      if (!options || !(options.isSubMenu || options.isMenuItem || options.isMenuItemGroup)) {
        return;
      }

      if (keys.indexOf(c.key) !== -1) {
        ret.find = true;
      } else if (c.componentOptions.children) {
        loopMenuItemRecursively(c.componentOptions.children, keys, ret);
      }
    }
  });
}
var menuAllProps = {
  props: ['defaultSelectedKeys', 'selectedKeys', 'defaultOpenKeys', 'openKeys', 'mode', 'getPopupContainer', 'openTransitionName', 'openAnimation', 'subMenuOpenDelay', 'subMenuCloseDelay', 'forceSubMenuRender', 'triggerSubMenuAction', 'level', 'selectable', 'multiple', 'visible', 'focusable', 'defaultActiveFirst', 'prefixCls', 'inlineIndent', 'parentMenu', 'title', 'rootPrefixCls', 'eventKey', 'active', 'popupOffset', 'isOpen', 'renderMenuItem', 'manualRef', 'subMenuKey', 'disabled', 'index', 'isSelected', 'store', 'activeKey', // the following keys found need to be removed from test regression
  'attribute', 'value', 'popupClassName', 'inlineCollapsed', 'menu', 'theme'],
  on: ['select', 'deselect', 'destroy', 'openChange', 'itemHover', 'titleMouseenter', 'titleMouseleave', 'titleClick']
};
// CONCATENATED MODULE: ./src/components/vc-menu/DOMWrap.jsx


function DOMWrap_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { DOMWrap_defineProperty(target, key, source[key]); }); } return target; }

function DOMWrap_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/* harmony default export */ var DOMWrap = ({
  name: 'DOMWrap',
  props: {
    visible: {
      type: Boolean,
      "default": false
    },
    tag: {
      type: String,
      "default": 'div'
    },
    hiddenClassName: {
      type: String,
      "default": ''
    }
  },
  computed: {
    "class": function _class() {
      var _this$$props = this.$props,
          visible = _this$$props.visible,
          hiddenClassName = _this$$props.hiddenClassName;
      return {// [hiddenClassName]: !visible,
      };
    }
  },
  render: function render() {
    var h = arguments[0];
    var otherProps = Object(es["a" /* default */])(this.$props, ['tag', 'hiddenClassName', 'visible']);
    var Tag = this.$props.tag;
    var tagProps = {
      attr: DOMWrap_objectSpread({}, otherProps, this.$attrs),
      on: this.$listeners
    };
    return h(Tag, babel_helper_vue_jsx_merge_props_default()([tagProps, {
      "class": this["class"]
    }]), [this.$slots["default"]]);
  }
});
// EXTERNAL MODULE: ./src/components/_util/vnode.js
var vnode = __webpack_require__(8);

// CONCATENATED MODULE: ./src/components/vc-menu/SubPopupMenu.jsx
function SubPopupMenu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { SubPopupMenu_defineProperty(target, key, source[key]); }); } return target; }

function SubPopupMenu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












function allDisabled(arr) {
  if (!arr.length) {
    return true;
  }

  return arr.every(function (c) {
    return !!c.disabled;
  });
}

function updateActiveKey(store, menuId, activeKey) {
  var state = store.getState();
  store.setState({
    activeKey: SubPopupMenu_objectSpread({}, state.activeKey, SubPopupMenu_defineProperty({}, menuId, activeKey))
  });
}

function SubPopupMenu_saveRef(key, c) {
  if (c) {
    var index = this.instanceArrayKeyIndexMap[key];
    this.instanceArray[index] = c; // const index = this.instanceArray.indexOf(c)
    // if (index !== -1) {
    //   // update component if it's already inside instanceArray
    //   this.instanceArray[index] = c
    // } else {
    //   // add component if it's not in instanceArray yet;
    //   this.instanceArray.push(c)
    // }
  }
}
function getActiveKey(props, originalActiveKey) {
  var activeKey = originalActiveKey;
  var eventKey = props.eventKey,
      defaultActiveFirst = props.defaultActiveFirst,
      children = props.children;

  if (activeKey !== undefined && activeKey !== null) {
    var found;
    loopMenuItem(children, function (c, i) {
      var propsData = c.componentOptions.propsData || {};

      if (c && !propsData.disabled && activeKey === getKeyFromChildrenIndex(c, eventKey, i)) {
        found = true;
      }
    });

    if (found) {
      return activeKey;
    }
  }

  activeKey = null;

  if (defaultActiveFirst) {
    loopMenuItem(children, function (c, i) {
      var propsData = c.componentOptions.propsData || {};

      if (!activeKey && c && !propsData.disabled) {
        activeKey = getKeyFromChildrenIndex(c, eventKey, i);
      }
    });
    return activeKey;
  }

  return activeKey;
}
var SubPopupMenu = {
  name: 'SubPopupMenu',
  props: Object(props_util["q" /* initDefaultProps */])({
    // onSelect: PropTypes.func,
    // onClick: PropTypes.func,
    // onDeselect: PropTypes.func,
    // onOpenChange: PropTypes.func,
    // onDestroy: PropTypes.func,
    prefixCls: vue_types["a" /* default */].string,
    openTransitionName: vue_types["a" /* default */].string,
    openAnimation: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].object]),
    openKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number])),
    visible: vue_types["a" /* default */].bool,
    parentMenu: vue_types["a" /* default */].object,
    eventKey: vue_types["a" /* default */].string,
    store: vue_types["a" /* default */].object,
    // adding in refactor
    focusable: vue_types["a" /* default */].bool,
    multiple: vue_types["a" /* default */].bool,
    defaultActiveFirst: vue_types["a" /* default */].bool,
    activeKey: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
    selectedKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number])),
    defaultSelectedKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number])),
    defaultOpenKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number])),
    level: vue_types["a" /* default */].number,
    mode: vue_types["a" /* default */].oneOf(['horizontal', 'vertical', 'vertical-left', 'vertical-right', 'inline']),
    triggerSubMenuAction: vue_types["a" /* default */].oneOf(['click', 'hover']),
    inlineIndent: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string]),
    manualRef: vue_types["a" /* default */].func,
    children: vue_types["a" /* default */].any.def([]),
    __propsSymbol__: vue_types["a" /* default */].any // mock componentWillReceiveProps

  }, {
    prefixCls: 'rc-menu',
    mode: 'vertical',
    level: 1,
    inlineIndent: 24,
    visible: true,
    focusable: true,
    manualRef: noop
  }),
  mixins: [BaseMixin["a" /* default */]],
  created: function created() {
    var props = this.$props;
    props.store.setState({
      activeKey: SubPopupMenu_objectSpread({}, props.store.getState().activeKey, SubPopupMenu_defineProperty({}, props.eventKey, getActiveKey(props, props.activeKey)))
    });
    this.instanceArray = [];
  },
  mounted: function mounted() {
    // invoke customized ref to expose component to mixin
    if (this.manualRef) {
      this.manualRef(this);
    }
  },
  watch: {
    __propsSymbol__: function __propsSymbol__() {
      var props = Object(props_util["j" /* getOptionProps */])(this);
      var storeActiveKey = this.getStore().getState().activeKey[this.getEventKey()];
      var originalActiveKey = 'activeKey' in props ? props.activeKey : storeActiveKey;
      var activeKey = getActiveKey(props, originalActiveKey);

      if (activeKey !== originalActiveKey || storeActiveKey !== activeKey) {
        updateActiveKey(this.getStore(), this.getEventKey(), activeKey);
      }
    }
  },
  methods: {
    // all keyboard events callbacks run from here at first
    onKeyDown: function onKeyDown(e, callback) {
      var keyCode = e.keyCode;
      var handled;
      this.getFlatInstanceArray().forEach(function (obj) {
        if (obj && obj.active && obj.onKeyDown) {
          handled = obj.onKeyDown(e);
        }
      });

      if (handled) {
        return 1;
      }

      var activeItem = null;

      if (keyCode === _util_KeyCode.UP || keyCode === _util_KeyCode.DOWN) {
        activeItem = this.step(keyCode === _util_KeyCode.UP ? -1 : 1);
      }

      if (activeItem) {
        e.preventDefault();
        updateActiveKey(this.getStore(), this.getEventKey(), activeItem.eventKey);

        if (typeof callback === 'function') {
          callback(activeItem);
        }

        return 1;
      }
    },
    onItemHover: function onItemHover(e) {
      var key = e.key,
          hover = e.hover;
      updateActiveKey(this.getStore(), this.getEventKey(), hover ? key : null);
    },
    onDeselect: function onDeselect(selectInfo) {
      this.__emit('deselect', selectInfo);
    },
    onSelect: function onSelect(selectInfo) {
      this.__emit('select', selectInfo);
    },
    onClick: function onClick(e) {
      this.__emit('click', e);
    },
    onOpenChange: function onOpenChange(e) {
      this.__emit('openChange', e);
    },
    onDestroy: function onDestroy(key) {
      this.__emit('destroy', key);
    },
    getFlatInstanceArray: function getFlatInstanceArray() {
      return this.instanceArray;
    },
    getStore: function getStore() {
      return this.store;
    },
    getEventKey: function getEventKey() {
      // when eventKey not available ,it's menu and return menu id '0-menu-'
      return this.eventKey !== undefined ? this.eventKey : '0-menu-';
    },
    getOpenTransitionName: function getOpenTransitionName() {
      return this.$props.openTransitionName;
    },
    step: function step(direction) {
      var children = this.getFlatInstanceArray();
      var activeKey = this.getStore().getState().activeKey[this.getEventKey()];
      var len = children.length;

      if (!len) {
        return null;
      }

      if (direction < 0) {
        children = children.concat().reverse();
      } // find current activeIndex


      var activeIndex = -1;
      children.every(function (c, ci) {
        if (c && c.eventKey === activeKey) {
          activeIndex = ci;
          return false;
        }

        return true;
      });

      if (!this.defaultActiveFirst && activeIndex !== -1 && allDisabled(children.slice(activeIndex, len - 1))) {
        return undefined;
      }

      var start = (activeIndex + 1) % len;
      var i = start;

      do {
        var child = children[i];

        if (!child || child.disabled) {
          i = (i + 1) % len;
        } else {
          return child;
        }
      } while (i !== start);

      return null;
    },
    renderCommonMenuItem: function renderCommonMenuItem(child, i, extraProps) {
      var _this = this;

      if (child.tag === undefined) {
        return child;
      }

      var state = this.getStore().getState();
      var props = this.$props;
      var key = getKeyFromChildrenIndex(child, props.eventKey, i);
      var childProps = child.componentOptions.propsData || {};
      var isActive = key === state.activeKey[this.getEventKey()];

      if (!childProps.disabled) {
        // manualRef的执行顺序不能保证，使用key映射ref在this.instanceArray中的位置
        this.instanceArrayKeyIndexMap[key] = Object.keys(this.instanceArrayKeyIndexMap).length;
      }

      var childListeners = Object(props_util["h" /* getEvents */])(child);
      var newChildProps = {
        props: SubPopupMenu_objectSpread({
          mode: props.mode,
          level: props.level,
          inlineIndent: props.inlineIndent,
          renderMenuItem: this.renderMenuItem,
          rootPrefixCls: props.prefixCls,
          index: i,
          parentMenu: props.parentMenu,
          // customized ref function, need to be invoked manually in child's componentDidMount
          manualRef: childProps.disabled ? noop : SubPopupMenu_saveRef.bind(this, key),
          eventKey: key,
          active: !childProps.disabled && isActive,
          multiple: props.multiple,
          openTransitionName: this.getOpenTransitionName(),
          openAnimation: props.openAnimation,
          subMenuOpenDelay: props.subMenuOpenDelay,
          subMenuCloseDelay: props.subMenuCloseDelay,
          forceSubMenuRender: props.forceSubMenuRender
        }, extraProps),
        on: {
          click: function click(e) {
            (childListeners.click || noop)(e);

            _this.onClick(e);
          },
          itemHover: this.onItemHover,
          openChange: this.onOpenChange,
          deselect: this.onDeselect,
          // destroy: this.onDestroy,
          select: this.onSelect
        }
      };

      if (props.mode === 'inline') {
        newChildProps.props.triggerSubMenuAction = 'click';
      }

      return Object(vnode["a" /* cloneElement */])(child, newChildProps);
    },
    renderMenuItem: function renderMenuItem(c, i, subMenuKey) {
      if (!c) {
        return null;
      }

      var state = this.getStore().getState();
      var extraProps = {
        openKeys: state.openKeys,
        selectedKeys: state.selectedKeys,
        triggerSubMenuAction: this.triggerSubMenuAction,
        isRootMenu: false,
        subMenuKey: subMenuKey
      };
      return this.renderCommonMenuItem(c, i, extraProps);
    }
  },
  render: function render() {
    var _this2 = this;

    var h = arguments[0];
    var props = Object.assign({}, this.$props);
    var eventKey = props.eventKey,
        visible = props.visible;
    this.instanceArray = [];
    this.instanceArrayKeyIndexMap = {};
    var className = classnames_default()(props.prefixCls, "".concat(props.prefixCls, "-").concat(props.mode));
    var domWrapProps = {
      props: {
        tag: 'ul',
        // hiddenClassName: `${prefixCls}-hidden`,
        visible: visible
      },
      attrs: {
        role: props.role || 'menu'
      },
      "class": className,
      // Otherwise, the propagated click event will trigger another onClick
      on: Object(es["a" /* default */])(this.$listeners || {}, ['click']) // if (props.id) {
      //   domProps.id = props.id
      // }

    };

    if (props.focusable) {
      domWrapProps.attrs.tabIndex = '0';
      domWrapProps.on.keydown = this.onKeyDown;
    }

    return (// ESLint is not smart enough to know that the type of `children` was checked.

      /* eslint-disable */
      h(DOMWrap, domWrapProps, [props.children.map(function (c, i) {
        return _this2.renderMenuItem(c, i, eventKey || '0-menu-');
      })])
      /*eslint -enable */

    );
  }
};
/* harmony default export */ var vc_menu_SubPopupMenu = (connect()(SubPopupMenu));
// CONCATENATED MODULE: ./src/components/vc-menu/commonPropsType.js

/* harmony default export */ var commonPropsType = ({
  prefixCls: vue_types["a" /* default */].string.def('rc-menu'),
  focusable: vue_types["a" /* default */].bool.def(true),
  multiple: vue_types["a" /* default */].bool,
  defaultActiveFirst: vue_types["a" /* default */].bool,
  visible: vue_types["a" /* default */].bool.def(true),
  activeKey: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
  selectedKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number])),
  defaultSelectedKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number])).def([]),
  defaultOpenKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number])).def([]),
  openKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number])),
  openAnimation: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].object]),
  mode: vue_types["a" /* default */].oneOf(['horizontal', 'vertical', 'vertical-left', 'vertical-right', 'inline']).def('vertical'),
  triggerSubMenuAction: vue_types["a" /* default */].string.def('hover'),
  subMenuOpenDelay: vue_types["a" /* default */].number.def(0.1),
  subMenuCloseDelay: vue_types["a" /* default */].number.def(0.1),
  level: vue_types["a" /* default */].number.def(1),
  inlineIndent: vue_types["a" /* default */].number.def(24),
  theme: vue_types["a" /* default */].oneOf(['light', 'dark']).def('light'),
  getPopupContainer: vue_types["a" /* default */].func,
  openTransitionName: vue_types["a" /* default */].string,
  forceSubMenuRender: vue_types["a" /* default */].bool,
  selectable: vue_types["a" /* default */].bool,
  isRootMenu: vue_types["a" /* default */].bool.def(true)
});
// CONCATENATED MODULE: ./src/components/vc-menu/Menu.jsx
function Menu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Menu_defineProperty(target, key, source[key]); }); } return target; }

function Menu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var Menu = {
  name: 'Menu',
  props: Menu_objectSpread({}, commonPropsType, {
    selectable: vue_types["a" /* default */].bool.def(true)
  }),
  mixins: [BaseMixin["a" /* default */]],
  data: function data() {
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var selectedKeys = props.defaultSelectedKeys;
    var openKeys = props.defaultOpenKeys;

    if ('selectedKeys' in props) {
      selectedKeys = props.selectedKeys || [];
    }

    if ('openKeys' in props) {
      openKeys = props.openKeys || [];
    }

    this.store = create_create({
      selectedKeys: selectedKeys,
      openKeys: openKeys,
      activeKey: {
        '0-menu-': getActiveKey(Menu_objectSpread({}, props, {
          children: this.$slots["default"] || []
        }), props.activeKey)
      }
    }); // this.isRootMenu = true // 声明在props上

    return {};
  },
  watch: {
    selectedKeys: function selectedKeys(val) {
      this.store.setState({
        selectedKeys: val || []
      });
    },
    openKeys: function openKeys(val) {
      this.store.setState({
        openKeys: val || []
      });
    } // '$props': {
    //   handler: function (nextProps) {
    //     if (hasProp(this, 'selectedKeys')) {
    //       this.setState({
    //         sSelectedKeys: nextProps.selectedKeys || [],
    //       })
    //     }
    //     if (hasProp(this, 'openKeys')) {
    //       this.setState({
    //         sOpenKeys: nextProps.openKeys || [],
    //       })
    //     }
    //   },
    //   deep: true,
    // },

  },
  methods: {
    // onDestroy (key) {
    //   const state = this.$data
    //   const sSelectedKeys = state.sSelectedKeys
    //   const sOpenKeys = state.sOpenKeys
    //   let index = sSelectedKeys.indexOf(key)
    //   if (!hasProp(this, 'selectedKeys') && index !== -1) {
    //     sSelectedKeys.splice(index, 1)
    //   }
    //   index = sOpenKeys.indexOf(key)
    //   if (!hasProp(this, 'openKeys') && index !== -1) {
    //     sOpenKeys.splice(index, 1)
    //   }
    // },
    onSelect: function onSelect(selectInfo) {
      var props = this.$props;

      if (props.selectable) {
        // root menu
        var selectedKeys = this.store.getState().selectedKeys;
        var selectedKey = selectInfo.key;

        if (props.multiple) {
          selectedKeys = selectedKeys.concat([selectedKey]);
        } else {
          selectedKeys = [selectedKey];
        }

        if (!Object(props_util["b" /* default */])(this, 'selectedKeys')) {
          this.store.setState({
            selectedKeys: selectedKeys
          });
        }

        this.__emit('select', Menu_objectSpread({}, selectInfo, {
          selectedKeys: selectedKeys
        }));
      }
    },
    onClick: function onClick(e) {
      this.__emit('click', e);
    },
    // onKeyDown needs to be exposed as a instance method
    // e.g., in rc-select, we need to navigate menu item while
    // current active item is rc-select input box rather than the menu itself
    onKeyDown: function onKeyDown(e, callback) {
      this.$refs.innerMenu.getWrappedInstance().onKeyDown(e, callback);
    },
    onOpenChange: function onOpenChange(event) {
      var openKeys = this.store.getState().openKeys.concat();
      var changed = false;

      var processSingle = function processSingle(e) {
        var oneChanged = false;

        if (e.open) {
          oneChanged = openKeys.indexOf(e.key) === -1;

          if (oneChanged) {
            openKeys.push(e.key);
          }
        } else {
          var index = openKeys.indexOf(e.key);
          oneChanged = index !== -1;

          if (oneChanged) {
            openKeys.splice(index, 1);
          }
        }

        changed = changed || oneChanged;
      };

      if (Array.isArray(event)) {
        // batch change call
        event.forEach(processSingle);
      } else {
        processSingle(event);
      }

      if (changed) {
        if (!Object(props_util["b" /* default */])(this, 'openKeys')) {
          this.store.setState({
            openKeys: openKeys
          });
        }

        this.__emit('openChange', openKeys);
      }
    },
    onDeselect: function onDeselect(selectInfo) {
      var props = this.$props;

      if (props.selectable) {
        var selectedKeys = this.store.getState().selectedKeys.concat();
        var selectedKey = selectInfo.key;
        var index = selectedKeys.indexOf(selectedKey);

        if (index !== -1) {
          selectedKeys.splice(index, 1);
        }

        if (!Object(props_util["b" /* default */])(this, 'selectedKeys')) {
          this.store.setState({
            selectedKeys: selectedKeys
          });
        }

        this.__emit('deselect', Menu_objectSpread({}, selectInfo, {
          selectedKeys: selectedKeys
        }));
      }
    },
    getOpenTransitionName: function getOpenTransitionName() {
      var props = this.$props;
      var transitionName = props.openTransitionName;
      var animationName = props.openAnimation;

      if (!transitionName && typeof animationName === 'string') {
        transitionName = "".concat(props.prefixCls, "-open-").concat(animationName);
      }

      return transitionName;
    } //   isInlineMode () {
    //     return this.$props.mode === 'inline'
    //   },
    //   lastOpenSubMenu () {
    //     let lastOpen = []
    //     const { sOpenKeys } = this.$data
    //     if (sOpenKeys.length) {
    //       lastOpen = this.getFlatInstanceArray().filter((c) => {
    //         return c && sOpenKeys.indexOf(c.eventKey) !== -1
    //       })
    //     }
    //     return lastOpen[0]
    //   },
    //   renderMenuItem (c, i, subIndex) {
    //     if (!c) {
    //       return null
    //     }
    //     const state = this.$data
    //     const extraProps = {
    //       openKeys: state.sOpenKeys,
    //       selectedKeys: state.sSelectedKeys,
    //       triggerSubMenuAction: this.$props.triggerSubMenuAction,
    //       isRootMenu: this.isRootMenu,
    //     }
    //     return this.renderCommonMenuItem(c, i, subIndex, extraProps)
    //   },

  },
  render: function render() {
    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var subPopupMenuProps = {
      props: Menu_objectSpread({}, props, {
        openTransitionName: this.getOpenTransitionName(),
        parentMenu: this,
        children: this.$slots["default"] || [],
        __propsSymbol__: Symbol()
      }),
      "class": "".concat(props.prefixCls, "-root"),
      on: {
        click: this.onClick,
        openChange: this.onOpenChange,
        deselect: this.onDeselect,
        select: this.onSelect
      },
      ref: 'innerMenu'
    };
    return h(Provider, {
      attrs: {
        store: this.store
      }
    }, [h(vc_menu_SubPopupMenu, subPopupMenuProps)]);
  }
};
/* harmony default export */ var vc_menu_Menu = (Menu);
// EXTERNAL MODULE: external "Vue"
var external_Vue_ = __webpack_require__(10);
var external_Vue_default = /*#__PURE__*/__webpack_require__.n(external_Vue_);

// EXTERNAL MODULE: ./src/components/_util/antRefDirective.js
var antRefDirective = __webpack_require__(48);

// CONCATENATED MODULE: ./src/components/_util/Dom/contains.js
function contains(root, n) {
  var node = n;

  while (node) {
    if (node === root) {
      return true;
    }

    node = node.parentNode;
  }

  return false;
}
// EXTERNAL MODULE: ./src/components/_util/requestAnimationTimeout.js + 1 modules
var requestAnimationTimeout = __webpack_require__(37);

// EXTERNAL MODULE: ./node_modules/warning/browser.js
var browser = __webpack_require__(26);
var browser_default = /*#__PURE__*/__webpack_require__.n(browser);

// CONCATENATED MODULE: ./src/components/_util/warning.js

var warned = {};
/* harmony default export */ var _util_warning = (function (valid, message, throwError) {
  if (!valid && !warned[message]) {
    browser_default()(false, message);
    warned[message] = true;
  }
});
// CONCATENATED MODULE: ./node_modules/dom-align/es/propertyUtils.js
var vendorPrefix = void 0;
var jsCssMap = {
  Webkit: '-webkit-',
  Moz: '-moz-',
  // IE did it wrong again ...
  ms: '-ms-',
  O: '-o-'
};

function getVendorPrefix() {
  if (vendorPrefix !== undefined) {
    return vendorPrefix;
  }

  vendorPrefix = '';
  var style = document.createElement('p').style;
  var testProp = 'Transform';

  for (var key in jsCssMap) {
    if (key + testProp in style) {
      vendorPrefix = key;
    }
  }

  return vendorPrefix;
}

function propertyUtils_getTransitionName() {
  return getVendorPrefix() ? getVendorPrefix() + 'TransitionProperty' : 'transitionProperty';
}

function getTransformName() {
  return getVendorPrefix() ? getVendorPrefix() + 'Transform' : 'transform';
}
function setTransitionProperty(node, value) {
  var name = propertyUtils_getTransitionName();

  if (name) {
    node.style[name] = value;

    if (name !== 'transitionProperty') {
      node.style.transitionProperty = value;
    }
  }
}

function setTransform(node, value) {
  var name = getTransformName();

  if (name) {
    node.style[name] = value;

    if (name !== 'transform') {
      node.style.transform = value;
    }
  }
}

function getTransitionProperty(node) {
  return node.style.transitionProperty || node.style[propertyUtils_getTransitionName()];
}
function getTransformXY(node) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());

  if (transform && transform !== 'none') {
    var matrix = transform.replace(/[^0-9\-.,]/g, '').split(',');
    return {
      x: parseFloat(matrix[12] || matrix[4], 0),
      y: parseFloat(matrix[13] || matrix[5], 0)
    };
  }

  return {
    x: 0,
    y: 0
  };
}
var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;
function setTransformXY(node, xy) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());

  if (transform && transform !== 'none') {
    var arr = void 0;
    var match2d = transform.match(matrix2d);

    if (match2d) {
      match2d = match2d[1];
      arr = match2d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[4] = xy.x;
      arr[5] = xy.y;
      setTransform(node, 'matrix(' + arr.join(',') + ')');
    } else {
      var match3d = transform.match(matrix3d)[1];
      arr = match3d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[12] = xy.x;
      arr[13] = xy.y;
      setTransform(node, 'matrix3d(' + arr.join(',') + ')');
    }
  } else {
    setTransform(node, 'translateX(' + xy.x + 'px) translateY(' + xy.y + 'px) translateZ(0)');
  }
}
// CONCATENATED MODULE: ./node_modules/dom-align/es/utils.js
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
};


var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var getComputedStyleX = void 0; // https://stackoverflow.com/a/3485654/3040605

function forceRelayout(elem) {
  var originalStyle = elem.style.display;
  elem.style.display = 'none';
  elem.offsetHeight; // eslint-disable-line

  elem.style.display = originalStyle;
}

function css(el, name, v) {
  var value = v;

  if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
    for (var i in name) {
      if (name.hasOwnProperty(i)) {
        css(el, i, name[i]);
      }
    }

    return undefined;
  }

  if (typeof value !== 'undefined') {
    if (typeof value === 'number') {
      value = value + 'px';
    }

    el.style[name] = value;
    return undefined;
  }

  return getComputedStyleX(el, name);
}

function getClientPosition(elem) {
  var box = void 0;
  var x = void 0;
  var y = void 0;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement; // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式

  box = elem.getBoundingClientRect(); // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

  x = box.left;
  y = box.top; // In IE, most of the time, 2 extra pixels are added to the top and left
  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
  // IE6 standards mode, this border can be overridden by setting the
  // document element's border to zero -- thus, we cannot rely on the
  // offset always being 2 pixels.
  // In quirks mode, the offset can be determined by querying the body's
  // clientLeft/clientTop, but in standards mode, it is found by querying
  // the document element's clientLeft/clientTop.  Since we already called
  // getClientBoundingRect we have already forced a reflow, so it is not
  // too expensive just to query them all.
  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
  // 窗口边框标准是设 documentElement ,quirks 时设置 body
  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
  // 标准 ie 下 docElem.clientTop 就是 border-top
  // ie7 html 即窗口边框改变不了。永远为 2
  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x,
    top: y
  };
}

function utils_getScroll(w, top) {
  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
  var method = 'scroll' + (top ? 'Top' : 'Left');

  if (typeof ret !== 'number') {
    var d = w.document; // ie6,7,8 standard mode

    ret = d.documentElement[method];

    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }

  return ret;
}

function getScrollLeft(w) {
  return utils_getScroll(w);
}

function getScrollTop(w) {
  return utils_getScroll(w, true);
}

function utils_getOffset(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w);
  pos.top += getScrollTop(w);
  return pos;
}
/**
 * A crude way of determining if an object is a window
 * @member util
 */


function utils_isWindow(obj) {
  // must use == for ie8

  /* eslint eqeqeq:0 */
  return obj !== null && obj !== undefined && obj == obj.window;
}

function getDocument(node) {
  if (utils_isWindow(node)) {
    return node.document;
  }

  if (node.nodeType === 9) {
    return node;
  }

  return node.ownerDocument;
}

function _getComputedStyle(elem, name, cs) {
  var computedStyle = cs;
  var val = '';
  var d = getDocument(elem);
  computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null); // https://github.com/kissyteam/kissy/issues/61

  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }

  return val;
}

var _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');

var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = 'currentStyle';
var RUNTIME_STYLE = 'runtimeStyle';
var LEFT = 'left';
var PX = 'px';

function _getComputedStyleIE(elem, name) {
  // currentStyle maybe null
  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name]; // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
  // 在 ie 下不对，需要直接用 offset 方式
  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了
  // From the awesome hack by Dean Edwards
  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
  // If we're not dealing with a regular pixel number
  // but a number that has a weird ending, we need to convert it to pixels
  // exclude left right for relativity

  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    // Remember the original values
    var style = elem.style;
    var left = style[LEFT];
    var rsLeft = elem[RUNTIME_STYLE][LEFT]; // prevent flashing of content

    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT]; // Put in the new values to get a computed value out

    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
    ret = style.pixelLeft + PX; // Revert the changed values

    style[LEFT] = left;
    elem[RUNTIME_STYLE][LEFT] = rsLeft;
  }

  return ret === '' ? 'auto' : ret;
}

if (typeof window !== 'undefined') {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}

function getOffsetDirection(dir, option) {
  if (dir === 'left') {
    return option.useCssRight ? 'right' : dir;
  }

  return option.useCssBottom ? 'bottom' : dir;
}

function oppositeOffsetDirection(dir) {
  if (dir === 'left') {
    return 'right';
  } else if (dir === 'right') {
    return 'left';
  } else if (dir === 'top') {
    return 'bottom';
  } else if (dir === 'bottom') {
    return 'top';
  }
} // 设置 elem 相对 elem.ownerDocument 的坐标


function setLeftTop(elem, offset, option) {
  // set position first, in-case top/left are set even on static elem
  if (css(elem, 'position') === 'static') {
    elem.style.position = 'relative';
  }

  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection('left', option);
  var verticalProperty = getOffsetDirection('top', option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);

  if (horizontalProperty !== 'left') {
    presetH = 999;
  }

  if (verticalProperty !== 'top') {
    presetV = 999;
  }

  var originalTransition = '';
  var originalOffset = utils_getOffset(elem);

  if ('left' in offset || 'top' in offset) {
    originalTransition = getTransitionProperty(elem) || '';
    setTransitionProperty(elem, 'none');
  }

  if ('left' in offset) {
    elem.style[oppositeHorizontalProperty] = '';
    elem.style[horizontalProperty] = presetH + 'px';
  }

  if ('top' in offset) {
    elem.style[oppositeVerticalProperty] = '';
    elem.style[verticalProperty] = presetV + 'px';
  } // force relayout


  forceRelayout(elem);
  var old = utils_getOffset(elem);
  var originalStyle = {};

  for (var key in offset) {
    if (offset.hasOwnProperty(key)) {
      var dir = getOffsetDirection(key, option);
      var preset = key === 'left' ? presetH : presetV;
      var off = originalOffset[key] - old[key];

      if (dir === key) {
        originalStyle[dir] = preset + off;
      } else {
        originalStyle[dir] = preset - off;
      }
    }
  }

  css(elem, originalStyle); // force relayout

  forceRelayout(elem);

  if ('left' in offset || 'top' in offset) {
    setTransitionProperty(elem, originalTransition);
  }

  var ret = {};

  for (var _key in offset) {
    if (offset.hasOwnProperty(_key)) {
      var _dir = getOffsetDirection(_key, option);

      var _off = offset[_key] - originalOffset[_key];

      if (_key === _dir) {
        ret[_dir] = originalStyle[_dir] + _off;
      } else {
        ret[_dir] = originalStyle[_dir] - _off;
      }
    }
  }

  css(elem, ret);
}

function utils_setTransform(elem, offset) {
  var originalOffset = utils_getOffset(elem);
  var originalXY = getTransformXY(elem);
  var resultXY = {
    x: originalXY.x,
    y: originalXY.y
  };

  if ('left' in offset) {
    resultXY.x = originalXY.x + offset.left - originalOffset.left;
  }

  if ('top' in offset) {
    resultXY.y = originalXY.y + offset.top - originalOffset.top;
  }

  setTransformXY(elem, resultXY);
}

function utils_setOffset(elem, offset, option) {
  if (option.ignoreShake) {
    var oriOffset = utils_getOffset(elem);
    var oLeft = oriOffset.left.toFixed(0);
    var oTop = oriOffset.top.toFixed(0);
    var tLeft = offset.left.toFixed(0);
    var tTop = offset.top.toFixed(0);

    if (oLeft === tLeft && oTop === tTop) {
      return;
    }
  }

  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset, option);
  } else if (option.useCssTransform && getTransformName() in document.body.style) {
    utils_setTransform(elem, offset, option);
  } else {
    setLeftTop(elem, offset, option);
  }
}

function each(arr, fn) {
  for (var i = 0; i < arr.length; i++) {
    fn(arr[i]);
  }
}

function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
}

var BOX_MODELS = ['margin', 'border', 'padding'];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;

function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name = void 0; // Remember the old values, and insert the new ones

  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }

  callback.call(elem); // Revert the old values

  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}

function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop = void 0;
  var j = void 0;
  var i = void 0;

  for (j = 0; j < props.length; j++) {
    prop = props[j];

    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = void 0;

        if (prop === 'border') {
          cssProp = '' + prop + which[i] + 'Width';
        } else {
          cssProp = prop + which[i];
        }

        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }

  return value;
}

var domUtils = {};
each(['Width', 'Height'], function (name) {
  domUtils['doc' + name] = function (refWin) {
    var d = refWin.document;
    return Math.max( // firefox chrome documentElement.scrollHeight< body.scrollHeight
    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
    d.documentElement['scroll' + name], // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
    d.body['scroll' + name], domUtils['viewport' + name](d));
  };

  domUtils['viewport' + name] = function (win) {
    // pc browser includes scrollbar in window.innerWidth
    var prop = 'client' + name;
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop]; // 标准模式取 documentElement
    // backcompat 取 body

    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  };
});
/*
 得到元素的大小信息
 @param elem
 @param name
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */

function getWH(elem, name, ex) {
  var extra = ex;

  if (utils_isWindow(elem)) {
    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }

  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  var borderBoxValue = name === 'width' ? elem.getBoundingClientRect().width : elem.getBoundingClientRect().height;
  var computedStyle = getComputedStyleX(elem);
  var isBorderBox = isBorderBoxFn(elem, computedStyle);
  var cssBoxValue = 0;

  if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
    borderBoxValue = undefined; // Fall back to computed then un computed css if necessary

    cssBoxValue = getComputedStyleX(elem, name);

    if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    } // Normalize '', auto, and prepare for extra


    cssBoxValue = parseFloat(cssBoxValue) || 0;
  }

  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }

  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  var val = borderBoxValue || cssBoxValue;

  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which, computedStyle);
    }

    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }

    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle));
  }

  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
}

var cssShow = {
  position: 'absolute',
  visibility: 'hidden',
  display: 'block'
}; // fix #119 : https://github.com/kissyteam/kissy/issues/119

function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args[_key2] = arguments[_key2];
  }

  var val = void 0;
  var elem = args[0]; // in case elem is window
  // elem.offsetWidth === undefined

  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    swap(elem, cssShow, function () {
      val = getWH.apply(undefined, args);
    });
  }

  return val;
}

each(['width', 'height'], function (name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);

  domUtils['outer' + first] = function (el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };

  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

  domUtils[name] = function (elem, v) {
    var val = v;

    if (val !== undefined) {
      if (elem) {
        var computedStyle = getComputedStyleX(elem);
        var isBorderBox = isBorderBoxFn(elem);

        if (isBorderBox) {
          val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);
        }

        return css(elem, name, val);
      }

      return undefined;
    }

    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});

function mix(to, from) {
  for (var i in from) {
    if (from.hasOwnProperty(i)) {
      to[i] = from[i];
    }
  }

  return to;
}

var utils = {
  getWindow: function getWindow(node) {
    if (node && node.document && node.setTimeout) {
      return node;
    }

    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  getDocument: getDocument,
  offset: function offset(el, value, option) {
    if (typeof value !== 'undefined') {
      utils_setOffset(el, value, option || {});
    } else {
      return utils_getOffset(el);
    }
  },
  isWindow: utils_isWindow,
  each: each,
  css: css,
  clone: function clone(obj) {
    var i = void 0;
    var ret = {};

    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }

    var overflow = obj.overflow;

    if (overflow) {
      for (i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }

    return ret;
  },
  mix: mix,
  getWindowScrollLeft: function getWindowScrollLeft(w) {
    return getScrollLeft(w);
  },
  getWindowScrollTop: function getWindowScrollTop(w) {
    return getScrollTop(w);
  },
  merge: function merge() {
    var ret = {};

    for (var _len2 = arguments.length, args = Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
      args[_key3] = arguments[_key3];
    }

    for (var i = 0; i < args.length; i++) {
      utils.mix(ret, args[i]);
    }

    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
mix(utils, domUtils);
/* harmony default export */ var es_utils = (utils);
// CONCATENATED MODULE: ./node_modules/dom-align/es/getOffsetParent.js

/**
 * 得到会导致元素显示不全的祖先元素
 */

function getOffsetParent(element) {
  if (es_utils.isWindow(element) || element.nodeType === 9) {
    return null;
  } // ie 这个也不是完全可行

  /*
   <div style="width: 50px;height: 100px;overflow: hidden">
   <div style="width: 50px;height: 100px;position: relative;" id="d6">
   元素 6 高 100px 宽 50px<br/>
   </div>
   </div>
   */
  // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
  //  In other browsers it only includes elements with position absolute, relative or
  // fixed, not elements with overflow set to auto or scroll.
  //        if (UA.ie && ieMode < 8) {
  //            return element.offsetParent;
  //        }
  // 统一的 offsetParent 方法


  var doc = es_utils.getDocument(element);
  var body = doc.body;
  var parent = void 0;
  var positionStyle = es_utils.css(element, 'position');
  var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';

  if (!skipStatic) {
    return element.nodeName.toLowerCase() === 'html' ? null : element.parentNode;
  }

  for (parent = element.parentNode; parent && parent !== body; parent = parent.parentNode) {
    positionStyle = es_utils.css(parent, 'position');

    if (positionStyle !== 'static') {
      return parent;
    }
  }

  return null;
}

/* harmony default export */ var es_getOffsetParent = (getOffsetParent);
// CONCATENATED MODULE: ./node_modules/dom-align/es/isAncestorFixed.js

function isAncestorFixed(element) {
  if (es_utils.isWindow(element) || element.nodeType === 9) {
    return false;
  }

  var doc = es_utils.getDocument(element);
  var body = doc.body;
  var parent = null;

  for (parent = element.parentNode; parent && parent !== body; parent = parent.parentNode) {
    var positionStyle = es_utils.css(parent, 'position');

    if (positionStyle === 'fixed') {
      return true;
    }
  }

  return false;
}
// CONCATENATED MODULE: ./node_modules/dom-align/es/getVisibleRectForElement.js



/**
 * 获得元素的显示部分的区域
 */

function getVisibleRectForElement(element) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = es_getOffsetParent(element);
  var doc = es_utils.getDocument(element);
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement; // Determine the size of the visible rect by climbing the dom accounting for
  // all scrollable containers.

  while (el) {
    // clientWidth is zero for inline block elements in ie.
    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    el !== body && el !== documentElement && es_utils.css(el, 'overflow') !== 'visible') {
      var pos = es_utils.offset(el); // add border

      pos.left += el.clientLeft;
      pos.top += el.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(visibleRect.right, // consider area without scrollBar
      pos.left + el.clientWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el === body || el === documentElement) {
      break;
    }

    el = es_getOffsetParent(el);
  } // Set element position to fixed
  // make sure absolute element itself don't affect it's visible area
  // https://github.com/ant-design/ant-design/issues/7601


  var originalPosition = null;

  if (!es_utils.isWindow(element) && element.nodeType !== 9) {
    originalPosition = element.style.position;
    var position = es_utils.css(element, 'position');

    if (position === 'absolute') {
      element.style.position = 'fixed';
    }
  }

  var scrollX = es_utils.getWindowScrollLeft(win);
  var scrollY = es_utils.getWindowScrollTop(win);
  var viewportWidth = es_utils.viewportWidth(win);
  var viewportHeight = es_utils.viewportHeight(win);
  var documentWidth = documentElement.scrollWidth;
  var documentHeight = documentElement.scrollHeight; // scrollXXX on html is sync with body which means overflow: hidden on body gets wrong scrollXXX.
  // We should cut this ourself.

  var bodyStyle = window.getComputedStyle(body);

  if (bodyStyle.overflowX === 'hidden') {
    documentWidth = win.innerWidth;
  }

  if (bodyStyle.overflowY === 'hidden') {
    documentHeight = win.innerHeight;
  } // Reset element position after calculate the visible area


  if (element.style) {
    element.style.position = originalPosition;
  }

  if (isAncestorFixed(element)) {
    // Clip by viewport's size.
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
  } else {
    // Clip by document's size.
    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
  }

  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}

/* harmony default export */ var es_getVisibleRectForElement = (getVisibleRectForElement);
// CONCATENATED MODULE: ./node_modules/dom-align/es/adjustForViewport.js


function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = es_utils.clone(elFuturePos);
  var size = {
    width: elRegion.width,
    height: elRegion.height
  };

  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  } // Left edge inside and right edge outside viewport, try to resize it.


  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
    size.width -= pos.left + size.width - visibleRect.right;
  } // Right edge outside viewport, try to move it.


  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
    // 保证左边界和可视区域左边界对齐
    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
  } // Top edge outside viewport, try to move it.


  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  } // Top edge inside and bottom edge outside viewport, try to resize it.


  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
    size.height -= pos.top + size.height - visibleRect.bottom;
  } // Bottom edge outside viewport, try to move it.


  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
    // 保证上边界和可视区域上边界对齐
    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
  }

  return es_utils.mix(pos, size);
}

/* harmony default export */ var es_adjustForViewport = (adjustForViewport);
// CONCATENATED MODULE: ./node_modules/dom-align/es/getRegion.js


function getRegion(node) {
  var offset = void 0;
  var w = void 0;
  var h = void 0;

  if (!es_utils.isWindow(node) && node.nodeType !== 9) {
    offset = es_utils.offset(node);
    w = es_utils.outerWidth(node);
    h = es_utils.outerHeight(node);
  } else {
    var win = es_utils.getWindow(node);
    offset = {
      left: es_utils.getWindowScrollLeft(win),
      top: es_utils.getWindowScrollTop(win)
    };
    w = es_utils.viewportWidth(win);
    h = es_utils.viewportHeight(win);
  }

  offset.width = w;
  offset.height = h;
  return offset;
}

/* harmony default export */ var es_getRegion = (getRegion);
// CONCATENATED MODULE: ./node_modules/dom-align/es/getAlignOffset.js
/**
 * 获取 node 上的 align 对齐点 相对于页面的坐标
 */
function getAlignOffset(region, align) {
  var V = align.charAt(0);
  var H = align.charAt(1);
  var w = region.width;
  var h = region.height;
  var x = region.left;
  var y = region.top;

  if (V === 'c') {
    y += h / 2;
  } else if (V === 'b') {
    y += h;
  }

  if (H === 'c') {
    x += w / 2;
  } else if (H === 'r') {
    x += w;
  }

  return {
    left: x,
    top: y
  };
}

/* harmony default export */ var es_getAlignOffset = (getAlignOffset);
// CONCATENATED MODULE: ./node_modules/dom-align/es/getElFuturePos.js


function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
  var p1 = es_getAlignOffset(refNodeRegion, points[1]);
  var p2 = es_getAlignOffset(elRegion, points[0]);
  var diff = [p2.left - p1.left, p2.top - p1.top];
  return {
    left: elRegion.left - diff[0] + offset[0] - targetOffset[0],
    top: elRegion.top - diff[1] + offset[1] - targetOffset[1]
  };
}

/* harmony default export */ var es_getElFuturePos = (getElFuturePos);
// CONCATENATED MODULE: ./node_modules/dom-align/es/align/align.js
/**
 * align dom node flexibly
 * @author yiminghe@gmail.com
 */




 // http://yiminghe.iteye.com/blog/1124720

function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}

function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}

function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}

function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}

function flip(points, reg, map) {
  var ret = [];
  es_utils.each(points, function (p) {
    ret.push(p.replace(reg, function (m) {
      return map[m];
    }));
  });
  return ret;
}

function flipOffset(offset, index) {
  offset[index] = -offset[index];
  return offset;
}

function convertOffset(str, offsetLen) {
  var n = void 0;

  if (/%$/.test(str)) {
    n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n = parseInt(str, 10);
  }

  return n || 0;
}

function normalizeOffset(offset, el) {
  offset[0] = convertOffset(offset[0], el.width);
  offset[1] = convertOffset(offset[1], el.height);
}
/**
 * @param el
 * @param tgtRegion 参照节点所占的区域: { left, top, width, height }
 * @param align
 */


function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
  var points = align.points;
  var offset = align.offset || [0, 0];
  var targetOffset = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var source = align.source || el;
  offset = [].concat(offset);
  targetOffset = [].concat(targetOffset);
  overflow = overflow || {};
  var newOverflowCfg = {};
  var fail = 0; // 当前节点可以被放置的显示区域

  var visibleRect = es_getVisibleRectForElement(source); // 当前节点所占的区域, left/top/width/height

  var elRegion = es_getRegion(source); // 将 offset 转换成数值，支持百分比

  normalizeOffset(offset, elRegion);
  normalizeOffset(targetOffset, tgtRegion); // 当前节点将要被放置的位置

  var elFuturePos = es_getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset); // 当前节点将要所处的区域

  var newElRegion = es_utils.merge(elRegion, elFuturePos); // 如果可视区域不能完全放置当前节点时允许调整

  if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
    if (overflow.adjustX) {
      // 如果横向不能放下
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        // 对齐位置反下
        var newPoints = flip(points, /[lr]/ig, {
          l: 'r',
          r: 'l'
        }); // 偏移量也反下

        var newOffset = flipOffset(offset, 0);
        var newTargetOffset = flipOffset(targetOffset, 0);
        var newElFuturePos = es_getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);

        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset = newOffset;
          targetOffset = newTargetOffset;
        }
      }
    }

    if (overflow.adjustY) {
      // 如果纵向不能放下
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        // 对齐位置反下
        var _newPoints = flip(points, /[tb]/ig, {
          t: 'b',
          b: 't'
        }); // 偏移量也反下


        var _newOffset = flipOffset(offset, 1);

        var _newTargetOffset = flipOffset(targetOffset, 1);

        var _newElFuturePos = es_getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);

        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = _newPoints;
          offset = _newOffset;
          targetOffset = _newTargetOffset;
        }
      }
    } // 如果失败，重新计算当前节点将要被放置的位置


    if (fail) {
      elFuturePos = es_getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset);
      es_utils.mix(newElRegion, elFuturePos);
    }

    var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
    var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect); // 检查反下后的位置是否可以放下了，如果仍然放不下：
    // 1. 复原修改过的定位参数

    if (isStillFailX || isStillFailY) {
      points = align.points;
      offset = align.offset || [0, 0];
      targetOffset = align.targetOffset || [0, 0];
    } // 2. 只有指定了可以调整当前方向才调整


    newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
    newOverflowCfg.adjustY = overflow.adjustY && isStillFailY; // 确实要调整，甚至可能会调整高度宽度

    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = es_adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  } // need judge to in case set fixed with in css on height auto element


  if (newElRegion.width !== elRegion.width) {
    es_utils.css(source, 'width', es_utils.width(source) + newElRegion.width - elRegion.width);
  }

  if (newElRegion.height !== elRegion.height) {
    es_utils.css(source, 'height', es_utils.height(source) + newElRegion.height - elRegion.height);
  } // https://github.com/kissyteam/kissy/issues/190
  // 相对于屏幕位置没变，而 left/top 变了
  // 例如 <div 'relative'><el absolute></div>


  es_utils.offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom,
    useCssTransform: align.useCssTransform,
    ignoreShake: align.ignoreShake
  });
  return {
    points: points,
    offset: offset,
    targetOffset: targetOffset,
    overflow: newOverflowCfg
  };
}

/* harmony default export */ var align_align = (doAlign);
/**
 *  2012-04-26 yiminghe@gmail.com
 *   - 优化智能对齐算法
 *   - 慎用 resizeXX
 *
 *  2011-07-13 yiminghe@gmail.com note:
 *   - 增加智能对齐，以及大小调整选项
 **/
// CONCATENATED MODULE: ./node_modules/dom-align/es/align/alignElement.js





function isOutOfVisibleRect(target) {
  var visibleRect = es_getVisibleRectForElement(target);
  var targetRegion = es_getRegion(target);
  return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
}

function alignElement(el, refNode, align) {
  var target = align.target || refNode;
  var refNodeRegion = es_getRegion(target);
  var isTargetNotOutOfVisible = !isOutOfVisibleRect(target);
  return align_align(el, refNodeRegion, align, isTargetNotOutOfVisible);
}

alignElement.__getOffsetParent = es_getOffsetParent;
alignElement.__getVisibleRectForElement = es_getVisibleRectForElement;
/* harmony default export */ var align_alignElement = (alignElement);
// CONCATENATED MODULE: ./node_modules/dom-align/es/align/alignPoint.js
var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



/**
 * `tgtPoint`: { pageX, pageY } or { clientX, clientY }.
 * If client position provided, will internal convert to page position.
 */

function alignPoint_alignPoint(el, tgtPoint, align) {
  var pageX = void 0;
  var pageY = void 0;
  var doc = es_utils.getDocument(el);
  var win = doc.defaultView || doc.parentWindow;
  var scrollX = es_utils.getWindowScrollLeft(win);
  var scrollY = es_utils.getWindowScrollTop(win);
  var viewportWidth = es_utils.viewportWidth(win);
  var viewportHeight = es_utils.viewportHeight(win);

  if ('pageX' in tgtPoint) {
    pageX = tgtPoint.pageX;
  } else {
    pageX = scrollX + tgtPoint.clientX;
  }

  if ('pageY' in tgtPoint) {
    pageY = tgtPoint.pageY;
  } else {
    pageY = scrollY + tgtPoint.clientY;
  }

  var tgtRegion = {
    left: pageX,
    top: pageY,
    width: 0,
    height: 0
  };
  var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight; // Provide default target point

  var points = [align.points[0], 'cc'];
  return align_align(el, tgtRegion, _extends({}, align, {
    points: points
  }), pointInView);
}

/* harmony default export */ var align_alignPoint = (alignPoint_alignPoint);
// CONCATENATED MODULE: ./node_modules/dom-align/es/index.js



/* harmony default export */ var dom_align_es = (align_alignElement);
// CONCATENATED MODULE: ./src/components/align/util.js
function util_typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { util_typeof2 = function _typeof2(obj) { return typeof obj; }; } else { util_typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return util_typeof2(obj); }

function util_typeof(obj) {
  if (typeof Symbol === "function" && util_typeof2(Symbol.iterator) === "symbol") {
    util_typeof = function _typeof(obj) {
      return util_typeof2(obj);
    };
  } else {
    util_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : util_typeof2(obj);
    };
  }

  return util_typeof(obj);
}

function buffer(fn, ms) {
  var timer;

  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }

  function bufferFn() {
    clear();
    timer = setTimeout(fn, ms);
  }

  bufferFn.clear = clear;
  return bufferFn;
}
function isSamePoint(prev, next) {
  if (prev === next) return true;
  if (!prev || !next) return false;

  if ('pageX' in next && 'pageY' in next) {
    return prev.pageX === next.pageX && prev.pageY === next.pageY;
  }

  if ('clientX' in next && 'clientY' in next) {
    return prev.clientX === next.clientX && prev.clientY === next.clientY;
  }

  return false;
}
function util_isWindow(obj) {
  return obj && util_typeof(obj) === 'object' && obj.window === obj;
}
// EXTERNAL MODULE: ./node_modules/lodash/cloneDeep.js
var cloneDeep = __webpack_require__(406);
var cloneDeep_default = /*#__PURE__*/__webpack_require__.n(cloneDeep);

// CONCATENATED MODULE: ./src/components/align/Align.jsx
function Align_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Align_defineProperty(target, key, source[key]); }); } return target; }

function Align_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Align_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Align_typeof = function _typeof(obj) { return typeof obj; }; } else { Align_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Align_typeof(obj); }








function getElement(func) {
  if (typeof func !== 'function' || !func) return null;
  return func();
}

function getPoint(point) {
  if (Align_typeof(point) !== 'object' || !point) return null;
  return point;
}

/* harmony default export */ var Align = ({
  props: {
    childrenProps: vue_types["a" /* default */].object,
    align: vue_types["a" /* default */].object.isRequired,
    target: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].func, vue_types["a" /* default */].object]).def(function () {
      return window;
    }),
    monitorBufferTime: vue_types["a" /* default */].number.def(50),
    monitorWindowResize: vue_types["a" /* default */].bool.def(false),
    disabled: vue_types["a" /* default */].bool.def(false)
  },
  data: function data() {
    this.aligned = false;
    return {};
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.prevProps = Align_objectSpread({}, _this.$props);
      var props = _this.$props; // if parent ref not attached .... use document.getElementById

      !_this.aligned && _this.forceAlign();

      if (!props.disabled && props.monitorWindowResize) {
        _this.startMonitorWindowResize();
      }
    });
  },
  updated: function updated() {
    var _this2 = this;

    this.$nextTick(function () {
      var prevProps = _this2.prevProps;
      var props = _this2.$props;
      var reAlign = false;

      if (!props.disabled) {
        var source = _this2.$el;
        var sourceRect = source ? source.getBoundingClientRect() : null;

        if (prevProps.disabled) {
          reAlign = true;
        } else {
          var lastElement = getElement(prevProps.target);
          var currentElement = getElement(props.target);
          var lastPoint = getPoint(prevProps.target);
          var currentPoint = getPoint(props.target);

          if (util_isWindow(lastElement) && util_isWindow(currentElement)) {
            // Skip if is window
            reAlign = false;
          } else if (lastElement !== currentElement || // Element change
          lastElement && !currentElement && currentPoint || // Change from element to point
          lastPoint && currentPoint && currentElement || // Change from point to element
          currentPoint && !isSamePoint(lastPoint, currentPoint)) {
            reAlign = true;
          } // If source element size changed


          var preRect = _this2.sourceRect || {};

          if (!reAlign && source && (preRect.width !== sourceRect.width || preRect.height !== sourceRect.height)) {
            reAlign = true;
          }
        }

        _this2.sourceRect = sourceRect;
      }

      if (reAlign) {
        _this2.forceAlign();
      }

      if (props.monitorWindowResize && !props.disabled) {
        _this2.startMonitorWindowResize();
      } else {
        _this2.stopMonitorWindowResize();
      }

      _this2.prevProps = Align_objectSpread({}, _this2.$props, {
        align: cloneDeep_default()(_this2.$props.align)
      });
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.stopMonitorWindowResize();
  },
  methods: {
    startMonitorWindowResize: function startMonitorWindowResize() {
      if (!this.resizeHandler) {
        this.bufferMonitor = buffer(this.forceAlign, this.$props.monitorBufferTime);
        this.resizeHandler = addEventListenerWrap(window, 'resize', this.bufferMonitor);
      }
    },
    stopMonitorWindowResize: function stopMonitorWindowResize() {
      if (this.resizeHandler) {
        this.bufferMonitor.clear();
        this.resizeHandler.remove();
        this.resizeHandler = null;
      }
    },
    forceAlign: function forceAlign() {
      var _this$$props = this.$props,
          disabled = _this$$props.disabled,
          target = _this$$props.target,
          align = _this$$props.align;

      if (!disabled && target) {
        var source = this.$el;
        var result;
        var element = getElement(target);
        var point = getPoint(target);

        if (element) {
          result = align_alignElement(source, element, align);
        } else if (point) {
          result = align_alignPoint(source, point, align);
        }

        this.aligned = true;
        this.$listeners.align && this.$listeners.align(source, result);
      }
    }
  },
  render: function render() {
    var childrenProps = this.$props.childrenProps;
    var child = this.$slots["default"][0];

    if (childrenProps) {
      return Object(vnode["a" /* cloneElement */])(child, {
        props: childrenProps
      });
    }

    return child;
  }
});
// CONCATENATED MODULE: ./src/components/align/index.js
// based on vc-align 2.4.3

/* harmony default export */ var components_align = (Align);
// CONCATENATED MODULE: ./src/components/trigger/LazyRenderBox.jsx

/* harmony default export */ var LazyRenderBox = ({
  props: {
    visible: vue_types["a" /* default */].bool,
    hiddenClassName: vue_types["a" /* default */].string
  },
  render: function render() {
    var h = arguments[0];
    var _this$$props = this.$props,
        hiddenClassName = _this$$props.hiddenClassName,
        visible = _this$$props.visible;
    var children = null;

    if (hiddenClassName || !this.$slots["default"] || this.$slots["default"].length > 1) {
      var cls = '';

      if (!visible && hiddenClassName) {// cls += ` ${hiddenClassName}`
      }

      children = h("div", {
        "class": cls
      }, [this.$slots["default"]]);
    } else {
      children = this.$slots["default"][0];
    }

    return children;
  }
});
// CONCATENATED MODULE: ./src/components/trigger/PopupInner.jsx



/* harmony default export */ var PopupInner = ({
  props: {
    hiddenClassName: vue_types["a" /* default */].string.def(''),
    prefixCls: vue_types["a" /* default */].string,
    visible: vue_types["a" /* default */].bool
  },
  render: function render() {
    var h = arguments[0];
    var _this$$props = this.$props,
        prefixCls = _this$$props.prefixCls,
        visible = _this$$props.visible,
        hiddenClassName = _this$$props.hiddenClassName;
    var $listeners = this.$listeners;
    var divProps = {
      on: $listeners
    };
    return h("div", babel_helper_vue_jsx_merge_props_default()([divProps, {
      "class": !visible ? hiddenClassName : ''
    }]), [h(LazyRenderBox, {
      "class": "".concat(prefixCls, "-content"),
      attrs: {
        visible: visible
      }
    }, [this.$slots["default"]])]);
  }
});
// CONCATENATED MODULE: ./src/components/trigger/utils.js
function utils_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      utils_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function utils_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function isPointsEq(a1, a2, isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }

  return a1[0] === a2[0] && a1[1] === a2[1];
}

function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return utils_objectSpread({}, baseAlign, align);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  var points = align.points;

  for (var placement in builtinPlacements) {
    if (builtinPlacements.hasOwnProperty(placement)) {
      if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
        return "".concat(prefixCls, "-placement-").concat(placement);
      }
    }
  }

  return '';
}
function utils_noop() {}
// EXTERNAL MODULE: ./src/components/_util/css-animation/index.js
var css_animation = __webpack_require__(57);

// CONCATENATED MODULE: ./src/components/trigger/Popup.jsx
function Popup_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Popup_typeof = function _typeof(obj) { return typeof obj; }; } else { Popup_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Popup_typeof(obj); }

function Popup_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Popup_defineProperty(target, key, source[key]); }); } return target; }

function Popup_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







/* harmony default export */ var Popup = ({
  props: {
    visible: vue_types["a" /* default */].bool,
    getClassNameFromAlign: vue_types["a" /* default */].func,
    getRootDomNode: vue_types["a" /* default */].func,
    align: vue_types["a" /* default */].any,
    destroyPopupOnHide: vue_types["a" /* default */].bool,
    prefixCls: vue_types["a" /* default */].string,
    getContainer: vue_types["a" /* default */].func,
    transitionName: vue_types["a" /* default */].string,
    animation: vue_types["a" /* default */].any,
    maskAnimation: vue_types["a" /* default */].string,
    maskTransitionName: vue_types["a" /* default */].string,
    mask: vue_types["a" /* default */].bool,
    zIndex: vue_types["a" /* default */].number,
    popupClassName: vue_types["a" /* default */].any,
    popupStyle: vue_types["a" /* default */].object.def({}),
    stretch: vue_types["a" /* default */].string,
    point: vue_types["a" /* default */].shape({
      pageX: vue_types["a" /* default */].number,
      pageY: vue_types["a" /* default */].number
    })
  },
  data: function data() {
    return {
      // Used for stretch
      stretchChecked: false,
      targetWidth: undefined,
      targetHeight: undefined
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.rootNode = _this.getPopupDomNode();

      _this.setStretchSize();
    });
  },
  updated: function updated() {
    var _this2 = this;

    this.$nextTick(function () {
      _this2.setStretchSize();
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.$el.remove();
  },
  methods: {
    onAlign: function onAlign(popupDomNode, align) {
      var props = this.$props;
      var currentAlignClassName = props.getClassNameFromAlign(align); // FIX: https://github.com/react-component/trigger/issues/56
      // FIX: https://github.com/react-component/tooltip/issues/79

      if (this.currentAlignClassName !== currentAlignClassName) {
        this.currentAlignClassName = currentAlignClassName;
        popupDomNode.className = this.getClassName(currentAlignClassName);
      }

      this.$listeners.align && this.$listeners.align(popupDomNode, align);
    },
    // Record size if stretch needed
    setStretchSize: function setStretchSize() {
      var _this$$props = this.$props,
          stretch = _this$$props.stretch,
          getRootDomNode = _this$$props.getRootDomNode,
          visible = _this$$props.visible;
      var _this$$data = this.$data,
          stretchChecked = _this$$data.stretchChecked,
          targetHeight = _this$$data.targetHeight,
          targetWidth = _this$$data.targetWidth;

      if (!stretch || !visible) {
        if (stretchChecked) {
          this.setState({
            stretchChecked: false
          });
        }

        return;
      }

      var $ele = getRootDomNode();
      if (!$ele) return;
      var height = $ele.offsetHeight;
      var width = $ele.offsetWidth;

      if (targetHeight !== height || targetWidth !== width || !stretchChecked) {
        this.setState({
          stretchChecked: true,
          targetHeight: height,
          targetWidth: width
        });
      }
    },
    getPopupDomNode: function getPopupDomNode() {
      return this.$refs.popupInstance ? this.$refs.popupInstance.$el : null;
    },
    getTargetElement: function getTargetElement() {
      return this.$props.getRootDomNode();
    },
    // `target` on `rc-align` can accept as a function to get the bind element or a point.
    // ref: https://www.npmjs.com/package/rc-align
    getAlignTarget: function getAlignTarget() {
      var point = this.$props.point;

      if (point) {
        return point;
      }

      return this.getTargetElement;
    },
    getMaskTransitionName: function getMaskTransitionName() {
      var props = this.$props;
      var transitionName = props.maskTransitionName;
      var animation = props.maskAnimation;

      if (!transitionName && animation) {
        transitionName = "".concat(props.prefixCls, "-").concat(animation);
      }

      return transitionName;
    },
    getTransitionName: function getTransitionName() {
      var props = this.$props;
      var transitionName = props.transitionName;
      var animation = props.animation;

      if (!transitionName) {
        if (typeof animation === 'string') {
          transitionName = "".concat(animation);
        } else if (animation && animation.props && animation.props.name) {
          transitionName = animation.props.name;
        }
      }

      return transitionName;
    },
    getClassName: function getClassName(currentAlignClassName) {
      return "".concat(this.$props.prefixCls, " ").concat(this.$props.popupClassName, " ").concat(currentAlignClassName);
    },
    getPopupElement: function getPopupElement() {
      var _this3 = this;

      var h = this.$createElement;
      var props = this.$props,
          $slots = this.$slots,
          $listeners = this.$listeners,
          getTransitionName = this.getTransitionName;
      var _this$$data2 = this.$data,
          stretchChecked = _this$$data2.stretchChecked,
          targetHeight = _this$$data2.targetHeight,
          targetWidth = _this$$data2.targetWidth;
      var align = props.align,
          visible = props.visible,
          prefixCls = props.prefixCls,
          animation = props.animation,
          popupStyle = props.popupStyle,
          getClassNameFromAlign = props.getClassNameFromAlign,
          destroyPopupOnHide = props.destroyPopupOnHide,
          stretch = props.stretch;
      var mouseenter = $listeners.mouseenter,
          mouseleave = $listeners.mouseleave;
      var className = this.getClassName(this.currentAlignClassName || getClassNameFromAlign(align)); // const hiddenClassName = `${prefixCls}-hidden`

      if (!visible) {
        this.currentAlignClassName = null;
      }

      var sizeStyle = {};

      if (stretch) {
        // Stretch with target
        if (stretch.indexOf('height') !== -1) {
          sizeStyle.height = typeof targetHeight === 'number' ? "".concat(targetHeight, "px") : targetHeight;
        } else if (stretch.indexOf('minHeight') !== -1) {
          sizeStyle.minHeight = typeof targetHeight === 'number' ? "".concat(targetHeight, "px") : targetHeight;
        }

        if (stretch.indexOf('width') !== -1) {
          sizeStyle.width = typeof targetWidth === 'number' ? "".concat(targetWidth, "px") : targetWidth;
        } else if (stretch.indexOf('minWidth') !== -1) {
          sizeStyle.minWidth = typeof targetWidth === 'number' ? "".concat(targetWidth, "px") : targetWidth;
        } // Delay force align to makes ui smooth


        if (!stretchChecked) {
          sizeStyle.visibility = 'hidden';
          setTimeout(function () {
            if (_this3.$refs.alignInstance) {
              _this3.$refs.alignInstance.forceAlign();
            }
          }, 0);
        }
      }

      var popupInnerProps = {
        props: {
          prefixCls: prefixCls,
          visible: visible // hiddenClassName,

        },
        "class": className,
        on: {
          mouseenter: mouseenter || utils_noop,
          mouseleave: mouseleave || utils_noop
        },
        ref: 'popupInstance',
        style: Popup_objectSpread({}, sizeStyle, popupStyle, this.getZIndexStyle())
      };
      var transitionProps = {
        props: Object.assign({
          appear: true,
          css: false
        })
      };
      var transitionName = getTransitionName();
      var useTransition = !!transitionName;
      var transitionEvent = {
        beforeEnter: function beforeEnter(el) {// el.style.display = el.__vOriginalDisplay
          // this.$refs.alignInstance.forceAlign()
        },
        enter: function enter(el, done) {
          // align updated后执行动画
          _this3.$nextTick(function () {
            _this3.$refs.alignInstance.$nextTick(function () {
              Object(css_animation["a" /* default */])(el, "".concat(transitionName, "-enter"), done);
            });
          });
        },
        leave: function leave(el, done) {
          Object(css_animation["a" /* default */])(el, "".concat(transitionName, "-leave"), done);
        }
      };

      if (Popup_typeof(animation) === 'object') {
        useTransition = true;

        var _animation$on = animation.on,
            on = _animation$on === void 0 ? {} : _animation$on,
            _animation$props = animation.props,
            _props = _animation$props === void 0 ? {} : _animation$props;

        transitionProps.props = Popup_objectSpread({}, transitionProps.props, _props);
        transitionProps.on = Popup_objectSpread({}, transitionEvent, on);
      } else {
        transitionProps.on = transitionEvent;
      }

      if (!useTransition) {
        transitionProps = {};
      }

      if (destroyPopupOnHide) {
        return h("transition", transitionProps, [visible ? h(components_align, {
          attrs: {
            target: this.getAlignTarget(),
            monitorWindowResize: true,
            align: align
          },
          key: 'popup',
          ref: 'alignInstance',
          on: {
            "align": this.onAlign
          }
        }, [h(PopupInner, popupInnerProps, [$slots["default"]])]) : null]);
      }

      return h("transition", transitionProps, [h(components_align, {
        directives: [{
          name: "show",
          value: visible
        }],
        attrs: {
          target: this.getAlignTarget(),
          monitorWindowResize: true,
          disabled: !visible,
          align: align
        },
        key: 'popup',
        ref: 'alignInstance',
        on: {
          "align": this.onAlign
        }
      }, [h(PopupInner, popupInnerProps, [$slots["default"]])])]);
    },
    getZIndexStyle: function getZIndexStyle() {
      var style = {};
      var props = this.$props;

      if (props.zIndex !== undefined) {
        style.zIndex = props.zIndex;
      }

      return style;
    },
    getMaskElement: function getMaskElement() {
      var h = this.$createElement;
      var props = this.$props;
      var maskElement = null;

      if (props.mask) {
        var maskTransition = this.getMaskTransitionName();
        maskElement = h(LazyRenderBox, {
          directives: [{
            name: "show",
            value: props.visible
          }],
          style: this.getZIndexStyle(),
          key: 'mask',
          "class": "".concat(props.prefixCls, "-mask"),
          attrs: {
            visible: props.visible
          }
        });

        if (maskTransition) {
          maskElement = h("transition", {
            attrs: {
              appear: true,
              name: maskTransition
            }
          }, [maskElement]);
        }
      }

      return maskElement;
    }
  },
  render: function render() {
    var h = arguments[0];
    var getMaskElement = this.getMaskElement,
        getPopupElement = this.getPopupElement;
    return h("div", [getMaskElement(), getPopupElement()]);
  }
});
// CONCATENATED MODULE: ./src/components/_util/ContainerRender.jsx


/* harmony default export */ var ContainerRender = ({
  props: {
    autoMount: vue_types["a" /* default */].bool.def(true),
    autoDestroy: vue_types["a" /* default */].bool.def(true),
    visible: vue_types["a" /* default */].bool,
    forceRender: vue_types["a" /* default */].bool.def(false),
    parent: vue_types["a" /* default */].any,
    getComponent: vue_types["a" /* default */].func.isRequired,
    getContainer: vue_types["a" /* default */].func.isRequired,
    children: vue_types["a" /* default */].func.isRequired
  },
  mounted: function mounted() {
    if (this.autoMount) {
      this.renderComponent();
    }
  },
  updated: function updated() {
    if (this.autoMount) {
      this.renderComponent();
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.autoDestroy) {
      this.removeContainer();
    }
  },
  methods: {
    removeContainer: function removeContainer() {
      if (this.container) {
        this._component && this._component.$destroy();
        this.container.parentNode.removeChild(this.container);
        this.container = null;
      }
    },
    renderComponent: function renderComponent() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var ready = arguments.length > 1 ? arguments[1] : undefined;
      var visible = this.visible,
          forceRender = this.forceRender,
          getContainer = this.getContainer,
          parent = this.parent;
      var self = this;

      if (visible || parent.$refs._component || forceRender) {
        var el = this.componentEl;

        if (!this.container) {
          this.container = getContainer();
          el = document.createElement('div');
          this.componentEl = el;
          this.container.appendChild(el);
        }

        if (!this._component) {
          this._component = new external_Vue_default.a({
            data: {
              comProps: props
            },
            parent: self.parent,
            el: el,
            mounted: function mounted() {
              this.$nextTick(function () {
                if (ready) {
                  ready.call(self);
                }
              });
            },
            updated: function updated() {
              this.$nextTick(function () {
                if (ready) {
                  ready.call(self);
                }
              });
            },
            render: function render() {
              return self.getComponent(this.comProps);
            }
          });
        } else {
          this._component.comProps = props;
        }
      }
    }
  },
  render: function render() {
    return this.children({
      renderComponent: this.renderComponent,
      removeContainer: this.removeContainer
    });
  }
});
// CONCATENATED MODULE: ./src/components/trigger/Trigger.jsx
function Trigger_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Trigger_defineProperty(target, key, source[key]); }); } return target; }

function Trigger_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }














external_Vue_default.a.use(antRefDirective["a" /* default */]);

function returnEmptyString() {
  return '';
}

function returnDocument() {
  return window.document;
}

var ALL_HANDLERS = ['click', 'mousedown', 'touchstart', 'mouseenter', 'mouseleave', 'focus', 'blur', 'contextmenu'];
/* harmony default export */ var Trigger = ({
  name: 'Trigger',
  props: {
    action: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string)]).def([]),
    showAction: vue_types["a" /* default */].any.def([]),
    hideAction: vue_types["a" /* default */].any.def([]),
    getPopupClassNameFromAlign: vue_types["a" /* default */].any.def(returnEmptyString),
    // onPopupVisibleChange: PropTypes.func.def(noop),
    afterPopupVisibleChange: vue_types["a" /* default */].func.def(utils_noop),
    popup: vue_types["a" /* default */].any,
    popupStyle: vue_types["a" /* default */].object.def({}),
    prefixCls: vue_types["a" /* default */].string.def('rc-trigger-popup'),
    popupClassName: vue_types["a" /* default */].string.def(''),
    popupPlacement: vue_types["a" /* default */].string,
    builtinPlacements: vue_types["a" /* default */].object,
    popupTransitionName: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].object]),
    popupAnimation: vue_types["a" /* default */].any,
    mouseEnterDelay: vue_types["a" /* default */].number.def(0),
    mouseLeaveDelay: vue_types["a" /* default */].number.def(0.1),
    zIndex: vue_types["a" /* default */].number,
    focusDelay: vue_types["a" /* default */].number.def(0),
    blurDelay: vue_types["a" /* default */].number.def(0.15),
    getPopupContainer: vue_types["a" /* default */].func,
    getDocument: vue_types["a" /* default */].func.def(returnDocument),
    forceRender: vue_types["a" /* default */].bool,
    destroyPopupOnHide: vue_types["a" /* default */].bool.def(false),
    mask: vue_types["a" /* default */].bool.def(false),
    maskClosable: vue_types["a" /* default */].bool.def(true),
    // onPopupAlign: PropTypes.func.def(noop),
    popupAlign: vue_types["a" /* default */].object.def({}),
    popupVisible: vue_types["a" /* default */].bool,
    defaultPopupVisible: vue_types["a" /* default */].bool.def(false),
    maskTransitionName: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].object]),
    maskAnimation: vue_types["a" /* default */].string,
    stretch: vue_types["a" /* default */].string,
    alignPoint: vue_types["a" /* default */].bool // Maybe we can support user pass position in the future

  },
  mixins: [BaseMixin["a" /* default */]],
  data: function data() {
    var props = this.$props;
    var popupVisible;

    if (Object(props_util["p" /* hasProp */])(this, 'popupVisible')) {
      popupVisible = !!props.popupVisible;
    } else {
      popupVisible = !!props.defaultPopupVisible;
    }

    return {
      sPopupVisible: popupVisible,
      point: null
    };
  },
  beforeCreate: function beforeCreate() {
    var _this = this;

    ALL_HANDLERS.forEach(function (h) {
      _this["fire".concat(h)] = function (e) {
        _this.fireEvents(h, e);
      };
    });
  },
  mounted: function mounted() {
    var _this2 = this;

    this.$nextTick(function () {
      _this2.renderComponent(null);

      _this2.updatedCal();
    });
  },
  watch: {
    popupVisible: function popupVisible(val) {
      if (val !== undefined) {
        this.sPopupVisible = val;
      }
    },
    sPopupVisible: function sPopupVisible(val) {
      var _this3 = this;

      this.$nextTick(function () {
        _this3.renderComponent(null, function () {
          _this3.afterPopupVisibleChange(val);
        });
      });
    }
  },
  updated: function updated() {
    var _this4 = this;

    this.$nextTick(function () {
      _this4.updatedCal();
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.clearDelayTimer();
    this.clearOutsideHandler();
  },
  methods: {
    updatedCal: function updatedCal() {
      var props = this.$props;
      var state = this.$data; // We must listen to `mousedown` or `touchstart`, edge case:
      // https://github.com/ant-design/ant-design/issues/5804
      // https://github.com/react-component/calendar/issues/250
      // https://github.com/react-component/trigger/issues/50

      if (state.sPopupVisible) {
        var currentDocument;

        if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextmenuToShow())) {
          currentDocument = props.getDocument();
          this.clickOutsideHandler = addEventListenerWrap(currentDocument, 'mousedown', this.onDocumentClick);
        } // always hide on mobile


        if (!this.touchOutsideHandler) {
          currentDocument = currentDocument || props.getDocument();
          this.touchOutsideHandler = addEventListenerWrap(currentDocument, 'touchstart', this.onDocumentClick);
        } // close popup when trigger type contains 'onContextmenu' and document is scrolling.


        if (!this.contextmenuOutsideHandler1 && this.isContextmenuToShow()) {
          currentDocument = currentDocument || props.getDocument();
          this.contextmenuOutsideHandler1 = addEventListenerWrap(currentDocument, 'scroll', this.onContextmenuClose);
        } // close popup when trigger type contains 'onContextmenu' and window is blur.


        if (!this.contextmenuOutsideHandler2 && this.isContextmenuToShow()) {
          this.contextmenuOutsideHandler2 = addEventListenerWrap(window, 'blur', this.onContextmenuClose);
        }
      } else {
        this.clearOutsideHandler();
      }
    },
    onMouseenter: function onMouseenter(e) {
      var mouseEnterDelay = this.$props.mouseEnterDelay;
      this.fireEvents('mouseenter', e);
      this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e);
    },
    onMouseMove: function onMouseMove(e) {
      this.fireEvents('mousemove', e);
      this.setPoint(e);
    },
    onMouseleave: function onMouseleave(e) {
      this.fireEvents('mouseleave', e);
      this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
    },
    onPopupMouseenter: function onPopupMouseenter() {
      this.clearDelayTimer();
    },
    onPopupMouseleave: function onPopupMouseleave(e) {
      if (e && e.relatedTarget && !e.relatedTarget.setTimeout && this._component && this._component.getPopupDomNode && contains(this._component.getPopupDomNode(), e.relatedTarget)) {
        return;
      }

      this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
    },
    onFocus: function onFocus(e) {
      this.fireEvents('focus', e); // incase focusin and focusout

      this.clearDelayTimer();

      if (this.isFocusToShow()) {
        this.focusTime = Date.now();
        this.delaySetPopupVisible(true, this.$props.focusDelay);
      }
    },
    onMousedown: function onMousedown(e) {
      this.fireEvents('mousedown', e);
      this.preClickTime = Date.now();
    },
    onTouchstart: function onTouchstart(e) {
      this.fireEvents('touchstart', e);
      this.preTouchTime = Date.now();
    },
    onBlur: function onBlur(e) {
      this.fireEvents('blur', e);
      this.clearDelayTimer();

      if (this.isBlurToHide()) {
        this.delaySetPopupVisible(false, this.$props.blurDelay);
      }
    },
    onContextmenu: function onContextmenu(e) {
      e.preventDefault();
      this.fireEvents('contextmenu', e);
      this.setPopupVisible(true, e);
    },
    onContextmenuClose: function onContextmenuClose() {
      if (this.isContextmenuToShow()) {
        this.close();
      }
    },
    onClick: function onClick(event) {
      this.fireEvents('click', event); // focus will trigger click

      if (this.focusTime) {
        var preTime;

        if (this.preClickTime && this.preTouchTime) {
          preTime = Math.min(this.preClickTime, this.preTouchTime);
        } else if (this.preClickTime) {
          preTime = this.preClickTime;
        } else if (this.preTouchTime) {
          preTime = this.preTouchTime;
        }

        if (Math.abs(preTime - this.focusTime) < 20) {
          return;
        }

        this.focusTime = 0;
      }

      this.preClickTime = 0;
      this.preTouchTime = 0;

      if (event && event.preventDefault) {
        event.preventDefault();
      }

      if (event && event.domEvent) {
        event.domEvent.preventDefault();
      }

      var nextVisible = !this.$data.sPopupVisible;

      if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) {
        this.setPopupVisible(!this.$data.sPopupVisible, event);
      }
    },
    onDocumentClick: function onDocumentClick(event) {
      if (this.$props.mask && !this.$props.maskClosable) {
        return;
      }

      var target = event.target;
      var root = this.$el;
      var popupNode = this.getPopupDomNode();

      if (!contains(root, target) && !contains(popupNode, target)) {
        this.close();
      }
    },
    getPopupDomNode: function getPopupDomNode() {
      if (this._component && this._component.getPopupDomNode) {
        return this._component.getPopupDomNode();
      }

      return null;
    },
    getRootDomNode: function getRootDomNode() {
      return this.$el; // return this.$el.children[0] || this.$el
    },
    handleGetPopupClassFromAlign: function handleGetPopupClassFromAlign(align) {
      var className = [];
      var props = this.$props;
      var popupPlacement = props.popupPlacement,
          builtinPlacements = props.builtinPlacements,
          prefixCls = props.prefixCls,
          alignPoint = props.alignPoint,
          getPopupClassNameFromAlign = props.getPopupClassNameFromAlign;

      if (popupPlacement && builtinPlacements) {
        className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint));
      }

      if (getPopupClassNameFromAlign) {
        className.push(getPopupClassNameFromAlign(align));
      }

      return className.join(' ');
    },
    getPopupAlign: function getPopupAlign() {
      var props = this.$props;
      var popupPlacement = props.popupPlacement,
          popupAlign = props.popupAlign,
          builtinPlacements = props.builtinPlacements;

      if (popupPlacement && builtinPlacements) {
        return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
      }

      return popupAlign;
    },
    savePopup: function savePopup(node) {
      this._component = node;
    },
    getComponent: function getComponent() {
      var h = this.$createElement;
      var self = this;
      var mouseProps = {};

      if (this.isMouseEnterToShow()) {
        mouseProps.mouseenter = self.onPopupMouseenter;
      }

      if (this.isMouseLeaveToHide()) {
        mouseProps.mouseleave = self.onPopupMouseleave;
      }

      var handleGetPopupClassFromAlign = self.handleGetPopupClassFromAlign,
          getRootDomNode = self.getRootDomNode,
          getContainer = self.getContainer,
          $listeners = self.$listeners;
      var _self$$props = self.$props,
          prefixCls = _self$$props.prefixCls,
          destroyPopupOnHide = _self$$props.destroyPopupOnHide,
          popupClassName = _self$$props.popupClassName,
          action = _self$$props.action,
          popupAnimation = _self$$props.popupAnimation,
          popupTransitionName = _self$$props.popupTransitionName,
          popupStyle = _self$$props.popupStyle,
          mask = _self$$props.mask,
          maskAnimation = _self$$props.maskAnimation,
          maskTransitionName = _self$$props.maskTransitionName,
          zIndex = _self$$props.zIndex,
          stretch = _self$$props.stretch,
          alignPoint = _self$$props.alignPoint;
      var _this$$data = this.$data,
          sPopupVisible = _this$$data.sPopupVisible,
          point = _this$$data.point;
      var align = this.getPopupAlign();
      var popupProps = {
        props: {
          prefixCls: prefixCls,
          destroyPopupOnHide: destroyPopupOnHide,
          visible: sPopupVisible,
          point: alignPoint && point,
          action: action,
          align: align,
          animation: popupAnimation,
          getClassNameFromAlign: handleGetPopupClassFromAlign,
          stretch: stretch,
          getRootDomNode: getRootDomNode,
          mask: mask,
          zIndex: zIndex,
          transitionName: popupTransitionName,
          maskAnimation: maskAnimation,
          maskTransitionName: maskTransitionName,
          getContainer: getContainer,
          popupClassName: popupClassName,
          popupStyle: popupStyle
        },
        on: Trigger_objectSpread({
          align: $listeners.popupAlign || utils_noop
        }, mouseProps),
        directives: [{
          name: 'ant-ref',
          value: this.savePopup
        }]
      };
      return h(Popup, popupProps, [Object(props_util["g" /* getComponentFromProp */])(self, 'popup')]);
    },
    getContainer: function getContainer() {
      var props = this.$props;
      var popupContainer = document.createElement('div'); // Make sure default popup container will never cause scrollbar appearing
      // https://github.com/react-component/trigger/issues/41

      popupContainer.style.position = 'absolute';
      popupContainer.style.top = '0';
      popupContainer.style.left = '0';
      popupContainer.style.width = '100%';
      var mountNode = props.getPopupContainer ? props.getPopupContainer(this.$el) : props.getDocument().body;
      mountNode.appendChild(popupContainer);
      this.popupContainer = popupContainer;
      return popupContainer;
    },
    setPopupVisible: function setPopupVisible(sPopupVisible, event) {
      var alignPoint = this.$props.alignPoint;
      this.clearDelayTimer();

      if (this.$data.sPopupVisible !== sPopupVisible) {
        if (!Object(props_util["p" /* hasProp */])(this, 'popupVisible')) {
          this.setState({
            sPopupVisible: sPopupVisible
          });
        }

        this.$listeners.popupVisibleChange && this.$listeners.popupVisibleChange(sPopupVisible);
      } // Always record the point position since mouseEnterDelay will delay the show


      if (sPopupVisible && alignPoint && event) {
        this.setPoint(event);
      }
    },
    setPoint: function setPoint(point) {
      var alignPoint = this.$props.alignPoint;
      if (!alignPoint || !point) return;
      this.setState({
        point: {
          pageX: point.pageX,
          pageY: point.pageY
        }
      });
    },
    delaySetPopupVisible: function delaySetPopupVisible(visible, delayS, event) {
      var _this5 = this;

      var delay = delayS * 1000;
      this.clearDelayTimer();

      if (delay) {
        var point = event ? {
          pageX: event.pageX,
          pageY: event.pageY
        } : null;
        this.delayTimer = Object(requestAnimationTimeout["b" /* requestAnimationTimeout */])(function () {
          _this5.setPopupVisible(visible, point);

          _this5.clearDelayTimer();
        }, delay);
      } else {
        this.setPopupVisible(visible, event);
      }
    },
    clearDelayTimer: function clearDelayTimer() {
      if (this.delayTimer) {
        Object(requestAnimationTimeout["a" /* cancelAnimationTimeout */])(this.delayTimer);
        this.delayTimer = null;
      }
    },
    clearOutsideHandler: function clearOutsideHandler() {
      if (this.clickOutsideHandler) {
        this.clickOutsideHandler.remove();
        this.clickOutsideHandler = null;
      }

      if (this.contextmenuOutsideHandler1) {
        this.contextmenuOutsideHandler1.remove();
        this.contextmenuOutsideHandler1 = null;
      }

      if (this.contextmenuOutsideHandler2) {
        this.contextmenuOutsideHandler2.remove();
        this.contextmenuOutsideHandler2 = null;
      }

      if (this.touchOutsideHandler) {
        this.touchOutsideHandler.remove();
        this.touchOutsideHandler = null;
      }
    },
    createTwoChains: function createTwoChains(event) {
      var fn = function fn() {};

      var events = this.$listeners;

      if (this.childOriginEvents[event] && events[event]) {
        return this["fire".concat(event)];
      }

      fn = this.childOriginEvents[event] || events[event] || fn;
      return fn;
    },
    isClickToShow: function isClickToShow() {
      var _this$$props = this.$props,
          action = _this$$props.action,
          showAction = _this$$props.showAction;
      return action.indexOf('click') !== -1 || showAction.indexOf('click') !== -1;
    },
    isContextmenuToShow: function isContextmenuToShow() {
      var _this$$props2 = this.$props,
          action = _this$$props2.action,
          showAction = _this$$props2.showAction;
      return action.indexOf('contextmenu') !== -1 || showAction.indexOf('contextmenu') !== -1;
    },
    isClickToHide: function isClickToHide() {
      var _this$$props3 = this.$props,
          action = _this$$props3.action,
          hideAction = _this$$props3.hideAction;
      return action.indexOf('click') !== -1 || hideAction.indexOf('click') !== -1;
    },
    isMouseEnterToShow: function isMouseEnterToShow() {
      var _this$$props4 = this.$props,
          action = _this$$props4.action,
          showAction = _this$$props4.showAction;
      return action.indexOf('hover') !== -1 || showAction.indexOf('mouseenter') !== -1;
    },
    isMouseLeaveToHide: function isMouseLeaveToHide() {
      var _this$$props5 = this.$props,
          action = _this$$props5.action,
          hideAction = _this$$props5.hideAction;
      return action.indexOf('hover') !== -1 || hideAction.indexOf('mouseleave') !== -1;
    },
    isFocusToShow: function isFocusToShow() {
      var _this$$props6 = this.$props,
          action = _this$$props6.action,
          showAction = _this$$props6.showAction;
      return action.indexOf('focus') !== -1 || showAction.indexOf('focus') !== -1;
    },
    isBlurToHide: function isBlurToHide() {
      var _this$$props7 = this.$props,
          action = _this$$props7.action,
          hideAction = _this$$props7.hideAction;
      return action.indexOf('focus') !== -1 || hideAction.indexOf('blur') !== -1;
    },
    forcePopupAlign: function forcePopupAlign() {
      if (this.$data.sPopupVisible && this._component && this._component.$refs.alignInstance) {
        this._component.$refs.alignInstance.forceAlign();
      }
    },
    fireEvents: function fireEvents(type, e) {
      if (this.childOriginEvents[type]) {
        this.childOriginEvents[type](e);
      }

      this.__emit(type, e);
    },
    close: function close() {
      this.setPopupVisible(false);
    }
  },
  render: function render(h) {
    var _this6 = this;

    var sPopupVisible = this.sPopupVisible;
    var children = Object(props_util["c" /* filterEmpty */])(this.$slots["default"]);
    var _this$$props8 = this.$props,
        forceRender = _this$$props8.forceRender,
        alignPoint = _this$$props8.alignPoint;

    if (children.length > 1) {
      _util_warning(false, 'Trigger $slots.default.length > 1, just support only one default', true);
    }

    var child = children[0];
    this.childOriginEvents = Object(props_util["h" /* getEvents */])(child);
    var newChildProps = {
      props: {},
      on: {},
      key: 'trigger'
    };

    if (this.isContextmenuToShow()) {
      newChildProps.on.contextmenu = this.onContextmenu;
    } else {
      newChildProps.on.contextmenu = this.createTwoChains('contextmenu');
    }

    if (this.isClickToHide() || this.isClickToShow()) {
      newChildProps.on.click = this.onClick;
      newChildProps.on.mousedown = this.onMousedown;
      newChildProps.on.touchstart = this.onTouchstart;
    } else {
      newChildProps.on.click = this.createTwoChains('click');
      newChildProps.on.mousedown = this.createTwoChains('mousedown');
      newChildProps.on.touchstart = this.createTwoChains('onTouchstart');
    }

    if (this.isMouseEnterToShow()) {
      newChildProps.on.mouseenter = this.onMouseenter;

      if (alignPoint) {
        newChildProps.on.mousemove = this.onMouseMove;
      }
    } else {
      newChildProps.on.mouseenter = this.createTwoChains('mouseenter');
    }

    if (this.isMouseLeaveToHide()) {
      newChildProps.on.mouseleave = this.onMouseleave;
    } else {
      newChildProps.on.mouseleave = this.createTwoChains('mouseleave');
    }

    if (this.isFocusToShow() || this.isBlurToHide()) {
      newChildProps.on.focus = this.onFocus;
      newChildProps.on.blur = this.onBlur;
    } else {
      newChildProps.on.focus = this.createTwoChains('focus');

      newChildProps.on.blur = function (e) {
        if (e && (!e.relatedTarget || !contains(e.target, e.relatedTarget))) {
          _this6.createTwoChains('blur')(e);
        }
      };
    }

    var trigger = Object(vnode["a" /* cloneElement */])(child, newChildProps);
    return h(ContainerRender, {
      attrs: {
        parent: this,
        visible: sPopupVisible,
        autoMount: false,
        forceRender: forceRender,
        getComponent: this.getComponent,
        getContainer: this.getContainer,
        children: function children(_ref) {
          var renderComponent = _ref.renderComponent;
          _this6.renderComponent = renderComponent;
          return trigger;
        }
      }
    });
  }
});
// CONCATENATED MODULE: ./src/components/trigger/index.js
// based on rc-trigger 2.5.4

/* harmony default export */ var components_trigger = (Trigger);
// CONCATENATED MODULE: ./src/components/vc-menu/placements.js
var placements_autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var placements = {
  topLeft: {
    points: ['bl', 'tl'],
    overflow: placements_autoAdjustOverflow,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: placements_autoAdjustOverflow,
    offset: [0, 7]
  },
  leftTop: {
    points: ['tr', 'tl'],
    overflow: placements_autoAdjustOverflow,
    offset: [-4, 0]
  },
  rightTop: {
    points: ['tl', 'tr'],
    overflow: placements_autoAdjustOverflow,
    offset: [4, 0]
  }
};
/* harmony default export */ var vc_menu_placements = (placements);
// EXTERNAL MODULE: ./src/components/_util/getTransitionProps.js
var getTransitionProps = __webpack_require__(20);

// CONCATENATED MODULE: ./src/components/vc-menu/SubMenu.jsx



function SubMenu_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { SubMenu_typeof = function _typeof(obj) { return typeof obj; }; } else { SubMenu_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return SubMenu_typeof(obj); }

function SubMenu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { SubMenu_defineProperty(target, key, source[key]); }); } return target; }

function SubMenu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













var guid = 0;
var popupPlacementMap = {
  horizontal: 'bottomLeft',
  vertical: 'rightTop',
  'vertical-left': 'rightTop',
  'vertical-right': 'leftTop'
};

var SubMenu_updateDefaultActiveFirst = function updateDefaultActiveFirst(store, eventKey, defaultActiveFirst) {
  var menuId = getMenuIdFromSubMenuEventKey(eventKey);
  var state = store.getState();
  store.setState({
    defaultActiveFirst: SubMenu_objectSpread({}, state.defaultActiveFirst, SubMenu_defineProperty({}, menuId, defaultActiveFirst))
  });
};

var SubMenu = {
  name: 'SubMenu',
  props: {
    parentMenu: vue_types["a" /* default */].object,
    title: vue_types["a" /* default */].any,
    selectedKeys: vue_types["a" /* default */].array.def([]),
    openKeys: vue_types["a" /* default */].array.def([]),
    openChange: vue_types["a" /* default */].func.def(noop),
    rootPrefixCls: vue_types["a" /* default */].string,
    eventKey: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
    multiple: vue_types["a" /* default */].bool,
    active: vue_types["a" /* default */].bool,
    // TODO: remove
    isRootMenu: vue_types["a" /* default */].bool.def(false),
    index: vue_types["a" /* default */].number,
    triggerSubMenuAction: vue_types["a" /* default */].string,
    popupClassName: vue_types["a" /* default */].string,
    getPopupContainer: vue_types["a" /* default */].func,
    test: vue_types["a" /* default */].any,
    forceSubMenuRender: vue_types["a" /* default */].bool,
    openAnimation: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].object]),
    disabled: vue_types["a" /* default */].bool,
    subMenuOpenDelay: vue_types["a" /* default */].number.def(0.1),
    subMenuCloseDelay: vue_types["a" /* default */].number.def(0.1),
    level: vue_types["a" /* default */].number.def(1),
    inlineIndent: vue_types["a" /* default */].number.def(24),
    openTransitionName: vue_types["a" /* default */].string,
    popupOffset: vue_types["a" /* default */].array,
    isOpen: vue_types["a" /* default */].bool,
    store: vue_types["a" /* default */].object,
    mode: vue_types["a" /* default */].oneOf(['horizontal', 'vertical', 'vertical-left', 'vertical-right', 'inline']).def('vertical'),
    manualRef: vue_types["a" /* default */].func.def(noop)
  },
  mixins: [BaseMixin["a" /* default */]],
  isSubMenu: true,
  data: function data() {
    var props = this.$props;
    var store = props.store;
    var eventKey = props.eventKey;
    var defaultActiveFirst = store.getState().defaultActiveFirst;
    var value = false;

    if (defaultActiveFirst) {
      value = defaultActiveFirst[eventKey];
    }

    SubMenu_updateDefaultActiveFirst(store, eventKey, value);
    return {// defaultActiveFirst: false,
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.handleUpdated();
    });
  },
  updated: function updated() {
    var _this2 = this;

    this.$nextTick(function () {
      _this2.handleUpdated();
    });
  },
  beforeDestroy: function beforeDestroy() {
    var eventKey = this.eventKey;

    this.__emit('destroy', eventKey);
    /* istanbul ignore if */


    if (this.minWidthTimeout) {
      Object(requestAnimationTimeout["a" /* cancelAnimationTimeout */])(this.minWidthTimeout);
      this.minWidthTimeout = null;
    }
    /* istanbul ignore if */


    if (this.mouseenterTimeout) {
      Object(requestAnimationTimeout["a" /* cancelAnimationTimeout */])(this.mouseenterTimeout);
      this.mouseenterTimeout = null;
    }
  },
  methods: {
    handleUpdated: function handleUpdated() {
      var _this3 = this;

      var _this$$props = this.$props,
          mode = _this$$props.mode,
          parentMenu = _this$$props.parentMenu,
          manualRef = _this$$props.manualRef; // invoke customized ref to expose component to mixin

      if (manualRef) {
        manualRef(this);
      }

      if (mode !== 'horizontal' || !parentMenu.isRootMenu || !this.isOpen) {
        return;
      }

      this.minWidthTimeout = Object(requestAnimationTimeout["b" /* requestAnimationTimeout */])(function () {
        return _this3.adjustWidth();
      }, 0);
    },
    onKeyDown: function onKeyDown(e) {
      var keyCode = e.keyCode;
      var menu = this.menuInstance;
      var _this$$props2 = this.$props,
          store = _this$$props2.store,
          isOpen = _this$$props2.isOpen;

      if (keyCode === _util_KeyCode.ENTER) {
        this.onTitleClick(e);
        SubMenu_updateDefaultActiveFirst(store, this.eventKey, true);
        return true;
      }

      if (keyCode === _util_KeyCode.RIGHT) {
        if (isOpen) {
          menu.onKeyDown(e);
        } else {
          this.triggerOpenChange(true); // need to update current menu's defaultActiveFirst value

          SubMenu_updateDefaultActiveFirst(store, this.eventKey, true);
        }

        return true;
      }

      if (keyCode === _util_KeyCode.LEFT) {
        var handled;

        if (isOpen) {
          handled = menu.onKeyDown(e);
        } else {
          return undefined;
        }

        if (!handled) {
          this.triggerOpenChange(false);
          handled = true;
        }

        return handled;
      }

      if (isOpen && (keyCode === _util_KeyCode.UP || keyCode === _util_KeyCode.DOWN)) {
        return menu.onKeyDown(e);
      }
    },
    onPopupVisibleChange: function onPopupVisibleChange(visible) {
      this.triggerOpenChange(visible, visible ? 'mouseenter' : 'mouseleave');
    },
    onMouseEnter: function onMouseEnter(e) {
      var _this$$props3 = this.$props,
          key = _this$$props3.eventKey,
          store = _this$$props3.store;
      SubMenu_updateDefaultActiveFirst(store, key, false);

      this.__emit('mouseenter', {
        key: key,
        domEvent: e
      });
    },
    onMouseLeave: function onMouseLeave(e) {
      var eventKey = this.eventKey,
          parentMenu = this.parentMenu;
      parentMenu.subMenuInstance = this; // parentMenu.subMenuLeaveFn = () => {
      // // trigger mouseleave
      //   this.__emit('mouseleave', {
      //     key: eventKey,
      //     domEvent: e,
      //   })
      // }

      this.__emit('mouseleave', {
        key: eventKey,
        domEvent: e
      }); // prevent popup menu and submenu gap
      // parentMenu.subMenuLeaveTimer = setTimeout(parentMenu.subMenuLeaveFn, 100)

    },
    onTitleMouseEnter: function onTitleMouseEnter(domEvent) {
      var key = this.$props.eventKey; // this.clearSubMenuTitleLeaveTimer()

      this.__emit('itemHover', {
        key: key,
        hover: true
      });

      this.__emit('titleMouseenter', {
        key: key,
        domEvent: domEvent
      });
    },
    onTitleMouseLeave: function onTitleMouseLeave(e) {
      var eventKey = this.eventKey,
          parentMenu = this.parentMenu;
      parentMenu.subMenuInstance = this;

      this.__emit('itemHover', {
        key: eventKey,
        hover: false
      });

      this.__emit('titleMouseleave', {
        key: eventKey,
        domEvent: e
      });
    },
    onTitleClick: function onTitleClick(e) {
      var _this$$props4 = this.$props,
          triggerSubMenuAction = _this$$props4.triggerSubMenuAction,
          eventKey = _this$$props4.eventKey,
          isOpen = _this$$props4.isOpen,
          store = _this$$props4.store;
      this.$emit('titleClick', {
        key: eventKey,
        domEvent: e
      });

      if (triggerSubMenuAction === 'hover') {
        return;
      }

      this.triggerOpenChange(!isOpen, 'click');
      SubMenu_updateDefaultActiveFirst(store, eventKey, false);
    },
    onSubMenuClick: function onSubMenuClick(info) {
      this.__emit('click', this.addKeyPath(info));
    },
    getPrefixCls: function getPrefixCls() {
      return "".concat(this.$props.rootPrefixCls, "-submenu");
    },
    getActiveClassName: function getActiveClassName() {
      return "".concat(this.getPrefixCls(), "-active");
    },
    getDisabledClassName: function getDisabledClassName() {
      return "".concat(this.getPrefixCls(), "-disabled");
    },
    getSelectedClassName: function getSelectedClassName() {
      return "".concat(this.getPrefixCls(), "-selected");
    },
    getOpenClassName: function getOpenClassName() {
      return "".concat(this.$props.rootPrefixCls, "-submenu-open");
    },
    saveMenuInstance: function saveMenuInstance(c) {
      // children menu instance
      this.menuInstance = c;
    },
    addKeyPath: function addKeyPath(info) {
      return SubMenu_objectSpread({}, info, {
        keyPath: (info.keyPath || []).concat(this.$props.eventKey)
      });
    },
    // triggerOpenChange (open, type) {
    //   const key = this.$props.eventKey
    //   this.__emit('openChange', {
    //     key,
    //     item: this,
    //     trigger: type,
    //     open,
    //   })
    // },
    triggerOpenChange: function triggerOpenChange(open, type) {
      var _this4 = this;

      var key = this.$props.eventKey;

      var openChange = function openChange() {
        _this4.__emit('openChange', {
          key: key,
          item: _this4,
          trigger: type,
          open: open
        });
      };

      if (type === 'mouseenter') {
        // make sure mouseenter happen after other menu item's mouseleave
        this.mouseenterTimeout = Object(requestAnimationTimeout["b" /* requestAnimationTimeout */])(function () {
          openChange();
        }, 0);
      } else {
        openChange();
      }
    },
    isChildrenSelected: function isChildrenSelected() {
      var ret = {
        find: false
      };
      loopMenuItemRecursively(this.$slots["default"], this.$props.selectedKeys, ret);
      return ret.find;
    },
    // isOpen () {
    //   return this.$props.openKeys.indexOf(this.$props.eventKey) !== -1
    // },
    adjustWidth: function adjustWidth() {
      /* istanbul ignore if */
      if (!this.$refs.subMenuTitle || !this.menuInstance) {
        return;
      }

      var popupMenu = this.menuInstance.$el;

      if (popupMenu.offsetWidth >= this.$refs.subMenuTitle.offsetWidth) {
        return;
      }
      /* istanbul ignore next */


      popupMenu.style.minWidth = "".concat(this.$refs.subMenuTitle.offsetWidth, "px");
    },
    renderChildren: function renderChildren(children) {
      var h = this.$createElement;
      var props = this.$props;
      var _this$$listeners = this.$listeners,
          select = _this$$listeners.select,
          deselect = _this$$listeners.deselect,
          openChange = _this$$listeners.openChange;
      var subPopupMenuProps = {
        props: {
          mode: props.mode === 'horizontal' ? 'vertical' : props.mode,
          visible: props.isOpen,
          level: props.level + 1,
          inlineIndent: props.inlineIndent,
          focusable: false,
          selectedKeys: props.selectedKeys,
          eventKey: "".concat(props.eventKey, "-menu-"),
          openKeys: props.openKeys,
          openTransitionName: props.openTransitionName,
          openAnimation: props.openAnimation,
          subMenuOpenDelay: props.subMenuOpenDelay,
          parentMenu: this,
          subMenuCloseDelay: props.subMenuCloseDelay,
          forceSubMenuRender: props.forceSubMenuRender,
          triggerSubMenuAction: props.triggerSubMenuAction,
          defaultActiveFirst: props.store.getState().defaultActiveFirst[getMenuIdFromSubMenuEventKey(props.eventKey)],
          multiple: props.multiple,
          prefixCls: props.rootPrefixCls,
          manualRef: this.saveMenuInstance,
          children: children,
          __propsSymbol__: Symbol()
        },
        on: {
          click: this.onSubMenuClick,
          select: select,
          deselect: deselect,
          openChange: openChange
        },
        id: this._menuId
      };
      var baseProps = subPopupMenuProps.props;
      var haveRendered = this.haveRendered;
      this.haveRendered = true;
      this.haveOpened = this.haveOpened || baseProps.visible || baseProps.forceSubMenuRender; // never rendered not planning to, don't render

      if (!this.haveOpened) {
        return h("div");
      } // don't show transition on first rendering (no animation for opened menu)
      // show appear transition if it's not visible (not sure why)
      // show appear transition if it's not inline mode


      var transitionAppear = haveRendered || !baseProps.visible || !baseProps.mode === 'inline';
      subPopupMenuProps["class"] = " ".concat(baseProps.prefixCls, "-sub");
      var animProps = {
        appear: transitionAppear
      };
      var transitionProps = {
        props: animProps,
        on: {}
      };

      if (baseProps.openTransitionName) {
        transitionProps = Object(getTransitionProps["a" /* default */])(baseProps.openTransitionName, {
          appear: transitionAppear
        });
      } else if (SubMenu_typeof(baseProps.openAnimation) === 'object') {
        animProps = SubMenu_objectSpread({}, animProps, baseProps.openAnimation.props || {});

        if (!transitionAppear) {
          animProps.appear = false;
        }
      } else if (typeof baseProps.openAnimation === 'string') {
        transitionProps = Object(getTransitionProps["a" /* default */])(baseProps.openAnimation, {
          appear: transitionAppear
        });
      }

      if (SubMenu_typeof(baseProps.openAnimation) === 'object' && baseProps.openAnimation.on) {
        transitionProps.on = SubMenu_objectSpread({}, baseProps.openAnimation.on);
      }

      return h("transition", transitionProps, [h(vc_menu_SubPopupMenu, babel_helper_vue_jsx_merge_props_default()([{
        directives: [{
          name: "show",
          value: props.isOpen
        }]
      }, subPopupMenuProps]))]);
    }
  },
  render: function render(h) {
    var _className;

    var props = this.$props;
    var rootPrefixCls = this.rootPrefixCls,
        parentMenu = this.parentMenu,
        _this$$listeners2 = this.$listeners,
        $listeners = _this$$listeners2 === void 0 ? {} : _this$$listeners2;
    var isOpen = props.isOpen;
    var prefixCls = this.getPrefixCls();
    var isInlineMode = props.mode === 'inline';
    var className = (_className = {}, SubMenu_defineProperty(_className, prefixCls, true), SubMenu_defineProperty(_className, "".concat(prefixCls, "-").concat(props.mode), true), SubMenu_defineProperty(_className, this.getOpenClassName(), isOpen), SubMenu_defineProperty(_className, this.getActiveClassName(), props.active || isOpen && !isInlineMode), SubMenu_defineProperty(_className, this.getDisabledClassName(), props.disabled), SubMenu_defineProperty(_className, this.getSelectedClassName(), this.isChildrenSelected()), _className);

    if (!this._menuId) {
      if (props.eventKey) {
        this._menuId = "".concat(props.eventKey, "$Menu");
      } else {
        this._menuId = "$__$".concat(++guid, "$Menu");
      }
    }

    var mouseEvents = {};
    var titleClickEvents = {};
    var titleMouseEvents = {};

    if (!props.disabled) {
      mouseEvents = {
        mouseleave: this.onMouseLeave,
        mouseenter: this.onMouseEnter // only works in title, not outer li

      };
      titleClickEvents = {
        click: this.onTitleClick
      };
      titleMouseEvents = {
        mouseenter: this.onTitleMouseEnter,
        mouseleave: this.onTitleMouseLeave
      };
    }

    var style = {};

    if (isInlineMode) {
      style.paddingLeft = "".concat(props.inlineIndent * props.level, "px");
    }

    var ariaOwns = {}; // only set aria-owns when menu is open
    // otherwise it would be an invalid aria-owns value
    // since corresponding node cannot be found

    if (isOpen) {
      ariaOwns = {
        'aria-owns': this._menuId
      };
    }

    var titleProps = {
      attrs: SubMenu_objectSpread({
        'aria-expanded': isOpen
      }, ariaOwns, {
        'aria-haspopup': 'true',
        title: typeof props.title === 'string' ? props.title : undefined
      }),
      on: SubMenu_objectSpread({}, titleMouseEvents, titleClickEvents),
      style: style,
      "class": "".concat(prefixCls, "-title"),
      ref: 'subMenuTitle'
    };
    var title = h("div", titleProps, [Object(props_util["g" /* getComponentFromProp */])(this, 'title'), h("i", {
      "class": "".concat(prefixCls, "-arrow")
    })]);
    var children = this.renderChildren(this.$slots["default"]);
    var getPopupContainer = this.parentMenu.isRootMenu ? this.parentMenu.getPopupContainer : function (triggerNode) {
      return triggerNode.parentNode;
    };
    var popupPlacement = popupPlacementMap[props.mode];
    var popupAlign = props.popupOffset ? {
      offset: props.popupOffset
    } : {};
    var popupClassName = props.mode === 'inline' ? '' : props.popupClassName;
    var liProps = {
      on: SubMenu_objectSpread({}, Object(es["a" /* default */])($listeners, ['click']), mouseEvents),
      "class": className
    };
    return h("li", babel_helper_vue_jsx_merge_props_default()([liProps, {
      attrs: {
        role: 'menuitem'
      }
    }]), [isInlineMode && title, isInlineMode && children, !isInlineMode && h(components_trigger, {
      attrs: {
        prefixCls: prefixCls,
        popupClassName: "".concat(prefixCls, "-popup ").concat(rootPrefixCls, "-").concat(parentMenu.theme, " ").concat(popupClassName || ''),
        getPopupContainer: getPopupContainer,
        builtinPlacements: vc_menu_placements,
        popupPlacement: popupPlacement,
        popupVisible: isOpen,
        popupAlign: popupAlign,
        action: props.disabled ? [] : [props.triggerSubMenuAction],
        mouseEnterDelay: props.subMenuOpenDelay,
        mouseLeaveDelay: props.subMenuCloseDelay,
        forceRender: props.forceSubMenuRender // popupTransitionName='rc-menu-open-slide-up'
        // popupAnimation={transitionProps}

      },
      on: {
        "popupVisibleChange": this.onPopupVisibleChange
      }
    }, [h("template", {
      slot: 'popup'
    }, [children]), title])]);
  }
};
var connected = connect(function (_ref, _ref2) {
  var openKeys = _ref.openKeys,
      activeKey = _ref.activeKey,
      selectedKeys = _ref.selectedKeys;
  var eventKey = _ref2.eventKey,
      subMenuKey = _ref2.subMenuKey;
  return {
    isOpen: openKeys.indexOf(eventKey) > -1,
    active: activeKey[subMenuKey] === eventKey,
    selectedKeys: selectedKeys
  };
})(SubMenu);
connected.isSubMenu = true;
/* harmony default export */ var vc_menu_SubMenu = (connected);
// EXTERNAL MODULE: ./node_modules/dom-scroll-into-view/lib/index.js
var dom_scroll_into_view_lib = __webpack_require__(107);
var dom_scroll_into_view_lib_default = /*#__PURE__*/__webpack_require__.n(dom_scroll_into_view_lib);

// CONCATENATED MODULE: ./src/components/vc-menu/MenuItem.jsx


function MenuItem_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { MenuItem_defineProperty(target, key, source[key]); }); } return target; }

function MenuItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var MenuItem_props = {
  attribute: vue_types["a" /* default */].object,
  rootPrefixCls: vue_types["a" /* default */].string,
  eventKey: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
  active: vue_types["a" /* default */].bool,
  selectedKeys: vue_types["a" /* default */].array,
  disabled: vue_types["a" /* default */].bool,
  title: vue_types["a" /* default */].string,
  index: vue_types["a" /* default */].number,
  inlineIndent: vue_types["a" /* default */].number.def(24),
  level: vue_types["a" /* default */].number.def(1),
  mode: vue_types["a" /* default */].oneOf(['horizontal', 'vertical', 'vertical-left', 'vertical-right', 'inline']).def('vertical'),
  parentMenu: vue_types["a" /* default */].object,
  multiple: vue_types["a" /* default */].bool,
  value: vue_types["a" /* default */].any,
  isSelected: vue_types["a" /* default */].bool,
  manualRef: vue_types["a" /* default */].func.def(noop),
  role: vue_types["a" /* default */].any,
  subMenuKey: vue_types["a" /* default */].string // clearSubMenuTimers: PropTypes.func.def(noop),

};
var MenuItem = {
  name: 'MenuItem',
  props: MenuItem_props,
  mixins: [BaseMixin["a" /* default */]],
  isMenuItem: true,
  created: function created() {
    // invoke customized ref to expose component to mixin
    this.callRef();
  },
  updated: function updated() {
    var _this = this;

    this.$nextTick(function () {
      if (_this.active) {
        dom_scroll_into_view_lib_default()(_this.$el, _this.parentMenu.$el, {
          onlyScrollIfNeeded: true
        });
      }
    });
    this.callRef();
  },
  beforeDestroy: function beforeDestroy() {
    var props = this.$props;

    this.__emit('destroy', props.eventKey);
  },
  methods: {
    onKeyDown: function onKeyDown(e) {
      var keyCode = e.keyCode;

      if (keyCode === _util_KeyCode.ENTER) {
        this.onClick(e);
        return true;
      }
    },
    onMouseLeave: function onMouseLeave(e) {
      var eventKey = this.$props.eventKey;

      this.__emit('itemHover', {
        key: eventKey,
        hover: false
      });

      this.__emit('mouseleave', {
        key: eventKey,
        domEvent: e
      });
    },
    onMouseEnter: function onMouseEnter(e) {
      var eventKey = this.eventKey;

      this.__emit('itemHover', {
        key: eventKey,
        hover: true
      });

      this.__emit('mouseenter', {
        key: eventKey,
        domEvent: e
      });
    },
    onClick: function onClick(e) {
      var _this$$props = this.$props,
          eventKey = _this$$props.eventKey,
          multiple = _this$$props.multiple,
          isSelected = _this$$props.isSelected;
      var info = {
        key: eventKey,
        keyPath: [eventKey],
        item: this,
        domEvent: e
      };

      this.__emit('click', info);

      if (multiple) {
        if (isSelected) {
          this.__emit('deselect', info);
        } else {
          this.__emit('select', info);
        }
      } else if (!isSelected) {
        this.__emit('select', info);
      }
    },
    getPrefixCls: function getPrefixCls() {
      return "".concat(this.$props.rootPrefixCls, "-item");
    },
    getActiveClassName: function getActiveClassName() {
      return "".concat(this.getPrefixCls(), "-active");
    },
    getSelectedClassName: function getSelectedClassName() {
      return "".concat(this.getPrefixCls(), "-selected");
    },
    getDisabledClassName: function getDisabledClassName() {
      return "".concat(this.getPrefixCls(), "-disabled");
    },
    callRef: function callRef() {
      if (this.manualRef) {
        this.manualRef(this);
      }
    }
  },
  render: function render() {
    var _className;

    var h = arguments[0];

    var props = MenuItem_objectSpread({}, this.$props);

    var className = (_className = {}, MenuItem_defineProperty(_className, this.getPrefixCls(), true), MenuItem_defineProperty(_className, this.getActiveClassName(), !props.disabled && props.active), MenuItem_defineProperty(_className, this.getSelectedClassName(), props.isSelected), MenuItem_defineProperty(_className, this.getDisabledClassName(), props.disabled), _className);

    var attrs = MenuItem_objectSpread({}, props.attribute, {
      title: props.title,
      role: 'menuitem',
      'aria-disabled': props.disabled
    });

    if (props.role === 'option') {
      // overwrite to option
      attrs = MenuItem_objectSpread({}, attrs, {
        role: 'option',
        'aria-selected': props.isSelected
      });
    } else if (props.role === null) {
      // sometimes we want to specify role inside <li/> element
      // <li><a role='menuitem'>Link</a></li> would be a good example
      delete attrs.role;
    } // In case that onClick/onMouseLeave/onMouseEnter is passed down from owner


    var mouseEvent = {
      click: props.disabled ? noop : this.onClick,
      mouseleave: props.disabled ? noop : this.onMouseLeave,
      mouseenter: props.disabled ? noop : this.onMouseEnter
    };
    var style = {};

    if (props.mode === 'inline') {
      style.paddingLeft = "".concat(props.inlineIndent * props.level, "px");
    }

    var listeners = MenuItem_objectSpread({}, this.$listeners);

    menuAllProps.props.forEach(function (key) {
      return delete props[key];
    });
    menuAllProps.on.forEach(function (key) {
      return delete listeners[key];
    });
    var liProps = {
      attrs: MenuItem_objectSpread({}, props, attrs),
      on: MenuItem_objectSpread({}, listeners, mouseEvent)
    };
    return h("li", babel_helper_vue_jsx_merge_props_default()([liProps, {
      style: style,
      "class": className
    }]), [this.$slots["default"]]);
  }
};
var MenuItem_connected = connect(function (_ref, _ref2) {
  var activeKey = _ref.activeKey,
      selectedKeys = _ref.selectedKeys;
  var eventKey = _ref2.eventKey,
      subMenuKey = _ref2.subMenuKey;
  return {
    active: activeKey[subMenuKey] === eventKey,
    isSelected: selectedKeys.indexOf(eventKey) !== -1
  };
})(MenuItem);
/* harmony default export */ var vc_menu_MenuItem = (MenuItem_connected);

// CONCATENATED MODULE: ./src/components/vc-menu/MenuItemGroup.jsx
function MenuItemGroup_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { MenuItemGroup_defineProperty(target, key, source[key]); }); } return target; }

function MenuItemGroup_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


 // import { menuAllProps } from './util'

var MenuItemGroup = {
  name: 'MenuItemGroup',
  props: {
    renderMenuItem: vue_types["a" /* default */].func,
    index: vue_types["a" /* default */].number,
    className: vue_types["a" /* default */].string,
    subMenuKey: vue_types["a" /* default */].string,
    rootPrefixCls: vue_types["a" /* default */].string,
    disabled: vue_types["a" /* default */].bool.def(true),
    title: vue_types["a" /* default */].any
  },
  isMenuItemGroup: true,
  methods: {
    renderInnerMenuItem: function renderInnerMenuItem(item) {
      var _this$$props = this.$props,
          renderMenuItem = _this$$props.renderMenuItem,
          index = _this$$props.index,
          subMenuKey = _this$$props.subMenuKey;
      return renderMenuItem(item, index, subMenuKey);
    }
  },
  render: function render() {
    var h = arguments[0];

    var props = MenuItemGroup_objectSpread({}, this.$props);

    var rootPrefixCls = props.rootPrefixCls,
        title = props.title;
    var titleClassName = "".concat(rootPrefixCls, "-item-group-title");
    var listClassName = "".concat(rootPrefixCls, "-item-group-list"); // menuAllProps.props.forEach(key => delete props[key])

    var listeners = MenuItemGroup_objectSpread({}, this.$listeners);

    delete listeners.click;
    return h("li", {
      on: listeners,
      "class": "".concat(rootPrefixCls, "-item-group")
    }, [h("div", {
      "class": titleClassName,
      attrs: {
        title: typeof title === 'string' ? title : undefined
      }
    }, [Object(props_util["g" /* getComponentFromProp */])(this, 'title')]), h("ul", {
      "class": listClassName
    }, [this.$slots["default"] && this.$slots["default"].map(this.renderInnerMenuItem)])]);
  }
};
/* harmony default export */ var vc_menu_MenuItemGroup = (MenuItemGroup);
// CONCATENATED MODULE: ./src/components/vc-menu/Divider.jsx
/* harmony default export */ var Divider = ({
  name: 'MenuDivider',
  props: {
    disabled: {
      type: Boolean,
      "default": true
    },
    rootPrefixCls: String
  },
  render: function render() {
    var h = arguments[0];
    var rootPrefixCls = this.$props.rootPrefixCls;
    return h("li", {
      "class": "".concat(rootPrefixCls, "-item-divider")
    });
  }
});
// CONCATENATED MODULE: ./src/components/vc-menu/index.js
// based on rc-menu 7.0.5






/* harmony default export */ var vc_menu = (vc_menu_Menu);
// CONCATENATED MODULE: ./src/components/vc-select/Option.jsx

/* harmony default export */ var Option = ({
  props: {
    value: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
    disabled: vue_types["a" /* default */].bool,
    title: vue_types["a" /* default */].string
  },
  isSelectOption: true
});
// CONCATENATED MODULE: ./src/components/vc-select/util.js
function vc_select_util_typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { vc_select_util_typeof2 = function _typeof2(obj) { return typeof obj; }; } else { vc_select_util_typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return vc_select_util_typeof2(obj); }

function vc_select_util_typeof(obj) {
  if (typeof Symbol === "function" && vc_select_util_typeof2(Symbol.iterator) === "symbol") {
    vc_select_util_typeof = function _typeof(obj) {
      return vc_select_util_typeof2(obj);
    };
  } else {
    vc_select_util_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : vc_select_util_typeof2(obj);
    };
  }

  return vc_select_util_typeof(obj);
}



function toTitle(title) {
  if (typeof title === 'string') {
    return title;
  }

  return null;
}
function getValuePropValue(child) {
  if (!child) {
    return null;
  }

  var props = Object(props_util["k" /* getPropsData */])(child);

  if ('value' in props) {
    return props.value;
  }

  if (Object(props_util["i" /* getKey */])(child) !== undefined) {
    return Object(props_util["i" /* getKey */])(child);
  }

  if (Object(props_util["l" /* getSlotOptions */])(child).isSelectOptGroup) {
    var label = Object(props_util["g" /* getComponentFromProp */])(child, 'label');

    if (label) {
      return label;
    }
  }

  throw new Error("Need at least a key or a value or a label(slot) (only for OptGroup) for ".concat(child));
}
function getPropValue(child, prop) {
  if (prop === 'value') {
    return getValuePropValue(child);
  }

  if (prop === 'children') {
    var newChild = child.$slots ? Object(vnode["b" /* cloneVNodes */])(child.$slots["default"], true) : Object(vnode["b" /* cloneVNodes */])(child.componentOptions.children, true);

    if (newChild.length === 1 && !newChild[0].tag) {
      return newChild[0].text;
    }

    return newChild;
  }

  var data = Object(props_util["k" /* getPropsData */])(child);

  if (prop in data) {
    return data[prop];
  } else {
    return Object(props_util["e" /* getAttrs */])(child)[prop];
  }
}
function isMultiple(props) {
  return props.multiple;
}
function isCombobox(props) {
  return props.combobox;
}
function isMultipleOrTags(props) {
  return props.multiple || props.tags;
}
function isMultipleOrTagsOrCombobox(props) {
  return isMultipleOrTags(props) || isCombobox(props);
}
function isSingleMode(props) {
  return !isMultipleOrTagsOrCombobox(props);
}
function toArray(value) {
  var ret = value;

  if (value === undefined) {
    ret = [];
  } else if (!Array.isArray(value)) {
    ret = [value];
  }

  return ret;
}
function getMapKey(value) {
  return "".concat(vc_select_util_typeof(value), "-").concat(value);
}
function preventDefaultEvent(e) {
  e.preventDefault();
}
function findIndexInValueBySingleValue(value, singleValue) {
  var index = -1;

  for (var i = 0; i < value.length; i++) {
    if (value[i] === singleValue) {
      index = i;
      break;
    }
  }

  return index;
}
function getLabelFromPropsValue(value, key) {
  var label;
  value = toArray(value);

  for (var i = 0; i < value.length; i++) {
    if (value[i].key === key) {
      label = value[i].label;
      break;
    }
  }

  return label;
}
function getSelectKeys(menuItems, value) {
  if (value === null || value === undefined) {
    return [];
  }

  var selectedKeys = [];
  menuItems.forEach(function (item) {
    if (Object(props_util["l" /* getSlotOptions */])(item).isMenuItemGroup) {
      selectedKeys = selectedKeys.concat(getSelectKeys(item.componentOptions.children, value));
    } else {
      var itemValue = getValuePropValue(item);
      var itemKey = item.key;

      if (findIndexInValueBySingleValue(value, itemValue) !== -1 && itemKey !== undefined) {
        selectedKeys.push(itemKey);
      }
    }
  });
  return selectedKeys;
}
var UNSELECTABLE_STYLE = {
  userSelect: 'none',
  WebkitUserSelect: 'none'
};
var UNSELECTABLE_ATTRIBUTE = {
  unselectable: 'on'
};
function findFirstMenuItem(children) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    var props = Object(props_util["k" /* getPropsData */])(child);

    if (Object(props_util["l" /* getSlotOptions */])(child).isMenuItemGroup) {
      var found = findFirstMenuItem(child.componentOptions.children);

      if (found) {
        return found;
      }
    } else if (!props.disabled) {
      return child;
    }
  }

  return null;
}
function includesSeparators(string, separators) {
  for (var i = 0; i < separators.length; ++i) {
    if (string.lastIndexOf(separators[i]) > 0) {
      return true;
    }
  }

  return false;
}
function splitBySeparators(string, separators) {
  var reg = new RegExp("[".concat(separators.join(), "]"));
  return string.split(reg).filter(function (token) {
    return token;
  });
}
function defaultFilterFn(input, child) {
  var props = Object(props_util["k" /* getPropsData */])(child);

  if (props.disabled) {
    return false;
  }

  var value = getPropValue(child, this.optionFilterProp);

  if (value.length && value[0].text) {
    value = value[0].text;
  } else {
    value = String(value);
  }

  return value.toLowerCase().indexOf(input.toLowerCase()) > -1;
}
function validateOptionValue(value, props) {
  if (isSingleMode(props) || isMultiple(props)) {
    return;
  }

  if (typeof value !== 'string') {
    throw new Error("Invalid `value` of type `".concat(vc_select_util_typeof(value), "` supplied to Option, ") + "expected `string` when `tags/combobox` is `true`.");
  }
}
function util_saveRef(instance, name) {
  return function (node) {
    instance[name] = node;
  };
}
// CONCATENATED MODULE: ./src/components/vc-select/DropdownMenu.jsx
function DropdownMenu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { DropdownMenu_defineProperty(target, key, source[key]); }); } return target; }

function DropdownMenu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









/* harmony default export */ var DropdownMenu = ({
  name: 'DropdownMenu',
  mixins: [BaseMixin["a" /* default */]],
  props: {
    defaultActiveFirstOption: vue_types["a" /* default */].bool,
    value: vue_types["a" /* default */].any,
    dropdownMenuStyle: vue_types["a" /* default */].object,
    multiple: vue_types["a" /* default */].bool,
    // onPopupFocus: PropTypes.func,
    // onPopupScroll: PropTypes.func,
    // onMenuDeSelect: PropTypes.func,
    // onMenuSelect: PropTypes.func,
    prefixCls: vue_types["a" /* default */].string,
    menuItems: vue_types["a" /* default */].any,
    inputValue: vue_types["a" /* default */].string,
    visible: vue_types["a" /* default */].bool,
    backfillValue: vue_types["a" /* default */].any
  },
  beforeMount: function beforeMount() {
    this.lastInputValue = this.$props.inputValue;
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.scrollActiveItemToView();
    });
    this.lastVisible = this.$props.visible;
  },
  watch: {
    visible: function visible(val) {
      if (!val) {
        this.lastVisible = val;
      }
    }
  },
  updated: function updated() {
    var _this2 = this;

    var props = this.$props;

    if (!this.prevVisible && props.visible) {
      this.$nextTick(function () {
        _this2.scrollActiveItemToView();
      });
    }

    this.lastVisible = props.visible;
    this.lastInputValue = props.inputValue;
    this.prevVisible = this.visible;
  },
  methods: {
    scrollActiveItemToView: function scrollActiveItemToView() {
      var _this3 = this;

      // scroll into view
      var itemComponent = this.firstActiveItem && this.firstActiveItem.$el;
      var props = this.$props;

      if (itemComponent) {
        var scrollIntoViewOpts = {
          onlyScrollIfNeeded: true
        };

        if ((!props.value || props.value.length === 0) && props.firstActiveValue) {
          scrollIntoViewOpts.alignWithTop = true;
        } // Delay to scroll since current frame item position is not ready when pre view is by filter
        // https://github.com/ant-design/ant-design/issues/11268#issuecomment-406634462


        raf_default()(function () {
          dom_scroll_into_view_lib_default()(itemComponent, _this3.$refs.menuRef.$el, scrollIntoViewOpts);
        });
      }
    },
    renderMenu: function renderMenu() {
      var _this4 = this;

      var h = this.$createElement;
      var props = this.$props;
      var menuItems = props.menuItems,
          defaultActiveFirstOption = props.defaultActiveFirstOption,
          value = props.value,
          prefixCls = props.prefixCls,
          multiple = props.multiple,
          inputValue = props.inputValue,
          firstActiveValue = props.firstActiveValue,
          dropdownMenuStyle = props.dropdownMenuStyle,
          backfillValue = props.backfillValue;
      var _this$$listeners = this.$listeners,
          menuDeselect = _this$$listeners.menuDeselect,
          menuSelect = _this$$listeners.menuSelect,
          popupScroll = _this$$listeners.popupScroll;

      if (menuItems && menuItems.length) {
        var selectedKeys = getSelectKeys(menuItems, value);
        var menuProps = {
          props: {
            multiple: multiple,
            defaultActiveFirst: defaultActiveFirstOption,
            selectedKeys: selectedKeys,
            prefixCls: "".concat(prefixCls, "-menu")
          },
          on: {},
          style: dropdownMenuStyle,
          ref: 'menuRef',
          attrs: {
            role: 'listbox'
          }
        };

        if (popupScroll) {
          menuProps.on.scroll = popupScroll;
        }

        if (multiple) {
          menuProps.on.deselect = menuDeselect;
          menuProps.on.select = menuSelect;
        } else {
          menuProps.on.click = menuSelect;
        }

        var activeKeyProps = {};
        var clonedMenuItems = menuItems;

        if (selectedKeys.length || firstActiveValue) {
          if (props.visible && !this.lastVisible) {
            activeKeyProps.activeKey = selectedKeys[0] !== undefined ? selectedKeys[0] : firstActiveValue;
          }

          var foundFirst = false; // set firstActiveItem via cloning menus
          // for scroll into view

          var clone = function clone(item) {
            if (!foundFirst && selectedKeys.indexOf(item.key) !== -1 || !foundFirst && !selectedKeys.length && firstActiveValue.indexOf(item.key) !== -1) {
              foundFirst = true;
              return Object(vnode["a" /* cloneElement */])(item, {
                directives: [{
                  name: 'ref',
                  value: function value(ref) {
                    _this4.firstActiveItem = ref;
                  }
                }]
              });
            }

            return item;
          };

          clonedMenuItems = menuItems.map(function (item) {
            if (Object(props_util["l" /* getSlotOptions */])(item).isMenuItemGroup) {
              var children = item.componentOptions.children.map(clone);
              return Object(vnode["a" /* cloneElement */])(item, {
                children: children
              });
            }

            return clone(item);
          });
        } else {
          // Clear firstActiveItem when dropdown menu items was empty
          // Avoid `Unable to find node on an unmounted component`
          // https://github.com/ant-design/ant-design/issues/10774
          this.firstActiveItem = null;
        } // clear activeKey when inputValue change


        var lastValue = value && value[value.length - 1];

        if (inputValue !== this.lastInputValue && (!lastValue || lastValue !== backfillValue)) {
          activeKeyProps.activeKey = '';
        }

        menuProps.props = DropdownMenu_objectSpread({}, activeKeyProps, menuProps.props);
        return h(vc_menu, menuProps, [clonedMenuItems]);
      }

      return null;
    }
  },
  render: function render() {
    var h = arguments[0];
    var renderMenu = this.renderMenu();
    var _this$$listeners2 = this.$listeners,
        popupFocus = _this$$listeners2.popupFocus,
        popupScroll = _this$$listeners2.popupScroll;
    return renderMenu ? h("div", {
      style: {
        overflow: 'auto'
      },
      on: {
        "focus": popupFocus,
        "mousedown": preventDefaultEvent,
        "scroll": popupScroll
      },
      ref: 'menuContainer'
    }, [renderMenu]) : null;
  }
});
// CONCATENATED MODULE: ./src/components/vc-select/SelectTrigger.jsx
function SelectTrigger_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { SelectTrigger_defineProperty(target, key, source[key]); }); } return target; }

function SelectTrigger_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var BUILT_IN_PLACEMENTS = {
  bottomLeft: {
    points: ['tl', 'bl'],
    offset: [0, 4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topLeft: {
    points: ['bl', 'tl'],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
/* harmony default export */ var SelectTrigger = ({
  name: 'SelectTrigger',
  mixins: [BaseMixin["a" /* default */]],
  props: {
    // onPopupFocus: PropTypes.func,
    // onPopupScroll: PropTypes.func,
    dropdownMatchSelectWidth: vue_types["a" /* default */].bool,
    defaultActiveFirstOption: vue_types["a" /* default */].bool,
    dropdownAlign: vue_types["a" /* default */].object,
    visible: vue_types["a" /* default */].bool,
    disabled: vue_types["a" /* default */].bool,
    showSearch: vue_types["a" /* default */].bool,
    dropdownClassName: vue_types["a" /* default */].string,
    dropdownStyle: vue_types["a" /* default */].object,
    dropdownMenuStyle: vue_types["a" /* default */].object,
    multiple: vue_types["a" /* default */].bool,
    inputValue: vue_types["a" /* default */].string,
    filterOption: vue_types["a" /* default */].any,
    options: vue_types["a" /* default */].any,
    prefixCls: vue_types["a" /* default */].string,
    popupClassName: vue_types["a" /* default */].string,
    value: vue_types["a" /* default */].array,
    // children: PropTypes.any,
    showAction: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
    combobox: vue_types["a" /* default */].bool,
    animation: vue_types["a" /* default */].string,
    transitionName: vue_types["a" /* default */].string,
    getPopupContainer: vue_types["a" /* default */].func,
    backfillValue: vue_types["a" /* default */].any
  },
  created: function created() {
    this.saveDropdownMenuRef = util_saveRef(this, 'dropdownMenuRef');
    this.saveTriggerRef = util_saveRef(this, 'triggerRef');
  },
  data: function data() {
    return {
      dropdownWidth: null
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.setDropdownWidth();
    });
  },
  updated: function updated() {
    var _this2 = this;

    this.$nextTick(function () {
      _this2.setDropdownWidth();
    });
  },
  methods: {
    setDropdownWidth: function setDropdownWidth() {
      var width = this.$el.offsetWidth;

      if (width !== this.dropdownWidth) {
        this.setState({
          dropdownWidth: width
        });
      }
    },
    getInnerMenu: function getInnerMenu() {
      return this.dropdownMenuRef && this.dropdownMenuRef.$refs.menuRef;
    },
    getPopupDOMNode: function getPopupDOMNode() {
      return this.triggerRef.getPopupDomNode();
    },
    getDropdownElement: function getDropdownElement(newProps) {
      var h = this.$createElement;
      var value = this.value,
          firstActiveValue = this.firstActiveValue,
          defaultActiveFirstOption = this.defaultActiveFirstOption,
          dropdownMenuStyle = this.dropdownMenuStyle,
          getDropdownPrefixCls = this.getDropdownPrefixCls,
          backfillValue = this.backfillValue;
      var _this$$listeners = this.$listeners,
          menuSelect = _this$$listeners.menuSelect,
          menuDeselect = _this$$listeners.menuDeselect,
          popupScroll = _this$$listeners.popupScroll;
      var dropdownMenuProps = {
        props: SelectTrigger_objectSpread({}, newProps.props, {
          prefixCls: getDropdownPrefixCls(),
          value: value,
          firstActiveValue: firstActiveValue,
          defaultActiveFirstOption: defaultActiveFirstOption,
          dropdownMenuStyle: dropdownMenuStyle,
          backfillValue: backfillValue
        }),
        on: SelectTrigger_objectSpread({}, newProps.on, {
          menuSelect: menuSelect,
          menuDeselect: menuDeselect,
          popupScroll: popupScroll
        }),
        directives: [{
          name: 'ref',
          value: this.saveDropdownMenuRef
        }]
      };
      return h(DropdownMenu, dropdownMenuProps);
    },
    getDropdownTransitionName: function getDropdownTransitionName() {
      var props = this.$props;
      var transitionName = props.transitionName;

      if (!transitionName && props.animation) {
        transitionName = "".concat(this.getDropdownPrefixCls(), "-").concat(props.animation);
      }

      return transitionName;
    },
    getDropdownPrefixCls: function getDropdownPrefixCls() {
      return "".concat(this.prefixCls, "-dropdown");
    }
  },
  render: function render() {
    var _popupClassName;

    var h = arguments[0];
    var $props = this.$props,
        $slots = this.$slots,
        $listeners = this.$listeners;
    var multiple = $props.multiple,
        visible = $props.visible,
        inputValue = $props.inputValue,
        dropdownAlign = $props.dropdownAlign,
        disabled = $props.disabled,
        showSearch = $props.showSearch,
        dropdownClassName = $props.dropdownClassName,
        dropdownStyle = $props.dropdownStyle,
        dropdownMatchSelectWidth = $props.dropdownMatchSelectWidth,
        options = $props.options,
        getPopupContainer = $props.getPopupContainer,
        showAction = $props.showAction;
    var mouseenter = $listeners.mouseenter,
        mouseleave = $listeners.mouseleave,
        popupFocus = $listeners.popupFocus,
        dropdownVisibleChange = $listeners.dropdownVisibleChange;
    var dropdownPrefixCls = this.getDropdownPrefixCls();
    var popupClassName = (_popupClassName = {}, SelectTrigger_defineProperty(_popupClassName, dropdownClassName, !!dropdownClassName), SelectTrigger_defineProperty(_popupClassName, "".concat(dropdownPrefixCls, "--").concat(multiple ? 'multiple' : 'single'), 1), _popupClassName);
    var popupElement = this.getDropdownElement({
      props: {
        menuItems: options,
        multiple: multiple,
        inputValue: inputValue,
        visible: visible
      },
      on: {
        popupFocus: popupFocus
      }
    });
    var hideAction;

    if (disabled) {
      hideAction = [];
    } else if (isSingleMode($props) && !showSearch) {
      hideAction = ['click'];
    } else {
      hideAction = ['blur'];
    }

    var popupStyle = SelectTrigger_objectSpread({}, dropdownStyle);

    var widthProp = dropdownMatchSelectWidth ? 'width' : 'minWidth';

    if (this.dropdownWidth) {
      popupStyle[widthProp] = "".concat(this.dropdownWidth, "px");
    }

    var triggerProps = {
      props: SelectTrigger_objectSpread({}, $props, {
        showAction: disabled ? [] : showAction,
        hideAction: hideAction,
        ref: 'triggerRef',
        popupPlacement: 'bottomLeft',
        builtinPlacements: BUILT_IN_PLACEMENTS,
        prefixCls: dropdownPrefixCls,
        popupTransitionName: this.getDropdownTransitionName(),
        popupAlign: dropdownAlign,
        popupVisible: visible,
        getPopupContainer: getPopupContainer,
        popupClassName: classnames_default()(popupClassName),
        popupStyle: popupStyle
      }),
      on: {
        popupVisibleChange: dropdownVisibleChange
      },
      directives: [{
        name: 'ref',
        value: this.saveTriggerRef
      }]
    };

    if (mouseenter) {
      triggerProps.on.mouseenter = mouseenter;
    }

    if (mouseleave) {
      triggerProps.on.mouseleave = mouseleave;
    }

    return h(components_trigger, triggerProps, [$slots["default"], h("template", {
      slot: 'popup'
    }, [popupElement])]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-select/PropTypes.js

var SelectPropTypes = {
  defaultActiveFirstOption: vue_types["a" /* default */].bool,
  multiple: vue_types["a" /* default */].bool,
  filterOption: vue_types["a" /* default */].any,
  // children: PropTypes.any,
  showSearch: vue_types["a" /* default */].bool,
  disabled: vue_types["a" /* default */].bool,
  allowClear: vue_types["a" /* default */].bool,
  showArrow: vue_types["a" /* default */].bool,
  tags: vue_types["a" /* default */].bool,
  prefixCls: vue_types["a" /* default */].string,
  // className: PropTypes.string,
  transitionName: vue_types["a" /* default */].string,
  optionLabelProp: vue_types["a" /* default */].string,
  optionFilterProp: vue_types["a" /* default */].string,
  animation: vue_types["a" /* default */].string,
  choiceTransitionName: vue_types["a" /* default */].string,
  // onChange: PropTypes.func,
  // onBlur: PropTypes.func,
  // onFocus: PropTypes.func,
  // onSelect: PropTypes.func,
  // onSearch: PropTypes.func,
  // onPopupScroll: PropTypes.func,
  // onMouseEnter: PropTypes.func,
  // onMouseLeave: PropTypes.func,
  // onInputKeyDown: PropTypes.func,
  placeholder: vue_types["a" /* default */].any,
  // onDeselect: PropTypes.func,
  labelInValue: vue_types["a" /* default */].bool,
  value: vue_types["a" /* default */].any,
  defaultValue: vue_types["a" /* default */].any,
  dropdownStyle: vue_types["a" /* default */].object,
  dropdownClassName: vue_types["a" /* default */].string,
  maxTagTextLength: vue_types["a" /* default */].number,
  maxTagCount: vue_types["a" /* default */].number,
  maxTagPlaceholder: vue_types["a" /* default */].any,
  tokenSeparators: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
  getInputElement: vue_types["a" /* default */].func,
  showAction: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
  autoFocus: vue_types["a" /* default */].bool,
  getPopupContainer: vue_types["a" /* default */].func
};
// CONCATENATED MODULE: ./src/components/vc-select/Select.jsx






function Select_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Select_defineProperty(target, key, source[key]); }); } return target; }

function Select_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


















external_Vue_default.a.use(antRefDirective["a" /* default */]);

function Select_noop() {}

function chaining() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    // eslint-disable-line
    // eslint-disable-line
    for (var i = 0; i < fns.length; i++) {
      if (fns[i] && typeof fns[i] === 'function') {
        fns[i].apply(this, args);
      }
    }
  };
}

var Select_Select = {
  inheritAttrs: false,
  name: 'Select',
  mixins: [BaseMixin["a" /* default */]],
  props: Select_objectSpread({}, SelectPropTypes, {
    prefixCls: SelectPropTypes.prefixCls.def('rc-select'),
    defaultOpen: vue_types["a" /* default */].bool.def(false),
    labelInValue: SelectPropTypes.labelInValue.def(false),
    defaultActiveFirstOption: SelectPropTypes.defaultActiveFirstOption.def(true),
    showSearch: SelectPropTypes.showSearch.def(true),
    allowClear: SelectPropTypes.allowClear.def(false),
    placeholder: SelectPropTypes.placeholder.def(''),
    showArrow: SelectPropTypes.showArrow.def(true),
    dropdownMatchSelectWidth: vue_types["a" /* default */].bool.def(true),
    dropdownStyle: SelectPropTypes.dropdownStyle.def({}),
    dropdownMenuStyle: vue_types["a" /* default */].object.def({}),
    optionFilterProp: SelectPropTypes.optionFilterProp.def('value'),
    optionLabelProp: SelectPropTypes.optionLabelProp.def('value'),
    notFoundContent: vue_types["a" /* default */].any.def('Not Found'),
    backfill: vue_types["a" /* default */].bool.def(false),
    showAction: SelectPropTypes.showAction.def(['click']),
    combobox: vue_types["a" /* default */].bool.def(false),
    tokenSeparators: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string).def([]),
    autoClearSearchValue: vue_types["a" /* default */].bool.def(true) // onChange: noop,
    // onFocus: noop,
    // onBlur: noop,
    // onSelect: noop,
    // onSearch: noop,
    // onDeselect: noop,
    // onInputKeydown: noop,

  }),
  model: {
    prop: 'value',
    event: 'change'
  },
  created: function created() {
    this.saveInputRef = util_saveRef(this, 'inputRef');
    this.saveInputMirrorRef = util_saveRef(this, 'inputMirrorRef');
    this.saveTopCtrlRef = util_saveRef(this, 'topCtrlRef');
    this.saveSelectTriggerRef = util_saveRef(this, 'selectTriggerRef');
    this.saveRootRef = util_saveRef(this, 'rootRef');
    this.saveSelectionRef = util_saveRef(this, 'selectionRef');
  },
  data: function data() {
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var optionsInfo = this.getOptionsInfoFromProps(props);
    browser_default()(this.__propsSymbol__, 'Replace slots.default with props.children and pass props.__propsSymbol__');
    return {
      _value: this.getValueFromProps(props, true),
      // true: use default value
      _inputValue: props.combobox ? this.getInputValueForCombobox(props, optionsInfo, true // use default value
      ) : '',
      _open: props.defaultOpen,
      _optionsInfo: optionsInfo,
      // a flag for aviod redundant getOptionsInfoFromProps call
      _skipBuildOptionsInfo: true
    };
  },
  beforeMount: function beforeMount() {
    var state = this.getDerivedStateFromProps(Object(props_util["j" /* getOptionProps */])(this), this.$data);
    Object.assign(this.$data, state);
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.autoFocus && _this.focus();
    });
  },
  watch: {
    __propsSymbol__: function __propsSymbol__() {
      Object.assign(this.$data, this.getDerivedStateFromProps(Object(props_util["j" /* getOptionProps */])(this), this.$data));
    } // value (val) {
    //   let sValue = toArray(val)
    //   if (this.labelInValue) {
    //     sValue.forEach(v => {
    //       v.key = v.key !== undefined ? v.key : v.value
    //     })
    //   } else {
    //     sValue = sValue.map(v => {
    //       return {
    //         key: v,
    //       }
    //     })
    //   }
    //   this.sValue = sValue
    //   this.initLabelAndTitleMap(sValue)
    //   sValue.forEach((val) => {
    //     const key = val.key
    //     let { label, title } = val
    //     label = label === undefined ? this.labelMap.get(key) : label
    //     title = title === undefined ? this.titleMap.get(key) : title
    //     this.labelMap.set(key, label === undefined ? key : label)
    //     this.titleMap.set(key, title)
    //   })
    //   if (this.combobox) {
    //     this.setState({
    //       _inputValue: sValue.length ? this.labelMap.get((sValue[0].key)) : '',
    //     })
    //   }
    // },
    // combobox (val) {
    //   if (val) {
    //     this.setState({
    //       _inputValue: this.sValue.length ? this.labelMap.get((this.sValue[0].key)) : '',
    //     })
    //   }
    // },

  },
  updated: function updated() {
    var _this2 = this;

    this.$nextTick(function () {
      if (isMultipleOrTags(_this2.$props)) {
        var inputNode = _this2.getInputDOMNode();

        var mirrorNode = _this2.getInputMirrorDOMNode();

        if (inputNode.value) {
          inputNode.style.width = '';
          inputNode.style.width = "".concat(mirrorNode.clientWidth + 10, "px");
        } else {
          inputNode.style.width = '';
        }
      }

      _this2.forcePopupAlign();
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.clearFocusTime();
    this.clearBlurTime();

    if (this.dropdownContainer) {
      document.body.removeChild(this.dropdownContainer);
      this.dropdownContainer = null;
    }
  },
  methods: {
    getDerivedStateFromProps: function getDerivedStateFromProps(nextProps, prevState) {
      var optionsInfo = prevState._skipBuildOptionsInfo ? prevState._optionsInfo : this.getOptionsInfoFromProps(nextProps, prevState);
      var newState = {
        _optionsInfo: optionsInfo,
        _skipBuildOptionsInfo: false
      };

      if ('open' in nextProps) {
        newState._open = nextProps.open;
      }

      if ('value' in nextProps) {
        var value = this.getValueFromProps(nextProps);
        newState._value = value;

        if (nextProps.combobox) {
          newState._inputValue = this.getInputValueForCombobox(nextProps, optionsInfo);
        }
      }

      return newState;
    },
    // initLabelAndTitleMap (sValue) {
    //   // 保留已选中的label and title
    //   const labelArr = []
    //   const titleArr = []
    //   const values = sValue || this.sValue
    //   values.forEach((val) => {
    //     const key = val.key
    //     let { label, title } = val
    //     label = label === undefined ? this.labelMap.get(key) : label
    //     title = title === undefined ? this.titleMap.get(key) : title
    //     title = typeof title === 'string' ? title.trim() : title
    //     labelArr.push([key, label === undefined ? key : label])
    //     titleArr.push([key, title])
    //   })
    //   this.labelMap = new Map(labelArr)
    //   this.titleMap = new Map(titleArr)
    //   this.updateLabelAndTitleMap(this.$props.children)
    // },
    // updateLabelAndTitleMap (children = []) {
    //   children.forEach(child => {
    //     if (!child.data || child.data.slot !== undefined) {
    //       return
    //     }
    //     if (getSlotOptions(child).isSelectOptGroup) {
    //       this.updateLabelAndTitleMap(child.componentOptions.children)
    //     } else {
    //       const key = getValuePropValue(child)
    //       this.titleMap.set(key, getValue(child, 'title'))
    //       this.labelMap.set(key, this.getLabelFromOption(child))
    //     }
    //   })
    // },
    onInputChange: function onInputChange(event) {
      var tokenSeparators = this.$props.tokenSeparators;
      var val = event.target.value;

      if (isMultipleOrTags(this.$props) && tokenSeparators.length && includesSeparators(val, tokenSeparators)) {
        var nextValue = this.getValueByInput(val);

        if (nextValue !== undefined) {
          this.fireChange(nextValue);
        }

        this.setOpenState(false, true);
        this.setInputValue('', false);
        return;
      }

      this.setInputValue(val);
      this.setState({
        _open: true
      });

      if (isCombobox(this.$props)) {
        this.fireChange([val]);
      }
    },
    onDropdownVisibleChange: function onDropdownVisibleChange(open) {
      if (open && !this._focused) {
        this.clearBlurTime();
        this.timeoutFocus();
        this._focused = true;
        this.updateFocusClassName();
      }

      this.setOpenState(open);
    },
    // combobox ignore
    onKeyDown: function onKeyDown(event) {
      var props = this.$props;

      if (props.disabled) {
        return;
      }

      var keyCode = event.keyCode;

      if (this.$data._open && !this.getInputDOMNode()) {
        this.onInputKeydown(event);
      } else if (keyCode === _util_KeyCode.ENTER || keyCode === _util_KeyCode.DOWN) {
        // vue state是同步更新，onKeyDown在onMenuSelect后会再次调用，单选时不在调用setOpenState
        if (keyCode === _util_KeyCode.ENTER && !isMultipleOrTags(props)) {
          this.maybeFocus(true);
        } else {
          this.setOpenState(true);
        }

        event.preventDefault();
      }
    },
    onInputKeydown: function onInputKeydown(event) {
      var props = this.$props;

      if (props.disabled) {
        return;
      }

      var state = this.$data;
      var keyCode = event.keyCode;

      if (isMultipleOrTags(props) && !event.target.value && keyCode === _util_KeyCode.BACKSPACE) {
        event.preventDefault();
        var value = state._value;

        if (value.length) {
          this.removeSelected(value[value.length - 1]);
        }

        return;
      }

      if (keyCode === _util_KeyCode.DOWN) {
        if (!state._open) {
          this.openIfHasChildren();
          event.preventDefault();
          event.stopPropagation();
          return;
        }
      } else if (keyCode === _util_KeyCode.ENTER && state._open) {
        // Aviod trigger form submit when select item
        // https://github.com/ant-design/ant-design/issues/10861
        event.preventDefault();
      } else if (keyCode === _util_KeyCode.ESC) {
        if (state._open) {
          this.setOpenState(false);
          event.preventDefault();
          event.stopPropagation();
        }

        return;
      }

      if (state._open) {
        var menu = this.selectTriggerRef.getInnerMenu();

        if (menu && menu.onKeyDown(event, this.handleBackfill)) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
    },
    onMenuSelect: function onMenuSelect(_ref) {
      var item = _ref.item;

      if (!item) {
        return;
      }

      var value = this.$data._value;
      var props = this.$props;
      var selectedValue = getValuePropValue(item);
      var lastValue = value[value.length - 1];
      this.fireSelect(selectedValue);

      if (isMultipleOrTags(props)) {
        if (findIndexInValueBySingleValue(value, selectedValue) !== -1) {
          return;
        }

        value = value.concat([selectedValue]);
      } else {
        if (lastValue && lastValue === selectedValue && selectedValue !== this.$data._backfillValue) {
          this.setOpenState(false, true);
          return;
        }

        value = [selectedValue];
        this.setOpenState(false, true);
      }

      this.fireChange(value);
      var inputValue;

      if (isCombobox(props)) {
        inputValue = getPropValue(item, props.optionLabelProp);
      } else {
        inputValue = '';
      }

      if (props.autoClearSearchValue) {
        this.setInputValue(inputValue, false);
      }
    },
    onMenuDeselect: function onMenuDeselect(_ref2) {
      var item = _ref2.item,
          domEvent = _ref2.domEvent;

      if (domEvent.type === 'click') {
        this.removeSelected(getValuePropValue(item));
      }

      if (this.autoClearSearchValue) {
        this.setInputValue('', false);
      }
    },
    onArrowClick: function onArrowClick(e) {
      e.stopPropagation();
      e.preventDefault();

      if (!this.disabled) {
        this.setOpenState(!this.$data._open, !this.$data._open);
      }
    },
    onPlaceholderClick: function onPlaceholderClick(e) {
      // if (this.openStatus) {
      //   e.stopPropagation()
      // }
      if (this.getInputDOMNode()) {
        this.getInputDOMNode().focus();
      }
    },
    // onOuterFocus (e) {
    //   if (this.disabled) {
    //     e.preventDefault()
    //     return
    //   }
    //   this.clearBlurTime()
    //   if (
    //     !isMultipleOrTagsOrCombobox(this.$props) &&
    //   e.target === this.getInputDOMNode()
    //   ) {
    //     return
    //   }
    //   if (this._focused) {
    //     return
    //   }
    //   this._focused = true
    //   this.updateFocusClassName()
    //   this.timeoutFocus()
    // },
    onPopupFocus: function onPopupFocus() {
      // fix ie scrollbar, focus element again
      this.maybeFocus(true, true);
    },
    // onOuterBlur (e) {
    //   if (this.disabled) {
    //     e.preventDefault()
    //     return
    //   }
    //   this.blurTimer = setTimeout(() => {
    //     this._focused = false
    //     this.updateFocusClassName()
    //     const props = this.$props
    //     let { sValue } = this
    //     const { inputValue } = this
    //     if (
    //       isSingleMode(props) &&
    //     props.showSearch &&
    //     inputValue &&
    //     props.defaultActiveFirstOption
    //     ) {
    //       const options = this._options || []
    //       if (options.length) {
    //         const firstOption = findFirstMenuItem(options)
    //         if (firstOption) {
    //           sValue = [
    //             {
    //               key: firstOption.key,
    //               label: this.getLabelFromOption(firstOption),
    //             },
    //           ]
    //           this.fireChange(sValue)
    //         }
    //       }
    //     } else if (isMultipleOrTags(props) && inputValue) {
    //       this.inputValue = this.getInputDOMNode().value = ''
    //     }
    //     this.$emit('blur', this.getVLForOnChange(sValue))
    //     this.setOpenState(false)
    //   }, 10)
    // },
    onClearSelection: function onClearSelection(event) {
      var props = this.$props;
      var state = this.$data;

      if (props.disabled) {
        return;
      }

      var inputValue = state._inputValue,
          value = state._value;
      event.stopPropagation();

      if (inputValue || value.length) {
        if (value.length) {
          this.fireChange([]);
        }

        this.setOpenState(false, true);

        if (inputValue) {
          this.setInputValue('');
        }
      }
    },
    onChoiceAnimationLeave: function onChoiceAnimationLeave() {
      this.forcePopupAlign();
    },
    getOptionsFromChildren: function getOptionsFromChildren() {
      var _this3 = this;

      var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      children.forEach(function (child) {
        if (!child.data || child.data.slot !== undefined) {
          return;
        }

        if (Object(props_util["l" /* getSlotOptions */])(child).isSelectOptGroup) {
          _this3.getOptionsFromChildren(child.componentOptions.children, options);
        } else {
          options.push(child);
        }
      });
      return options;
    },
    getInputValueForCombobox: function getInputValueForCombobox(props, optionsInfo, useDefaultValue) {
      var value = [];

      if ('value' in props && !useDefaultValue) {
        value = toArray(props.value);
      }

      if ('defaultValue' in props && useDefaultValue) {
        value = toArray(props.defaultValue);
      }

      if (value.length) {
        value = value[0];
      } else {
        return '';
      }

      var label = value;

      if (props.labelInValue) {
        label = value.label;
      } else if (optionsInfo[getMapKey(value)]) {
        label = optionsInfo[getMapKey(value)].label;
      }

      if (label === undefined) {
        label = '';
      }

      return label;
    },
    getLabelFromOption: function getLabelFromOption(props, option) {
      return getPropValue(option, props.optionLabelProp);
    },
    getOptionsInfoFromProps: function getOptionsInfoFromProps(props, preState) {
      var _this4 = this;

      var options = this.getOptionsFromChildren(this.$props.children);
      var optionsInfo = {};
      options.forEach(function (option) {
        var singleValue = getValuePropValue(option);
        optionsInfo[getMapKey(singleValue)] = {
          option: option,
          value: singleValue,
          label: _this4.getLabelFromOption(props, option),
          title: Object(props_util["o" /* getValueByProp */])(option, 'title')
        };
      });

      if (preState) {
        // keep option info in pre state value.
        var oldOptionsInfo = preState._optionsInfo;
        var value = preState._value;
        value.forEach(function (v) {
          var key = getMapKey(v);

          if (!optionsInfo[key] && oldOptionsInfo[key] !== undefined) {
            optionsInfo[key] = oldOptionsInfo[key];
          }
        });
      }

      return optionsInfo;
    },
    getValueFromProps: function getValueFromProps(props, useDefaultValue) {
      var value = [];

      if ('value' in props && !useDefaultValue) {
        value = toArray(props.value);
      }

      if ('defaultValue' in props && useDefaultValue) {
        value = toArray(props.defaultValue);
      }

      if (props.labelInValue) {
        value = value.map(function (v) {
          return v.key;
        });
      }

      return value;
    },
    getOptionInfoBySingleValue: function getOptionInfoBySingleValue(value, optionsInfo) {
      var h = this.$createElement;
      var info;
      optionsInfo = optionsInfo || this.$data._optionsInfo;

      if (optionsInfo[getMapKey(value)]) {
        info = optionsInfo[getMapKey(value)];
      }

      if (info) {
        return info;
      }

      var defaultLabel = value;

      if (this.$props.labelInValue) {
        var label = getLabelFromPropsValue(this.$props.value, value);

        if (label !== undefined) {
          defaultLabel = label;
        }
      }

      var defaultInfo = {
        option: h(Option, {
          attrs: {
            value: value
          },
          key: value
        }, [value]),
        value: value,
        label: defaultLabel
      };
      return defaultInfo;
    },
    getOptionBySingleValue: function getOptionBySingleValue(value) {
      var _this$getOptionInfoBy = this.getOptionInfoBySingleValue(value),
          option = _this$getOptionInfoBy.option;

      return option;
    },
    getOptionsBySingleValue: function getOptionsBySingleValue(values) {
      var _this5 = this;

      return values.map(function (value) {
        return _this5.getOptionBySingleValue(value);
      });
    },
    // getSingleOptionByValueKey (key) {
    //   return this.getOptionsFromChildren({
    //     key,
    //     label: key,
    //   }, this.$props.children)
    // },
    // getOptionsByValue (value) {
    //   if (value === undefined) {
    //     return undefined
    //   }
    //   if (value.length === 0) {
    //     return []
    //   }
    //   return this.getOptionsFromChildren(value, this.$props.children)
    // },
    // getLabelBySingleValue (children = [], value) {
    //   if (value === undefined) {
    //     return null
    //   }
    //   let label = null
    //   children.forEach(child => {
    //     if (!child.data || child.data.slot !== undefined) {
    //       return
    //     }
    //     if (getSlotOptions(child).isSelectOptGroup) {
    //       const maybe = this.getLabelBySingleValue(child.componentOptions.children, value)
    //       if (maybe !== null) {
    //         label = maybe
    //       }
    //     } else if (getValuePropValue(child) === value) {
    //       label = this.getLabelFromOption(child)
    //     }
    //   })
    //   return label
    // },
    getValueByLabel: function getValueByLabel(label) {
      var _this6 = this;

      if (label === undefined) {
        return null;
      }

      var value = null;
      Object.keys(this.$data._optionsInfo).forEach(function (key) {
        var info = _this6.$data._optionsInfo[key];

        if (toArray(info.label).join('') === label) {
          value = info.value;
        }
      });
      return value;
    },
    // getValueByLabel (children = [], label) {
    //   if (label === undefined) {
    //     return null
    //   }
    //   let value = null
    //   children.forEach(child => {
    //     if (!child.data || child.data.slot !== undefined) {
    //       return
    //     }
    //     if (getSlotOptions(child).isSelectOptGroup) {
    //       const maybe = this.getValueByLabel(child.componentOptions.children, label)
    //       if (maybe !== null) {
    //         value = maybe
    //       }
    //     } else if (toArray(this.getLabelFromOption(child)).join('') === label) {
    //       value = getValuePropValue(child)
    //     }
    //   })
    //   return value
    // },
    // getLabelFromOption (child) {
    //   let label = getPropValue(child, this.optionLabelProp)
    //   if (Array.isArray(label) && label.length === 1 && !label[0].tag) {
    //     label = label[0].text
    //   }
    //   return label
    // },
    getVLBySingleValue: function getVLBySingleValue(value) {
      if (this.$props.labelInValue) {
        return {
          key: value,
          label: this.getLabelBySingleValue(value)
        };
      }

      return value;
    },
    // getLabelFromProps (value) {
    //   return this.getLabelByValue(this.$props.children || [], value)
    // },
    getVLForOnChange: function getVLForOnChange(vls_) {
      var _this7 = this;

      var vls = vls_;

      if (vls !== undefined) {
        if (!this.labelInValue) {
          vls = vls.map(function (v) {
            return v;
          });
        } else {
          vls = vls.map(function (vl) {
            return {
              key: vl,
              label: _this7.getLabelBySingleValue(vl)
            };
          });
        }

        return isMultipleOrTags(this.$props) ? vls : vls[0];
      }

      return vls;
    },
    getLabelBySingleValue: function getLabelBySingleValue(value, optionsInfo) {
      var _this$getOptionInfoBy2 = this.getOptionInfoBySingleValue(value, optionsInfo),
          label = _this$getOptionInfoBy2.label;

      return label;
    },
    // getLabelByValue (children, value) {
    //   const label = this.getLabelBySingleValue(children, value)
    //   if (label === null) {
    //     return value
    //   }
    //   return label
    // },
    getDropdownContainer: function getDropdownContainer() {
      if (!this.dropdownContainer) {
        this.dropdownContainer = document.createElement('div');
        document.body.appendChild(this.dropdownContainer);
      }

      return this.dropdownContainer;
    },
    getPlaceholderElement: function getPlaceholderElement() {
      var h = this.$createElement;
      var props = this.$props,
          state = this.$data;
      var hidden = false;

      if (state._inputValue) {
        hidden = true;
      }

      if (state._value.length) {
        hidden = true;
      }

      if (isCombobox(props) && state._value.length === 1 && !state._value[0]) {
        hidden = false;
      }

      var placeholder = props.placeholder;

      if (placeholder) {
        var p = {
          on: {
            mousedown: preventDefaultEvent,
            click: this.onPlaceholderClick
          },
          attrs: UNSELECTABLE_ATTRIBUTE,
          style: Select_objectSpread({
            display: hidden ? 'none' : 'block'
          }, UNSELECTABLE_STYLE),
          "class": "".concat(props.prefixCls, "-selection__placeholder")
        };
        return h("div", p, [placeholder]);
      }

      return null;
    },
    inputClick: function inputClick(e) {
      if (this.$data._open) {
        this.clearBlurTime();
        e.stopPropagation();
      } else {
        this._focused = false;
      }
    },
    inputBlur: function inputBlur(e) {
      var _this8 = this;

      this.clearBlurTime();

      if (this.disabled) {
        return;
      }

      this.blurTimer = setTimeout(function () {
        _this8._focused = false;

        _this8.updateFocusClassName();

        var props = _this8.$props;
        var value = _this8.$data._value;
        var inputValue = _this8.$data._inputValue;

        if (isSingleMode(props) && props.showSearch && inputValue && props.defaultActiveFirstOption) {
          var options = _this8._options || [];

          if (options.length) {
            var firstOption = findFirstMenuItem(options);

            if (firstOption) {
              value = [getValuePropValue(firstOption)];

              _this8.fireChange(value);
            }
          }
        } else if (isMultipleOrTags(props) && inputValue) {
          _this8.$data._inputValue = _this8.getInputDOMNode().value = '';
          value = _this8.getValueByInput(inputValue);

          if (value !== undefined) {
            _this8.fireChange(value);
          }
        }

        _this8.$emit('blur', _this8.getVLForOnChange(value));

        _this8.setOpenState(false);
      }, 10);
    },
    inputFocus: function inputFocus(e) {
      this.clearBlurTime();
      this.clearFocusTime();
      this.timeoutFocus();
    },
    _getInputElement: function _getInputElement() {
      var h = this.$createElement;
      var props = this.$props;
      var inputValue = this.$data._inputValue;
      var attrs = Object(props_util["e" /* getAttrs */])(this);
      var inputElement = props.getInputElement ? props.getInputElement() : h("input", {
        attrs: {
          id: attrs.id,
          autoComplete: 'off'
        }
      });
      var inputCls = classnames_default()(Object(props_util["f" /* getClass */])(inputElement), Select_defineProperty({}, "".concat(props.prefixCls, "-search__field"), true));
      var inputEvents = Object(props_util["h" /* getEvents */])(inputElement); // https://github.com/ant-design/ant-design/issues/4992#issuecomment-281542159
      // Add space to the end of the inputValue as the width measurement tolerance

      inputElement.data = inputElement.data || {};
      return h("div", {
        "class": "".concat(props.prefixCls, "-search__field__wrap"),
        on: {
          "click": this.inputClick
        }
      }, [Object(vnode["a" /* cloneElement */])(inputElement, {
        props: {
          disabled: props.disabled,
          value: inputValue
        },
        attrs: Select_objectSpread({}, inputElement.data.attrs || {}, {
          disabled: props.disabled,
          value: inputValue
        }),
        domProps: {
          value: inputValue
        },
        "class": inputCls,
        directives: [{
          name: 'ant-ref',
          value: this.saveInputRef
        }],
        on: {
          input: this.onInputChange,
          keydown: chaining(this.onInputKeydown, inputEvents.keydown, this.$listeners.inputKeydown),
          focus: chaining(this.inputFocus, inputEvents.focus),
          blur: chaining(this.inputBlur, inputEvents.blur)
        }
      }), h("span", babel_helper_vue_jsx_merge_props_default()([{
        directives: [{
          name: 'ref',
          value: this.saveInputMirrorRef
        }]
      }, {
        // ref='inputMirrorRef'
        "class": "".concat(props.prefixCls, "-search__field__mirror")
      }]), [inputValue, "\xA0"])]);
    },
    getInputDOMNode: function getInputDOMNode() {
      return this.topCtrlRef ? this.topCtrlRef.querySelector('input,textarea,div[contentEditable]') : this.inputRef;
    },
    getInputMirrorDOMNode: function getInputMirrorDOMNode() {
      return this.inputMirrorRef;
    },
    getPopupDOMNode: function getPopupDOMNode() {
      return this.selectTriggerRef.getPopupDOMNode();
    },
    getPopupMenuComponent: function getPopupMenuComponent() {
      return this.selectTriggerRef.getInnerMenu();
    },
    setOpenState: function setOpenState(open, needFocus) {
      var _this9 = this;

      var props = this.$props,
          state = this.$data;

      if (state._open === open) {
        this.maybeFocus(open, needFocus);
        return;
      }

      var nextState = {
        _open: open,
        _backfillValue: undefined // clear search input value when open is false in singleMode.

      };

      if (!open && isSingleMode(props) && props.showSearch) {
        this.setInputValue('', false);
      }

      if (!open) {
        this.maybeFocus(open, needFocus);
      }

      this.setState(nextState, function () {
        if (open) {
          _this9.maybeFocus(open, needFocus);
        }
      });
    },
    setInputValue: function setInputValue(inputValue) {
      var fireSearch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (inputValue !== this.$data._inputValue) {
        this.setState({
          _inputValue: inputValue
        }, this.forcePopupAlign);

        if (fireSearch) {
          this.$emit('search', inputValue);
        }
      }
    },
    getValueByInput: function getValueByInput(string) {
      var _this10 = this;

      var _this$$props = this.$props,
          multiple = _this$$props.multiple,
          tokenSeparators = _this$$props.tokenSeparators;
      var nextValue = this.$data._value;
      var hasNewValue = false;
      splitBySeparators(string, tokenSeparators).forEach(function (label) {
        var selectedValue = [label];

        if (multiple) {
          var value = _this10.getValueByLabel(label);

          if (value && findIndexInValueBySingleValue(nextValue, value) === -1) {
            nextValue = nextValue.concat(value);
            hasNewValue = true;

            _this10.fireSelect(value);
          }
        } else {
          // tag
          if (findIndexInValueBySingleValue(nextValue, label) === -1) {
            nextValue = nextValue.concat(selectedValue);
            hasNewValue = true;

            _this10.fireSelect(label);
          }
        }
      });
      return hasNewValue ? nextValue : undefined;
    },
    getRealOpenState: function getRealOpenState() {
      var open = this.$data._open;
      var options = this._options || [];

      if (isMultipleOrTagsOrCombobox(this.$props) || !this.$props.showSearch) {
        if (open && !options.length) {
          open = false;
        }
      }

      return open;
    },
    // getValueByInput (string) {
    //   const { multiple, tokenSeparators, $slots } = this
    //   let nextValue = this.sValue
    //   splitBySeparators(string, tokenSeparators).forEach(label => {
    //     const selectedValue = { key: label, label }
    //     if (findIndexInValueByLabel(nextValue, label) === -1) {
    //       if (multiple) {
    //         const value = this.getValueByLabel($props.children, label)
    //         if (value) {
    //           selectedValue.key = value
    //           nextValue = nextValue.concat(selectedValue)
    //         }
    //       } else {
    //         nextValue = nextValue.concat(selectedValue)
    //       }
    //     }
    //     this.fireSelect({
    //       key: label,
    //       label,
    //     })
    //   })
    //   return nextValue
    // },
    focus: function focus() {
      if (isSingleMode(this.$props)) {
        this.selectionRef.focus();
      } else {
        this.getInputDOMNode().focus();
      }
    },
    blur: function blur() {
      if (isSingleMode(this.$props)) {
        this.selectionRef.blur();
      } else {
        this.getInputDOMNode().blur();
      }
    },
    handleBackfill: function handleBackfill(item) {
      if (!this.backfill || !(isSingleMode(this.$props) || isCombobox(this.$props))) {
        return;
      }

      var key = getValuePropValue(item);

      if (isCombobox(this.$props)) {
        this.setInputValue(key, false);
      }

      this.setState({
        _value: [key],
        _backfillValue: key
      });
    },
    _filterOption: function _filterOption(input, child) {
      var defaultFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultFilterFn;
      var _this$$data = this.$data,
          value = _this$$data._value,
          backfillValue = _this$$data._backfillValue;
      var lastValue = value[value.length - 1];

      if (!input || lastValue && lastValue === backfillValue) {
        return true;
      }

      var filterFn = this.$props.filterOption;

      if (Object(props_util["p" /* hasProp */])(this, 'filterOption')) {
        if (this.filterOption === true) {
          filterFn = defaultFilter;
        }
      } else {
        filterFn = defaultFilter;
      }

      if (!filterFn) {
        return true;
      } else if (typeof filterFn === 'function') {
        return filterFn.call(this, input, child);
      } else if (Object(props_util["o" /* getValueByProp */])(child, 'disabled')) {
        return false;
      }

      return true;
    },
    timeoutFocus: function timeoutFocus() {
      var _this11 = this;

      if (this.focusTimer) {
        this.clearFocusTime();
      }

      this.focusTimer = setTimeout(function () {
        _this11._focused = true;

        _this11.updateFocusClassName();

        _this11.$emit('focus');
      }, 10);
    },
    clearFocusTime: function clearFocusTime() {
      if (this.focusTimer) {
        clearTimeout(this.focusTimer);
        this.focusTimer = null;
      }
    },
    clearBlurTime: function clearBlurTime() {
      if (this.blurTimer) {
        clearTimeout(this.blurTimer);
        this.blurTimer = null;
      }
    },
    updateFocusClassName: function updateFocusClassName() {
      var rootRef = this.rootRef,
          prefixCls = this.prefixCls; // avoid setState and its side effect

      if (this._focused) {
        component_classes_default()(rootRef).add("".concat(prefixCls, "-focused"));
      } else {
        component_classes_default()(rootRef).remove("".concat(prefixCls, "-focused"));
      }
    },
    maybeFocus: function maybeFocus(open, needFocus) {
      if (needFocus || open) {
        var input = this.getInputDOMNode();
        var _document = document,
            activeElement = _document.activeElement;

        if (input && (open || isMultipleOrTagsOrCombobox(this.$props))) {
          if (activeElement !== input) {
            input.focus();
            this._focused = true;
          }
        } else {
          if (activeElement !== this.selectionRef) {
            this.selectionRef.focus();
            this._focused = true;
          }
        }
      }
    },
    // addLabelToValue (value_) {
    //   let value = value_
    //   if (this.labelInValue) {
    //     value.forEach(v => {
    //       v.label = v.label || this.getLabelFromProps(v.key)
    //     })
    //   } else {
    //     value = value.map(v => {
    //       return {
    //         key: v,
    //         label: this.getLabelFromProps(v),
    //       }
    //     })
    //   }
    //   return value
    // },
    // addTitleToValue (children = [], values) {
    //   let nextValues = values
    //   const keys = values.map(v => v.key)
    //   children.forEach(child => {
    //     if (!child) {
    //       return
    //     }
    //     if (getSlotOptions(child).isSelectOptGroup) {
    //       nextValues = this.addTitleToValue(child.componentOptions.children, nextValues)
    //     } else {
    //       const value = getValuePropValue(child)
    //       const valueIndex = keys.indexOf(value)
    //       if (valueIndex > -1) {
    //         nextValues[valueIndex].title = getValue(child, 'title')
    //       }
    //     }
    //   })
    //   return nextValues
    // },
    removeSelected: function removeSelected(selectedKey, e) {
      var props = this.$props;

      if (props.disabled || this.isChildDisabled(selectedKey)) {
        return;
      } // Do not trigger Trigger popup


      if (e && e.stopPropagation) {
        e.stopPropagation();
      }

      var value = this.$data._value.filter(function (singleValue) {
        return singleValue !== selectedKey;
      });

      var canMultiple = isMultipleOrTags(props);

      if (canMultiple) {
        var event = selectedKey;

        if (props.labelInValue) {
          event = {
            key: selectedKey,
            label: this.getLabelBySingleValue(selectedKey)
          };
        }

        this.$emit('deselect', event, this.getOptionBySingleValue(selectedKey));
      }

      this.fireChange(value);
    },
    openIfHasChildren: function openIfHasChildren() {
      var $props = this.$props;

      if ($props.children && $props.children.length || isSingleMode($props)) {
        this.setOpenState(true);
      }
    },
    fireSelect: function fireSelect(value) {
      this.$emit('select', this.getVLBySingleValue(value), this.getOptionBySingleValue(value));
    },
    fireChange: function fireChange(value) {
      if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
        this.setState({
          _value: value
        }, this.forcePopupAlign);
      }

      var vls = this.getVLForOnChange(value);
      var options = this.getOptionsBySingleValue(value);
      this._valueOptions = options;
      this.$emit('change', vls, isMultipleOrTags(this.$props) ? options : options[0]);
    },
    isChildDisabled: function isChildDisabled(key) {
      return (this.$props.children || []).some(function (child) {
        var childValue = getValuePropValue(child);
        return childValue === key && Object(props_util["o" /* getValueByProp */])(child, 'disabled');
      });
    },
    forcePopupAlign: function forcePopupAlign() {
      this.selectTriggerRef && this.selectTriggerRef.triggerRef.forcePopupAlign();
    },
    // getOptionsAndOpenStatus () {
    //   let sOpen = this.sOpen
    //   if (this.skipAdjustOpen) {
    //     this.openStatus = sOpen
    //     return {
    //       options: this._options,
    //       open: sOpen,
    //     }
    //   }
    //   const { $props, showSearch } = this
    //   let options = []
    //   // If hidden menu due to no options, then it should be calculated again
    //   if (sOpen || this.hiddenForNoOptions) {
    //     options = this.renderFilterOptions()
    //   }
    //   this._options = options
    //   if (isMultipleOrTagsOrCombobox($props) || !showSearch) {
    //     if (sOpen && !options.length) {
    //       sOpen = false
    //       this.hiddenForNoOptions = true
    //     }
    //     // Keep menu open if there are options and hidden for no options before
    //     if (this.hiddenForNoOptions && options.length) {
    //       sOpen = true
    //       this.hiddenForNoOptions = false
    //     }
    //   }
    //   this.openStatus = sOpen
    //   return {
    //     options,
    //     open: sOpen,
    //   }
    // },
    renderFilterOptions: function renderFilterOptions() {
      var _this12 = this;

      var h = this.$createElement;
      var inputValue = this.$data._inputValue;
      var _this$$props2 = this.$props,
          children = _this$$props2.children,
          tags = _this$$props2.tags,
          filterOption = _this$$props2.filterOption,
          notFoundContent = _this$$props2.notFoundContent;
      var menuItems = [];
      var childrenKeys = [];
      var options = this.renderFilterOptionsFromChildren(children, childrenKeys, menuItems);

      if (tags) {
        // tags value must be string
        var value = this.$data._value;
        value = value.filter(function (singleValue) {
          return childrenKeys.indexOf(singleValue) === -1 && (!inputValue || String(singleValue).indexOf(String(inputValue)) > -1);
        });
        value.forEach(function (singleValue) {
          var key = singleValue;
          var menuItem = h(vc_menu_MenuItem, babel_helper_vue_jsx_merge_props_default()([{
            style: UNSELECTABLE_STYLE
          }, {
            attrs: UNSELECTABLE_ATTRIBUTE
          }, {
            attrs: {
              value: key,
              role: 'option'
            },
            key: key
          }]), [key]);
          options.push(menuItem);
          menuItems.push(menuItem);
        });

        if (inputValue) {
          var notFindInputItem = menuItems.every(function (option) {
            // this.filterOption return true has two meaning,
            // 1, some one exists after filtering
            // 2, filterOption is set to false
            // condition 2 does not mean the option has same value with inputValue
            var filterFn = function filterFn() {
              return getValuePropValue(option) === inputValue;
            };

            if (filterOption !== false) {
              return !_this12._filterOption(inputValue, option, filterFn);
            }

            return !filterFn();
          });

          if (notFindInputItem) {
            var p = {
              attrs: UNSELECTABLE_ATTRIBUTE,
              key: inputValue,
              props: {
                value: inputValue,
                role: 'option'
              },
              style: UNSELECTABLE_STYLE
            };
            options.unshift(h(vc_menu_MenuItem, p, [inputValue]));
          }
        }
      }

      if (!options.length && notFoundContent) {
        var _p = {
          attrs: UNSELECTABLE_ATTRIBUTE,
          key: 'NOT_FOUND',
          props: {
            value: 'NOT_FOUND',
            disabled: true,
            role: 'option'
          },
          style: UNSELECTABLE_STYLE
        };
        options = [h(vc_menu_MenuItem, _p, [notFoundContent])];
      }

      return options;
    },
    renderFilterOptionsFromChildren: function renderFilterOptionsFromChildren() {
      var _this13 = this;

      var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var childrenKeys = arguments.length > 1 ? arguments[1] : undefined;
      var menuItems = arguments.length > 2 ? arguments[2] : undefined;
      var h = this.$createElement;
      var sel = [];
      var props = this.$props;
      var inputValue = this.$data._inputValue;
      var tags = props.tags;
      children.forEach(function (child) {
        if (!child.data || child.data.slot !== undefined) {
          return;
        }

        if (Object(props_util["l" /* getSlotOptions */])(child).isSelectOptGroup) {
          var innerItems = _this13.renderFilterOptionsFromChildren(child.componentOptions.children, childrenKeys, menuItems);

          if (innerItems.length) {
            var label = Object(props_util["g" /* getComponentFromProp */])(child, 'label');
            var key = child.key;

            if (!key && typeof label === 'string') {
              key = label;
            } else if (!label && key) {
              label = key;
            }

            sel.push(h(vc_menu_MenuItemGroup, {
              key: key,
              attrs: {
                title: label
              },
              "class": Object(props_util["f" /* getClass */])(child)
            }, [innerItems]));
          }

          return;
        }

        browser_default()(Object(props_util["l" /* getSlotOptions */])(child).isSelectOption, 'the children of `Select` should be `Select.Option` or `Select.OptGroup`, ' + "instead of `".concat(Object(props_util["l" /* getSlotOptions */])(child).name || Object(props_util["l" /* getSlotOptions */])(child), "`."));
        var childValue = getValuePropValue(child);
        validateOptionValue(childValue, _this13.$props);

        if (_this13._filterOption(inputValue, child)) {
          var p = {
            attrs: Select_objectSpread({}, UNSELECTABLE_ATTRIBUTE, Object(props_util["e" /* getAttrs */])(child)),
            key: childValue,
            props: Select_objectSpread({
              value: childValue
            }, Object(props_util["k" /* getPropsData */])(child), {
              role: 'option'
            }),
            style: UNSELECTABLE_STYLE,
            on: Object(props_util["h" /* getEvents */])(child),
            "class": Object(props_util["f" /* getClass */])(child)
          };
          var menuItem = h(vc_menu_MenuItem, p, [child.componentOptions.children]);
          sel.push(menuItem);
          menuItems.push(menuItem);
        }

        if (tags) {
          childrenKeys.push(childValue);
        }
      });
      return sel;
    },
    renderTopControlNode: function renderTopControlNode() {
      var _this14 = this;

      var h = this.$createElement;
      var props = this.$props;
      var _this$$data2 = this.$data,
          value = _this$$data2._value,
          inputValue = _this$$data2._inputValue,
          open = _this$$data2._open;
      var choiceTransitionName = props.choiceTransitionName,
          prefixCls = props.prefixCls,
          maxTagTextLength = props.maxTagTextLength,
          maxTagCount = props.maxTagCount,
          maxTagPlaceholder = props.maxTagPlaceholder,
          showSearch = props.showSearch;
      var className = "".concat(prefixCls, "-selection__rendered"); // search input is inside topControlNode in single, multiple & combobox. 2016/04/13

      var innerNode = null;

      if (isSingleMode(props)) {
        var selectedValue = null;

        if (value.length) {
          var showSelectedValue = false;
          var opacity = 1;

          if (!showSearch) {
            showSelectedValue = true;
          } else {
            if (open) {
              showSelectedValue = !inputValue;

              if (showSelectedValue) {
                opacity = 0.4;
              }
            } else {
              showSelectedValue = true;
            }
          }

          var singleValue = value[0];

          var _this$getOptionInfoBy3 = this.getOptionInfoBySingleValue(singleValue),
              label = _this$getOptionInfoBy3.label,
              title = _this$getOptionInfoBy3.title;

          selectedValue = h("div", {
            key: 'value',
            "class": "".concat(prefixCls, "-selection-selected-value"),
            attrs: {
              title: toTitle(title || label)
            },
            style: {
              display: showSelectedValue ? 'block' : 'none',
              opacity: opacity
            }
          }, [label]);
        }

        if (!showSearch) {
          innerNode = [selectedValue];
        } else {
          innerNode = [selectedValue, h("div", {
            "class": "".concat(prefixCls, "-search ").concat(prefixCls, "-search--inline"),
            key: 'input',
            style: {
              display: open ? 'block' : 'none'
            }
          }, [this._getInputElement()])];
        }
      } else {
        var selectedValueNodes = [];
        var limitedCountValue = value;
        var maxTagPlaceholderEl;

        if (maxTagCount !== undefined && value.length > maxTagCount) {
          limitedCountValue = limitedCountValue.slice(0, maxTagCount);
          var omittedValues = this.getVLForOnChange(value.slice(maxTagCount, value.length));
          var content = "+ ".concat(value.length - maxTagCount, " ...");

          if (maxTagPlaceholder) {
            content = typeof maxTagPlaceholder === 'function' ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
          }

          maxTagPlaceholderEl = h("li", {
            style: UNSELECTABLE_STYLE,
            attrs: {
              unselectable: 'unselectable',
              title: toTitle(content)
            },
            on: {
              "mousedown": preventDefaultEvent
            },
            "class": "".concat(prefixCls, "-selection__choice ").concat(prefixCls, "-selection__choice__disabled"),
            key: 'maxTagPlaceholder'
          }, [h("div", {
            "class": "".concat(prefixCls, "-selection__choice__content")
          }, [content])]);
        }

        if (isMultipleOrTags(props)) {
          selectedValueNodes = limitedCountValue.map(function (singleValue) {
            var info = _this14.getOptionInfoBySingleValue(singleValue);

            var content = info.label;
            var title = info.title || content;

            if (maxTagTextLength && typeof content === 'string' && content.length > maxTagTextLength) {
              content = "".concat(content.slice(0, maxTagTextLength), "...");
            }

            var disabled = _this14.isChildDisabled(singleValue);

            var choiceClassName = disabled ? "".concat(prefixCls, "-selection__choice ").concat(prefixCls, "-selection__choice__disabled") : "".concat(prefixCls, "-selection__choice");
            return h("li", {
              style: UNSELECTABLE_STYLE,
              attrs: {
                unselectable: 'unselectable',
                title: toTitle(title)
              },
              on: {
                "mousedown": preventDefaultEvent
              },
              "class": choiceClassName,
              key: singleValue
            }, [h("div", {
              "class": "".concat(prefixCls, "-selection__choice__content")
            }, [content]), disabled ? null : h("span", {
              "class": "".concat(prefixCls, "-selection__choice__remove"),
              on: {
                "click": function click(event) {
                  _this14.removeSelected(singleValue, event);
                }
              }
            })]);
          });
        }

        if (maxTagPlaceholderEl) {
          selectedValueNodes.push(maxTagPlaceholderEl);
        }

        selectedValueNodes.push(h("li", {
          "class": "".concat(prefixCls, "-search ").concat(prefixCls, "-search--inline"),
          key: '__input'
        }, [this._getInputElement()]));

        if (isMultipleOrTags(props) && choiceTransitionName) {
          var transitionProps = Object(getTransitionProps["a" /* default */])(choiceTransitionName, {
            tag: 'ul',
            afterLeave: this.onChoiceAnimationLeave
          });
          innerNode = h("transition-group", transitionProps, [selectedValueNodes]);
        } else {
          innerNode = h("ul", [selectedValueNodes]);
        }
      }

      return h("div", babel_helper_vue_jsx_merge_props_default()([{
        "class": className
      }, {
        directives: [{
          name: 'ref',
          value: this.saveTopCtrlRef
        }]
      }, {
        on: {
          "click": this.topCtrlContainerClick
        }
      }]), [this.getPlaceholderElement(), innerNode]);
    },
    topCtrlContainerClick: function topCtrlContainerClick(e) {
      if (this.$data._open && !isSingleMode(this.$props)) {
        e.stopPropagation();
      }
    },
    renderClear: function renderClear() {
      var h = this.$createElement;
      var _this$$props3 = this.$props,
          prefixCls = _this$$props3.prefixCls,
          allowClear = _this$$props3.allowClear;
      var _this$$data3 = this.$data,
          value = _this$$data3._value,
          inputValue = _this$$data3._inputValue;
      var clear = h("span", {
        key: 'clear',
        on: {
          "mousedown": preventDefaultEvent,
          "click": this.onClearSelection
        },
        style: UNSELECTABLE_STYLE,
        attrs: {
          unselectable: 'unselectable'
        },
        "class": "".concat(prefixCls, "-selection__clear")
      });

      if (!allowClear) {
        return null;
      }

      if (isCombobox(this.$props)) {
        if (inputValue) {
          return clear;
        }

        return null;
      }

      if (inputValue || value.length) {
        return clear;
      }

      return null;
    },
    // rootRefClick (e) {
    //   // e.stopPropagation()
    //   if (this._focused) {
    //     // this.getInputDOMNode().blur()
    //     this.onOuterBlur()
    //   } else {
    //     this.onOuterFocus()
    //     // this.getInputDOMNode().focus()
    //   }
    // },
    selectionRefClick: function selectionRefClick(e) {
      e.stopPropagation();

      if (!this.disabled) {
        var input = this.getInputDOMNode();

        if (this._focused && this.$data._open) {
          this._focused = false;
          this.setOpenState(false, false);
          input && input.blur();
        } else {
          this.clearBlurTime();
          this._focused = true;
          this.setOpenState(true, true);
          input && input.focus();
        }
      }
    },
    selectionRefFocus: function selectionRefFocus(e) {
      if (this._focused || this.disabled) {
        return;
      }

      this._focused = true;
      this.updateFocusClassName();
      this.$emit('focus');
    },
    selectionRefBlur: function selectionRefBlur(e) {
      this._focused = false;
      this.updateFocusClassName();
      this.$emit('blur');
    }
  },
  render: function render() {
    var _rootCls;

    var h = arguments[0];
    var props = this.$props;
    var multiple = isMultipleOrTags(props);
    var state = this.$data;
    var disabled = props.disabled,
        prefixCls = props.prefixCls;
    var ctrlNode = this.renderTopControlNode();
    var _this$$data4 = this.$data,
        open = _this$$data4._open,
        inputValue = _this$$data4._inputValue,
        value = _this$$data4._value;

    if (open) {
      this._options = this.renderFilterOptions();
    }

    var realOpen = this.getRealOpenState();
    var options = this._options || [];
    var $listeners = this.$listeners;
    var _$listeners$mouseente = $listeners.mouseenter,
        mouseenter = _$listeners$mouseente === void 0 ? Select_noop : _$listeners$mouseente,
        _$listeners$mouseleav = $listeners.mouseleave,
        mouseleave = _$listeners$mouseleav === void 0 ? Select_noop : _$listeners$mouseleav,
        _$listeners$popupScro = $listeners.popupScroll,
        popupScroll = _$listeners$popupScro === void 0 ? Select_noop : _$listeners$popupScro;
    var selectionProps = {
      props: {},
      attrs: {
        role: 'combobox',
        'aria-autocomplete': 'list',
        'aria-haspopup': 'true',
        'aria-expanded': realOpen
      },
      on: {
        click: this.selectionRefClick
      },
      "class": "".concat(prefixCls, "-selection ").concat(prefixCls, "-selection--").concat(multiple ? 'multiple' : 'single'),
      directives: [{
        name: 'ref',
        value: this.saveSelectionRef
      }],
      key: 'selection'
    };

    if (!isMultipleOrTagsOrCombobox(props)) {
      selectionProps.on.keydown = this.onKeyDown;
      selectionProps.on.focus = this.selectionRefFocus;
      selectionProps.on.blur = this.selectionRefBlur;
      selectionProps.attrs.tabIndex = props.disabled ? -1 : 0;
    }

    var rootCls = (_rootCls = {}, Select_defineProperty(_rootCls, prefixCls, true), Select_defineProperty(_rootCls, "".concat(prefixCls, "-open"), open), Select_defineProperty(_rootCls, "".concat(prefixCls, "-focused"), open || !!this._focused), Select_defineProperty(_rootCls, "".concat(prefixCls, "-combobox"), isCombobox(props)), Select_defineProperty(_rootCls, "".concat(prefixCls, "-disabled"), disabled), Select_defineProperty(_rootCls, "".concat(prefixCls, "-enabled"), !disabled), Select_defineProperty(_rootCls, "".concat(prefixCls, "-allow-clear"), !!props.allowClear), Select_defineProperty(_rootCls, "".concat(prefixCls, "-no-arrow"), !props.showArrow), _rootCls);
    return h(SelectTrigger, babel_helper_vue_jsx_merge_props_default()([{
      attrs: {
        dropdownAlign: props.dropdownAlign,
        dropdownClassName: props.dropdownClassName,
        dropdownMatchSelectWidth: props.dropdownMatchSelectWidth,
        defaultActiveFirstOption: props.defaultActiveFirstOption,
        dropdownMenuStyle: props.dropdownMenuStyle,
        transitionName: props.transitionName,
        animation: props.animation,
        prefixCls: props.prefixCls,
        dropdownStyle: props.dropdownStyle,
        combobox: props.combobox,
        showSearch: props.showSearch,
        options: options,
        multiple: multiple,
        disabled: disabled,
        visible: realOpen,
        inputValue: inputValue,
        value: value,
        backfillValue: state._backfillValue,
        firstActiveValue: props.firstActiveValue,
        getPopupContainer: props.getPopupContainer,
        showAction: props.showAction
      },
      on: {
        "dropdownVisibleChange": this.onDropdownVisibleChange,
        "menuSelect": this.onMenuSelect,
        "menuDeselect": this.onMenuDeselect,
        "popupScroll": popupScroll,
        "popupFocus": this.onPopupFocus,
        "mouseenter": mouseenter,
        "mouseleave": mouseleave
      }
    }, {
      directives: [{
        name: 'ref',
        value: this.saveSelectTriggerRef
      }]
    }]), [h("div", babel_helper_vue_jsx_merge_props_default()([{
      directives: [{
        name: 'ref',
        value: this.saveRootRef
      }]
    }, {
      style: Object(props_util["n" /* getStyle */])(this),
      "class": classnames_default()(rootCls) // tabindex='-1'
      // onBlur={this.onOuterBlur}
      // onFocus={this.onOuterFocus}

    }]), [h("div", selectionProps, [ctrlNode, this.renderClear(), multiple || !props.showArrow ? null : h("span", {
      key: 'arrow',
      "class": "".concat(prefixCls, "-arrow"),
      style: UNSELECTABLE_STYLE,
      attrs: {
        unselectable: 'unselectable' // onClick={this.onArrowClick}

      }
    }, [h("b")])])])]);
  }
};

/* harmony default export */ var vc_select_Select = (Object(proxyComponent["a" /* default */])(Select_Select));
// CONCATENATED MODULE: ./src/components/vc-select/OptGroup.jsx

/* harmony default export */ var OptGroup = ({
  props: {
    label: vue_types["a" /* default */].any
  },
  isSelectOptGroup: true
});
// CONCATENATED MODULE: ./src/components/vc-select/index.js
// based on vc-select 7.7.5




Select_Select.Option = Option;
Select_Select.OptGroup = OptGroup;
vc_select_Select.Option = Option;
vc_select_Select.OptGroup = OptGroup;

/* harmony default export */ var vc_select = (vc_select_Select);
// CONCATENATED MODULE: ./src/components/locale-provider/LocaleReceiver.jsx
function LocaleReceiver_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { LocaleReceiver_defineProperty(target, key, source[key]); }); } return target; }

function LocaleReceiver_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/* harmony default export */ var LocaleReceiver = ({
  props: {
    componentName: vue_types["a" /* default */].string,
    defaultLocale: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].object, vue_types["a" /* default */].func]),
    children: vue_types["a" /* default */].func
  },
  inject: {
    localeData: {
      "default": {}
    }
  },
  methods: {
    getLocale: function getLocale() {
      var componentName = this.componentName,
          defaultLocale = this.defaultLocale;
      var antLocale = this.localeData.antLocale;
      var localeFromContext = antLocale && antLocale[componentName];
      return LocaleReceiver_objectSpread({}, typeof defaultLocale === 'function' ? defaultLocale() : defaultLocale, localeFromContext || {});
    },
    getLocaleCode: function getLocaleCode() {
      var antLocale = this.localeData.antLocale;
      var localeCode = antLocale && antLocale.locale; // Had use LocaleProvide but didn't set locale

      if (antLocale && antLocale.exist && !localeCode) {
        return 'zh_CN';
      }

      return localeCode;
    }
  },
  render: function render() {
    var $scopedSlots = this.$scopedSlots;
    var children = this.children || $scopedSlots["default"];
    return children(this.getLocale(), this.getLocaleCode());
  }
});
// CONCATENATED MODULE: ./src/components/vc-pagination/locale/en_US.js
/* harmony default export */ var en_US = ({
  // Options.jsx
  items_per_page: '/ page',
  jump_to: 'Goto',
  jump_to_confirm: 'confirm',
  page: '',
  // Pagination.jsx
  prev_page: 'Previous Page',
  next_page: 'Next Page',
  prev_5: 'Previous 5 Pages',
  next_5: 'Next 5 Pages',
  prev_3: 'Previous 3 Pages',
  next_3: 'Next 3 Pages'
});
// CONCATENATED MODULE: ./src/components/vc-calendar/src/locale/en_US.js
/* harmony default export */ var locale_en_US = ({
  today: 'Today',
  now: 'Now',
  backToToday: 'Back to today',
  ok: 'Ok',
  clear: 'Clear',
  month: 'Month',
  year: 'Year',
  timeSelect: 'select time',
  dateSelect: 'select date',
  weekSelect: 'Choose a week',
  monthSelect: 'Choose a month',
  yearSelect: 'Choose a year',
  decadeSelect: 'Choose a decade',
  yearFormat: 'YYYY',
  dateFormat: 'M/D/YYYY',
  dayFormat: 'D',
  dateTimeFormat: 'M/D/YYYY HH:mm:ss',
  monthBeforeYear: true,
  previousMonth: 'Previous month (PageUp)',
  nextMonth: 'Next month (PageDown)',
  previousYear: 'Last year (Control + left)',
  nextYear: 'Next year (Control + right)',
  previousDecade: 'Last decade',
  nextDecade: 'Next decade',
  previousCentury: 'Last century',
  nextCentury: 'Next century'
});
// CONCATENATED MODULE: ./src/components/time-picker/locale/en_US.js
var en_US_locale = {
  placeholder: 'Select time'
};
/* harmony default export */ var time_picker_locale_en_US = (en_US_locale);
// CONCATENATED MODULE: ./src/components/date-picker/locale/en_US.js
function en_US_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      en_US_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function en_US_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


 // Merge into a locale object

var locale_en_US_locale = {
  lang: en_US_objectSpread({
    placeholder: 'Select date',
    rangePlaceholder: ['Start date', 'End date']
  }, locale_en_US),
  timePickerLocale: en_US_objectSpread({}, time_picker_locale_en_US) // All settings at:
  // https://github.com/ant-design/ant-design/blob/master/components/date-picker/lo
  // cale/example.json

};
/* harmony default export */ var date_picker_locale_en_US = (locale_en_US_locale);
// CONCATENATED MODULE: ./src/components/calendar/locale/en_US.js

/* harmony default export */ var calendar_locale_en_US = (date_picker_locale_en_US);
// CONCATENATED MODULE: ./src/components/locale-provider/default.js




/* harmony default export */ var locale_provider_default = ({
  locale: 'en',
  Pagination: en_US,
  DatePicker: date_picker_locale_en_US,
  TimePicker: time_picker_locale_en_US,
  Calendar: calendar_locale_en_US,
  Table: {
    filterTitle: 'Filter menu',
    filterConfirm: 'OK',
    filterReset: 'Reset',
    emptyText: 'No data',
    selectAll: 'Select current page',
    selectInvert: 'Invert current page'
  },
  Modal: {
    okText: 'OK',
    cancelText: 'Cancel',
    justOkText: 'OK'
  },
  Popconfirm: {
    okText: 'OK',
    cancelText: 'Cancel'
  },
  Transfer: {
    titles: ['', ''],
    notFoundContent: 'Not Found',
    searchPlaceholder: 'Search here',
    itemUnit: 'item',
    itemsUnit: 'items'
  },
  Select: {
    notFoundContent: 'Not Found'
  },
  Upload: {
    uploading: 'Uploading...',
    removeFile: 'Remove file',
    uploadError: 'Upload error',
    previewFile: 'Preview file'
  }
});
// CONCATENATED MODULE: ./src/components/select/index.jsx


function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function select_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { select_defineProperty(target, key, source[key]); }); } return target; }

function select_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var select_AbstractSelectProps = function AbstractSelectProps() {
  return {
    prefixCls: vue_types["a" /* default */].string,
    size: vue_types["a" /* default */].oneOf(['small', 'large', 'default']),
    notFoundContent: vue_types["a" /* default */].any,
    transitionName: vue_types["a" /* default */].string,
    choiceTransitionName: vue_types["a" /* default */].string,
    showSearch: vue_types["a" /* default */].bool,
    allowClear: vue_types["a" /* default */].bool,
    disabled: vue_types["a" /* default */].bool,
    tabIndex: vue_types["a" /* default */].number,
    placeholder: vue_types["a" /* default */].any,
    defaultActiveFirstOption: vue_types["a" /* default */].bool,
    dropdownClassName: vue_types["a" /* default */].string,
    dropdownStyle: vue_types["a" /* default */].any,
    dropdownMenuStyle: vue_types["a" /* default */].any,
    dropdownMatchSelectWidth: vue_types["a" /* default */].bool,
    // onSearch: (value: string) => any,
    filterOption: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, vue_types["a" /* default */].func]),
    autoFocus: vue_types["a" /* default */].bool,
    backfill: vue_types["a" /* default */].bool,
    showArrow: vue_types["a" /* default */].bool,
    getPopupContainer: vue_types["a" /* default */].func
  };
};

var Value = vue_types["a" /* default */].shape({
  key: vue_types["a" /* default */].string
}).loose;
var SelectValue = vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number, vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].oneOfType([Value, vue_types["a" /* default */].string, vue_types["a" /* default */].number])), Value]);

var SelectProps = select_objectSpread({}, select_AbstractSelectProps(), {
  value: SelectValue,
  defaultValue: SelectValue,
  // mode: PropTypes.oneOf(['default', 'multiple', 'tags', 'combobox']),
  mode: vue_types["a" /* default */].string,
  optionLabelProp: vue_types["a" /* default */].string,
  firstActiveValue: vue_types["a" /* default */].oneOfType([String, vue_types["a" /* default */].arrayOf(String)]),
  // onChange?: (value: SelectValue, option: React.ReactElement<any> | React.ReactElement<any>[]) => void;
  // onSelect?: (value: SelectValue, option: React.ReactElement<any>) => any;
  // onDeselect?: (value: SelectValue) => any;
  // onBlur?: () => any;
  // onFocus?: () => any;
  // onInputKeyDown?: (e: React.KeyboardEvent<HTMLInputElement>) => void;
  maxTagCount: vue_types["a" /* default */].number,
  maxTagPlaceholder: vue_types["a" /* default */].any,
  dropdownMatchSelectWidth: vue_types["a" /* default */].bool,
  optionFilterProp: vue_types["a" /* default */].string,
  labelInValue: vue_types["a" /* default */]["boolean"],
  getPopupContainer: vue_types["a" /* default */].func,
  tokenSeparators: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
  getInputElement: vue_types["a" /* default */].func,
  options: vue_types["a" /* default */].array
});

var select_SelectPropTypes = {
  prefixCls: vue_types["a" /* default */].string,
  size: vue_types["a" /* default */].oneOf(['default', 'large', 'small']),
  // combobox: PropTypes.bool,
  notFoundContent: vue_types["a" /* default */].any,
  showSearch: vue_types["a" /* default */].bool,
  optionLabelProp: vue_types["a" /* default */].string,
  transitionName: vue_types["a" /* default */].string,
  choiceTransitionName: vue_types["a" /* default */].string
};

var SECRET_COMBOBOX_MODE_DO_NOT_USE = 'SECRET_COMBOBOX_MODE_DO_NOT_USE';
var select_Select = {
  SECRET_COMBOBOX_MODE_DO_NOT_USE: SECRET_COMBOBOX_MODE_DO_NOT_USE,
  Option: select_objectSpread({}, Option, {
    name: 'TaSelectOption'
  }),
  OptGroup: select_objectSpread({}, OptGroup, {
    name: 'TaSelectOptGroup'
  }),
  name: 'TaSelect',
  props: select_objectSpread({}, SelectProps, {
    prefixCls: vue_types["a" /* default */].string.def('ant-select'),
    showSearch: vue_types["a" /* default */].bool.def(false),
    transitionName: vue_types["a" /* default */].string.def('slide-up'),
    choiceTransitionName: vue_types["a" /* default */].string.def('zoom')
  }),
  propTypes: select_SelectPropTypes,
  model: {
    prop: 'value',
    event: 'change'
  },
  created: function created() {
    browser_default()(this.$props.mode !== 'combobox', 'The combobox mode of Select is deprecated,' + 'it will be removed in next major version,' + 'please use AutoComplete instead');
  },
  methods: {
    focus: function focus() {
      this.$refs.vcSelect.focus();
    },
    blur: function blur() {
      this.$refs.vcSelect.blur();
    },
    getNotFoundContent: function getNotFoundContent(locale) {
      var notFoundContent = Object(props_util["g" /* getComponentFromProp */])(this, 'notFoundContent');

      if (this.isCombobox()) {
        // AutoComplete don't have notFoundContent defaultly
        return notFoundContent === undefined ? null : notFoundContent;
      }

      return notFoundContent === undefined ? locale.notFoundContent : notFoundContent;
    },
    isCombobox: function isCombobox() {
      var mode = this.mode;
      return mode === 'combobox' || mode === SECRET_COMBOBOX_MODE_DO_NOT_USE;
    },
    renderSelect: function renderSelect(locale) {
      var _cls;

      var h = this.$createElement;

      var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
          prefixCls = _getOptionProps.prefixCls,
          size = _getOptionProps.size,
          mode = _getOptionProps.mode,
          options = _getOptionProps.options,
          restProps = _objectWithoutProperties(_getOptionProps, ["prefixCls", "size", "mode", "options"]);

      var cls = (_cls = {}, select_defineProperty(_cls, "".concat(prefixCls, "-lg"), size === 'large'), select_defineProperty(_cls, "".concat(prefixCls, "-sm"), size === 'small'), _cls);
      var optionLabelProp = this.$props.optionLabelProp;

      if (this.isCombobox()) {
        // children 带 dom 结构时，无法填入输入框
        optionLabelProp = optionLabelProp || 'value';
      }

      var modeConfig = {
        multiple: mode === 'multiple',
        tags: mode === 'tags',
        combobox: this.isCombobox()
      };
      var selectProps = {
        props: select_objectSpread({}, restProps, modeConfig, {
          prefixCls: prefixCls,
          optionLabelProp: optionLabelProp || 'children',
          notFoundContent: this.getNotFoundContent(locale),
          maxTagPlaceholder: Object(props_util["g" /* getComponentFromProp */])(this, 'maxTagPlaceholder'),
          placeholder: Object(props_util["g" /* getComponentFromProp */])(this, 'placeholder'),
          children: options ? options.map(function (option) {
            var key = option.key,
                _option$label = option.label,
                label = _option$label === void 0 ? option.title : _option$label,
                restOption = _objectWithoutProperties(option, ["key", "label"]);

            return h(Option, babel_helper_vue_jsx_merge_props_default()([{
              key: key
            }, {
              props: restOption
            }]), [label]);
          }) : Object(props_util["c" /* filterEmpty */])(this.$slots["default"]),
          __propsSymbol__: Symbol()
        }),
        on: this.$listeners,
        "class": cls,
        ref: 'vcSelect'
      };
      return h(Select_Select, selectProps);
    }
  },
  render: function render() {
    var h = arguments[0];
    return h(LocaleReceiver, {
      attrs: {
        componentName: 'Select',
        defaultLocale: locale_provider_default.Select
      },
      scopedSlots: {
        "default": this.renderSelect
      }
    });
  }
};
/* istanbul ignore next */

select_Select.install = function (Vue) {
  Vue.component(select_Select.name, select_Select);
  Vue.component(select_Select.Option.name, select_Select.Option);
  Vue.component(select_Select.OptGroup.name, select_Select.OptGroup);
};

/* harmony default export */ var components_select = (select_Select);
// CONCATENATED MODULE: ./src/components/input/inputProps.js

/* harmony default export */ var input_inputProps = ({
  prefixCls: {
    "default": 'ant-input',
    type: String
  },
  defaultValue: [String, Number],
  value: [String, Number],
  placeholder: [String, Number],
  type: {
    "default": 'text',
    type: String
  },
  name: String,
  size: {
    validator: function validator(value) {
      return ['small', 'large', 'default'].includes(value);
    }
  },
  disabled: {
    "default": false,
    type: Boolean
  },
  readOnly: Boolean,
  addonBefore: vue_types["a" /* default */].any,
  addonAfter: vue_types["a" /* default */].any,
  // onPressEnter?: React.FormEventHandler<any>;
  // onKeyDown?: React.FormEventHandler<any>;
  // onChange?: React.ChangeEventHandler<HTMLInputElement>;
  // onClick?: React.FormEventHandler<any>;
  // onFocus?: React.FormEventHandler<any>;
  // onBlur?: React.FormEventHandler<any>;
  prefix: vue_types["a" /* default */].any,
  suffix: vue_types["a" /* default */].any,
  spellCheck: Boolean,
  autoFocus: Boolean
});
// CONCATENATED MODULE: ./src/components/input/calculateNodeHeight.js
// Thanks to https://github.com/andreypopp/react-textarea-autosize/

/**
 * calculateNodeHeight(uiTextNode, useCache = false)
 */
var HIDDEN_TEXTAREA_STYLE = "\nmin-height:0 !important;\nmax-height:none !important;\nheight:0 !important;\nvisibility:hidden !important;\noverflow:hidden !important;\nposition:absolute !important;\nz-index:-1000 !important;\ntop:0 !important;\nright:0 !important\n";
var SIZING_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];
var computedStyleCache = {};
var hiddenTextarea;

function calculateNodeStyling(node) {
  var useCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var nodeRef = node.getAttribute('id') || node.getAttribute('data-reactid') || node.getAttribute('name');

  if (useCache && computedStyleCache[nodeRef]) {
    return computedStyleCache[nodeRef];
  }

  var style = window.getComputedStyle(node);
  var boxSizing = style.getPropertyValue('box-sizing') || style.getPropertyValue('-moz-box-sizing') || style.getPropertyValue('-webkit-box-sizing');
  var paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));
  var borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));
  var sizingStyle = SIZING_STYLE.map(function (name) {
    return "".concat(name, ":").concat(style.getPropertyValue(name));
  }).join(';');
  var nodeInfo = {
    sizingStyle: sizingStyle,
    paddingSize: paddingSize,
    borderSize: borderSize,
    boxSizing: boxSizing
  };

  if (useCache && nodeRef) {
    computedStyleCache[nodeRef] = nodeInfo;
  }

  return nodeInfo;
}

function calculateNodeHeight(uiTextNode) {
  var useCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var minRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var maxRows = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    document.body.appendChild(hiddenTextarea);
  } // Fix wrap="off" issue
  // https://github.com/ant-design/ant-design/issues/6577


  if (uiTextNode.getAttribute('wrap')) {
    hiddenTextarea.setAttribute('wrap', uiTextNode.getAttribute('wrap'));
  } else {
    hiddenTextarea.removeAttribute('wrap');
  } // Copy all CSS properties that have an impact on the height of the content in
  // the textbox


  var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache),
      paddingSize = _calculateNodeStyling.paddingSize,
      borderSize = _calculateNodeStyling.borderSize,
      boxSizing = _calculateNodeStyling.boxSizing,
      sizingStyle = _calculateNodeStyling.sizingStyle; // Need to have the overflow attribute to hide the scrollbar otherwise
  // text-lines will not calculated properly as the shadow will technically be
  // narrower for content


  hiddenTextarea.setAttribute('style', "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || '';
  var minHeight = -Infinity;
  var maxHeight = Infinity;
  var height = hiddenTextarea.scrollHeight;
  var overflowY;

  if (boxSizing === 'border-box') {
    // border-box: add border, since height = content + padding + border
    height = height + borderSize;
  } else if (boxSizing === 'content-box') {
    // remove padding, since height = content
    height = height - paddingSize;
  }

  if (minRows !== null || maxRows !== null) {
    // measure height of a textarea with a single row
    hiddenTextarea.value = '';
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

    if (minRows !== null) {
      minHeight = singleRowHeight * minRows;

      if (boxSizing === 'border-box') {
        minHeight = minHeight + paddingSize + borderSize;
      }

      height = Math.max(minHeight, height);
    }

    if (maxRows !== null) {
      maxHeight = singleRowHeight * maxRows;

      if (boxSizing === 'border-box') {
        maxHeight = maxHeight + paddingSize + borderSize;
      }

      overflowY = height > maxHeight ? '' : 'hidden';
      height = Math.min(maxHeight, height);
    }
  } // Remove scroll bar flash when autosize without maxRows


  if (!maxRows) {
    overflowY = 'hidden';
  }

  return {
    height: "".concat(height, "px"),
    minHeight: "".concat(minHeight, "px"),
    maxHeight: "".concat(maxHeight, "px"),
    overflowY: overflowY
  };
}
// CONCATENATED MODULE: ./src/components/input/TextArea.jsx


function TextArea_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { TextArea_defineProperty(target, key, source[key]); }); } return target; }

function TextArea_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






function onNextFrame(cb) {
  if (window.requestAnimationFrame) {
    return window.requestAnimationFrame(cb);
  }

  return window.setTimeout(cb, 1);
}

function clearNextFrameAction(nextFrameId) {
  if (window.cancelAnimationFrame) {
    window.cancelAnimationFrame(nextFrameId);
  } else {
    window.clearTimeout(nextFrameId);
  }
}

function fixControlledValue(value) {
  if (typeof value === 'undefined' || value === null) {
    return '';
  }

  return value;
}

/* harmony default export */ var TextArea = ({
  name: 'TaTextarea',
  props: TextArea_objectSpread({}, input_inputProps, {
    autosize: [Object, Boolean]
  }),
  model: {
    prop: 'value',
    event: 'change.value'
  },
  data: function data() {
    var _this$$props = this.$props,
        value = _this$$props.value,
        defaultValue = _this$$props.defaultValue;
    return {
      stateValue: fixControlledValue(!Object(props_util["b" /* default */])(this, 'value') ? defaultValue : value),
      nextFrameActionId: undefined,
      textareaStyles: {}
    };
  },
  computed: {},
  watch: {
    value: function value(val) {
      this.stateValue = fixControlledValue(val);

      if (this.nextFrameActionId) {
        clearNextFrameAction(this.nextFrameActionId);
      }

      this.nextFrameActionId = onNextFrame(this.resizeTextarea);
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.resizeTextarea();

      if (_this.autoFocus) {
        _this.focus();
      }
    });
  },
  methods: {
    handleKeyDown: function handleKeyDown(e) {
      if (e.keyCode === 13) {
        this.$emit('pressEnter', e);
      }

      this.$emit('keydown', e);
    },
    resizeTextarea: function resizeTextarea() {
      var autosize = this.$props.autosize;

      if (!autosize || !this.$refs.textArea) {
        return;
      }

      var minRows = autosize ? autosize.minRows : null;
      var maxRows = autosize ? autosize.maxRows : null;
      var textareaStyles = calculateNodeHeight(this.$refs.textArea, false, minRows, maxRows);
      this.textareaStyles = textareaStyles;
    },
    getTextAreaClassName: function getTextAreaClassName() {
      var _ref;

      var _this$$props2 = this.$props,
          prefixCls = _this$$props2.prefixCls,
          disabled = _this$$props2.disabled;
      return _ref = {}, TextArea_defineProperty(_ref, prefixCls, true), TextArea_defineProperty(_ref, "".concat(prefixCls, "-disabled"), disabled), _ref;
    },
    handleTextareaChange: function handleTextareaChange(e) {
      var _this2 = this;

      if (!Object(props_util["b" /* default */])(this, 'value')) {
        this.stateValue = e.target.value;
        this.$nextTick(function () {
          _this2.resizeTextarea();
        });
      } else {
        this.$forceUpdate();
      }

      if (!e.target.composing) {
        this.$emit('change.value', e.target.value);
      }

      this.$emit('change', e);
      this.$emit('input', e);
    },
    focus: function focus() {
      this.$refs.textArea.focus();
    },
    blur: function blur() {
      this.$refs.textArea.blur();
    }
  },
  render: function render() {
    var h = arguments[0];
    var stateValue = this.stateValue,
        getTextAreaClassName = this.getTextAreaClassName,
        handleKeyDown = this.handleKeyDown,
        handleTextareaChange = this.handleTextareaChange,
        textareaStyles = this.textareaStyles,
        $attrs = this.$attrs,
        $listeners = this.$listeners;
    var otherProps = Object(es["a" /* default */])(this.$props, ['prefixCls', 'autosize', 'type']);
    var textareaProps = {
      attrs: TextArea_objectSpread({}, otherProps, $attrs),
      on: TextArea_objectSpread({}, $listeners, {
        keydown: handleKeyDown,
        input: handleTextareaChange
      })
    };

    if ($listeners['change.value']) {
      textareaProps.directives = [{
        name: 'ant-input'
      }];
    }

    return h("textarea", babel_helper_vue_jsx_merge_props_default()([textareaProps, {
      domProps: {
        "value": stateValue
      },
      "class": getTextAreaClassName(),
      style: textareaStyles,
      ref: 'textArea'
    }]));
  }
});
// CONCATENATED MODULE: ./src/components/_util/env.js
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
// CONCATENATED MODULE: ./src/components/input/Input.jsx


function Input_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Input_defineProperty(target, key, source[key]); }); } return target; }

function Input_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








function Input_fixControlledValue(value) {
  if (typeof value === 'undefined' || value === null) {
    return '';
  }

  return value;
}

/* harmony default export */ var Input = ({
  inheritAttrs: false,
  name: 'TaInput',
  props: Input_objectSpread({}, input_inputProps),
  model: {
    prop: 'value',
    event: 'change.value'
  },
  data: function data() {
    var _this$$props = this.$props,
        value = _this$$props.value,
        defaultValue = _this$$props.defaultValue;
    return {
      stateValue: Input_fixControlledValue(!Object(props_util["p" /* hasProp */])(this, 'value') ? defaultValue : value)
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      if (_this.autoFocus) {
        _this.focus();
      }
    });
  },
  watch: {
    value: function value(val) {
      this.stateValue = Input_fixControlledValue(val);
    }
  },
  methods: {
    handleKeyDown: function handleKeyDown(e) {
      if (e.keyCode === 13) {
        this.$emit('pressEnter', e);
      }

      this.$emit('keydown', e);
    },
    handleChange: function handleChange(e) {
      // https://github.com/vueComponent/ant-design-vue/issues/92
      if (isIE && !isIE9 && this.stateValue === e.target.value) {
        return;
      }

      if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
        this.stateValue = e.target.value;
      } else {
        this.$forceUpdate();
      }

      if (!e.target.composing) {
        this.$emit('change.value', e.target.value);
      }

      this.$emit('change', e);
      this.$emit('input', e);
    },
    focus: function focus() {
      this.$refs.input.focus();
    },
    blur: function blur() {
      this.$refs.input.blur();
    },
    getInputClassName: function getInputClassName() {
      var _ref;

      var _this$$props2 = this.$props,
          prefixCls = _this$$props2.prefixCls,
          size = _this$$props2.size,
          disabled = _this$$props2.disabled;
      return _ref = {}, Input_defineProperty(_ref, "".concat(prefixCls), true), Input_defineProperty(_ref, "".concat(prefixCls, "-sm"), size === 'small'), Input_defineProperty(_ref, "".concat(prefixCls, "-lg"), size === 'large'), Input_defineProperty(_ref, "".concat(prefixCls, "-disabled"), disabled), _ref;
    },
    renderLabeledInput: function renderLabeledInput(children) {
      var _className, _classNames;

      var h = this.$createElement;
      var props = this.$props;
      var addonAfter = Object(props_util["g" /* getComponentFromProp */])(this, 'addonAfter');
      var addonBefore = Object(props_util["g" /* getComponentFromProp */])(this, 'addonBefore'); // Not wrap when there is not addons

      if (!addonBefore && !addonAfter) {
        return children;
      }

      var wrapperClassName = "".concat(props.prefixCls, "-group");
      var addonClassName = "".concat(wrapperClassName, "-addon");
      addonBefore = addonBefore ? h("span", {
        "class": addonClassName
      }, [addonBefore]) : null;
      addonAfter = addonAfter ? h("span", {
        "class": addonClassName
      }, [addonAfter]) : null;
      var className = (_className = {}, Input_defineProperty(_className, "".concat(props.prefixCls, "-wrapper"), true), Input_defineProperty(_className, wrapperClassName, addonBefore || addonAfter), _className);
      var groupClassName = classnames_default()("".concat(props.prefixCls, "-group-wrapper"), (_classNames = {}, Input_defineProperty(_classNames, "".concat(props.prefixCls, "-group-wrapper-sm"), props.size === 'small'), Input_defineProperty(_classNames, "".concat(props.prefixCls, "-group-wrapper-lg"), props.size === 'large'), _classNames));
      return h("span", {
        "class": groupClassName,
        style: Object(props_util["n" /* getStyle */])(this)
      }, [h("span", {
        "class": className
      }, [addonBefore, children, addonAfter])]);
    },
    renderLabeledIcon: function renderLabeledIcon(children) {
      var _classNames2;

      var h = this.$createElement;
      var _this$$props3 = this.$props,
          prefixCls = _this$$props3.prefixCls,
          size = _this$$props3.size;
      var prefix = Object(props_util["g" /* getComponentFromProp */])(this, 'prefix');
      var suffix = Object(props_util["g" /* getComponentFromProp */])(this, 'suffix');

      if (!prefix && !suffix) {
        return children;
      }

      prefix = prefix ? h("span", {
        "class": "".concat(prefixCls, "-prefix")
      }, [prefix]) : null;
      suffix = suffix ? h("span", {
        "class": "".concat(prefixCls, "-suffix")
      }, [suffix]) : null;
      var affixWrapperCls = classnames_default()(Object(props_util["f" /* getClass */])(this), "".concat(prefixCls, "-affix-wrapper"), (_classNames2 = {}, Input_defineProperty(_classNames2, "".concat(prefixCls, "-affix-wrapper-sm"), size === 'small'), Input_defineProperty(_classNames2, "".concat(prefixCls, "-affix-wrapper-lg"), size === 'large'), _classNames2));
      return h("span", {
        "class": affixWrapperCls,
        style: Object(props_util["n" /* getStyle */])(this)
      }, [prefix, children, suffix]);
    },
    renderInput: function renderInput() {
      var h = this.$createElement;
      var otherProps = Object(es["a" /* default */])(this.$props, ['prefixCls', 'addonBefore', 'addonAfter', 'prefix', 'suffix']);
      var stateValue = this.stateValue,
          getInputClassName = this.getInputClassName,
          handleKeyDown = this.handleKeyDown,
          handleChange = this.handleChange,
          $listeners = this.$listeners;
      var inputProps = {
        domProps: {
          value: stateValue
        },
        attrs: Input_objectSpread({}, otherProps, this.$attrs),
        on: Input_objectSpread({}, $listeners, {
          keydown: handleKeyDown,
          input: handleChange
        }),
        "class": classnames_default()(getInputClassName(), Object(props_util["f" /* getClass */])(this)),
        ref: 'input'
      };

      if ($listeners['change.value']) {
        inputProps.directives = [{
          name: 'ant-input'
        }];
      }

      return this.renderLabeledIcon(h("input", inputProps));
    }
  },
  render: function render() {
    var h = arguments[0];

    if (this.$props.type === 'textarea') {
      var $listeners = this.$listeners;
      var textareaProps = {
        props: this.$props,
        attrs: this.$attrs,
        on: Input_objectSpread({}, $listeners, {
          change: this.handleChange,
          keydown: this.handleKeyDown
        }),
        directives: [{
          name: 'ant-input'
        }]
      };
      return h(TextArea, babel_helper_vue_jsx_merge_props_default()([textareaProps, {
        ref: 'input'
      }]));
    }

    return this.renderLabeledInput(this.renderInput());
  }
});
// CONCATENATED MODULE: ./src/components/input/Group.jsx


function Group_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/* harmony default export */ var Group = ({
  name: 'TaInputGroup',
  props: {
    prefixCls: {
      "default": 'ant-input-group',
      type: String
    },
    size: {
      validator: function validator(value) {
        return ['small', 'large', 'default'].includes(value);
      }
    },
    compact: Boolean
  },
  computed: {
    classes: function classes() {
      var _ref;

      var prefixCls = this.prefixCls,
          size = this.size,
          _this$compact = this.compact,
          compact = _this$compact === void 0 ? false : _this$compact;
      return _ref = {}, Group_defineProperty(_ref, "".concat(prefixCls), true), Group_defineProperty(_ref, "".concat(prefixCls, "-lg"), size === 'large'), Group_defineProperty(_ref, "".concat(prefixCls, "-sm"), size === 'small'), Group_defineProperty(_ref, "".concat(prefixCls, "-compact"), compact), _ref;
    }
  },
  methods: {},
  render: function render() {
    var h = arguments[0];
    var $listeners = this.$listeners;
    return h("span", babel_helper_vue_jsx_merge_props_default()([{
      "class": this.classes
    }, {
      on: $listeners
    }]), [Object(props_util["c" /* filterEmpty */])(this.$slots["default"])]);
  }
});
// CONCATENATED MODULE: ./src/components/icon/icon.jsx
function icon_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { icon_defineProperty(target, key, source[key]); }); } return target; }

function icon_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* harmony default export */ var icon_icon = ({
  name: 'TaIcon',
  props: {
    prefixCls: {
      "default": 'anticon',
      type: String
    },
    type: String,
    title: String,
    spin: Boolean
  },
  data: function data() {
    return {};
  },
  computed: {
    classes: function classes() {
      var _ref;

      var prefixCls = this.prefixCls,
          type = this.type,
          spin = this.spin;
      return _ref = {}, icon_defineProperty(_ref, "".concat(prefixCls), true), icon_defineProperty(_ref, "".concat(prefixCls, "-").concat(type), type), icon_defineProperty(_ref, "".concat(prefixCls, "-spin"), !!spin || type === 'loading'), _ref;
    }
  },
  methods: {
    handleClick: function handleClick(event) {
      var _this = this;

      if (this.clicked) {
        return;
      }

      this.clicked = true;
      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        return _this.clicked = false;
      }, 500);
      this.$emit('click', event);
    }
  },
  render: function render() {
    var h = arguments[0];
    var title = this.title,
        classes = this.classes,
        handleClick = this.handleClick,
        $listeners = this.$listeners;
    var iconProps = {
      attrs: {
        title: title
      },
      "class": classes,
      on: icon_objectSpread({}, $listeners, {
        click: handleClick
      })
    };
    return h("i", iconProps);
  },
  beforeDestroy: function beforeDestroy() {
    if (this.timeout) {
      clearTimeout(this.timeout);
    }
  }
});
// CONCATENATED MODULE: ./src/components/icon/index.js

/* istanbul ignore next */

icon_icon.install = function (Vue) {
  Vue.component(icon_icon.name, icon_icon);
};

/* harmony default export */ var components_icon = (icon_icon);
// EXTERNAL MODULE: ./src/components/_util/css-animation/Event.js
var Event = __webpack_require__(66);

// CONCATENATED MODULE: ./src/components/_util/wave.jsx

/* harmony default export */ var wave = ({
  name: 'Wave',
  props: ['insertExtraNode'],
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.instance = _this.bindAnimationEvent(_this.$el);
    });
  },
  beforeDestroy: function beforeDestroy() {
    if (this.instance) {
      this.instance.cancel();
    }
  },
  methods: {
    isNotGrey: function isNotGrey(color) {
      var match = (color || '').match(/rgba?\((\d*), (\d*), (\d*)(, [\.\d]*)?\)/);

      if (match && match[1] && match[2] && match[3]) {
        return !(match[1] === match[2] && match[2] === match[3]);
      }

      return true;
    },
    onClick: function onClick(node, waveColor) {
      if (node.className.indexOf('-leave') >= 0) {
        return;
      }

      this.removeExtraStyleNode();
      var insertExtraNode = this.$props.insertExtraNode;
      this.extraNode = document.createElement('div');
      var extraNode = this.extraNode;
      extraNode.className = 'ant-click-animating-node';
      var attributeName = this.getAttributeName();
      node.removeAttribute(attributeName);
      node.setAttribute(attributeName, 'true'); // Not white or transparnt or grey

      if (waveColor && waveColor !== '#ffffff' && waveColor !== 'rgb(255, 255, 255)' && this.isNotGrey(waveColor) && !/rgba\(\d*, \d*, \d*, 0\)/.test(waveColor) && // any transparent rgba color
      waveColor !== 'transparent') {
        extraNode.style.borderColor = waveColor;
        this.styleForPesudo = document.createElement('style');
        this.styleForPesudo.innerHTML = "[ant-click-animating-without-extra-node]:after { border-color: ".concat(waveColor, "; }");
        document.body.appendChild(this.styleForPesudo);
      }

      if (insertExtraNode) {
        node.appendChild(extraNode);
      }

      Event["a" /* default */].addEndEventListener(node, this.onTransitionEnd);
    },
    bindAnimationEvent: function bindAnimationEvent(node) {
      var _this2 = this;

      if (!node || !node.getAttribute || node.getAttribute('disabled') || node.className.indexOf('disabled') >= 0) {
        return;
      }

      var onClick = function onClick(e) {
        // Fix radio button click twice
        if (e.target.tagName === 'INPUT') {
          return;
        }

        _this2.resetEffect(node); // Get wave color from target


        var waveColor = getComputedStyle(node).getPropertyValue('border-top-color') || // Firefox Compatible
        getComputedStyle(node).getPropertyValue('border-color') || getComputedStyle(node).getPropertyValue('background-color');
        _this2.clickWaveTimeoutId = window.setTimeout(function () {
          return _this2.onClick(node, waveColor);
        }, 0);
      };

      node.addEventListener('click', onClick, true);
      return {
        cancel: function cancel() {
          node.removeEventListener('click', onClick, true);
        }
      };
    },
    getAttributeName: function getAttributeName() {
      var insertExtraNode = this.$props.insertExtraNode;
      return insertExtraNode ? 'ant-click-animating' : 'ant-click-animating-without-extra-node';
    },
    resetEffect: function resetEffect(node) {
      if (!node || node === this.extraNode) {
        return;
      }

      var insertExtraNode = this.$props.insertExtraNode;
      var attributeName = this.getAttributeName();
      node.removeAttribute(attributeName);
      this.removeExtraStyleNode();

      if (insertExtraNode && this.extraNode && node.contains(this.extraNode)) {
        node.removeChild(this.extraNode);
      }

      Event["a" /* default */].removeEndEventListener(node, this.onTransitionEnd);
    },
    onTransitionEnd: function onTransitionEnd(e) {
      if (!e || e.animationName !== 'fadeEffect') {
        return;
      }

      this.resetEffect(e.target);
    },
    removeExtraStyleNode: function removeExtraStyleNode() {
      if (this.styleForPesudo && document.body.contains(this.styleForPesudo)) {
        document.body.removeChild(this.styleForPesudo);
        this.styleForPesudo = null;
      }
    }
  },
  render: function render() {
    return this.$slots["default"] && this.$slots["default"][0];
  }
});
// CONCATENATED MODULE: ./src/components/button/buttonTypes.js

/* harmony default export */ var buttonTypes = (function () {
  return {
    prefixCls: vue_types["a" /* default */].string.def('ant-btn'),
    type: vue_types["a" /* default */].oneOf(['primary', 'danger', 'dashed', 'ghost', 'default']).def('default'),
    htmlType: vue_types["a" /* default */].oneOf(['button', 'submit', 'reset']).def('button'),
    icon: vue_types["a" /* default */].string,
    shape: vue_types["a" /* default */].oneOf(['circle', 'circle-outline']),
    size: vue_types["a" /* default */].oneOf(['small', 'large', 'default']).def('default'),
    loading: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, vue_types["a" /* default */].object]),
    disabled: vue_types["a" /* default */].bool,
    ghost: vue_types["a" /* default */].bool,
    block: vue_types["a" /* default */].bool
  };
});
// CONCATENATED MODULE: ./src/components/button/button.jsx
function button_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { button_defineProperty(target, key, source[key]); }); } return target; }

function button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
var isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
var button_props = buttonTypes();
/* harmony default export */ var button_button = ({
  name: 'TaButton',
  __ANT_BUTTON: true,
  props: button_objectSpread({}, button_props),
  data: function data() {
    return {
      sizeMap: {
        large: 'lg',
        small: 'sm'
      },
      // clicked: false,
      sLoading: !!this.loading,
      hasTwoCNChar: false
    };
  },
  mounted: function mounted() {
    this.fixTwoCNChar();
  },
  updated: function updated() {
    this.fixTwoCNChar();
  },
  beforeDestroy: function beforeDestroy() {
    // if (this.timeout) {
    //   clearTimeout(this.timeout)
    // }
    if (this.delayTimeout) {
      clearTimeout(this.delayTimeout);
    }
  },
  watch: {
    loading: function loading(val) {
      var _this = this;

      clearTimeout(this.delayTimeout);

      if (typeof val !== 'boolean' && val && val.delay) {
        this.delayTimeout = setTimeout(function () {
          _this.sLoading = !!val;
        }, val.delay);
      } else {
        this.sLoading = !!val;
      }
    }
  },
  computed: {
    classes: function classes() {
      var _ref;

      var prefixCls = this.prefixCls,
          type = this.type,
          shape = this.shape,
          size = this.size,
          hasTwoCNChar = this.hasTwoCNChar,
          sLoading = this.sLoading,
          ghost = this.ghost,
          block = this.block,
          sizeMap = this.sizeMap;
      var sizeCls = sizeMap[size] || '';
      return _ref = {}, button_defineProperty(_ref, "".concat(prefixCls), true), button_defineProperty(_ref, "".concat(prefixCls, "-").concat(type), type), button_defineProperty(_ref, "".concat(prefixCls, "-").concat(shape), shape), button_defineProperty(_ref, "".concat(prefixCls, "-").concat(sizeCls), sizeCls), button_defineProperty(_ref, "".concat(prefixCls, "-loading"), sLoading), button_defineProperty(_ref, "".concat(prefixCls, "-background-ghost"), ghost || type === 'ghost'), button_defineProperty(_ref, "".concat(prefixCls, "-two-chinese-chars"), hasTwoCNChar), button_defineProperty(_ref, "".concat(prefixCls, "-block"), block), _ref;
    }
  },
  methods: {
    fixTwoCNChar: function fixTwoCNChar() {
      // Fix for HOC usage like <FormatMessage />
      var node = this.$el;
      var buttonText = node.textContent || node.innerText;

      if (this.isNeedInserted() && isTwoCNChar(buttonText)) {
        if (!this.hasTwoCNChar) {
          this.hasTwoCNChar = true;
        }
      } else if (this.hasTwoCNChar) {
        this.hasTwoCNChar = false;
      }
    },
    handleClick: function handleClick(event) {
      // this.clicked = true
      // clearTimeout(this.timeout)
      // this.timeout = setTimeout(() => (this.clicked = false), 500)
      this.$emit('click', event);
    },
    insertSpace: function insertSpace(child, needInserted) {
      var h = this.$createElement;
      var SPACE = needInserted ? ' ' : '';

      if (typeof child.text === 'string') {
        var text = child.text.trim();

        if (isTwoCNChar(text)) {
          text = text.split('').join(SPACE);
        }

        return h("span", [text]);
      }

      return child;
    },
    isNeedInserted: function isNeedInserted() {
      var icon = this.icon,
          $slots = this.$slots;
      return $slots["default"] && $slots["default"].length === 1 && !icon;
    }
  },
  render: function render() {
    var h = arguments[0];
    var htmlType = this.htmlType,
        classes = this.classes,
        icon = this.icon,
        disabled = this.disabled,
        handleClick = this.handleClick,
        sLoading = this.sLoading,
        $slots = this.$slots,
        $attrs = this.$attrs,
        $listeners = this.$listeners;
    var buttonProps = {
      props: {},
      attrs: button_objectSpread({}, $attrs, {
        type: htmlType,
        disabled: disabled
      }),
      "class": classes,
      on: button_objectSpread({}, $listeners, {
        click: handleClick
      })
    };
    var iconType = sLoading ? 'loading' : icon;
    var iconNode = iconType ? h(components_icon, {
      attrs: {
        type: iconType
      }
    }) : null;
    var kids = $slots["default"] && $slots["default"].length === 1 ? this.insertSpace($slots["default"][0], this.isNeedInserted()) : $slots["default"];

    if ('href' in $attrs) {
      return h("a", buttonProps, [iconNode, kids]);
    } else {
      return h(wave, [h("button", buttonProps, [iconNode, kids])]);
    }
  }
});
// CONCATENATED MODULE: ./src/components/button/button-group.jsx
function button_group_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var ButtonGroupProps = {
  prefixCls: {
    "default": 'ant-btn-group',
    type: String
  },
  size: {
    validator: function validator(value) {
      return ['small', 'large', 'default'].includes(value);
    }
  }
};

/* harmony default export */ var button_group = ({
  name: 'TaButtonGroup',
  props: ButtonGroupProps,
  data: function data() {
    return {
      sizeMap: {
        large: 'lg',
        small: 'sm'
      }
    };
  },
  computed: {
    classes: function classes() {
      var _ref;

      var prefixCls = this.prefixCls,
          size = this.size,
          sizeMap = this.sizeMap;
      var sizeCls = sizeMap[size] || '';
      return [(_ref = {}, button_group_defineProperty(_ref, "".concat(prefixCls), true), button_group_defineProperty(_ref, "".concat(prefixCls, "-").concat(sizeCls), sizeCls), _ref)];
    }
  },
  render: function render() {
    var h = arguments[0];
    var classes = this.classes,
        $slots = this.$slots;
    return h("div", {
      "class": classes
    }, [Object(props_util["c" /* filterEmpty */])($slots["default"])]);
  }
});
// CONCATENATED MODULE: ./src/components/button/index.js


button_button.Group = button_group;
/* istanbul ignore next */

button_button.install = function (Vue) {
  Vue.component(button_button.name, button_button);
  Vue.component(button_group.name, button_group);
};

/* harmony default export */ var components_button = (button_button);
// CONCATENATED MODULE: ./src/components/input/Search.jsx


function Search_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Search_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Search_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function Search_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Search_defineProperty(target, key, source[key]); }); } return target; }

function Search_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









/* harmony default export */ var Search = ({
  name: 'TaInputSearch',
  props: Search_objectSpread({}, input_inputProps, {
    prefixCls: {
      "default": 'ant-input-search',
      type: String
    },
    inputPrefixCls: {
      "default": 'ant-input',
      type: String
    },
    enterButton: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, vue_types["a" /* default */].string, vue_types["a" /* default */].object])
  }),
  model: {
    prop: 'value',
    event: 'change.value'
  },
  methods: {
    onSearch: function onSearch(e) {
      this.$emit('search', this.$refs.input.stateValue, e);
      this.$refs.input.focus();
    },
    focus: function focus() {
      this.$refs.input.focus();
    },
    blur: function blur() {
      this.$refs.input.blur();
    },
    getButtonOrIcon: function getButtonOrIcon() {
      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          size = this.size,
          disabled = this.disabled;
      var enterButton = Object(props_util["g" /* getComponentFromProp */])(this, 'enterButton');
      var enterButtonAsElement = Array.isArray(enterButton) ? enterButton[0] : enterButton;
      var node;

      if (!enterButton) {
        node = h(components_icon, {
          "class": "".concat(prefixCls, "-icon"),
          attrs: {
            type: 'search'
          },
          key: 'searchIcon'
        });
      } else if (enterButtonAsElement.tag === 'button' || enterButtonAsElement.componentOptions && enterButtonAsElement.componentOptions.Ctor.extendOptions.__ANT_BUTTON) {
        node = Object(vnode["a" /* cloneElement */])(enterButtonAsElement, {
          "class": "".concat(prefixCls, "-button"),
          props: {
            size: size
          }
        });
      } else {
        node = h(components_button, {
          "class": "".concat(prefixCls, "-button"),
          attrs: {
            type: 'primary',
            size: size,
            disabled: disabled
          },
          key: 'enterButton'
        }, [enterButton === true ? h(components_icon, {
          attrs: {
            type: 'search'
          }
        }) : enterButton]);
      }

      return Object(vnode["a" /* cloneElement */])(node, {
        on: {
          click: this.onSearch
        }
      });
    }
  },
  render: function render() {
    var _classNames;

    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        prefixCls = _getOptionProps.prefixCls,
        inputPrefixCls = _getOptionProps.inputPrefixCls,
        size = _getOptionProps.size,
        suffix = _getOptionProps.suffix,
        others = Search_objectWithoutProperties(_getOptionProps, ["prefixCls", "inputPrefixCls", "size", "suffix"]);

    var enterButton = Object(props_util["g" /* getComponentFromProp */])(this, 'enterButton');
    var buttonOrIcon = this.getButtonOrIcon();
    var searchSuffix = suffix ? [suffix, buttonOrIcon] : buttonOrIcon;
    var inputClassName = classnames_default()(prefixCls, (_classNames = {}, Search_defineProperty(_classNames, "".concat(prefixCls, "-enter-button"), !!enterButton), Search_defineProperty(_classNames, "".concat(prefixCls, "-").concat(size), !!size), _classNames));

    var on = Search_objectSpread({}, this.$listeners);

    delete on.search;
    var inputProps = {
      props: Search_objectSpread({}, others, {
        prefixCls: inputPrefixCls,
        size: size,
        suffix: searchSuffix
      }),
      attrs: this.$attrs,
      on: Search_objectSpread({
        pressEnter: this.onSearch
      }, on)
    };
    return h(Input, babel_helper_vue_jsx_merge_props_default()([inputProps, {
      "class": inputClassName,
      ref: 'input'
    }]));
  }
});
// CONCATENATED MODULE: ./src/components/_util/antInputDirective.js
/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */
var antInputDirective_inBrowser = typeof window !== 'undefined';
var antInputDirective_UA = antInputDirective_inBrowser && window.navigator.userAgent.toLowerCase();
var antInputDirective_isIE9 = antInputDirective_UA && antInputDirective_UA.indexOf('msie 9.0') > 0;

function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) return;
  e.target.composing = false;
  antInputDirective_trigger(e.target, 'input');
}

function antInputDirective_trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
/* istanbul ignore if */


if (antInputDirective_isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;

    if (el && el.vmodel) {
      antInputDirective_trigger(el, 'input');
    }
  });
}

/* harmony default export */ var antInputDirective = ({
  install: function install(Vue, options) {
    Vue.directive('ant-input', {
      inserted: function inserted(el, binding, vnode, oldVnode) {
        if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
          if (!binding.modifiers || !binding.modifiers.lazy) {
            el.addEventListener('compositionstart', onCompositionStart);
            el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
            // switching focus before confirming composition choice
            // this also fixes the issue where some browsers e.g. iOS Chrome
            // fires "change" instead of "input" on autocomplete.

            el.addEventListener('change', onCompositionEnd);
            /* istanbul ignore if */

            if (antInputDirective_isIE9) {
              el.vmodel = true;
            }
          }
        }
      }
    });
  }
});
// CONCATENATED MODULE: ./src/components/input/index.js






external_Vue_default.a.use(antInputDirective);
Input.Group = Group;
Input.Search = Search;
Input.TextArea = TextArea;
/* istanbul ignore next */

Input.install = function (Vue) {
  Vue.component(Input.name, Input);
  Vue.component(Input.Group.name, Input.Group);
  Vue.component(Input.Search.name, Input.Search);
  Vue.component(Input.TextArea.name, Input.TextArea);
};

/* harmony default export */ var components_input = (Input);
// CONCATENATED MODULE: ./src/components/auto-complete/InputElement.jsx
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function InputElement_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { InputElement_defineProperty(target, key, source[key]); }); } return target; }

function InputElement_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




function InputElement_chaining() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    // eslint-disable-line
    // eslint-disable-line
    for (var i = 0; i < fns.length; i++) {
      if (fns[i] && typeof fns[i] === 'function') {
        fns[i].apply(this, args);
      }
    }
  };
}

/* harmony default export */ var InputElement = ({
  props: {
    value: vue_types["a" /* default */].any,
    disabled: vue_types["a" /* default */].bool
  },
  methods: {
    focus: function focus() {
      var ele = this.$refs.ele;
      ele.focus ? ele.focus() : this.$el.focus();
    },
    blur: function blur() {
      var ele = this.$refs.ele;
      ele.blur ? ele.blur() : this.$el.blur();
    }
  },
  render: function render() {
    var _this$$slots = this.$slots,
        $slots = _this$$slots === void 0 ? {} : _this$$slots,
        _this$$listeners = this.$listeners,
        $listeners = _this$$listeners === void 0 ? {} : _this$$listeners,
        _this$$props = this.$props,
        $props = _this$$props === void 0 ? {} : _this$$props,
        _this$$attrs = this.$attrs,
        $attrs = _this$$attrs === void 0 ? {} : _this$$attrs;
    var value = $props.value === undefined ? '' : $props.value;
    var children = $slots["default"][0];
    var _$slots$default$0$com = $slots["default"][0].componentOptions,
        componentOptions = _$slots$default$0$com === void 0 ? {} : _$slots$default$0$com;
    var _componentOptions$lis = componentOptions.listeners,
        listeners = _componentOptions$lis === void 0 ? {} : _componentOptions$lis;

    var newEvent = InputElement_objectSpread({}, listeners);

    for (var _i = 0, _Object$entries = Object.entries($listeners); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          eventName = _Object$entries$_i[0],
          event = _Object$entries$_i[1];

      newEvent[eventName] = InputElement_chaining(event, listeners[eventName]);
    }

    return Object(vnode["a" /* cloneElement */])(children, {
      domProps: {
        value: value
      },
      props: $props,
      on: newEvent,
      attrs: InputElement_objectSpread({}, $attrs, {
        value: value
      }),
      ref: 'ele'
    });
  }
});
// CONCATENATED MODULE: ./src/components/auto-complete/index.jsx
function auto_complete_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { auto_complete_typeof = function _typeof(obj) { return typeof obj; }; } else { auto_complete_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return auto_complete_typeof(obj); }

function auto_complete_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { auto_complete_defineProperty(target, key, source[key]); }); } return target; }

function auto_complete_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






 // const DataSourceItemObject = PropTypes.shape({
//   value: String,
//   text: String,
// }).loose
// const DataSourceItemType = PropTypes.oneOfType([
//   PropTypes.string,
//   DataSourceItemObject,
// ]).isRequired
// export interface AutoCompleteInputProps {
//   onChange?: React.FormEventHandler<any>;
//   value: any;
// }

var AutoCompleteProps = auto_complete_objectSpread({}, select_AbstractSelectProps(), {
  value: SelectValue,
  defaultValue: SelectValue,
  dataSource: vue_types["a" /* default */].array,
  optionLabelProp: String,
  dropdownMatchSelectWidth: vue_types["a" /* default */].bool // onChange?: (value: SelectValue) => void;
  // onSelect?: (value: SelectValue, option: Object) => any;

});

var AutoComplete = {
  name: 'TaAutoComplete',
  props: auto_complete_objectSpread({}, AutoCompleteProps, {
    prefixCls: vue_types["a" /* default */].string.def('ant-select'),
    showSearch: vue_types["a" /* default */].bool.def(false),
    transitionName: vue_types["a" /* default */].string.def('slide-up'),
    choiceTransitionName: vue_types["a" /* default */].string.def('zoom'),
    autoFocus: vue_types["a" /* default */].bool,
    backfill: vue_types["a" /* default */].bool,
    optionLabelProp: vue_types["a" /* default */].string.def('children'),
    filterOption: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, vue_types["a" /* default */].func]).def(false),
    defaultActiveFirstOption: vue_types["a" /* default */].bool.def(true)
  }),
  Option: auto_complete_objectSpread({}, Option, {
    name: 'TaAutoCompleteOption'
  }),
  OptGroup: auto_complete_objectSpread({}, OptGroup, {
    name: 'TaAutoCompleteOptGroup'
  }),
  model: {
    prop: 'value',
    event: 'change'
  },
  methods: {
    getInputElement: function getInputElement() {
      var h = this.$createElement;
      var $slots = this.$slots;
      var children = Object(props_util["c" /* filterEmpty */])($slots["default"]);
      var element = children.length ? children[0] : h(components_input);
      return h(InputElement, [element]);
    },
    focus: function focus() {
      if (this.$refs.select) {
        this.$refs.select.focus();
      }
    },
    blur: function blur() {
      if (this.$refs.select) {
        this.$refs.select.blur();
      }
    }
  },
  render: function render() {
    var _cls;

    var h = arguments[0];
    var size = this.size,
        prefixCls = this.prefixCls,
        optionLabelProp = this.optionLabelProp,
        dataSource = this.dataSource,
        $slots = this.$slots,
        $listeners = this.$listeners;
    var cls = (_cls = {}, auto_complete_defineProperty(_cls, "".concat(prefixCls, "-lg"), size === 'large'), auto_complete_defineProperty(_cls, "".concat(prefixCls, "-sm"), size === 'small'), auto_complete_defineProperty(_cls, "".concat(prefixCls, "-show-search"), true), auto_complete_defineProperty(_cls, "".concat(prefixCls, "-auto-complete"), true), _cls);
    var options;
    var childArray = Object(props_util["c" /* filterEmpty */])($slots.dataSource);

    if (childArray.length) {
      options = childArray;
    } else {
      options = dataSource ? dataSource.map(function (item) {
        if (Object(props_util["s" /* isValidElement */])(item)) {
          return item;
        }

        switch (auto_complete_typeof(item)) {
          case 'string':
            return h(Option, {
              key: item
            }, [item]);

          case 'object':
            return h(Option, {
              key: item.value
            }, [item.text]);

          default:
            throw new Error('AutoComplete[dataSource] only supports type `string[] | Object[]`.');
        }
      }) : [];
    }

    var selectProps = {
      props: auto_complete_objectSpread({}, Object(props_util["j" /* getOptionProps */])(this), {
        mode: components_select.SECRET_COMBOBOX_MODE_DO_NOT_USE,
        optionLabelProp: optionLabelProp,
        getInputElement: this.getInputElement,
        notFoundContent: Object(props_util["g" /* getComponentFromProp */])(this, 'notFoundContent')
      }),
      "class": cls,
      ref: 'select',
      on: auto_complete_objectSpread({}, $listeners)
    };
    return h(components_select, selectProps, [options]);
  }
};
/* istanbul ignore next */

AutoComplete.install = function (Vue) {
  Vue.component(AutoComplete.name, AutoComplete);
  Vue.component(AutoComplete.Option.name, AutoComplete.Option);
  Vue.component(AutoComplete.OptGroup.name, AutoComplete.OptGroup);
};

/* harmony default export */ var auto_complete = (AutoComplete);
// CONCATENATED MODULE: ./src/components/alert/index.jsx
function alert_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








function alert_noop() {}

var AlertProps = {
  /**
   * Type of Alert styles, options:`success`, `info`, `warning`, `error`
   */
  type: vue_types["a" /* default */].oneOf(['success', 'info', 'warning', 'error']),

  /** Whether Alert can be closed */
  closable: vue_types["a" /* default */].bool,

  /** Close text to show */
  closeText: vue_types["a" /* default */].any,

  /** Content of Alert */
  message: vue_types["a" /* default */].any,

  /** Additional content of Alert */
  description: vue_types["a" /* default */].any,

  /** Callback when close Alert */
  // onClose?: React.MouseEventHandler<HTMLAnchorElement>;

  /** Trigger when animation ending of Alert */
  afterClose: vue_types["a" /* default */].func.def(alert_noop),

  /** Whether to show icon */
  showIcon: vue_types["a" /* default */].bool,
  iconType: vue_types["a" /* default */].string,
  prefixCls: vue_types["a" /* default */].string,
  banner: vue_types["a" /* default */].bool
};
var Alert = {
  props: AlertProps,
  mixins: [BaseMixin["a" /* default */]],
  name: 'TaAlert',
  data: function data() {
    return {
      closing: true,
      closed: false
    };
  },
  methods: {
    handleClose: function handleClose(e) {
      e.preventDefault();
      var dom = this.$el;
      dom.style.height = "".concat(dom.offsetHeight, "px"); // Magic code
      // 重复一次后才能正确设置 height

      dom.style.height = "".concat(dom.offsetHeight, "px");
      this.setState({
        closing: false
      });
      this.$emit('close', e);
    },
    animationEnd: function animationEnd() {
      this.setState({
        closed: true,
        closing: true
      });
      this.afterClose();
    }
  },
  render: function render() {
    var _classNames;

    var h = arguments[0];
    var _this$prefixCls = this.prefixCls,
        prefixCls = _this$prefixCls === void 0 ? 'ant-alert' : _this$prefixCls,
        banner = this.banner,
        closing = this.closing,
        closed = this.closed;
    var closable = this.closable,
        type = this.type,
        showIcon = this.showIcon,
        iconType = this.iconType;
    var closeText = Object(props_util["g" /* getComponentFromProp */])(this, 'closeText');
    var description = Object(props_util["g" /* getComponentFromProp */])(this, 'description');
    var message = Object(props_util["g" /* getComponentFromProp */])(this, 'message'); // banner模式默认有 Icon

    showIcon = banner && showIcon === undefined ? true : showIcon; // banner模式默认为警告

    type = banner && type === undefined ? 'warning' : type || 'info';

    if (!iconType) {
      switch (type) {
        case 'success':
          iconType = 'check-circle';
          break;

        case 'info':
          iconType = 'info-circle';
          break;

        case 'error':
          iconType = 'cross-circle';
          break;

        case 'warning':
          iconType = 'exclamation-circle';
          break;

        default:
          iconType = 'default';
      } // use outline icon in alert with description


      if (description) {
        iconType += '-o';
      }
    }

    var alertCls = classnames_default()(prefixCls, (_classNames = {}, alert_defineProperty(_classNames, "".concat(prefixCls, "-").concat(type), true), alert_defineProperty(_classNames, "".concat(prefixCls, "-close"), !closing), alert_defineProperty(_classNames, "".concat(prefixCls, "-with-description"), !!description), alert_defineProperty(_classNames, "".concat(prefixCls, "-no-icon"), !showIcon), alert_defineProperty(_classNames, "".concat(prefixCls, "-banner"), !!banner), _classNames)); // closeable when closeText is assigned

    if (closeText) {
      closable = true;
    }

    var closeIcon = closable ? h("a", {
      on: {
        "click": this.handleClose
      },
      "class": "".concat(prefixCls, "-close-icon")
    }, [closeText || h(components_icon, {
      attrs: {
        type: 'cross'
      }
    })]) : null;
    var transitionProps = Object(getTransitionProps["a" /* default */])("".concat(prefixCls, "-slide-up"), {
      appear: false,
      afterLeave: this.animationEnd
    });
    return closed ? null : h("transition", transitionProps, [h("div", {
      directives: [{
        name: "show",
        value: closing
      }],
      "class": alertCls,
      attrs: {
        "data-show": closing
      }
    }, [showIcon ? h(components_icon, {
      "class": "".concat(prefixCls, "-icon"),
      attrs: {
        type: iconType
      }
    }) : null, h("span", {
      "class": "".concat(prefixCls, "-message")
    }, [message]), h("span", {
      "class": "".concat(prefixCls, "-description")
    }, [description]), closeIcon])]);
  }
};
/* istanbul ignore next */

Alert.install = function (Vue) {
  Vue.component(Alert.name, Alert);
};

/* harmony default export */ var components_alert = (Alert);
// CONCATENATED MODULE: ./src/components/avatar/Avatar.jsx
function Avatar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Avatar_defineProperty(target, key, source[key]); }); } return target; }

function Avatar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/* harmony default export */ var Avatar = ({
  name: 'TaAvatar',
  props: {
    prefixCls: {
      type: String,
      "default": 'ant-avatar'
    },
    shape: {
      validator: function validator(val) {
        return ['circle', 'square'].includes(val);
      },
      "default": 'circle'
    },
    size: {
      validator: function validator(val) {
        return typeof val === 'number' || ['small', 'large', 'default'].includes(val);
      },
      "default": 'default'
    },
    src: String,
    icon: String,
    alt: String,
    loadError: Function
  },
  data: function data() {
    return {
      isImgExist: true,
      scale: 1
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.prevChildren = this.$slots["default"];
    this.prevState = Avatar_objectSpread({}, this.$data);
    this.$nextTick(function () {
      _this.setScale();
    });
  },
  updated: function updated() {
    var _this2 = this;

    if (this.preChildren !== this.$slots["default"] || this.prevState.scale !== this.$data.scale && this.$data.scale === 1 || this.prevState.isImgExist !== this.$data.isImgExist) {
      this.$nextTick(function () {
        _this2.setScale();
      });
    }

    this.preChildren = this.$slots["default"];
    this.prevState = Avatar_objectSpread({}, this.$data);
  },
  methods: {
    setScale: function setScale() {
      var childrenNode = this.$refs.avatarChildren;

      if (childrenNode) {
        var childrenWidth = childrenNode.offsetWidth;
        var avatarWidth = this.$el.getBoundingClientRect().width;

        if (avatarWidth - 8 < childrenWidth) {
          this.scale = (avatarWidth - 8) / childrenWidth;
        } else {
          this.scale = 1;
        }

        this.$forceUpdate();
      }
    },
    handleImgLoadError: function handleImgLoadError() {
      var loadError = this.$props.loadError;
      var errorFlag = loadError ? loadError() : undefined;

      if (errorFlag !== false) {
        this.isImgExist = false;
      }
    }
  },
  render: function render() {
    var _sizeCls, _objectSpread3;

    var h = arguments[0];
    var _this$$props = this.$props,
        prefixCls = _this$$props.prefixCls,
        shape = _this$$props.shape,
        size = _this$$props.size,
        src = _this$$props.src,
        icon = _this$$props.icon,
        alt = _this$$props.alt;
    var _this$$data = this.$data,
        isImgExist = _this$$data.isImgExist,
        scale = _this$$data.scale;
    var sizeCls = (_sizeCls = {}, Avatar_defineProperty(_sizeCls, "".concat(prefixCls, "-lg"), size === 'large'), Avatar_defineProperty(_sizeCls, "".concat(prefixCls, "-sm"), size === 'small'), _sizeCls);

    var classString = Avatar_objectSpread(Avatar_defineProperty({}, prefixCls, true), sizeCls, (_objectSpread3 = {}, Avatar_defineProperty(_objectSpread3, "".concat(prefixCls, "-").concat(shape), shape), Avatar_defineProperty(_objectSpread3, "".concat(prefixCls, "-image"), src && isImgExist), Avatar_defineProperty(_objectSpread3, "".concat(prefixCls, "-icon"), icon), _objectSpread3));

    var sizeStyle = typeof size === 'number' ? {
      width: "".concat(size, "px"),
      height: "".concat(size, "px"),
      lineHeight: "".concat(size, "px"),
      fontSize: icon ? "".concat(size / 2, "px") : '18px'
    } : {};
    var children = this.$slots["default"];

    if (src && isImgExist) {
      children = h("img", {
        attrs: {
          src: src,
          alt: alt
        },
        on: {
          "error": this.handleImgLoadError
        }
      });
    } else if (icon) {
      children = h(components_icon, {
        attrs: {
          type: icon
        }
      });
    } else {
      var childrenNode = this.$refs.avatarChildren;

      if (childrenNode || scale !== 1 && childrenNode) {
        var childrenStyle = {
          msTransform: "scale(".concat(scale, ")"),
          WebkitTransform: "scale(".concat(scale, ")"),
          transform: "scale(".concat(scale, ")"),
          position: 'absolute',
          display: 'inline-block',
          left: "calc(50% - ".concat(Math.round(childrenNode.offsetWidth / 2), "px)")
        };
        var sizeChildrenStyle = typeof size === 'number' ? {
          lineHeight: "".concat(size, "px")
        } : {};
        children = h("span", {
          "class": "".concat(prefixCls, "-string"),
          ref: 'avatarChildren',
          style: Avatar_objectSpread({}, sizeChildrenStyle, childrenStyle)
        }, [children]);
      } else {
        children = h("span", {
          "class": "".concat(prefixCls, "-string"),
          ref: 'avatarChildren'
        }, [children]);
      }
    }

    return h("span", {
      on: this.$listeners,
      "class": classString,
      style: sizeStyle
    }, [children]);
  }
});
// CONCATENATED MODULE: ./src/components/avatar/index.js

/* istanbul ignore next */

Avatar.install = function (Vue) {
  Vue.component(Avatar.name, Avatar);
};

/* harmony default export */ var components_avatar = (Avatar);
// CONCATENATED MODULE: ./src/components/back-top/index.jsx
function back_top_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { back_top_defineProperty(target, key, source[key]); }); } return target; }

function back_top_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var back_top_easeInOutCubic = function easeInOutCubic(t, b, c, d) {
  var cc = c - b;
  t /= d / 2;

  if (t < 1) {
    return cc / 2 * t * t * t + b;
  } else {
    return cc / 2 * ((t -= 2) * t * t + 2) + b;
  }
};

function back_top_getDefaultTarget() {
  return window;
}

var BackTopProps = {
  visibilityHeight: vue_types["a" /* default */].number,
  // onClick?: React.MouseEventHandler<any>;
  target: vue_types["a" /* default */].func,
  prefixCls: vue_types["a" /* default */].string
};
var BackTop = {
  name: 'TaBackTop',
  mixins: [BaseMixin["a" /* default */]],
  props: back_top_objectSpread({}, BackTopProps, {
    visibilityHeight: vue_types["a" /* default */].number.def(400)
  }),
  data: function data() {
    this.scrollEvent = null;
    return {
      visible: false
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      var getTarget = _this.target || back_top_getDefaultTarget;
      _this.scrollEvent = addEventListenerWrap(getTarget(), 'scroll', _this.handleScroll);

      _this.handleScroll();
    });
  },
  beforeDestroy: function beforeDestroy() {
    if (this.scrollEvent) {
      this.scrollEvent.remove();
    }
  },
  methods: {
    getCurrentScrollTop: function getCurrentScrollTop() {
      var getTarget = this.target || back_top_getDefaultTarget;
      var targetNode = getTarget();

      if (targetNode === window) {
        return window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;
      }

      return targetNode.scrollTop;
    },
    scrollToTop: function scrollToTop(e) {
      var _this2 = this;

      var scrollTop = this.getCurrentScrollTop();
      var startTime = Date.now();

      var frameFunc = function frameFunc() {
        var timestamp = Date.now();
        var time = timestamp - startTime;

        _this2.setScrollTop(back_top_easeInOutCubic(time, scrollTop, 0, 450));

        if (time < 450) {
          raf_default()(frameFunc);
        } else {
          _this2.setScrollTop(0);
        }
      };

      raf_default()(frameFunc);
      this.$emit('click', e);
    },
    setScrollTop: function setScrollTop(value) {
      var getTarget = this.target || back_top_getDefaultTarget;
      var targetNode = getTarget();

      if (targetNode === window) {
        document.body.scrollTop = value;
        document.documentElement.scrollTop = value;
      } else {
        targetNode.scrollTop = value;
      }
    },
    handleScroll: function handleScroll() {
      var visibilityHeight = this.visibilityHeight,
          _this$target = this.target,
          target = _this$target === void 0 ? back_top_getDefaultTarget : _this$target;
      var scrollTop = getScroll(target(), true);
      this.setState({
        visible: scrollTop > visibilityHeight
      });
    }
  },
  render: function render() {
    var h = arguments[0];
    var _this$prefixCls = this.prefixCls,
        prefixCls = _this$prefixCls === void 0 ? 'ant-back-top' : _this$prefixCls,
        $slots = this.$slots,
        $listeners = this.$listeners;
    var defaultElement = h("div", {
      "class": "".concat(prefixCls, "-content")
    }, [h("div", {
      "class": "".concat(prefixCls, "-icon")
    })]);
    var divProps = {
      on: back_top_objectSpread({}, $listeners, {
        click: this.scrollToTop
      }),
      "class": prefixCls
    };
    var backTopBtn = this.visible ? h("div", divProps, [$slots["default"] || defaultElement]) : null;
    var transitionProps = Object(getTransitionProps["a" /* default */])('fade');
    return h("transition", transitionProps, [backTopBtn]);
  }
};
/* istanbul ignore next */

BackTop.install = function (Vue) {
  Vue.component(BackTop.name, BackTop);
};

/* harmony default export */ var back_top = (BackTop);
// CONCATENATED MODULE: ./src/components/badge/ScrollNumber.jsx
function ScrollNumber_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { ScrollNumber_defineProperty(target, key, source[key]); }); } return target; }

function ScrollNumber_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






function getNumberArray(num) {
  return num ? num.toString().split('').reverse().map(function (i) {
    return Number(i);
  }) : [];
}

var ScrollNumberProps = {
  prefixCls: vue_types["a" /* default */].string.def('ant-scroll-number'),
  count: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string, null]).def(null),
  component: vue_types["a" /* default */].string,
  title: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string, null])
};
/* harmony default export */ var ScrollNumber = ({
  mixins: [BaseMixin["a" /* default */]],
  props: ScrollNumberProps,
  data: function data() {
    return {
      animateStarted: true,
      sCount: this.count
    };
  },
  watch: {
    count: function count(val) {
      var _this = this;

      if (this.sCount !== val) {
        this.lastCount = this.sCount; // 复原数字初始位置

        this.setState({
          animateStarted: true
        }, function () {
          // 等待数字位置复原完毕
          // 开始设置完整的数字
          setTimeout(function () {
            _this.setState({
              animateStarted: false,
              sCount: val
            }, function () {
              _this.$emit('animated');
            });
          }, 5);
        });
      }
    }
  },
  methods: {
    getPositionByNum: function getPositionByNum(num, i) {
      if (this.animateStarted) {
        return 10 + num;
      }

      var currentDigit = getNumberArray(this.sCount)[i];
      var lastDigit = getNumberArray(this.lastCount)[i]; // 同方向则在同一侧切换数字

      if (this.sCount > this.lastCount) {
        if (currentDigit >= lastDigit) {
          return 10 + num;
        }

        return 20 + num;
      }

      if (currentDigit <= lastDigit) {
        return 10 + num;
      }

      return num;
    },
    renderNumberList: function renderNumberList(position) {
      var h = this.$createElement;
      var childrenToReturn = [];

      for (var i = 0; i < 30; i++) {
        var currentClassName = position === i ? 'current' : '';
        childrenToReturn.push(h("p", {
          key: i.toString(),
          "class": currentClassName
        }, [i % 10]));
      }

      return childrenToReturn;
    },
    renderCurrentNumber: function renderCurrentNumber(num, i) {
      var h = this.$createElement;
      var position = this.getPositionByNum(num, i);
      var removeTransition = this.animateStarted || getNumberArray(this.lastCount)[i] === undefined;
      var style = {
        transition: removeTransition ? 'none' : undefined,
        msTransform: "translateY(".concat(-position * 100, "%)"),
        WebkitTransform: "translateY(".concat(-position * 100, "%)"),
        transform: "translateY(".concat(-position * 100, "%)")
      };
      return h("span", {
        "class": "".concat(this.prefixCls, "-only"),
        style: style,
        key: i
      }, [this.renderNumberList(position)]);
    },
    renderNumberElement: function renderNumberElement() {
      var _this2 = this;

      var sCount = this.sCount;

      if (!sCount || isNaN(sCount)) {
        return sCount;
      }

      return getNumberArray(sCount).map(function (num, i) {
        return _this2.renderCurrentNumber(num, i);
      }).reverse();
    }
  },
  render: function render() {
    var h = arguments[0];
    var prefixCls = this.prefixCls,
        title = this.title,
        _this$component = this.component,
        Tag = _this$component === void 0 ? 'sup' : _this$component;
    var style = Object(props_util["n" /* getStyle */])(this, true); // fix https://fb.me/react-unknown-prop

    var restProps = Object(es["a" /* default */])(this.$props, ['count', 'component', 'prefixCls']);
    var newProps = {
      props: ScrollNumber_objectSpread({}, restProps),
      attrs: {
        title: title
      },
      "class": prefixCls,
      style: style // allow specify the border
      // mock border-color by box-shadow for compatible with old usage:
      // <Badge count={4} style={{ backgroundColor: '#fff', color: '#999', borderColor: '#d9d9d9' }} />

    };

    if (style && style.borderColor) {
      newProps.style.boxShadow = "0 0 0 1px ".concat(style.borderColor, " inset");
    }

    return h(Tag, newProps, [this.renderNumberElement()]);
  }
});
// CONCATENATED MODULE: ./src/components/badge/Badge.jsx



function Badge_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Badge_defineProperty(target, key, source[key]); }); } return target; }

function Badge_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var BadgeProps = {
  /** Number to show in badge */
  count: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string, null]),
  showZero: vue_types["a" /* default */].bool,

  /** Max count to show */
  overflowCount: vue_types["a" /* default */].number,

  /** whether to show red dot without number */
  dot: vue_types["a" /* default */].bool,
  prefixCls: vue_types["a" /* default */].string,
  scrollNumberPrefixCls: vue_types["a" /* default */].string,
  status: vue_types["a" /* default */].oneOf(['success', 'processing', 'default', 'error', 'warning']),
  text: vue_types["a" /* default */].string,
  offset: vue_types["a" /* default */].array,
  numberStyle: vue_types["a" /* default */].object.def({}),
  title: vue_types["a" /* default */].string
};
/* harmony default export */ var Badge = ({
  name: 'TaBadge',
  props: Object(props_util["q" /* initDefaultProps */])(BadgeProps, {
    prefixCls: 'ant-badge',
    scrollNumberPrefixCls: 'ant-scroll-number',
    count: null,
    showZero: false,
    dot: false,
    overflowCount: 99
  }),
  render: function render() {
    var _classNames, _classNames2, _classNames3;

    var h = arguments[0];
    var count = this.count,
        showZero = this.showZero,
        prefixCls = this.prefixCls,
        scrollNumberPrefixCls = this.scrollNumberPrefixCls,
        overflowCount = this.overflowCount,
        dot = this.dot,
        status = this.status,
        text = this.text,
        offset = this.offset,
        $slots = this.$slots,
        numberStyle = this.numberStyle,
        title = this.title;
    var displayCount = count > overflowCount ? "".concat(overflowCount, "+") : count;
    var isZero = displayCount === '0' || displayCount === 0;
    var isDot = dot && !isZero || status; // dot mode don't need count

    if (isDot) {
      displayCount = '';
    }

    var children = Object(props_util["c" /* filterEmpty */])($slots["default"]);
    var isEmpty = displayCount === null || displayCount === undefined || displayCount === '';
    var hidden = (isEmpty || isZero && !showZero) && !isDot;
    var statusCls = classnames_default()((_classNames = {}, Badge_defineProperty(_classNames, "".concat(prefixCls, "-status-dot"), !!status), Badge_defineProperty(_classNames, "".concat(prefixCls, "-status-").concat(status), !!status), _classNames));
    var scrollNumberCls = classnames_default()((_classNames2 = {}, Badge_defineProperty(_classNames2, "".concat(prefixCls, "-dot"), isDot), Badge_defineProperty(_classNames2, "".concat(prefixCls, "-count"), !isDot), Badge_defineProperty(_classNames2, "".concat(prefixCls, "-multiple-words"), !isDot && count && count.toString && count.toString().length > 1), Badge_defineProperty(_classNames2, "".concat(prefixCls, "-status-").concat(status), !!status), _classNames2));
    var badgeCls = classnames_default()(prefixCls, (_classNames3 = {}, Badge_defineProperty(_classNames3, "".concat(prefixCls, "-status"), !!status), Badge_defineProperty(_classNames3, "".concat(prefixCls, "-not-a-wrapper"), !children.length), _classNames3));
    var styleWithOffset = offset ? Badge_objectSpread({
      marginLeft: typeof offset[0] === 'number' ? "".concat(offset[0], "px") : offset[0],
      marginTop: typeof offset[1] === 'number' ? "".concat(offset[1], "px") : offset[1]
    }, numberStyle) : numberStyle; // <Badge status="success" />

    if (!children.length && status) {
      return h("span", babel_helper_vue_jsx_merge_props_default()([{
        on: this.$listeners
      }, {
        "class": badgeCls,
        style: styleWithOffset
      }]), [h("span", {
        "class": statusCls
      }), h("span", {
        "class": "".concat(prefixCls, "-status-text")
      }, [text])]);
    }

    var scrollNumber = hidden ? null : h(ScrollNumber, {
      attrs: {
        prefixCls: scrollNumberPrefixCls,
        count: displayCount,
        title: title || count
      },
      directives: [{
        name: "show",
        value: !hidden
      }],
      "class": scrollNumberCls,
      style: styleWithOffset,
      key: 'scrollNumber'
    });
    var statusText = hidden || !text ? null : h("span", {
      "class": "".concat(prefixCls, "-status-text")
    }, [text]);
    var transitionProps = Object(getTransitionProps["a" /* default */])(children.length ? "".concat(prefixCls, "-zoom") : '');
    return h("span", babel_helper_vue_jsx_merge_props_default()([{
      on: this.$listeners
    }, {
      "class": badgeCls
    }]), [children, h("transition", transitionProps, [scrollNumber]), statusText]);
  }
});
// CONCATENATED MODULE: ./src/components/badge/index.js

/* istanbul ignore next */

Badge.install = function (Vue) {
  Vue.component(Badge.name, Badge);
};

/* harmony default export */ var badge = (Badge);
// CONCATENATED MODULE: ./src/components/breadcrumb/BreadcrumbItem.jsx


/* harmony default export */ var BreadcrumbItem = ({
  name: 'TaBreadcrumbItem',
  __ANT_BREADCRUMB_ITEM: true,
  props: {
    prefixCls: vue_types["a" /* default */].string.def('ant-breadcrumb'),
    href: vue_types["a" /* default */].string,
    separator: vue_types["a" /* default */].any
  },
  render: function render() {
    var h = arguments[0];
    var prefixCls = this.prefixCls,
        $slots = this.$slots;
    var children = $slots["default"];
    var link;

    if (Object(props_util["p" /* hasProp */])(this, 'href')) {
      link = h("a", {
        "class": "".concat(prefixCls, "-link")
      }, [children]);
    } else {
      link = h("span", {
        "class": "".concat(prefixCls, "-link")
      }, [children]);
    }

    if (children) {
      return h("span", [link, h("span", {
        "class": "".concat(prefixCls, "-separator")
      }, [Object(props_util["g" /* getComponentFromProp */])(this, 'separator') || '/'])]);
    }

    return null;
  }
});
// CONCATENATED MODULE: ./src/components/breadcrumb/Breadcrumb.jsx





var Route = vue_types["a" /* default */].shape({
  path: vue_types["a" /* default */].string,
  breadcrumbName: vue_types["a" /* default */].string
}).loose;
var BreadcrumbProps = {
  prefixCls: vue_types["a" /* default */].string.def('ant-breadcrumb'),
  routes: vue_types["a" /* default */].arrayOf(Route),
  params: vue_types["a" /* default */].any,
  separator: vue_types["a" /* default */].any,
  itemRender: vue_types["a" /* default */].func
};

function getBreadcrumbName(route, params) {
  if (!route.breadcrumbName) {
    return null;
  }

  var paramsKeys = Object.keys(params).join('|');
  var name = route.breadcrumbName.replace(new RegExp(":(".concat(paramsKeys, ")"), 'g'), function (replacement, key) {
    return params[key] || replacement;
  });
  return name;
}

/* harmony default export */ var Breadcrumb = ({
  name: 'TaBreadcrumb',
  props: BreadcrumbProps,
  methods: {
    defaultItemRender: function defaultItemRender(_ref) {
      var route = _ref.route,
          params = _ref.params,
          routes = _ref.routes,
          paths = _ref.paths;
      var h = this.$createElement;
      var isLastItem = routes.indexOf(route) === routes.length - 1;
      var name = getBreadcrumbName(route, params);
      return isLastItem ? h("span", [name]) : h("a", {
        attrs: {
          href: "#/".concat(paths.join('/'))
        }
      }, [name]);
    }
  },
  render: function render() {
    var h = arguments[0];
    var crumbs;
    var prefixCls = this.prefixCls,
        routes = this.routes,
        _this$params = this.params,
        params = _this$params === void 0 ? {} : _this$params,
        $slots = this.$slots,
        $scopedSlots = this.$scopedSlots;
    var children = Object(props_util["c" /* filterEmpty */])($slots["default"]);
    var separator = Object(props_util["g" /* getComponentFromProp */])(this, 'separator');

    if (routes && routes.length > 0) {
      var paths = [];
      var itemRender = this.itemRender || $scopedSlots.itemRender || this.defaultItemRender;
      crumbs = routes.map(function (route) {
        route.path = route.path || '';
        var path = route.path.replace(/^\//, '');
        Object.keys(params).forEach(function (key) {
          path = path.replace(":".concat(key), params[key]);
        });

        if (path) {
          paths.push(path);
        }

        return h(BreadcrumbItem, {
          attrs: {
            separator: separator
          },
          key: route.breadcrumbName || path
        }, [itemRender({
          route: route,
          params: params,
          routes: routes,
          paths: paths
        })]);
      });
    } else if (children.length) {
      crumbs = children.map(function (element, index) {
        _util_warning(Object(props_util["l" /* getSlotOptions */])(element).__ANT_BREADCRUMB_ITEM, 'Breadcrumb only accepts Breadcrumb.Item as it\'s children');
        return Object(vnode["a" /* cloneElement */])(element, {
          props: {
            separator: separator
          },
          key: index
        });
      });
    }

    return h("div", {
      "class": prefixCls
    }, [crumbs]);
  }
});
// CONCATENATED MODULE: ./src/components/breadcrumb/index.js


Breadcrumb.Item = BreadcrumbItem;
/* istanbul ignore next */

Breadcrumb.install = function (Vue) {
  Vue.component(Breadcrumb.name, Breadcrumb);
  Vue.component(BreadcrumbItem.name, BreadcrumbItem);
};

/* harmony default export */ var breadcrumb = (Breadcrumb);
// EXTERNAL MODULE: external "moment"
var external_moment_ = __webpack_require__(12);
var external_moment_default = /*#__PURE__*/__webpack_require__.n(external_moment_);

// CONCATENATED MODULE: ./src/components/vc-calendar/src/date/DateConstants.js
/* harmony default export */ var DateConstants = ({
  DATE_ROW_COUNT: 6,
  DATE_COL_COUNT: 7
});
// CONCATENATED MODULE: ./src/components/vc-calendar/src/date/DateTHead.jsx


/* harmony default export */ var DateTHead = ({
  functional: true,
  render: function render(createElement, context) {
    var h = arguments[0];
    var props = context.props;
    var value = props.value;
    var localeData = value.localeData();
    var prefixCls = props.prefixCls;
    var veryShortWeekdays = [];
    var weekDays = [];
    var firstDayOfWeek = localeData.firstDayOfWeek();
    var showWeekNumberEl;
    var now = external_moment_default()();

    for (var dateColIndex = 0; dateColIndex < DateConstants.DATE_COL_COUNT; dateColIndex++) {
      var index = (firstDayOfWeek + dateColIndex) % DateConstants.DATE_COL_COUNT;
      now.day(index);
      veryShortWeekdays[dateColIndex] = localeData.weekdaysMin(now);
      weekDays[dateColIndex] = localeData.weekdaysShort(now);
    }

    if (props.showWeekNumber) {
      showWeekNumberEl = h("th", {
        attrs: {
          role: 'columnheader'
        },
        "class": "".concat(prefixCls, "-column-header ").concat(prefixCls, "-week-number-header")
      }, [h("span", {
        "class": "".concat(prefixCls, "-column-header-inner")
      }, ["x"])]);
    }

    var weekDaysEls = weekDays.map(function (day, xindex) {
      return h("th", {
        key: xindex,
        attrs: {
          role: 'columnheader',
          title: day
        },
        "class": "".concat(prefixCls, "-column-header")
      }, [h("span", {
        "class": "".concat(prefixCls, "-column-header-inner")
      }, [veryShortWeekdays[xindex]])]);
    });
    return h("thead", [h("tr", {
      attrs: {
        role: 'row'
      }
    }, [showWeekNumberEl, weekDaysEls])]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-calendar/src/util/index.js
function util_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      util_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function util_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


var defaultDisabledTime = {
  disabledHours: function disabledHours() {
    return [];
  },
  disabledMinutes: function disabledMinutes() {
    return [];
  },
  disabledSeconds: function disabledSeconds() {
    return [];
  }
};
function getTodayTime(value) {
  var today = external_moment_default()();
  today.locale(value.locale()).utcOffset(value.utcOffset());
  return today;
}
function getTitleString(value) {
  return value.format('LL');
}
function getTodayTimeStr(value) {
  var today = getTodayTime(value);
  return getTitleString(today);
}
function getMonthName(month) {
  var locale = month.locale();
  var localeData = month.localeData();
  return localeData[locale === 'zh-cn' ? 'months' : 'monthsShort'](month);
}
function syncTime(from, to) {
  if (!external_moment_default.a.isMoment(from) || !external_moment_default.a.isMoment(to)) return;
  to.hour(from.hour());
  to.minute(from.minute());
  to.second(from.second());
}
function getTimeConfig(value, disabledTime) {
  var disabledTimeConfig = disabledTime ? disabledTime(value) : {};
  disabledTimeConfig = util_objectSpread({}, defaultDisabledTime, disabledTimeConfig);
  return disabledTimeConfig;
}
function isTimeValidByConfig(value, disabledTimeConfig) {
  var invalidTime = false;

  if (value) {
    var hour = value.hour();
    var minutes = value.minute();
    var seconds = value.second();
    var disabledHours = disabledTimeConfig.disabledHours();

    if (disabledHours.indexOf(hour) === -1) {
      var disabledMinutes = disabledTimeConfig.disabledMinutes(hour);

      if (disabledMinutes.indexOf(minutes) === -1) {
        var disabledSeconds = disabledTimeConfig.disabledSeconds(hour, minutes);
        invalidTime = disabledSeconds.indexOf(seconds) !== -1;
      } else {
        invalidTime = true;
      }
    } else {
      invalidTime = true;
    }
  }

  return !invalidTime;
}
function isTimeValid(value, disabledTime) {
  var disabledTimeConfig = getTimeConfig(value, disabledTime);
  return isTimeValidByConfig(value, disabledTimeConfig);
}
function util_isAllowedDate(value, disabledDate, disabledTime) {
  if (disabledDate) {
    if (disabledDate(value)) {
      return false;
    }
  }

  if (disabledTime) {
    if (!isTimeValid(value, disabledTime)) {
      return false;
    }
  }

  return true;
}
// CONCATENATED MODULE: ./src/components/vc-calendar/src/date/DateTBody.jsx
function DateTBody_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







function DateTBody_noop() {}

function isSameDay(one, two) {
  return one && two && one.isSame(two, 'day');
}

function beforeCurrentMonthYear(current, today) {
  if (current.year() < today.year()) {
    return 1;
  }

  return current.year() === today.year() && current.month() < today.month();
}

function afterCurrentMonthYear(current, today) {
  if (current.year() > today.year()) {
    return 1;
  }

  return current.year() === today.year() && current.month() > today.month();
}

function getIdFromDate(date) {
  return "rc-calendar-".concat(date.year(), "-").concat(date.month(), "-").concat(date.date());
}

var DateTBody = {
  props: {
    contentRender: vue_types["a" /* default */].func,
    dateRender: vue_types["a" /* default */].func,
    disabledDate: vue_types["a" /* default */].func,
    prefixCls: vue_types["a" /* default */].string,
    selectedValue: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].any, vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].any)]),
    value: vue_types["a" /* default */].object,
    hoverValue: vue_types["a" /* default */].any.def([]),
    showWeekNumber: vue_types["a" /* default */].bool
  },
  render: function render() {
    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var contentRender = props.contentRender,
        prefixCls = props.prefixCls,
        selectedValue = props.selectedValue,
        value = props.value,
        showWeekNumber = props.showWeekNumber,
        dateRender = props.dateRender,
        disabledDate = props.disabledDate,
        hoverValue = props.hoverValue;
    var _this$$listeners = this.$listeners,
        $listeners = _this$$listeners === void 0 ? {} : _this$$listeners;
    var _$listeners$select = $listeners.select,
        select = _$listeners$select === void 0 ? DateTBody_noop : _$listeners$select,
        _$listeners$dayHover = $listeners.dayHover,
        dayHover = _$listeners$dayHover === void 0 ? DateTBody_noop : _$listeners$dayHover;
    var iIndex;
    var jIndex;
    var current;
    var dateTable = [];
    var today = getTodayTime(value);
    var cellClass = "".concat(prefixCls, "-cell");
    var weekNumberCellClass = "".concat(prefixCls, "-week-number-cell");
    var dateClass = "".concat(prefixCls, "-date");
    var todayClass = "".concat(prefixCls, "-today");
    var selectedClass = "".concat(prefixCls, "-selected-day");
    var selectedDateClass = "".concat(prefixCls, "-selected-date"); // do not move with mouse operation

    var selectedStartDateClass = "".concat(prefixCls, "-selected-start-date");
    var selectedEndDateClass = "".concat(prefixCls, "-selected-end-date");
    var inRangeClass = "".concat(prefixCls, "-in-range-cell");
    var lastMonthDayClass = "".concat(prefixCls, "-last-month-cell");
    var nextMonthDayClass = "".concat(prefixCls, "-next-month-btn-day");
    var disabledClass = "".concat(prefixCls, "-disabled-cell");
    var firstDisableClass = "".concat(prefixCls, "-disabled-cell-first-of-row");
    var lastDisableClass = "".concat(prefixCls, "-disabled-cell-last-of-row");
    var lastDayOfMonthClass = "".concat(prefixCls, "-last-day-of-month");
    var month1 = value.clone();
    month1.date(1);
    var day = month1.day();
    var lastMonthDiffDay = (day + 7 - value.localeData().firstDayOfWeek()) % 7; // calculate last month

    var lastMonth1 = month1.clone();
    lastMonth1.add(0 - lastMonthDiffDay, 'days');
    var passed = 0;

    for (iIndex = 0; iIndex < DateConstants.DATE_ROW_COUNT; iIndex++) {
      for (jIndex = 0; jIndex < DateConstants.DATE_COL_COUNT; jIndex++) {
        current = lastMonth1;

        if (passed) {
          current = current.clone();
          current.add(passed, 'days');
        }

        dateTable.push(current);
        passed++;
      }
    }

    var tableHtml = [];
    passed = 0;

    for (iIndex = 0; iIndex < DateConstants.DATE_ROW_COUNT; iIndex++) {
      var _cx;

      var isCurrentWeek = void 0;
      var weekNumberCell = void 0;
      var isActiveWeek = false;
      var dateCells = [];

      if (showWeekNumber) {
        weekNumberCell = h("td", {
          key: "week-".concat(dateTable[passed].week()),
          attrs: {
            role: 'gridcell'
          },
          "class": weekNumberCellClass
        }, [dateTable[passed].week()]);
      }

      for (jIndex = 0; jIndex < DateConstants.DATE_COL_COUNT; jIndex++) {
        var next = null;
        var last = null;
        current = dateTable[passed];

        if (jIndex < DateConstants.DATE_COL_COUNT - 1) {
          next = dateTable[passed + 1];
        }

        if (jIndex > 0) {
          last = dateTable[passed - 1];
        }

        var cls = cellClass;
        var disabled = false;
        var selected = false;

        if (isSameDay(current, today)) {
          cls += " ".concat(todayClass);
          isCurrentWeek = true;
        }

        var isBeforeCurrentMonthYear = beforeCurrentMonthYear(current, value);
        var isAfterCurrentMonthYear = afterCurrentMonthYear(current, value);

        if (selectedValue && Array.isArray(selectedValue)) {
          var rangeValue = hoverValue.length ? hoverValue : selectedValue;

          if (!isBeforeCurrentMonthYear && !isAfterCurrentMonthYear) {
            var startValue = rangeValue[0];
            var endValue = rangeValue[1];

            if (startValue) {
              if (isSameDay(current, startValue)) {
                selected = true;
                isActiveWeek = true;
                cls += " ".concat(selectedStartDateClass);
              }
            }

            if (startValue && endValue) {
              if (isSameDay(current, endValue)) {
                selected = true;
                isActiveWeek = true;
                cls += " ".concat(selectedEndDateClass);
              } else if (current.isAfter(startValue, 'day') && current.isBefore(endValue, 'day')) {
                cls += " ".concat(inRangeClass);
              }
            }
          }
        } else if (isSameDay(current, value)) {
          // keyboard change value, highlight works
          selected = true;
          isActiveWeek = true;
        }

        if (isSameDay(current, selectedValue)) {
          cls += " ".concat(selectedDateClass);
        }

        if (isBeforeCurrentMonthYear) {
          cls += " ".concat(lastMonthDayClass);
        }

        if (isAfterCurrentMonthYear) {
          cls += " ".concat(nextMonthDayClass);
        }

        if (current.clone().endOf('month').date() === current.date()) {
          cls += " ".concat(lastDayOfMonthClass);
        }

        if (disabledDate) {
          if (disabledDate(current, value)) {
            disabled = true;

            if (!last || !disabledDate(last, value)) {
              cls += " ".concat(firstDisableClass);
            }

            if (!next || !disabledDate(next, value)) {
              cls += " ".concat(lastDisableClass);
            }
          }
        }

        if (selected) {
          cls += " ".concat(selectedClass);
        }

        if (disabled) {
          cls += " ".concat(disabledClass);
        }

        var dateHtml = void 0;

        if (dateRender) {
          dateHtml = dateRender(current, value);
        } else {
          var content = contentRender ? contentRender(current, value) : current.date();
          dateHtml = h("div", {
            key: getIdFromDate(current),
            "class": dateClass,
            attrs: {
              "aria-selected": selected,
              "aria-disabled": disabled
            }
          }, [content]);
        }

        dateCells.push(h("td", {
          key: passed,
          on: {
            "click": disabled ? DateTBody_noop : select.bind(null, current),
            "mouseenter": disabled ? DateTBody_noop : dayHover.bind(null, current)
          },
          attrs: {
            role: 'gridcell',
            title: getTitleString(current)
          },
          "class": cls
        }, [dateHtml]));
        passed++;
      }

      tableHtml.push(h("tr", {
        key: iIndex,
        attrs: {
          role: 'row'
        },
        "class": classnames_default()((_cx = {}, DateTBody_defineProperty(_cx, "".concat(prefixCls, "-current-week"), isCurrentWeek), DateTBody_defineProperty(_cx, "".concat(prefixCls, "-active-week"), isActiveWeek), _cx))
      }, [weekNumberCell, dateCells]));
    }

    return h("tbody", {
      "class": "".concat(prefixCls, "-tbody")
    }, [tableHtml]);
  }
};
/* harmony default export */ var date_DateTBody = (DateTBody);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/date/DateTable.jsx


/* harmony default export */ var DateTable = ({
  functional: true,
  render: function render(createElement, context) {
    var h = arguments[0];
    var props = context.props,
        _context$listeners = context.listeners,
        listeners = _context$listeners === void 0 ? {} : _context$listeners;
    var prefixCls = props.prefixCls;
    var bodyProps = {
      props: props,
      on: listeners
    };
    return h("table", {
      "class": "".concat(prefixCls, "-table"),
      attrs: {
        cellSpacing: '0',
        role: 'grid'
      }
    }, [h(DateTHead, bodyProps), h(date_DateTBody, bodyProps)]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-calendar/src/month/MonthTable.jsx
function MonthTable_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var ROW = 4;
var COL = 3;

function chooseMonth(month) {
  var next = this.sValue.clone();
  next.month(month);
  this.setAndSelectValue(next);
}

function MonthTable_noop() {}

var MonthTable = {
  mixins: [BaseMixin["a" /* default */]],
  props: {
    cellRender: vue_types["a" /* default */].func,
    prefixCls: vue_types["a" /* default */].string,
    value: vue_types["a" /* default */].object,
    locale: vue_types["a" /* default */].any,
    contentRender: vue_types["a" /* default */].any,
    disabledDate: vue_types["a" /* default */].func
  },
  data: function data() {
    return {
      sValue: this.value
    };
  },
  watch: {
    value: function value(val) {
      this.setState({
        sValue: val
      });
    }
  },
  methods: {
    setAndSelectValue: function setAndSelectValue(value) {
      this.setState({
        sValue: value
      });

      this.__emit('select', value);
    },
    months: function months() {
      var value = this.sValue;
      var current = value.clone();
      var months = [];
      var index = 0;

      for (var rowIndex = 0; rowIndex < ROW; rowIndex++) {
        months[rowIndex] = [];

        for (var colIndex = 0; colIndex < COL; colIndex++) {
          current.month(index);
          var content = getMonthName(current);
          months[rowIndex][colIndex] = {
            value: index,
            content: content,
            title: content
          };
          index++;
        }
      }

      return months;
    }
  },
  render: function render() {
    var _this = this;

    var h = arguments[0];
    var props = this.$props;
    var value = this.sValue;
    var today = getTodayTime(value);
    var months = this.months();
    var currentMonth = value.month();
    var prefixCls = props.prefixCls,
        locale = props.locale,
        contentRender = props.contentRender,
        cellRender = props.cellRender,
        disabledDate = props.disabledDate;
    var monthsEls = months.map(function (month, index) {
      var tds = month.map(function (monthData) {
        var _classNameMap;

        var disabled = false;

        if (disabledDate) {
          var testValue = value.clone();
          testValue.month(monthData.value);
          disabled = disabledDate(testValue);
        }

        var classNameMap = (_classNameMap = {}, MonthTable_defineProperty(_classNameMap, "".concat(prefixCls, "-cell"), 1), MonthTable_defineProperty(_classNameMap, "".concat(prefixCls, "-cell-disabled"), disabled), MonthTable_defineProperty(_classNameMap, "".concat(prefixCls, "-selected-cell"), monthData.value === currentMonth), MonthTable_defineProperty(_classNameMap, "".concat(prefixCls, "-current-cell"), today.year() === value.year() && monthData.value === today.month()), _classNameMap);
        var cellEl;

        if (cellRender) {
          var currentValue = value.clone();
          currentValue.month(monthData.value);
          cellEl = cellRender(currentValue, locale);
        } else {
          var content;

          if (contentRender) {
            var _currentValue = value.clone();

            _currentValue.month(monthData.value);

            content = contentRender(_currentValue, locale);
          } else {
            content = monthData.content;
          }

          cellEl = h("a", {
            "class": "".concat(prefixCls, "-month")
          }, [content]);
        }

        return h("td", {
          attrs: {
            role: 'gridcell',
            title: monthData.title
          },
          key: monthData.value,
          on: {
            "click": disabled ? MonthTable_noop : chooseMonth.bind(_this, monthData.value)
          },
          "class": classNameMap
        }, [cellEl]);
      });
      return h("tr", {
        key: index,
        attrs: {
          role: 'row'
        }
      }, [tds]);
    });
    return h("table", {
      "class": "".concat(prefixCls, "-table"),
      attrs: {
        cellSpacing: '0',
        role: 'grid'
      }
    }, [h("tbody", {
      "class": "".concat(prefixCls, "-tbody")
    }, [monthsEls])]);
  }
};
/* harmony default export */ var month_MonthTable = (MonthTable);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/mixin/CalendarMixin.js
function CalendarMixin_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}







function CalendarMixin_noop() {}

function getNow() {
  return external_moment_default()();
}

function getNowByCurrentStateValue(value) {
  var ret;

  if (value) {
    ret = getTodayTime(value);
  } else {
    ret = getNow();
  }

  return ret;
}

function isMoment(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || value.findIndex(function (val) {
      return val === undefined || external_moment_default.a.isMoment(val);
    }) !== -1;
  } else {
    return value === undefined || external_moment_default.a.isMoment(value);
  }
}

var MomentType = vue_types["a" /* default */].custom(isMoment);
var CalendarMixin = {
  mixins: [BaseMixin["a" /* default */]],
  props: {
    value: MomentType,
    defaultValue: MomentType
  },
  data: function data() {
    var props = this.$props;
    var sValue = props.value || props.defaultValue || getNow();
    return {
      sValue: sValue,
      sSelectedValue: props.selectedValue || props.defaultSelectedValue
    };
  },
  watch: {
    value: function value(val) {
      var sValue = val || this.defaultValue || getNowByCurrentStateValue(this.sValue);
      this.setState({
        sValue: sValue
      });
    },
    selectedValue: function selectedValue(val) {
      this.setState({
        sSelectedValue: val
      });
    }
  },
  methods: {
    onSelect: function onSelect(value, cause) {
      if (value) {
        this.setValue(value);
      }

      this.setSelectedValue(value, cause);
    },
    renderRoot: function renderRoot(newProps) {
      var _className;

      var h = this.$createElement;
      var props = this.$props;
      var prefixCls = props.prefixCls;
      var className = (_className = {}, CalendarMixin_defineProperty(_className, prefixCls, 1), CalendarMixin_defineProperty(_className, "".concat(prefixCls, "-hidden"), !props.visible), CalendarMixin_defineProperty(_className, newProps["class"], !!newProps["class"]), _className);
      return h("div", {
        ref: 'rootInstance',
        "class": className,
        attrs: {
          tabIndex: '0'
        },
        on: {
          "keydown": this.onKeyDown || CalendarMixin_noop
        }
      }, [newProps.children]);
    },
    setSelectedValue: function setSelectedValue(selectedValue, cause) {
      // if (this.isAllowedDate(selectedValue)) {
      if (!Object(props_util["p" /* hasProp */])(this, 'selectedValue')) {
        this.setState({
          sSelectedValue: selectedValue
        });
      }

      this.__emit('select', selectedValue, cause); // }

    },
    setValue: function setValue(value) {
      var originalValue = this.sValue;

      if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
        this.setState({
          sValue: value
        });
      }

      if (originalValue && value && !originalValue.isSame(value) || !originalValue && value || originalValue && !value) {
        this.__emit('change', value);
      }
    },
    isAllowedDate: function isAllowedDate(value) {
      var disabledDate = this.disabledDate;
      var disabledTime = this.disabledTime;
      return util_isAllowedDate(value, disabledDate, disabledTime);
    }
  }
};
/* harmony default export */ var mixin_CalendarMixin = (CalendarMixin);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/mixin/CommonMixin.js
/* harmony default export */ var CommonMixin = ({
  // getDefaultProps () {
  //   return {
  //     locale: enUs,
  //     visible: true,
  //     prefixCls: 'rc-calendar',
  //     renderFooter () {
  //       return null
  //     },
  //     renderSidebar () {
  //       return null
  //     },
  //   }
  // },
  // shouldComponentUpdate (nextProps) {
  //   return this.props.visible || nextProps.visible
  // },
  methods: {
    getFormat: function getFormat() {
      var format = this.format;
      var locale = this.locale,
          timePicker = this.timePicker;

      if (!format) {
        if (timePicker) {
          format = locale.dateTimeFormat;
        } else {
          format = locale.dateFormat;
        }
      }

      return format;
    },
    focus: function focus() {
      if (this.$refs.rootInstance) {
        this.$refs.rootInstance.focus();
      }
    }
  }
});
// CONCATENATED MODULE: ./src/components/vc-calendar/src/full-calendar/CalendarHeader.jsx



var CalendarHeader = {
  mixins: [BaseMixin["a" /* default */]],
  props: {
    value: vue_types["a" /* default */].object,
    locale: vue_types["a" /* default */].object,
    yearSelectOffset: vue_types["a" /* default */].number.def(10),
    yearSelectTotal: vue_types["a" /* default */].number.def(20),
    // onValueChange: PropTypes.func,
    // onTypeChange: PropTypes.func,
    Select: vue_types["a" /* default */].object,
    prefixCls: vue_types["a" /* default */].string,
    type: vue_types["a" /* default */].string,
    showTypeSwitch: vue_types["a" /* default */].bool,
    headerComponents: vue_types["a" /* default */].array
  },
  methods: {
    onYearChange: function onYearChange(year) {
      var newValue = this.value.clone();
      newValue.year(parseInt(year, 10));

      this.__emit('valueChange', newValue);
    },
    onMonthChange: function onMonthChange(month) {
      var newValue = this.value.clone();
      newValue.month(parseInt(month, 10));

      this.__emit('valueChange', newValue);
    },
    yearSelectElement: function yearSelectElement(year) {
      var h = this.$createElement;
      var yearSelectOffset = this.yearSelectOffset,
          yearSelectTotal = this.yearSelectTotal,
          prefixCls = this.prefixCls,
          Select = this.Select;
      var start = year - yearSelectOffset;
      var end = start + yearSelectTotal;
      var options = [];

      for (var index = start; index < end; index++) {
        options.push(h(Select.Option, {
          key: "".concat(index)
        }, [index]));
      }

      return h(Select, {
        "class": "".concat(prefixCls, "-header-year-select"),
        on: {
          "change": this.onYearChange
        },
        attrs: {
          dropdownStyle: {
            zIndex: 2000
          },
          dropdownMenuStyle: {
            maxHeight: '250px',
            overflow: 'auto',
            fontSize: '12px'
          },
          optionLabelProp: 'children',
          value: String(year),
          showSearch: false
        }
      }, [options]);
    },
    monthSelectElement: function monthSelectElement(month) {
      var h = this.$createElement;
      var value = this.value,
          Select = this.Select,
          prefixCls = this.prefixCls;
      var t = value.clone();
      var options = [];

      for (var index = 0; index < 12; index++) {
        t.month(index);
        options.push(h(Select.Option, {
          key: "".concat(index)
        }, [getMonthName(t)]));
      }

      return h(Select, {
        "class": "".concat(prefixCls, "-header-month-select"),
        attrs: {
          dropdownStyle: {
            zIndex: 2000
          },
          dropdownMenuStyle: {
            maxHeight: '250px',
            overflow: 'auto',
            overflowX: 'hidden',
            fontSize: '12px'
          },
          optionLabelProp: 'children',
          value: String(month),
          showSearch: false
        },
        on: {
          "change": this.onMonthChange
        }
      }, [options]);
    },
    changeTypeToDate: function changeTypeToDate() {
      this.__emit('typeChange', 'date');
    },
    changeTypeToMonth: function changeTypeToMonth() {
      this.__emit('typeChange', 'month');
    }
  },
  render: function render() {
    var h = arguments[0];
    var value = this.value,
        locale = this.locale,
        prefixCls = this.prefixCls,
        type = this.type,
        showTypeSwitch = this.showTypeSwitch,
        headerComponents = this.headerComponents;
    var year = value.year();
    var month = value.month();
    var yearSelect = this.yearSelectElement(year);
    var monthSelect = type === 'month' ? null : this.monthSelectElement(month);
    var switchCls = "".concat(prefixCls, "-header-switcher");
    var typeSwitcher = showTypeSwitch ? h("span", {
      "class": switchCls
    }, [type === 'date' ? h("span", {
      "class": "".concat(switchCls, "-focus")
    }, [locale.month]) : h("span", {
      on: {
        "click": this.changeTypeToDate
      },
      "class": "".concat(switchCls, "-normal")
    }, [locale.month]), type === 'month' ? h("span", {
      "class": "".concat(switchCls, "-focus")
    }, [locale.year]) : h("span", {
      on: {
        "click": this.changeTypeToMonth
      },
      "class": "".concat(switchCls, "-normal")
    }, [locale.year])]) : null;
    return h("div", {
      "class": "".concat(prefixCls, "-header")
    }, [typeSwitcher, monthSelect, yearSelect, headerComponents]);
  }
};
/* harmony default export */ var full_calendar_CalendarHeader = (CalendarHeader);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/locale/zh_CN.js
/* harmony default export */ var zh_CN = ({
  today: '今天',
  now: '此刻',
  backToToday: '返回今天',
  ok: '确定',
  timeSelect: '选择时间',
  dateSelect: '选择日期',
  weekSelect: '选择周',
  clear: '清除',
  month: '月',
  year: '年',
  previousMonth: '上个月 (翻页上键)',
  nextMonth: '下个月 (翻页下键)',
  monthSelect: '选择月份',
  yearSelect: '选择年份',
  decadeSelect: '选择年代',
  yearFormat: 'YYYY年',
  dayFormat: 'D日',
  dateFormat: 'YYYY年M月D日',
  dateTimeFormat: 'YYYY年M月D日 HH时mm分ss秒',
  previousYear: '上一年 (Control键加左方向键)',
  nextYear: '下一年 (Control键加右方向键)',
  previousDecade: '上一年代',
  nextDecade: '下一年代',
  previousCentury: '上一世纪',
  nextCentury: '下一世纪'
});
// CONCATENATED MODULE: ./src/components/vc-calendar/src/FullCalendar.jsx
function FullCalendar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { FullCalendar_defineProperty(target, key, source[key]); }); } return target; }

function FullCalendar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










var FullCalendar = {
  props: {
    locale: vue_types["a" /* default */].object.def(zh_CN),
    format: vue_types["a" /* default */].string,
    visible: vue_types["a" /* default */].bool.def(true),
    prefixCls: vue_types["a" /* default */].string.def('rc-calendar'),
    defaultType: vue_types["a" /* default */].string.def('date'),
    type: vue_types["a" /* default */].string,
    // locale: PropTypes.object,
    // onTypeChange: PropTypes.func,
    fullscreen: vue_types["a" /* default */].bool.def(false),
    monthCellRender: vue_types["a" /* default */].func,
    dateCellRender: vue_types["a" /* default */].func,
    showTypeSwitch: vue_types["a" /* default */].bool.def(true),
    Select: vue_types["a" /* default */].object.isRequired,
    headerComponents: vue_types["a" /* default */].array,
    headerComponent: vue_types["a" /* default */].object,
    // The whole header component
    headerRender: vue_types["a" /* default */].func,
    showHeader: vue_types["a" /* default */].bool.def(true),
    disabledDate: vue_types["a" /* default */].func,
    renderFooter: vue_types["a" /* default */].func.def(function () {
      return null;
    }),
    renderSidebar: vue_types["a" /* default */].func.def(function () {
      return null;
    })
  },
  mixins: [BaseMixin["a" /* default */], CommonMixin, mixin_CalendarMixin],
  data: function data() {
    var type;

    if (Object(props_util["p" /* hasProp */])(this, 'type')) {
      type = this.type;
    } else {
      type = this.defaultType;
    }

    return {
      sType: type
    };
  },
  watch: {
    type: function type(val) {
      this.setState({
        sType: val
      });
    }
  },
  methods: {
    onMonthSelect: function onMonthSelect(value) {
      this.onSelect(value, {
        target: 'month'
      });
    },
    setType: function setType(type) {
      if (!Object(props_util["p" /* hasProp */])(this, 'type')) {
        this.setState({
          sType: type
        });
      }

      this.__emit('typeChange', type);
    }
  },
  render: function render() {
    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var locale = props.locale,
        prefixCls = props.prefixCls,
        fullscreen = props.fullscreen,
        showHeader = props.showHeader,
        headerComponent = props.headerComponent,
        headerRender = props.headerRender,
        disabledDate = props.disabledDate;
    var value = this.sValue,
        type = this.sType,
        $listeners = this.$listeners;
    var header = null;

    if (showHeader) {
      if (headerRender) {
        header = headerRender(value, type, locale);
      } else {
        var TheHeader = headerComponent || full_calendar_CalendarHeader;
        var headerProps = {
          props: FullCalendar_objectSpread({}, props, {
            prefixCls: "".concat(prefixCls, "-full"),
            type: type,
            value: value
          }),
          on: FullCalendar_objectSpread({}, $listeners, {
            typeChange: this.setType,
            valueChange: this.setValue
          }),
          key: 'calendar-header'
        };
        header = h(TheHeader, headerProps);
      }
    }

    var table = type === 'date' ? h(DateTable, {
      attrs: {
        dateRender: props.dateCellRender,
        contentRender: props.dateCellContentRender,
        locale: locale,
        prefixCls: prefixCls,
        value: value,
        disabledDate: disabledDate
      },
      on: {
        "select": this.onSelect
      }
    }) : h(month_MonthTable, {
      attrs: {
        cellRender: props.monthCellRender,
        contentRender: props.monthCellContentRender,
        locale: locale,
        prefixCls: "".concat(prefixCls, "-month-panel"),
        value: value,
        disabledDate: disabledDate
      },
      on: {
        "select": this.onMonthSelect
      }
    });
    var children = [header, h("div", {
      key: 'calendar-body',
      "class": "".concat(prefixCls, "-calendar-body")
    }, [table])];
    var className = ["".concat(prefixCls, "-full")];

    if (fullscreen) {
      className.push("".concat(prefixCls, "-fullscreen"));
    }

    return this.renderRoot({
      children: children,
      "class": className.join(' ')
    });
  }
};
/* harmony default export */ var src_FullCalendar = (FullCalendar);
// CONCATENATED MODULE: ./src/components/calendar/Constants.js
var PREFIX_CLS = 'ant-fullcalendar';
// CONCATENATED MODULE: ./src/components/vc-checkbox/src/Checkbox.jsx


function Checkbox_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Checkbox_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Checkbox_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function Checkbox_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Checkbox_defineProperty(target, key, source[key]); }); } return target; }

function Checkbox_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





/* harmony default export */ var Checkbox = ({
  name: 'Checkbox',
  mixins: [BaseMixin["a" /* default */]],
  inheritAttrs: false,
  props: Object(props_util["q" /* initDefaultProps */])({
    prefixCls: vue_types["a" /* default */].string,
    name: vue_types["a" /* default */].string,
    id: vue_types["a" /* default */].string,
    type: vue_types["a" /* default */].string,
    defaultChecked: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].bool]),
    checked: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].bool]),
    disabled: vue_types["a" /* default */].bool,
    // onFocus: PropTypes.func,
    // onBlur: PropTypes.func,
    // onChange: PropTypes.func,
    // onClick: PropTypes.func,
    tabIndex: vue_types["a" /* default */].string,
    readOnly: vue_types["a" /* default */].bool,
    autoFocus: vue_types["a" /* default */].bool,
    value: vue_types["a" /* default */].any
  }, {
    prefixCls: 'rc-checkbox',
    type: 'checkbox',
    defaultChecked: false
  }),
  model: {
    prop: 'checked',
    event: 'change'
  },
  data: function data() {
    var checked = Object(props_util["p" /* hasProp */])(this, 'checked') ? this.checked : this.defaultChecked;
    return {
      sChecked: checked
    };
  },
  watch: {
    checked: function checked(val) {
      this.sChecked = val;
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      if (_this.autoFocus) {
        _this.$refs.input && _this.$refs.input.focus();
      }
    });
  },
  methods: {
    focus: function focus() {
      this.$refs.input.focus();
    },
    blur: function blur() {
      this.$refs.input.blur();
    },
    handleChange: function handleChange(e) {
      var props = Object(props_util["j" /* getOptionProps */])(this);

      if (props.disabled) {
        return;
      }

      if (!('checked' in props)) {
        this.sChecked = e.target.checked;
      }

      this.$forceUpdate(); // change前，维持现有状态

      this.__emit('change', {
        target: Checkbox_objectSpread({}, props, {
          checked: e.target.checked
        }),
        stopPropagation: function stopPropagation() {
          e.stopPropagation();
        },
        preventDefault: function preventDefault() {
          e.preventDefault();
        },
        nativeEvent: Checkbox_objectSpread({}, e, {
          shiftKey: this.eventShiftKey
        })
      });

      this.eventShiftKey = false;
    },
    onClick: function onClick(e) {
      this.__emit('click', e); // onChange没能获取到shiftKey，使用onClick hack


      this.eventShiftKey = e.shiftKey;
    }
  },
  render: function render() {
    var _classNames;

    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        prefixCls = _getOptionProps.prefixCls,
        name = _getOptionProps.name,
        id = _getOptionProps.id,
        type = _getOptionProps.type,
        disabled = _getOptionProps.disabled,
        readOnly = _getOptionProps.readOnly,
        tabIndex = _getOptionProps.tabIndex,
        autoFocus = _getOptionProps.autoFocus,
        value = _getOptionProps.value,
        others = Checkbox_objectWithoutProperties(_getOptionProps, ["prefixCls", "name", "id", "type", "disabled", "readOnly", "tabIndex", "autoFocus", "value"]);

    var attrs = Object(props_util["e" /* getAttrs */])(this);
    var globalProps = Object.keys(Checkbox_objectSpread({}, others, attrs)).reduce(function (prev, key) {
      if (key.substr(0, 5) === 'aria-' || key.substr(0, 5) === 'data-' || key === 'role') {
        prev[key] = others[key];
      }

      return prev;
    }, {});
    var sChecked = this.sChecked;
    var classString = classnames_default()(prefixCls, (_classNames = {}, Checkbox_defineProperty(_classNames, "".concat(prefixCls, "-checked"), sChecked), Checkbox_defineProperty(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
    return h("span", {
      "class": classString
    }, [h("input", babel_helper_vue_jsx_merge_props_default()([{
      attrs: {
        name: name,
        id: id,
        type: type,
        readOnly: readOnly,
        disabled: disabled,
        tabIndex: tabIndex,
        autoFocus: autoFocus
      },
      "class": "".concat(prefixCls, "-input"),
      domProps: {
        "checked": !!sChecked,
        "value": value
      },
      ref: 'input'
    }, {
      attrs: globalProps,
      on: Checkbox_objectSpread({}, this.$listeners, {
        change: this.handleChange,
        click: this.onClick
      })
    }])), h("span", {
      "class": "".concat(prefixCls, "-inner")
    })]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-checkbox/src/index.js

/* harmony default export */ var vc_checkbox_src = (Checkbox);
// CONCATENATED MODULE: ./src/components/vc-checkbox/index.js
// based on rc-checkbox 2.1.5

// CONCATENATED MODULE: ./src/components/radio/Radio.jsx


function Radio_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Radio_defineProperty(target, key, source[key]); }); } return target; }

function Radio_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Radio_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Radio_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Radio_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






function Radio_noop() {}

/* harmony default export */ var Radio = ({
  name: 'TaRadio',
  props: {
    prefixCls: {
      "default": 'ant-radio',
      type: String
    },
    defaultChecked: Boolean,
    checked: {
      type: Boolean,
      "default": undefined
    },
    disabled: Boolean,
    isGroup: Boolean,
    value: vue_types["a" /* default */].any,
    name: String,
    id: String,
    autoFocus: Boolean,
    type: vue_types["a" /* default */].string.def('radio')
  },
  model: {
    prop: 'checked'
  },
  inject: {
    radioGroupContext: {
      "default": undefined
    }
  },
  methods: {
    handleChange: function handleChange(event) {
      var targetChecked = event.target.checked;
      this.$emit('input', targetChecked);
      this.$emit('change', event);
    },
    focus: function focus() {
      this.$refs.vcCheckbox.focus();
    },
    blur: function blur() {
      this.$refs.vcCheckbox.blur();
    }
  },
  render: function render() {
    var _classNames;

    var h = arguments[0];
    var $slots = this.$slots,
        $listeners = this.$listeners,
        radioGroup = this.radioGroupContext;
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var children = $slots["default"];

    var _$listeners$mouseente = $listeners.mouseenter,
        mouseenter = _$listeners$mouseente === void 0 ? Radio_noop : _$listeners$mouseente,
        _$listeners$mouseleav = $listeners.mouseleave,
        mouseleave = _$listeners$mouseleav === void 0 ? Radio_noop : _$listeners$mouseleav,
        restListeners = Radio_objectWithoutProperties($listeners, ["mouseenter", "mouseleave"]);

    var prefixCls = props.prefixCls,
        restProps = Radio_objectWithoutProperties(props, ["prefixCls"]);

    var radioProps = {
      props: Radio_objectSpread({}, restProps, {
        prefixCls: prefixCls
      }),
      on: restListeners,
      attrs: Object(props_util["e" /* getAttrs */])(this)
    };

    if (radioGroup) {
      radioProps.props.name = radioGroup.name;
      radioProps.on.change = radioGroup.onRadioChange;
      radioProps.props.checked = props.value === radioGroup.stateValue;
      radioProps.props.disabled = props.disabled || radioGroup.disabled;
    } else {
      radioProps.on.change = this.handleChange;
    }

    var wrapperClassString = classnames_default()((_classNames = {}, Radio_defineProperty(_classNames, "".concat(prefixCls, "-wrapper"), true), Radio_defineProperty(_classNames, "".concat(prefixCls, "-wrapper-checked"), radioProps.props.checked), Radio_defineProperty(_classNames, "".concat(prefixCls, "-wrapper-disabled"), radioProps.props.disabled), _classNames));
    return h("label", {
      "class": wrapperClassString,
      on: {
        "mouseenter": mouseenter,
        "mouseleave": mouseleave
      }
    }, [h(vc_checkbox_src, babel_helper_vue_jsx_merge_props_default()([radioProps, {
      ref: 'vcCheckbox'
    }])), children !== undefined ? h("span", [children]) : null]);
  }
});
// CONCATENATED MODULE: ./src/components/radio/Group.jsx
function Group_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { radio_Group_defineProperty(target, key, source[key]); }); } return target; }

function radio_Group_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






function Group_noop() {}

function getCheckedValue(children) {
  var value = null;
  var matched = false;
  children.forEach(function (radio) {
    if (radio && radio.componentOptions && radio.componentOptions.propsData.checked) {
      value = radio.componentOptions.propsData.value;
      matched = true;
    }
  });
  return matched ? {
    value: value
  } : undefined;
}

/* harmony default export */ var radio_Group = ({
  name: 'TaRadioGroup',
  props: {
    prefixCls: {
      "default": 'ant-radio',
      type: String
    },
    defaultValue: vue_types["a" /* default */].any,
    value: vue_types["a" /* default */].any,
    size: {
      "default": 'default',
      validator: function validator(value) {
        return ['large', 'default', 'small'].includes(value);
      }
    },
    options: {
      "default": function _default() {
        return [];
      },
      type: Array
    },
    disabled: Boolean,
    name: String,
    buttonStyle: vue_types["a" /* default */].string.def('outline')
  },
  data: function data() {
    var value = this.value,
        defaultValue = this.defaultValue;
    return {
      stateValue: value || defaultValue
    };
  },
  model: {
    prop: 'value'
  },
  provide: function provide() {
    return {
      radioGroupContext: this
    };
  },
  computed: {
    radioOptions: function radioOptions() {
      var disabled = this.disabled;
      return this.options.map(function (option) {
        return typeof option === 'string' ? {
          label: option,
          value: option
        } : Group_objectSpread({}, option, {
          disabled: option.disabled === undefined ? disabled : option.disabled
        });
      });
    },
    classes: function classes() {
      var _ref;

      var prefixCls = this.prefixCls,
          size = this.size;
      return _ref = {}, radio_Group_defineProperty(_ref, "".concat(prefixCls), true), radio_Group_defineProperty(_ref, "".concat(prefixCls, "-").concat(size), size), _ref;
    }
  },
  methods: {
    onRadioChange: function onRadioChange(ev) {
      var lastValue = this.stateValue;
      var value = ev.target.value;

      if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
        this.stateValue = value;
      }

      if (value !== lastValue) {
        this.$emit('input', value);
        this.$emit('change', ev);
      }
    }
  },
  watch: {
    value: function value(val) {
      this.stateValue = val;
    }
  },
  render: function render() {
    var _this = this;

    var h = arguments[0];
    var _this$$listeners = this.$listeners,
        _this$$listeners$mous = _this$$listeners.mouseenter,
        mouseenter = _this$$listeners$mous === void 0 ? Group_noop : _this$$listeners$mous,
        _this$$listeners$mous2 = _this$$listeners.mouseleave,
        mouseleave = _this$$listeners$mous2 === void 0 ? Group_noop : _this$$listeners$mous2;
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var prefixCls = props.prefixCls,
        options = props.options,
        buttonStyle = props.buttonStyle;
    var groupPrefixCls = "".concat(prefixCls, "-group");
    var classString = classnames_default()(groupPrefixCls, "".concat(groupPrefixCls, "-").concat(buttonStyle), radio_Group_defineProperty({}, "".concat(groupPrefixCls, "-").concat(props.size), props.size));
    var children = Object(props_util["c" /* filterEmpty */])(this.$slots["default"]); // 如果存在 options, 优先使用

    if (options && options.length > 0) {
      children = options.map(function (option, index) {
        if (typeof option === 'string') {
          return h(Radio, {
            key: index,
            attrs: {
              prefixCls: prefixCls,
              disabled: props.disabled,
              value: option,
              checked: _this.stateValue === option
            },
            on: {
              "change": _this.onRadioChange
            }
          }, [option]);
        } else {
          return h(Radio, {
            key: index,
            attrs: {
              prefixCls: prefixCls,
              disabled: option.disabled || props.disabled,
              value: option.value,
              checked: _this.stateValue === option.value
            },
            on: {
              "change": _this.onRadioChange
            }
          }, [option.label]);
        }
      });
    }

    return h("div", {
      "class": classString,
      on: {
        "mouseenter": mouseenter,
        "mouseleave": mouseleave
      }
    }, [children]);
  }
});
// CONCATENATED MODULE: ./src/components/radio/RadioButton.jsx
function RadioButton_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { RadioButton_defineProperty(target, key, source[key]); }); } return target; }

function RadioButton_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/* harmony default export */ var RadioButton = ({
  name: 'TaRadioButton',
  props: RadioButton_objectSpread({}, Radio.props, {
    prefixCls: {
      "default": 'ant-radio-button',
      type: String
    }
  }),
  inject: {
    radioGroupContext: {
      "default": undefined
    }
  },
  render: function render() {
    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var radioProps = {
      props: props,
      on: RadioButton_objectSpread({}, this.$listeners)
    };

    if (this.radioGroupContext) {
      radioProps.on.change = this.radioGroupContext.onRadioChange;
      radioProps.props.checked = props.value === this.radioGroupContext.stateValue;
      radioProps.props.disabled = props.disabled || this.radioGroupContext.disabled;
    }

    return h(wave, [h(Radio, radioProps, [this.$slots["default"]])]);
  }
});
// CONCATENATED MODULE: ./src/components/radio/index.js



Radio.Group = radio_Group;
Radio.Button = RadioButton;
/* istanbul ignore next */

Radio.install = function (Vue) {
  Vue.component(Radio.name, Radio);
  Vue.component(Radio.Group.name, Radio.Group);
  Vue.component(Radio.Button.name, Radio.Button);
};


/* harmony default export */ var components_radio = (Radio);
// CONCATENATED MODULE: ./src/components/calendar/Header.jsx
function Header_slicedToArray(arr, i) { return Header_arrayWithHoles(arr) || Header_iterableToArrayLimit(arr, i) || Header_nonIterableRest(); }

function Header_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function Header_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function Header_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






var Header_Option = components_select.Option;
var HeaderProps = {
  prefixCls: vue_types["a" /* default */].string,
  locale: vue_types["a" /* default */].any,
  fullscreen: vue_types["a" /* default */]["boolean"],
  yearSelectOffset: vue_types["a" /* default */].number,
  yearSelectTotal: vue_types["a" /* default */].number,
  type: vue_types["a" /* default */].string,
  // onValueChange: PropTypes.(value: moment.Moment) => void,
  // onTypeChange: PropTypes.(type: string) => void,
  value: vue_types["a" /* default */].any,
  validRange: vue_types["a" /* default */].array
};
/* harmony default export */ var Header = ({
  props: Object(props_util["q" /* initDefaultProps */])(HeaderProps, {
    prefixCls: "".concat(PREFIX_CLS, "-header"),
    yearSelectOffset: 10,
    yearSelectTotal: 20
  }),
  // private calenderHeaderNode: HTMLDivElement;
  methods: {
    getYearSelectElement: function getYearSelectElement(year) {
      var _this = this;

      var h = this.$createElement;
      var yearSelectOffset = this.yearSelectOffset,
          yearSelectTotal = this.yearSelectTotal,
          locale = this.locale,
          prefixCls = this.prefixCls,
          fullscreen = this.fullscreen,
          validRange = this.validRange;
      var start = year - yearSelectOffset;
      var end = start + yearSelectTotal;

      if (validRange) {
        start = validRange[0].get('year');
        end = validRange[1].get('year') + 1;
      }

      var suffix = locale.year === '年' ? '年' : '';
      var options = [];

      for (var index = start; index < end; index++) {
        options.push(h(Header_Option, {
          key: "".concat(index)
        }, [index + suffix]));
      }

      return h(components_select, {
        attrs: {
          size: fullscreen ? 'default' : 'small',
          dropdownMatchSelectWidth: false,
          value: String(year),
          getPopupContainer: function getPopupContainer() {
            return _this.getCalenderHeaderNode();
          }
        },
        "class": "".concat(prefixCls, "-year-select"),
        on: {
          "change": this.onYearChange
        }
      }, [options]);
    },
    getMonthsLocale: function getMonthsLocale(value) {
      var current = value.clone();
      var localeData = value.localeData();
      var months = [];

      for (var i = 0; i < 12; i++) {
        current.month(i);
        months.push(localeData.monthsShort(current));
      }

      return months;
    },
    getMonthSelectElement: function getMonthSelectElement(month, months) {
      var _this2 = this;

      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          fullscreen = this.fullscreen,
          validRange = this.validRange,
          value = this.value;
      var options = [];
      var start = 0;
      var end = 12;

      if (validRange) {
        var _validRange = Header_slicedToArray(validRange, 2),
            rangeStart = _validRange[0],
            rangeEnd = _validRange[1];

        var currentYear = value.get('year');

        if (rangeEnd.get('year') === currentYear) {
          end = rangeEnd.get('month') + 1;
        } else {
          start = rangeStart.get('month');
        }
      }

      for (var index = start; index < end; index++) {
        options.push(h(Header_Option, {
          key: "".concat(index)
        }, [months[index]]));
      }

      return h(components_select, {
        attrs: {
          size: fullscreen ? 'default' : 'small',
          dropdownMatchSelectWidth: false,
          value: String(month),
          getPopupContainer: function getPopupContainer() {
            return _this2.getCalenderHeaderNode();
          }
        },
        "class": "".concat(prefixCls, "-month-select"),
        on: {
          "change": this.onMonthChange
        }
      }, [options]);
    },
    onYearChange: function onYearChange(year) {
      var value = this.value,
          validRange = this.validRange;
      var newValue = value.clone();
      newValue.year(parseInt(year, 10)); // switch the month so that it remains within range when year changes

      if (validRange) {
        var _validRange2 = Header_slicedToArray(validRange, 2),
            start = _validRange2[0],
            end = _validRange2[1];

        var newYear = newValue.get('year');
        var newMonth = newValue.get('month');

        if (newYear === end.get('year') && newMonth > end.get('month')) {
          newValue.month(end.get('month'));
        }

        if (newYear === start.get('year') && newMonth < start.get('month')) {
          newValue.month(start.get('month'));
        }
      }

      this.$emit('valueChange', newValue);
    },
    onMonthChange: function onMonthChange(month) {
      var newValue = this.value.clone();
      newValue.month(parseInt(month, 10));
      this.$emit('valueChange', newValue);
    },
    onTypeChange: function onTypeChange(e) {
      this.$emit('typeChange', e.target.value);
    },
    getCalenderHeaderNode: function getCalenderHeaderNode() {
      return this.$refs.calenderHeaderNode;
    }
  },
  render: function render() {
    var h = arguments[0];
    var type = this.type,
        value = this.value,
        prefixCls = this.prefixCls,
        locale = this.locale,
        fullscreen = this.fullscreen;
    var yearSelect = this.getYearSelectElement(value.year());
    var monthSelect = type === 'date' ? this.getMonthSelectElement(value.month(), this.getMonthsLocale(value)) : null;
    var size = fullscreen ? 'default' : 'small';
    var typeSwitch = h(radio_Group, {
      on: {
        "change": this.onTypeChange
      },
      attrs: {
        value: type,
        size: size
      }
    }, [h(RadioButton, {
      attrs: {
        value: 'date'
      }
    }, [locale.month]), h(RadioButton, {
      attrs: {
        value: 'month'
      }
    }, [locale.year])]);
    return h("div", {
      "class": "".concat(prefixCls, "-header"),
      ref: 'calenderHeaderNode'
    }, [yearSelect, monthSelect, typeSwitch]);
  }
});
// CONCATENATED MODULE: ./src/components/_util/interopDefault.js
// https://github.com/moment/moment/issues/3650
function interopDefault(m) {
  return m["default"] || m;
}
// CONCATENATED MODULE: ./src/components/time-picker/locale/zh_CN.js
var zh_CN_locale = {
  placeholder: '请选择时间'
};
/* harmony default export */ var locale_zh_CN = (zh_CN_locale);
// CONCATENATED MODULE: ./src/components/date-picker/locale/zh_CN.js
function zh_CN_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      zh_CN_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function zh_CN_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



var locale_zh_CN_locale = {
  lang: zh_CN_objectSpread({
    placeholder: '请选择日期',
    rangePlaceholder: ['开始日期', '结束日期']
  }, zh_CN),
  timePickerLocale: zh_CN_objectSpread({}, locale_zh_CN) // should add whitespace between char in Button

};
locale_zh_CN_locale.lang.ok = '确 定'; // All settings at:
// https://github.com/ant-design/ant-design/blob/master/components/date-picker/l
// o cale/example.json

/* harmony default export */ var date_picker_locale_zh_CN = (locale_zh_CN_locale);
// CONCATENATED MODULE: ./src/components/calendar/locale/zh_CN.js

/* harmony default export */ var calendar_locale_zh_CN = (date_picker_locale_zh_CN);
// CONCATENATED MODULE: ./src/components/calendar/index.jsx
function calendar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { calendar_defineProperty(target, key, source[key]); }); } return target; }

function calendar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function calendar_slicedToArray(arr, i) { return calendar_arrayWithHoles(arr) || calendar_iterableToArrayLimit(arr, i) || calendar_nonIterableRest(); }

function calendar_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function calendar_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function calendar_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }













function calendar_noop() {
  return null;
}

function zerofixed(v) {
  if (v < 10) {
    return "0".concat(v);
  }

  return "".concat(v);
}

var calendar_MomentType = {
  type: Object,
  validator: function validator(value) {
    return external_moment_["isMoment"](value);
  }
};

function isMomentArray(value) {
  return Array.isArray(value) && !!value.find(function (val) {
    return external_moment_["isMoment"](val);
  });
}

var CalendarMode = vue_types["a" /* default */].oneOf(['month', 'year']);
var calendar_CalendarProps = function CalendarProps() {
  return {
    prefixCls: vue_types["a" /* default */].string,
    value: calendar_MomentType,
    defaultValue: calendar_MomentType,
    mode: CalendarMode,
    fullscreen: vue_types["a" /* default */].bool,
    // dateCellRender: PropTypes.func,
    // monthCellRender: PropTypes.func,
    // dateFullCellRender: PropTypes.func,
    // monthFullCellRender: PropTypes.func,
    locale: vue_types["a" /* default */].any,
    // onPanelChange?: (date?: moment.Moment, mode?: CalendarMode) => void;
    // onSelect?: (date?: moment.Moment) => void;
    disabledDate: vue_types["a" /* default */].func,
    validRange: vue_types["a" /* default */].custom(isMomentArray)
  };
};
var Calendar = {
  name: 'TaCalendar',
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(calendar_CalendarProps(), {
    locale: {},
    fullscreen: true,
    prefixCls: PREFIX_CLS,
    mode: 'month'
  }),
  model: {
    prop: 'value',
    event: 'change'
  },
  data: function data() {
    var value = this.value || this.defaultValue || interopDefault(external_moment_)();

    if (!interopDefault(external_moment_).isMoment(value)) {
      throw new Error('The value/defaultValue of Calendar must be a moment object, ');
    }

    return {
      sValue: value,
      sMode: this.mode
    };
  },
  watch: {
    value: function value(val) {
      this.setState({
        sValue: val
      });
    },
    mode: function mode(val) {
      this.setState({
        sMode: val
      });
    }
  },
  methods: {
    monthCellRender2: function monthCellRender2(value) {
      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          $scopedSlots = this.$scopedSlots;
      var monthCellRender = this.monthCellRender || $scopedSlots.monthCellRender || calendar_noop;
      return h("div", {
        "class": "".concat(prefixCls, "-month")
      }, [h("div", {
        "class": "".concat(prefixCls, "-value")
      }, [value.localeData().monthsShort(value)]), h("div", {
        "class": "".concat(prefixCls, "-content")
      }, [monthCellRender(value)])]);
    },
    dateCellRender2: function dateCellRender2(value) {
      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          $scopedSlots = this.$scopedSlots;
      var dateCellRender = this.dateCellRender || $scopedSlots.dateCellRender || calendar_noop;
      return h("div", {
        "class": "".concat(prefixCls, "-date")
      }, [h("div", {
        "class": "".concat(prefixCls, "-value")
      }, [zerofixed(value.date())]), h("div", {
        "class": "".concat(prefixCls, "-content")
      }, [dateCellRender(value)])]);
    },
    setValue: function setValue(value, way) {
      if (way === 'select') {
        this.$emit('select', value);
      } else if (way === 'changePanel') {
        this.onPanelChange(value, this.sMode);
      }

      if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
        this.setState({
          sValue: value
        });
      }
    },
    setType: function setType(type) {
      var mode = type === 'date' ? 'month' : 'year';

      if (this.sMode !== mode) {
        this.setState({
          sMode: mode
        });
        this.onPanelChange(this.sValue, mode);
      }
    },
    onHeaderValueChange: function onHeaderValueChange(value) {
      this.setValue(value, 'changePanel');
    },
    onHeaderTypeChange: function onHeaderTypeChange(type) {
      this.setType(type);
    },
    onPanelChange: function onPanelChange(value, mode) {
      this.$emit('panelChange', value, mode);

      if (value !== this.sValue) {
        this.$emit('change', value);
      }
    },
    onSelect: function onSelect(value) {
      this.setValue(value, 'select');
    },
    getDateRange: function getDateRange(validRange, disabledDate) {
      return function (current) {
        if (!current) {
          return false;
        }

        var _validRange = calendar_slicedToArray(validRange, 2),
            startDate = _validRange[0],
            endDate = _validRange[1];

        var inRange = !current.isBetween(startDate, endDate, 'days', '[]');

        if (disabledDate) {
          return disabledDate(current) || inRange;
        }

        return inRange;
      };
    },
    renderCalendar: function renderCalendar(locale, localeCode) {
      var h = this.$createElement;
      var props = Object(props_util["j" /* getOptionProps */])(this);
      var value = this.sValue,
          mode = this.sMode,
          $listeners = this.$listeners,
          $scopedSlots = this.$scopedSlots;

      if (value && localeCode) {
        value.locale(localeCode);
      }

      var prefixCls = props.prefixCls,
          fullscreen = props.fullscreen,
          dateFullCellRender = props.dateFullCellRender,
          monthFullCellRender = props.monthFullCellRender;
      var type = mode === 'year' ? 'month' : 'date';
      var cls = '';

      if (fullscreen) {
        cls += " ".concat(prefixCls, "-fullscreen");
      }

      var monthCellRender = monthFullCellRender || $scopedSlots.monthFullCellRender || this.monthCellRender2;
      var dateCellRender = dateFullCellRender || $scopedSlots.dateFullCellRender || this.dateCellRender2;
      var disabledDate = props.disabledDate;

      if (props.validRange) {
        disabledDate = this.getDateRange(props.validRange, disabledDate);
      }

      var fullCalendarProps = {
        props: calendar_objectSpread({}, props, {
          Select: {},
          locale: locale.lang,
          type: type,
          prefixCls: prefixCls,
          showHeader: false,
          value: value,
          monthCellRender: monthCellRender,
          dateCellRender: dateCellRender,
          disabledDate: disabledDate
        }),
        on: calendar_objectSpread({}, $listeners, {
          select: this.onSelect
        })
      };
      return h("div", {
        "class": cls
      }, [h(Header, {
        attrs: {
          fullscreen: fullscreen,
          type: type,
          value: value,
          locale: locale.lang,
          prefixCls: prefixCls,
          validRange: props.validRange
        },
        on: {
          "typeChange": this.onHeaderTypeChange,
          "valueChange": this.onHeaderValueChange
        }
      }), h(src_FullCalendar, fullCalendarProps)]);
    }
  },
  render: function render() {
    var h = arguments[0];
    return h(LocaleReceiver, {
      attrs: {
        componentName: 'Calendar',
        defaultLocale: calendar_locale_zh_CN
      },
      scopedSlots: {
        "default": this.renderCalendar
      }
    });
  }
};
/* istanbul ignore next */

Calendar.install = function (Vue) {
  Vue.component(Calendar.name, Calendar);
};

/* harmony default export */ var components_calendar = (Calendar);
// CONCATENATED MODULE: ./src/components/vc-tabs/src/KeyCode.js
/* harmony default export */ var src_KeyCode = ({
  /**
   * LEFT
   */
  LEFT: 37,
  // also NUM_WEST

  /**
   * UP
   */
  UP: 38,
  // also NUM_NORTH

  /**
   * RIGHT
   */
  RIGHT: 39,
  // also NUM_EAST

  /**
   * DOWN
   */
  DOWN: 40 // also NUM_SOUTH

});
// CONCATENATED MODULE: ./src/components/vc-tabs/src/Tabs.jsx
function Tabs_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








function getDefaultActiveKey(props) {
  var activeKey;
  var children = props.children;
  children.forEach(function (child) {
    if (child && !activeKey && !child.disabled) {
      activeKey = child.key;
    }
  });
  return activeKey;
}

function activeKeyIsValid(props, key) {
  var children = props.children;
  var keys = children.map(function (child) {
    return child && child.key;
  });
  return keys.indexOf(key) >= 0;
}

/* harmony default export */ var Tabs = ({
  name: 'Tabs',
  model: {
    prop: 'activeKey',
    event: 'change'
  },
  mixins: [BaseMixin["a" /* default */]],
  props: {
    destroyInactiveTabPane: vue_types["a" /* default */].bool,
    renderTabBar: vue_types["a" /* default */].func.isRequired,
    renderTabContent: vue_types["a" /* default */].func.isRequired,
    navWrapper: vue_types["a" /* default */].func.def(function (arg) {
      return arg;
    }),
    children: vue_types["a" /* default */].any.def([]),
    prefixCls: vue_types["a" /* default */].string.def('ant-tabs'),
    tabBarPosition: vue_types["a" /* default */].string.def('top'),
    activeKey: vue_types["a" /* default */].string,
    defaultActiveKey: vue_types["a" /* default */].string,
    __propsSymbol__: vue_types["a" /* default */].any
  },
  data: function data() {
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var activeKey;

    if ('activeKey' in props) {
      activeKey = props.activeKey;
    } else if ('defaultActiveKey' in props) {
      activeKey = props.defaultActiveKey;
    } else {
      activeKey = getDefaultActiveKey(props);
    }

    return {
      _activeKey: activeKey
    };
  },
  watch: {
    __propsSymbol__: function __propsSymbol__() {
      var nextProps = Object(props_util["j" /* getOptionProps */])(this);

      if ('activeKey' in nextProps) {
        this.setState({
          _activeKey: nextProps.activeKey
        });
      } else if (!activeKeyIsValid(nextProps, this.$data._activeKey)) {
        // https://github.com/ant-design/ant-design/issues/7093
        this.setState({
          _activeKey: getDefaultActiveKey(nextProps)
        });
      }
    }
  },
  methods: {
    onTabClick: function onTabClick(activeKey, e) {
      if (this.tabBar.componentOptions && this.tabBar.componentOptions.listeners && this.tabBar.componentOptions.listeners.tabClick) {
        this.tabBar.componentOptions.listeners.tabClick(activeKey, e);
      }

      this.setActiveKey(activeKey);
    },
    onNavKeyDown: function onNavKeyDown(e) {
      var eventKeyCode = e.keyCode;

      if (eventKeyCode === src_KeyCode.RIGHT || eventKeyCode === src_KeyCode.DOWN) {
        e.preventDefault();
        var nextKey = this.getNextActiveKey(true);
        this.onTabClick(nextKey);
      } else if (eventKeyCode === src_KeyCode.LEFT || eventKeyCode === src_KeyCode.UP) {
        e.preventDefault();
        var previousKey = this.getNextActiveKey(false);
        this.onTabClick(previousKey);
      }
    },
    setActiveKey: function setActiveKey(activeKey) {
      if (this.$data._activeKey !== activeKey) {
        var props = Object(props_util["j" /* getOptionProps */])(this);

        if (!('activeKey' in props)) {
          this.setState({
            _activeKey: activeKey
          });
        }

        this.__emit('change', activeKey);
      }
    },
    getNextActiveKey: function getNextActiveKey(next) {
      var activeKey = this.$data._activeKey;
      var children = [];
      this.$props.children.forEach(function (c) {
        if (c && !c.disabled && c.disabled !== '') {
          if (next) {
            children.push(c);
          } else {
            children.unshift(c);
          }
        }
      });
      var length = children.length;
      var ret = length && children[0].key;
      children.forEach(function (child, i) {
        if (child.key === activeKey) {
          if (i === length - 1) {
            ret = children[0].key;
          } else {
            ret = children[i + 1].key;
          }
        }
      });
      return ret;
    }
  },
  render: function render() {
    var _cls;

    var h = arguments[0];
    var props = this.$props;
    var prefixCls = props.prefixCls,
        navWrapper = props.navWrapper,
        tabBarPosition = props.tabBarPosition,
        renderTabContent = props.renderTabContent,
        renderTabBar = props.renderTabBar,
        destroyInactiveTabPane = props.destroyInactiveTabPane;
    var cls = (_cls = {}, Tabs_defineProperty(_cls, prefixCls, 1), Tabs_defineProperty(_cls, "".concat(prefixCls, "-").concat(tabBarPosition), 1), _cls);
    this.tabBar = renderTabBar();
    var contents = [Object(vnode["a" /* cloneElement */])(this.tabBar, {
      props: {
        prefixCls: prefixCls,
        navWrapper: navWrapper,
        tabBarPosition: tabBarPosition,
        panels: props.children,
        activeKey: this.$data._activeKey
      },
      on: {
        keydown: this.onNavKeyDown,
        tabClick: this.onTabClick
      },
      key: 'tabBar'
    }), Object(vnode["a" /* cloneElement */])(renderTabContent(), {
      props: {
        prefixCls: prefixCls,
        tabBarPosition: tabBarPosition,
        activeKey: this.$data._activeKey,
        destroyInactiveTabPane: destroyInactiveTabPane
      },
      on: {
        change: this.setActiveKey
      },
      children: props.children,
      key: 'tabContent'
    })];

    if (tabBarPosition === 'bottom') {
      contents.reverse();
    }

    return h("div", {
      on: Object(es["a" /* default */])(this.$listeners, ['change']),
      "class": cls
    }, [contents]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-tabs/src/TabPane.jsx
function TabPane_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/* harmony default export */ var TabPane = ({
  name: 'TabPane',
  props: {
    active: vue_types["a" /* default */].bool,
    destroyInactiveTabPane: vue_types["a" /* default */].bool,
    forceRender: vue_types["a" /* default */].bool,
    placeholder: vue_types["a" /* default */].any,
    rootPrefixCls: vue_types["a" /* default */].string,
    tab: vue_types["a" /* default */].any,
    closable: vue_types["a" /* default */].bool,
    disabled: vue_types["a" /* default */].bool
  },
  render: function render() {
    var _cls;

    var h = arguments[0];
    var _this$$props = this.$props,
        destroyInactiveTabPane = _this$$props.destroyInactiveTabPane,
        active = _this$$props.active,
        forceRender = _this$$props.forceRender,
        rootPrefixCls = _this$$props.rootPrefixCls;
    var children = this.$slots["default"];
    var placeholder = Object(props_util["g" /* getComponentFromProp */])(this, 'placeholder');
    this._isActived = this._isActived || active;
    var prefixCls = "".concat(rootPrefixCls, "-tabpane");
    var cls = (_cls = {}, TabPane_defineProperty(_cls, prefixCls, 1), TabPane_defineProperty(_cls, "".concat(prefixCls, "-inactive"), !active), TabPane_defineProperty(_cls, "".concat(prefixCls, "-active"), active), _cls);
    var isRender = destroyInactiveTabPane ? active : this._isActived;
    return h("div", {
      "class": cls,
      attrs: {
        role: 'tabpanel',
        "aria-hidden": active ? 'false' : 'true'
      }
    }, [isRender || forceRender ? children : placeholder]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-tabs/src/utils.js
function src_utils_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function utils_toArray(children) {
  var c = [];
  children.forEach(function (child) {
    if (child.data) {
      c.push(child);
    }
  });
  return c;
}
function getActiveIndex(children, activeKey) {
  var c = utils_toArray(children);

  for (var i = 0; i < c.length; i++) {
    if (c[i].key === activeKey) {
      return i;
    }
  }

  return -1;
}
function utils_getActiveKey(children, index) {
  var c = utils_toArray(children);
  return c[index].key;
}
function src_utils_setTransform(style, v) {
  style.transform = v;
  style.webkitTransform = v;
  style.mozTransform = v;
}
function isTransformSupported(style) {
  return 'transform' in style || 'webkitTransform' in style || 'MozTransform' in style;
}
function setTransition(style, v) {
  style.transition = v;
  style.webkitTransition = v;
  style.MozTransition = v;
}
function getTransformPropValue(v) {
  return {
    transform: v,
    WebkitTransform: v,
    MozTransform: v
  };
}
function utils_isVertical(tabBarPosition) {
  return tabBarPosition === 'left' || tabBarPosition === 'right';
}
function getTransformByIndex(index, tabBarPosition) {
  var translate = utils_isVertical(tabBarPosition) ? 'translateY' : 'translateX';
  return "".concat(translate, "(").concat(-index * 100, "%) translateZ(0)");
}
function getMarginStyle(index, tabBarPosition) {
  var marginDirection = utils_isVertical(tabBarPosition) ? 'marginTop' : 'marginLeft';
  return src_utils_defineProperty({}, marginDirection, "".concat(-index * 100, "%"));
}
function utils_getStyle(el, property) {
  return +window.getComputedStyle(el).getPropertyValue(property).replace('px', '');
}
function setPxStyle(el, value, vertical) {
  value = vertical ? "0px, ".concat(value, "px, 0px") : "".concat(value, "px, 0px, 0px");
  src_utils_setTransform(el.style, "translate3d(".concat(value, ")"));
}
function getDataAttr(props) {
  return Object.keys(props).reduce(function (prev, key) {
    if (key.substr(0, 5) === 'aria-' || key.substr(0, 5) === 'data-' || key === 'role') {
      prev[key] = props[key];
    }

    return prev;
  }, {});
}
// CONCATENATED MODULE: ./src/components/vc-tabs/src/TabContent.jsx
function TabContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/* harmony default export */ var TabContent = ({
  name: 'TabContent',
  props: {
    animated: {
      type: Boolean,
      "default": true
    },
    animatedWithMargin: {
      type: Boolean,
      "default": true
    },
    prefixCls: {
      "default": 'ant-tabs',
      type: String
    },
    activeKey: String,
    tabBarPosition: String
  },
  computed: {
    classes: function classes() {
      var _ref;

      var animated = this.animated,
          prefixCls = this.prefixCls;
      return _ref = {}, TabContent_defineProperty(_ref, "".concat(prefixCls, "-content"), true), TabContent_defineProperty(_ref, animated ? "".concat(prefixCls, "-content-animated") : "".concat(prefixCls, "-content-no-animated"), true), _ref;
    }
  },
  methods: {
    getTabPanes: function getTabPanes() {
      var props = this.$props;
      var activeKey = props.activeKey;
      var children = this.$slots["default"] || [];
      var newChildren = [];
      children.forEach(function (child) {
        if (!child) {
          return;
        }

        var key = child.key;
        var active = activeKey === key;
        newChildren.push(Object(vnode["a" /* cloneElement */])(child, {
          props: {
            active: active,
            destroyInactiveTabPane: props.destroyInactiveTabPane,
            rootPrefixCls: props.prefixCls
          }
        }));
      });
      return newChildren;
    }
  },
  render: function render() {
    var h = arguments[0];
    var activeKey = this.activeKey,
        tabBarPosition = this.tabBarPosition,
        animated = this.animated,
        animatedWithMargin = this.animatedWithMargin,
        classes = this.classes;
    var style = {};

    if (animated && this.$slots["default"]) {
      var activeIndex = getActiveIndex(this.$slots["default"], activeKey);

      if (activeIndex !== -1) {
        var animatedStyle = animatedWithMargin ? getMarginStyle(activeIndex, tabBarPosition) : getTransformPropValue(getTransformByIndex(activeIndex, tabBarPosition));
        style = animatedStyle;
      } else {
        style = {
          display: 'none'
        };
      }
    }

    return h("div", {
      "class": classes,
      style: style
    }, [this.getTabPanes()]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-tabs/src/index.js
// based on rc-tabs 9.3.6



/* harmony default export */ var vc_tabs_src = (Tabs);

// CONCATENATED MODULE: ./src/components/vc-tabs/src/InkTabBarNode.jsx


function InkTabBarNode_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




function InkTabBarNode_getScroll(w, top) {
  var ret = w["page".concat(top ? 'Y' : 'X', "Offset")];
  var method = "scroll".concat(top ? 'Top' : 'Left');

  if (typeof ret !== 'number') {
    var d = w.document; // ie6,7,8 standard mode

    ret = d.documentElement[method];

    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }

  return ret;
}

function InkTabBarNode_offset(elem) {
  var x;
  var y;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  var box = elem.getBoundingClientRect();
  x = box.left;
  y = box.top;
  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;
  var w = doc.defaultView || doc.parentWindow;
  x += InkTabBarNode_getScroll(w);
  y += InkTabBarNode_getScroll(w, true);
  return {
    left: x,
    top: y
  };
}

function componentDidUpdate(component, init) {
  var _component$$props$sty = component.$props.styles,
      styles = _component$$props$sty === void 0 ? {} : _component$$props$sty;
  var rootNode = component.getRef('root');
  var wrapNode = component.getRef('nav') || rootNode;
  var containerOffset = InkTabBarNode_offset(wrapNode);
  var inkBarNode = component.getRef('inkBar');
  var activeTab = component.getRef('activeTab');
  var inkBarNodeStyle = inkBarNode.style;
  var tabBarPosition = component.$props.tabBarPosition;

  if (init) {
    // prevent mount animation
    inkBarNodeStyle.display = 'none';
  }

  if (activeTab) {
    var tabNode = activeTab;
    var tabOffset = InkTabBarNode_offset(tabNode);
    var transformSupported = isTransformSupported(inkBarNodeStyle);

    if (tabBarPosition === 'top' || tabBarPosition === 'bottom') {
      var left = tabOffset.left - containerOffset.left;
      var width = tabNode.offsetWidth; // If tabNode'width width equal to wrapNode'width when tabBarPosition is top or bottom
      // It means no css working, then ink bar should not have width until css is loaded
      // Fix https://github.com/ant-design/ant-design/issues/7564

      if (width === rootNode.offsetWidth) {
        width = 0;
      } else if (styles.inkBar && styles.inkBar.width !== undefined) {
        width = parseFloat(styles.inkBar.width, 10);

        if (width) {
          left = left + (tabNode.offsetWidth - width) / 2;
        }
      } // use 3d gpu to optimize render


      if (transformSupported) {
        src_utils_setTransform(inkBarNodeStyle, "translate3d(".concat(left, "px,0,0)"));
        inkBarNodeStyle.width = "".concat(width, "px");
        inkBarNodeStyle.height = '';
      } else {
        inkBarNodeStyle.left = "".concat(left, "px");
        inkBarNodeStyle.top = '';
        inkBarNodeStyle.bottom = '';
        inkBarNodeStyle.right = "".concat(wrapNode.offsetWidth - left - width, "px");
      }
    } else {
      var top = tabOffset.top - containerOffset.top;
      var height = tabNode.offsetHeight;

      if (styles.inkBar && styles.inkBar.height !== undefined) {
        height = parseFloat(styles.inkBar.height, 10);

        if (height) {
          top = top + (tabNode.offsetHeight - height) / 2;
        }
      }

      if (transformSupported) {
        src_utils_setTransform(inkBarNodeStyle, "translate3d(0,".concat(top, "px,0)"));
        inkBarNodeStyle.height = "".concat(height, "px");
        inkBarNodeStyle.width = '';
      } else {
        inkBarNodeStyle.left = '';
        inkBarNodeStyle.right = '';
        inkBarNodeStyle.top = "".concat(top, "px");
        inkBarNodeStyle.bottom = "".concat(wrapNode.offsetHeight - top - height, "px");
      }
    }
  }

  inkBarNodeStyle.display = activeTab ? 'block' : 'none';
}

/* harmony default export */ var InkTabBarNode = ({
  name: 'InkTabBarNode',
  mixins: [BaseMixin["a" /* default */]],
  props: {
    inkBarAnimated: {
      type: Boolean,
      "default": true
    },
    prefixCls: String,
    styles: Object,
    tabBarPosition: String,
    saveRef: vue_types["a" /* default */].func.def(function () {}),
    getRef: vue_types["a" /* default */].func.def(function () {})
  },
  updated: function updated() {
    this.$nextTick(function () {
      componentDidUpdate(this);
    });
  },
  mounted: function mounted() {
    this.$nextTick(function () {
      componentDidUpdate(this, true);
    });
  },
  render: function render() {
    var _classes;

    var h = arguments[0];
    var prefixCls = this.prefixCls,
        _this$styles = this.styles,
        styles = _this$styles === void 0 ? {} : _this$styles,
        inkBarAnimated = this.inkBarAnimated;
    var className = "".concat(prefixCls, "-ink-bar");
    var classes = (_classes = {}, InkTabBarNode_defineProperty(_classes, className, true), InkTabBarNode_defineProperty(_classes, inkBarAnimated ? "".concat(className, "-animated") : "".concat(className, "-no-animated"), true), _classes);
    return h("div", babel_helper_vue_jsx_merge_props_default()([{
      style: styles.inkBar,
      "class": classes,
      key: 'inkBar'
    }, {
      directives: [{
        name: 'ref',
        value: this.saveRef('inkBar')
      }]
    }]));
  }
});
// CONCATENATED MODULE: ./src/components/vc-tabs/src/TabBarTabsNode.jsx






function TabBarTabsNode_noop() {}

/* harmony default export */ var TabBarTabsNode = ({
  name: 'TabBarTabsNode',
  mixins: [BaseMixin["a" /* default */]],
  props: {
    activeKey: vue_types["a" /* default */].string,
    panels: vue_types["a" /* default */].any.def([]),
    prefixCls: vue_types["a" /* default */].string.def(''),
    tabBarGutter: vue_types["a" /* default */].any.def(null),
    onTabClick: vue_types["a" /* default */].func,
    saveRef: vue_types["a" /* default */].func.def(TabBarTabsNode_noop),
    getRef: vue_types["a" /* default */].func.def(TabBarTabsNode_noop)
  },
  render: function render() {
    var _this = this;

    var h = arguments[0];
    var _this$$props = this.$props,
        children = _this$$props.panels,
        activeKey = _this$$props.activeKey,
        prefixCls = _this$$props.prefixCls,
        tabBarGutter = _this$$props.tabBarGutter;
    var rst = [];
    children.forEach(function (child, index) {
      if (!child) {
        return;
      }

      var props = Object(props_util["j" /* getOptionProps */])(child);
      var key = child.key;
      var cls = activeKey === key ? "".concat(prefixCls, "-tab-active") : '';
      cls += " ".concat(prefixCls, "-tab");
      var events = {
        on: {}
      };
      var disabled = props.disabled || props.disabled === '';

      if (disabled) {
        cls += " ".concat(prefixCls, "-tab-disabled");
      } else {
        events.on.click = function () {
          _this.__emit('tabClick', key);
        };
      }

      var directives = [];

      if (activeKey === key) {
        directives.push({
          name: 'ref',
          value: _this.saveRef('activeTab')
        });
      }

      var tab = Object(props_util["g" /* getComponentFromProp */])(child, 'tab');
      browser_default()(tab !== undefined, 'There must be `tab` property or slot on children of Tabs.');
      rst.push(h("div", babel_helper_vue_jsx_merge_props_default()([{
        attrs: {
          role: 'tab',
          "aria-disabled": disabled ? 'true' : 'false',
          "aria-selected": activeKey === key ? 'true' : 'false'
        }
      }, events, {
        "class": cls,
        key: key,
        style: {
          marginRight: tabBarGutter && index === children.length - 1 ? 0 : "".concat(tabBarGutter, "px")
        }
      }, {
        directives: directives
      }]), [tab]));
    });
    return h("div", [rst]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-tabs/src/TabBarRootNode.jsx


function TabBarRootNode_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { TabBarRootNode_defineProperty(target, key, source[key]); }); } return target; }

function TabBarRootNode_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





function TabBarRootNode_noop() {}

/* harmony default export */ var TabBarRootNode = ({
  name: 'TabBarRootNode',
  mixins: [BaseMixin["a" /* default */]],
  props: {
    saveRef: vue_types["a" /* default */].func.def(TabBarRootNode_noop),
    getRef: vue_types["a" /* default */].func.def(TabBarRootNode_noop),
    prefixCls: vue_types["a" /* default */].string.def(''),
    tabBarPosition: vue_types["a" /* default */].string.def('top'),
    extraContent: vue_types["a" /* default */].any
  },
  methods: {
    onKeyDown: function onKeyDown(e) {
      this.__emit('keydown', e);
    }
  },
  render: function render() {
    var h = arguments[0];
    var prefixCls = this.prefixCls,
        onKeyDown = this.onKeyDown,
        tabBarPosition = this.tabBarPosition,
        extraContent = this.extraContent;

    var cls = TabBarRootNode_defineProperty({}, "".concat(prefixCls, "-bar"), true);

    var topOrBottom = tabBarPosition === 'top' || tabBarPosition === 'bottom';
    var tabBarExtraContentStyle = topOrBottom ? {
      "float": 'right'
    } : {};
    var children = this.$slots["default"];
    var newChildren = children;

    if (extraContent) {
      newChildren = [Object(vnode["a" /* cloneElement */])(extraContent, {
        key: 'extra',
        style: TabBarRootNode_objectSpread({}, tabBarExtraContentStyle)
      }), Object(vnode["a" /* cloneElement */])(children, {
        key: 'content'
      })];
      newChildren = topOrBottom ? newChildren : newChildren.reverse();
    }

    return h("div", babel_helper_vue_jsx_merge_props_default()([{
      attrs: {
        role: 'tablist',
        tabIndex: '0'
      },
      "class": cls,
      on: {
        "keydown": onKeyDown
      }
    }, {
      directives: [{
        name: 'ref',
        value: this.saveRef('root')
      }]
    }]), [newChildren]);
  }
});
// EXTERNAL MODULE: ./node_modules/lodash/debounce.js
var debounce = __webpack_require__(42);
var debounce_default = /*#__PURE__*/__webpack_require__.n(debounce);

// CONCATENATED MODULE: ./src/components/vc-tabs/src/ScrollableTabBarNode.jsx




function ScrollableTabBarNode_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







function ScrollableTabBarNode_noop() {}

/* harmony default export */ var ScrollableTabBarNode = ({
  name: 'ScrollableTabBarNode',
  mixins: [BaseMixin["a" /* default */]],
  props: {
    saveRef: vue_types["a" /* default */].func.def(function () {}),
    getRef: vue_types["a" /* default */].func.def(function () {}),
    tabBarPosition: vue_types["a" /* default */].oneOf(['left', 'right', 'top', 'bottom']).def('left'),
    prefixCls: vue_types["a" /* default */].string.def(''),
    scrollAnimated: vue_types["a" /* default */].bool.def(true),
    navWrapper: vue_types["a" /* default */].func.def(function (arg) {
      return arg;
    })
  },
  data: function data() {
    this.offset = 0;
    this.prevProps = this.$props;
    return {
      next: false,
      prev: false
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.updatedCal();

      _this.debouncedResize = debounce_default()(function () {
        _this.setNextPrev();

        _this.scrollToActiveTab();
      }, 200);
      _this.resizeEvent = lib_default()(window, 'resize', _this.debouncedResize);
    });
  },
  updated: function updated() {
    var _this2 = this;

    this.$nextTick(function () {
      _this2.updatedCal(_this2.prevProps);

      _this2.prevProps = _this2.$props;
    });
  },
  beforeDestroy: function beforeDestroy() {
    if (this.resizeEvent) {
      this.resizeEvent.remove();
    }

    if (this.debouncedResize && this.debouncedResize.cancel) {
      this.debouncedResize.cancel();
    }
  },
  watch: {
    tabBarPosition: function tabBarPosition(val) {
      var _this3 = this;

      this.tabBarPositionChange = true;
      this.$nextTick(function () {
        _this3.setOffset(0);
      });
    }
  },
  methods: {
    updatedCal: function updatedCal(prevProps) {
      var _this4 = this;

      var props = this.$props;

      if (prevProps && prevProps.tabBarPosition !== props.tabBarPosition) {
        this.setOffset(0);
        return;
      }

      var nextPrev = this.setNextPrev(); // wait next, prev show hide

      /* eslint react/no-did-update-set-state:0 */

      if (this.isNextPrevShown(this.$data) !== this.isNextPrevShown(nextPrev)) {
        this.$foreceUpdate();
        this.$nextTick(function () {
          _this4.scrollToActiveTab();
        });
      } else if (!prevProps || props.activeKey !== prevProps.activeKey) {
        // can not use props.activeKey
        this.scrollToActiveTab();
      }
    },
    setNextPrev: function setNextPrev() {
      var navNode = this.$props.getRef('nav');
      var navNodeWH = this.getScrollWH(navNode);
      var containerWH = this.getOffsetWH(this.$props.getRef('container'));
      var navWrapNodeWH = this.getOffsetWH(this.$props.getRef('navWrap'));
      var offset = this.offset;
      var minOffset = containerWH - navNodeWH;
      var next = this.next,
          prev = this.prev;

      if (minOffset >= 0) {
        next = false;
        this.setOffset(0, false);
        offset = 0;
      } else if (minOffset < offset) {
        next = true;
      } else {
        next = false; // Fix https://github.com/ant-design/ant-design/issues/8861
        // Test with container offset which is stable
        // and set the offset of the nav wrap node

        var realOffset = navWrapNodeWH - navNodeWH;
        this.setOffset(realOffset, false);
        offset = realOffset;
      }

      if (offset < 0) {
        prev = true;
      } else {
        prev = false;
      }

      this.setNext(next);
      this.setPrev(prev);
      return {
        next: next,
        prev: prev
      };
    },
    getOffsetWH: function getOffsetWH(node) {
      var tabBarPosition = this.$props.tabBarPosition;
      var prop = 'offsetWidth';

      if (tabBarPosition === 'left' || tabBarPosition === 'right') {
        prop = 'offsetHeight';
      }

      return node[prop];
    },
    getScrollWH: function getScrollWH(node) {
      var tabBarPosition = this.tabBarPosition;
      var prop = 'scrollWidth';

      if (tabBarPosition === 'left' || tabBarPosition === 'right') {
        prop = 'scrollHeight';
      }

      return node[prop];
    },
    getOffsetLT: function getOffsetLT(node) {
      var tabBarPosition = this.$props.tabBarPosition;
      var prop = 'left';

      if (tabBarPosition === 'left' || tabBarPosition === 'right') {
        prop = 'top';
      }

      return node.getBoundingClientRect()[prop];
    },
    setOffset: function setOffset(offset) {
      var checkNextPrev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var target = Math.min(0, offset);

      if (this.offset !== target) {
        this.offset = target;
        var navOffset = {};
        var tabBarPosition = this.$props.tabBarPosition;
        var navStyle = this.$props.getRef('nav').style;
        var transformSupported = isTransformSupported(navStyle);

        if (tabBarPosition === 'left' || tabBarPosition === 'right') {
          if (transformSupported) {
            navOffset = {
              value: "translate3d(0,".concat(target, "px,0)")
            };
          } else {
            navOffset = {
              name: 'top',
              value: "".concat(target, "px")
            };
          }
        } else {
          if (transformSupported) {
            navOffset = {
              value: "translate3d(".concat(target, "px,0,0)")
            };
          } else {
            navOffset = {
              name: 'left',
              value: "".concat(target, "px")
            };
          }
        }

        if (transformSupported) {
          src_utils_setTransform(navStyle, navOffset.value);
        } else {
          navStyle[navOffset.name] = navOffset.value;
        }

        if (checkNextPrev) {
          this.setNextPrev();
        }
      }
    },
    setPrev: function setPrev(v) {
      if (this.prev !== v) {
        this.prev = v;
      }
    },
    setNext: function setNext(v) {
      if (!v) {// debugger
      }

      if (this.next !== v) {
        this.next = v;
      }
    },
    isNextPrevShown: function isNextPrevShown(state) {
      if (state) {
        return state.next || state.prev;
      }

      return this.next || this.prev;
    },
    prevTransitionEnd: function prevTransitionEnd(e) {
      if (e.propertyName !== 'opacity') {
        return;
      }

      var container = this.$props.getRef('container');
      this.scrollToActiveTab({
        target: container,
        currentTarget: container
      });
    },
    scrollToActiveTab: function scrollToActiveTab(e) {
      var activeTab = this.$props.getRef('activeTab');
      var navWrap = this.$props.getRef('navWrap');

      if (e && e.target !== e.currentTarget || !activeTab) {
        return;
      } // when not scrollable or enter scrollable first time, don't emit scrolling


      var needToSroll = this.isNextPrevShown() && this.lastNextPrevShown;
      this.lastNextPrevShown = this.isNextPrevShown();

      if (!needToSroll) {
        return;
      }

      var activeTabWH = this.getScrollWH(activeTab);
      var navWrapNodeWH = this.getOffsetWH(navWrap);
      var offset = this.offset;
      var wrapOffset = this.getOffsetLT(navWrap);
      var activeTabOffset = this.getOffsetLT(activeTab);

      if (wrapOffset > activeTabOffset) {
        offset += wrapOffset - activeTabOffset;
        this.setOffset(offset);
      } else if (wrapOffset + navWrapNodeWH < activeTabOffset + activeTabWH) {
        offset -= activeTabOffset + activeTabWH - (wrapOffset + navWrapNodeWH);
        this.setOffset(offset);
      }
    },
    prevClick: function prevClick(e) {
      this.__emit('prevClick', e);

      var navWrapNode = this.$props.getRef('navWrap');
      var navWrapNodeWH = this.getOffsetWH(navWrapNode);
      var offset = this.offset;
      this.setOffset(offset + navWrapNodeWH);
    },
    nextClick: function nextClick(e) {
      // this.__emit('nextClick', e)
      var navWrapNode = this.$props.getRef('navWrap');
      var navWrapNodeWH = this.getOffsetWH(navWrapNode);
      var offset = this.offset;
      this.setOffset(offset - navWrapNodeWH);
    }
  },
  render: function render() {
    var _ref, _ref2, _navClasses, _ref3;

    var h = arguments[0];
    var next = this.next,
        prev = this.prev;
    var _this$$props = this.$props,
        prefixCls = _this$$props.prefixCls,
        scrollAnimated = _this$$props.scrollAnimated,
        navWrapper = _this$$props.navWrapper;
    var showNextPrev = prev || next;
    var prevButton = h("span", {
      on: {
        "click": prev ? this.prevClick : ScrollableTabBarNode_noop,
        "transitionend": this.prevTransitionEnd
      },
      attrs: {
        unselectable: 'unselectable'
      },
      "class": (_ref = {}, ScrollableTabBarNode_defineProperty(_ref, "".concat(prefixCls, "-tab-prev"), 1), ScrollableTabBarNode_defineProperty(_ref, "".concat(prefixCls, "-tab-btn-disabled"), !prev), ScrollableTabBarNode_defineProperty(_ref, "".concat(prefixCls, "-tab-arrow-show"), showNextPrev), _ref)
    }, [h("span", {
      "class": "".concat(prefixCls, "-tab-prev-icon")
    })]);
    var nextButton = h("span", {
      on: {
        "click": next ? this.nextClick : ScrollableTabBarNode_noop
      },
      attrs: {
        unselectable: 'unselectable'
      },
      "class": (_ref2 = {}, ScrollableTabBarNode_defineProperty(_ref2, "".concat(prefixCls, "-tab-next"), 1), ScrollableTabBarNode_defineProperty(_ref2, "".concat(prefixCls, "-tab-btn-disabled"), !next), ScrollableTabBarNode_defineProperty(_ref2, "".concat(prefixCls, "-tab-arrow-show"), showNextPrev), _ref2)
    }, [h("span", {
      "class": "".concat(prefixCls, "-tab-next-icon")
    })]);
    var navClassName = "".concat(prefixCls, "-nav");
    var navClasses = (_navClasses = {}, ScrollableTabBarNode_defineProperty(_navClasses, navClassName, true), ScrollableTabBarNode_defineProperty(_navClasses, scrollAnimated ? "".concat(navClassName, "-animated") : "".concat(navClassName, "-no-animated"), true), _navClasses);
    return h("div", babel_helper_vue_jsx_merge_props_default()([{
      "class": (_ref3 = {}, ScrollableTabBarNode_defineProperty(_ref3, "".concat(prefixCls, "-nav-container"), 1), ScrollableTabBarNode_defineProperty(_ref3, "".concat(prefixCls, "-nav-container-scrolling"), showNextPrev), _ref3),
      key: 'container'
    }, {
      directives: [{
        name: 'ref',
        value: this.saveRef('container')
      }]
    }]), [prevButton, nextButton, h("div", babel_helper_vue_jsx_merge_props_default()([{
      "class": "".concat(prefixCls, "-nav-wrap")
    }, {
      directives: [{
        name: 'ref',
        value: this.saveRef('navWrap')
      }]
    }]), [h("div", {
      "class": "".concat(prefixCls, "-nav-scroll")
    }, [h("div", babel_helper_vue_jsx_merge_props_default()([{
      "class": navClasses
    }, {
      directives: [{
        name: 'ref',
        value: this.saveRef('nav')
      }]
    }]), [navWrapper(this.$slots["default"])])])])]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-tabs/src/SaveRef.jsx

/* harmony default export */ var SaveRef = ({
  props: {
    children: vue_types["a" /* default */].func.def(function () {
      return null;
    })
  },
  methods: {
    getRef: function getRef(name) {
      return this[name];
    },
    saveRef: function saveRef(name) {
      var _this = this;

      return function (node) {
        if (node) {
          _this[name] = node;
        }
      };
    }
  },
  render: function render() {
    var _this2 = this;

    // 每次都new一个新的function，避免子节点不能重新渲染
    var saveRef = function saveRef(name) {
      return _this2.saveRef(name);
    };

    var getRef = function getRef(name) {
      return _this2.getRef(name);
    };

    return this.children(saveRef, getRef);
  }
});
// CONCATENATED MODULE: ./src/components/vc-tabs/src/ScrollableInkTabBar.jsx





function ScrollableInkTabBar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { ScrollableInkTabBar_defineProperty(target, key, source[key]); }); } return target; }

function ScrollableInkTabBar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






/* harmony default export */ var ScrollableInkTabBar = ({
  name: 'ScrollableInkTabBar',
  inheritAttrs: false,
  props: ['extraContent', 'inkBarAnimated', 'tabBarGutter', 'prefixCls', 'navWrapper', 'tabBarPosition', 'panels', 'activeKey'],
  render: function render() {
    var h = arguments[0];

    var props = ScrollableInkTabBar_objectSpread({}, this.$props);

    var listeners = this.$listeners;
    return h(SaveRef, {
      attrs: {
        children: function children(saveRef, getRef) {
          return h(TabBarRootNode, babel_helper_vue_jsx_merge_props_default()([{
            attrs: {
              saveRef: saveRef
            }
          }, {
            props: props,
            on: listeners
          }]), [h(ScrollableTabBarNode, babel_helper_vue_jsx_merge_props_default()([{
            attrs: {
              saveRef: saveRef,
              getRef: getRef
            }
          }, {
            props: props,
            on: listeners
          }]), [h(TabBarTabsNode, babel_helper_vue_jsx_merge_props_default()([{
            attrs: {
              saveRef: saveRef
            }
          }, {
            props: props,
            on: listeners
          }])), h(InkTabBarNode, babel_helper_vue_jsx_merge_props_default()([{
            attrs: {
              saveRef: saveRef,
              getRef: getRef
            }
          }, {
            props: props,
            on: listeners
          }]))])]);
        }
      }
    });
  }
});
// CONCATENATED MODULE: ./src/components/_util/isFlexSupported.js
function isFlexSupported() {
  if (typeof window !== 'undefined' && window.document && window.document.documentElement) {
    var documentElement = window.document.documentElement;
    return 'flex' in documentElement.style || 'webkitFlex' in documentElement.style || 'Flex' in documentElement.style || 'msFlex' in documentElement.style;
  }

  return false;
}
// CONCATENATED MODULE: ./src/components/tabs/tabs.jsx
function tabs_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { tabs_defineProperty(target, key, source[key]); }); } return target; }

function tabs_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function tabs_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { tabs_typeof = function _typeof(obj) { return typeof obj; }; } else { tabs_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return tabs_typeof(obj); }









/* harmony default export */ var tabs_tabs = ({
  TabPane: TabPane,
  name: 'TaTabs',
  props: {
    prefixCls: {
      type: String,
      "default": 'ant-tabs'
    },
    activeKey: String,
    defaultActiveKey: String,
    hideAdd: {
      type: Boolean,
      "default": false
    },
    tabBarStyle: Object,
    tabBarExtraContent: [String, Number, Function],
    destroyInactiveTabPane: {
      type: Boolean,
      "default": false
    },
    type: {
      validator: function validator(value) {
        return ['line', 'card', 'editable-card'].includes(value);
      }
    },
    tabPosition: {
      validator: function validator(value) {
        return ['top', 'right', 'bottom', 'left'].includes(value);
      }
    },
    size: {
      validator: function validator(value) {
        return ['default', 'small', 'large'].includes(value);
      }
    },
    animated: {
      type: [Boolean, Object],
      "default": undefined
    },
    tabBarGutter: Number
  },
  model: {
    prop: 'activeKey',
    event: 'change'
  },
  methods: {
    createNewTab: function createNewTab(targetKey) {
      this.$emit('edit', targetKey, 'add');
    },
    removeTab: function removeTab(targetKey, e) {
      e.stopPropagation();

      if (!targetKey) {
        return;
      }

      this.$emit('edit', targetKey, 'remove');
    },
    handleChange: function handleChange(activeKey) {
      this.$emit('change', activeKey);
    },
    onTabClick: function onTabClick(val) {
      this.$emit('tabClick', val);
    },
    onPrevClick: function onPrevClick(val) {
      this.$emit('prevClick', val);
    },
    onNextClick: function onNextClick(val) {
      this.$emit('nextClick', val);
    }
  },
  mounted: function mounted() {
    var NO_FLEX = ' no-flex';
    var tabNode = this.$el;

    if (tabNode && !isFlexSupported() && tabNode.className.indexOf(NO_FLEX) === -1) {
      tabNode.className += NO_FLEX;
    }
  },
  render: function render(createElement) {
    var _cls,
        _this = this;

    var h = arguments[0];
    var prefixCls = this.prefixCls,
        size = this.size,
        _this$type = this.type,
        type = _this$type === void 0 ? 'line' : _this$type,
        tabPosition = this.tabPosition,
        tabBarStyle = this.tabBarStyle,
        hideAdd = this.hideAdd,
        onTabClick = this.onTabClick,
        onPrevClick = this.onPrevClick,
        onNextClick = this.onNextClick,
        animated = this.animated,
        tabBarGutter = this.tabBarGutter;
    var children = Object(props_util["c" /* filterEmpty */])(this.$slots["default"]);
    var tabBarExtraContent = Object(props_util["g" /* getComponentFromProp */])(this, 'tabBarExtraContent');

    var _ref = tabs_typeof(animated) === 'object' ? {
      // eslint-disable-line
      inkBarAnimated: !!animated.inkBar,
      tabPaneAnimated: !!animated.tabPane
    } : {
      inkBarAnimated: animated === undefined || animated,
      tabPaneAnimated: animated === undefined || animated // card tabs should not have animation

    },
        inkBarAnimated = _ref.inkBarAnimated,
        tabPaneAnimated = _ref.tabPaneAnimated;

    if (type !== 'line') {
      tabPaneAnimated = animated === undefined ? false : tabPaneAnimated;
    }

    var cls = (_cls = {}, tabs_defineProperty(_cls, "".concat(prefixCls, "-small"), size === 'small'), tabs_defineProperty(_cls, "".concat(prefixCls, "-large"), size === 'large'), tabs_defineProperty(_cls, "".concat(prefixCls, "-default"), size === 'default'), tabs_defineProperty(_cls, "".concat(prefixCls, "-vertical"), tabPosition === 'left' || tabPosition === 'right'), tabs_defineProperty(_cls, "".concat(prefixCls, "-card"), type.indexOf('card') >= 0), tabs_defineProperty(_cls, "".concat(prefixCls, "-").concat(type), true), tabs_defineProperty(_cls, "".concat(prefixCls, "-no-animation"), !tabPaneAnimated), _cls); // only card type tabs can be added and closed

    var childrenWithClose = [];

    if (type === 'editable-card') {
      childrenWithClose = [];
      children.forEach(function (child, index) {
        var props = Object(props_util["j" /* getOptionProps */])(child);
        var closable = props.closable;
        closable = typeof closable === 'undefined' ? true : closable;
        var closeIcon = closable ? h(components_icon, {
          attrs: {
            type: 'close'
          },
          on: {
            "click": function click(e) {
              return _this.removeTab(child.key, e);
            }
          }
        }) : null;
        childrenWithClose.push(Object(vnode["a" /* cloneElement */])(child, {
          props: {
            tab: h("div", {
              "class": closable ? undefined : "".concat(prefixCls, "-tab-unclosable")
            }, [Object(props_util["g" /* getComponentFromProp */])(child, 'tab'), closeIcon])
          },
          key: child.key || index
        }));
      }); // Add new tab handler

      if (!hideAdd) {
        tabBarExtraContent = h("span", [h(components_icon, {
          attrs: {
            type: 'plus'
          },
          "class": "".concat(prefixCls, "-new-tab"),
          on: {
            "click": this.createNewTab
          }
        }), tabBarExtraContent]);
      }
    }

    tabBarExtraContent = tabBarExtraContent ? h("div", {
      "class": "".concat(prefixCls, "-extra-content")
    }, [tabBarExtraContent]) : null;

    var renderTabBar = function renderTabBar() {
      var scrollableInkTabBarProps = {
        props: {
          inkBarAnimated: inkBarAnimated,
          extraContent: tabBarExtraContent,
          tabBarGutter: tabBarGutter
        },
        on: {
          tabClick: onTabClick,
          prevClick: onPrevClick,
          nextClick: onNextClick
        },
        style: tabBarStyle
      };
      return h(ScrollableInkTabBar, scrollableInkTabBarProps);
    };

    var tabsProps = {
      props: tabs_objectSpread({}, Object(props_util["j" /* getOptionProps */])(this), {
        tabBarPosition: tabPosition,
        renderTabBar: renderTabBar,
        renderTabContent: function renderTabContent() {
          return h(TabContent, {
            attrs: {
              animated: tabPaneAnimated,
              animatedWithMargin: true
            }
          });
        },
        children: childrenWithClose.length > 0 ? childrenWithClose : children,
        __propsSymbol__: Symbol()
      }),
      on: tabs_objectSpread({}, this.$listeners, {
        change: this.handleChange
      }),
      "class": cls
    };
    return h(vc_tabs_src, tabsProps);
  }
});
// CONCATENATED MODULE: ./src/components/tabs/index.js
function components_tabs_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      components_tabs_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function components_tabs_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}




tabs_tabs.TabPane = components_tabs_objectSpread({}, TabPane, {
  name: 'TaTabPane',
  __ANT_TAB_PANE: true
});
tabs_tabs.TabContent = components_tabs_objectSpread({}, TabContent, {
  name: 'TaTabContent'
  /* istanbul ignore next */

});

tabs_tabs.install = function (Vue) {
  Vue.component(tabs_tabs.name, tabs_tabs);
  Vue.component(tabs_tabs.TabPane.name, tabs_tabs.TabPane);
  Vue.component(tabs_tabs.TabContent.name, tabs_tabs.TabContent);
};

/* harmony default export */ var components_tabs = (tabs_tabs);

// CONCATENATED MODULE: ./src/components/grid/Row.jsx
function Row_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Row_typeof = function _typeof(obj) { return typeof obj; }; } else { Row_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Row_typeof(obj); }

function Row_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Row_defineProperty(target, key, source[key]); }); } return target; }

function Row_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




 // matchMedia polyfill for
// https://github.com/WickyNilliams/enquire.js/issues/82

var enquire = null;

if (typeof window !== 'undefined') {
  var matchMediaPolyfill = function matchMediaPolyfill(mediaQuery) {
    return {
      media: mediaQuery,
      matches: false,
      addListener: function addListener() {},
      removeListener: function removeListener() {}
    };
  };

  window.matchMedia = window.matchMedia || matchMediaPolyfill;
  enquire = __webpack_require__(292);
}

var BreakpointMap = vue_types["a" /* default */].shape({
  xs: vue_types["a" /* default */].number,
  sm: vue_types["a" /* default */].number,
  md: vue_types["a" /* default */].number,
  lg: vue_types["a" /* default */].number,
  xl: vue_types["a" /* default */].number,
  xxl: vue_types["a" /* default */].number
}).loose;
var RowProps = {
  gutter: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, BreakpointMap]),
  type: vue_types["a" /* default */].oneOf(['flex']),
  align: vue_types["a" /* default */].oneOf(['top', 'middle', 'bottom']),
  justify: vue_types["a" /* default */].oneOf(['start', 'end', 'center', 'space-around', 'space-between']),
  prefixCls: vue_types["a" /* default */].string
};
var responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];
var responsiveMap = {
  xs: '(max-width: 575px)',
  sm: '(min-width: 576px)',
  md: '(min-width: 768px)',
  lg: '(min-width: 992px)',
  xl: '(min-width: 1200px)',
  xxl: '(min-width: 1600px)'
};
/* harmony default export */ var Row = ({
  name: 'TaRow',
  mixins: [BaseMixin["a" /* default */]],
  props: Row_objectSpread({}, RowProps, {
    gutter: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, BreakpointMap]).def(0)
  }),
  data: function data() {
    return {
      screens: {}
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      Object.keys(responsiveMap).map(function (screen) {
        return enquire.register(responsiveMap[screen], {
          match: function match() {
            if (Row_typeof(_this.gutter) !== 'object') {
              return;
            }

            _this.setState(function (prevState) {
              return {
                screens: Row_objectSpread({}, prevState.screens, Row_defineProperty({}, screen, true))
              };
            });
          },
          unmatch: function unmatch() {
            if (Row_typeof(_this.gutter) !== 'object') {
              return;
            }

            _this.setState(function (prevState) {
              return {
                screens: Row_objectSpread({}, prevState.screens, Row_defineProperty({}, screen, false))
              };
            });
          },
          // Keep a empty destory to avoid triggering unmatch when unregister
          destroy: function destroy() {}
        });
      });
    });
  },
  beforeDestroy: function beforeDestroy() {
    Object.keys(responsiveMap).map(function (screen) {
      return enquire.unregister(responsiveMap[screen]);
    });
  },
  methods: {
    getGutter: function getGutter() {
      var gutter = this.gutter;

      if (Row_typeof(gutter) === 'object') {
        for (var i = 0; i <= responsiveArray.length; i++) {
          var breakpoint = responsiveArray[i];

          if (this.screens[breakpoint] && gutter[breakpoint] !== undefined) {
            return gutter[breakpoint];
          }
        }
      }

      return gutter;
    }
  },
  render: function render() {
    var _classes;

    var h = arguments[0];
    var type = this.type,
        justify = this.justify,
        align = this.align,
        _this$prefixCls = this.prefixCls,
        prefixCls = _this$prefixCls === void 0 ? 'ant-row' : _this$prefixCls,
        $slots = this.$slots;
    var gutter = this.getGutter();
    var classes = (_classes = {}, Row_defineProperty(_classes, prefixCls, !type), Row_defineProperty(_classes, "".concat(prefixCls, "-").concat(type), type), Row_defineProperty(_classes, "".concat(prefixCls, "-").concat(type, "-").concat(justify), type && justify), Row_defineProperty(_classes, "".concat(prefixCls, "-").concat(type, "-").concat(align), type && align), _classes);
    var rowStyle = gutter > 0 ? {
      marginLeft: "".concat(gutter / -2, "px"),
      marginRight: "".concat(gutter / -2, "px")
    } : {};
    var cols = ($slots["default"] || []).map(function (col) {
      if (Object(props_util["r" /* isEmptyElement */])(col)) {
        return null;
      }

      if (Object(props_util["j" /* getOptionProps */])(col) && gutter > 0) {
        return Object(vnode["a" /* cloneElement */])(col, {
          style: Row_objectSpread({
            paddingLeft: "".concat(gutter / 2, "px"),
            paddingRight: "".concat(gutter / 2, "px")
          }, Object(props_util["n" /* getStyle */])(col, true))
        });
      }

      return col;
    });
    return h("div", {
      "class": classes,
      style: rowStyle
    }, [cols]);
  }
});
// CONCATENATED MODULE: ./src/components/grid/Col.jsx
function Col_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Col_defineProperty(target, key, source[key]); }); } return target; }

function Col_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Col_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Col_typeof = function _typeof(obj) { return typeof obj; }; } else { Col_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Col_typeof(obj); }


var stringOrNumber = vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]);
var ColSize = vue_types["a" /* default */].shape({
  span: stringOrNumber,
  order: stringOrNumber,
  offset: stringOrNumber,
  push: stringOrNumber,
  pull: stringOrNumber
}).loose;
var objectOrNumber = vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, ColSize]);
var ColProps = {
  span: objectOrNumber,
  order: objectOrNumber,
  offset: objectOrNumber,
  push: objectOrNumber,
  pull: objectOrNumber,
  xs: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, ColSize]),
  sm: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, ColSize]),
  md: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, ColSize]),
  lg: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, ColSize]),
  xl: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, ColSize]),
  xxl: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, ColSize]),
  prefixCls: vue_types["a" /* default */].string
};
/* harmony default export */ var Col = ({
  props: ColProps,
  name: 'TaCol',
  render: function render() {
    var _this = this,
        _objectSpread3;

    var h = arguments[0];
    var span = this.span,
        order = this.order,
        offset = this.offset,
        push = this.push,
        pull = this.pull,
        _this$prefixCls = this.prefixCls,
        prefixCls = _this$prefixCls === void 0 ? 'ant-col' : _this$prefixCls,
        $slots = this.$slots,
        $attrs = this.$attrs,
        $listeners = this.$listeners;
    var sizeClassObj = {};
    ['xs', 'sm', 'md', 'lg', 'xl', 'xxl'].forEach(function (size) {
      var _objectSpread2;

      var sizeProps = {};

      if (typeof _this[size] === 'number') {
        sizeProps.span = _this[size];
      } else if (Col_typeof(_this[size]) === 'object') {
        sizeProps = _this[size] || {};
      }

      sizeClassObj = Col_objectSpread({}, sizeClassObj, (_objectSpread2 = {}, Col_defineProperty(_objectSpread2, "".concat(prefixCls, "-").concat(size, "-").concat(sizeProps.span), sizeProps.span !== undefined), Col_defineProperty(_objectSpread2, "".concat(prefixCls, "-").concat(size, "-order-").concat(sizeProps.order), sizeProps.order || sizeProps.order === 0), Col_defineProperty(_objectSpread2, "".concat(prefixCls, "-").concat(size, "-offset-").concat(sizeProps.offset), sizeProps.offset || sizeProps.offset === 0), Col_defineProperty(_objectSpread2, "".concat(prefixCls, "-").concat(size, "-push-").concat(sizeProps.push), sizeProps.push || sizeProps.push === 0), Col_defineProperty(_objectSpread2, "".concat(prefixCls, "-").concat(size, "-pull-").concat(sizeProps.pull), sizeProps.pull || sizeProps.pull === 0), _objectSpread2));
    });

    var classes = Col_objectSpread((_objectSpread3 = {}, Col_defineProperty(_objectSpread3, "".concat(prefixCls, "-").concat(span), span !== undefined), Col_defineProperty(_objectSpread3, "".concat(prefixCls, "-order-").concat(order), order), Col_defineProperty(_objectSpread3, "".concat(prefixCls, "-offset-").concat(offset), offset), Col_defineProperty(_objectSpread3, "".concat(prefixCls, "-push-").concat(push), push), Col_defineProperty(_objectSpread3, "".concat(prefixCls, "-pull-").concat(pull), pull), _objectSpread3), sizeClassObj);

    var divProps = {
      on: $listeners,
      attrs: $attrs,
      "class": classes
    };
    return h("div", divProps, [$slots["default"]]);
  }
});
// CONCATENATED MODULE: ./src/components/grid/index.js



// CONCATENATED MODULE: ./src/components/row/index.js

/* istanbul ignore next */

Row.install = function (Vue) {
  Vue.component(Row.name, Row);
};

/* harmony default export */ var components_row = (Row);
// CONCATENATED MODULE: ./src/components/col/index.js

/* istanbul ignore next */

Col.install = function (Vue) {
  Vue.component(Col.name, Col);
};

/* harmony default export */ var components_col = (Col);
// CONCATENATED MODULE: ./src/components/card/Card.jsx


function Card_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










var Card_TabPane = components_tabs.TabPane;
/* harmony default export */ var Card = ({
  name: 'TaCard',
  mixins: [BaseMixin["a" /* default */]],
  props: {
    prefixCls: vue_types["a" /* default */].string.def('ant-card'),
    title: vue_types["a" /* default */].any,
    extra: vue_types["a" /* default */].any,
    bordered: vue_types["a" /* default */].bool.def(true),
    bodyStyle: vue_types["a" /* default */].object,
    headStyle: vue_types["a" /* default */].object,
    loading: vue_types["a" /* default */].bool.def(false),
    hoverable: vue_types["a" /* default */].bool.def(false),
    type: vue_types["a" /* default */].string,
    actions: vue_types["a" /* default */].any,
    tabList: vue_types["a" /* default */].array,
    activeTabKey: vue_types["a" /* default */].string,
    defaultActiveTabKey: vue_types["a" /* default */].string
  },
  data: function data() {
    this.updateWiderPaddingCalled = false;
    return {
      widerPadding: false
    };
  },
  beforeMount: function beforeMount() {
    this.updateWiderPadding = throttleByAnimationFrame(this.updateWiderPadding);
  },
  mounted: function mounted() {
    this.updateWiderPadding();
    this.resizeEvent = addEventListenerWrap(window, 'resize', this.updateWiderPadding);
  },
  beforeDestroy: function beforeDestroy() {
    if (this.resizeEvent) {
      this.resizeEvent.remove();
    }

    this.updateWiderPadding.cancel && this.updateWiderPadding.cancel();
  },
  methods: {
    updateWiderPadding: function updateWiderPadding() {
      var _this = this;

      var cardContainerRef = this.$refs.cardContainerRef;

      if (!cardContainerRef) {
        return;
      } // 936 is a magic card width pixel number indicated by designer


      var WIDTH_BOUNDARY_PX = 936;

      if (cardContainerRef.offsetWidth >= WIDTH_BOUNDARY_PX && !this.widerPadding) {
        this.setState({
          widerPadding: true
        }, function () {
          _this.updateWiderPaddingCalled = true; // first render without css transition
        });
      }

      if (cardContainerRef.offsetWidth < WIDTH_BOUNDARY_PX && this.widerPadding) {
        this.setState({
          widerPadding: false
        }, function () {
          _this.updateWiderPaddingCalled = true; // first render without css transition
        });
      }
    },
    onHandleTabChange: function onHandleTabChange(key) {
      this.$emit('tabChange', key);
    },
    isContainGrid: function isContainGrid() {
      var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var containGrid;
      obj.forEach(function (element) {
        if (element && Object(props_util["l" /* getSlotOptions */])(element).__ANT_CARD_GRID) {
          containGrid = true;
        }
      });
      return containGrid;
    },
    getAction: function getAction(actions) {
      var h = this.$createElement;

      if (!actions || !actions.length) {
        return null;
      }

      var actionList = actions.map(function (action, index) {
        return h("li", {
          style: {
            width: "".concat(100 / actions.length, "%")
          },
          key: "action-".concat(index)
        }, [h("span", [action])]);
      });
      return actionList;
    }
  },
  render: function render() {
    var _classString;

    var h = arguments[0];
    var _this$$props = this.$props,
        _this$$props$prefixCl = _this$$props.prefixCls,
        prefixCls = _this$$props$prefixCl === void 0 ? 'ant-card' : _this$$props$prefixCl,
        _this$$props$headStyl = _this$$props.headStyle,
        headStyle = _this$$props$headStyl === void 0 ? {} : _this$$props$headStyl,
        _this$$props$bodyStyl = _this$$props.bodyStyle,
        bodyStyle = _this$$props$bodyStyl === void 0 ? {} : _this$$props$bodyStyl,
        loading = _this$$props.loading,
        _this$$props$bordered = _this$$props.bordered,
        bordered = _this$$props$bordered === void 0 ? true : _this$$props$bordered,
        type = _this$$props.type,
        tabList = _this$$props.tabList,
        hoverable = _this$$props.hoverable,
        activeTabKey = _this$$props.activeTabKey,
        defaultActiveTabKey = _this$$props.defaultActiveTabKey;
    var $slots = this.$slots,
        $scopedSlots = this.$scopedSlots,
        $listeners = this.$listeners;
    var classString = (_classString = {}, Card_defineProperty(_classString, "".concat(prefixCls), true), Card_defineProperty(_classString, "".concat(prefixCls, "-loading"), loading), Card_defineProperty(_classString, "".concat(prefixCls, "-bordered"), bordered), Card_defineProperty(_classString, "".concat(prefixCls, "-hoverable"), !!hoverable), Card_defineProperty(_classString, "".concat(prefixCls, "-wider-padding"), this.widerPadding), Card_defineProperty(_classString, "".concat(prefixCls, "-padding-transition"), this.updateWiderPaddingCalled), Card_defineProperty(_classString, "".concat(prefixCls, "-contain-grid"), this.isContainGrid($slots["default"])), Card_defineProperty(_classString, "".concat(prefixCls, "-contain-tabs"), tabList && tabList.length), Card_defineProperty(_classString, "".concat(prefixCls, "-type-").concat(type), !!type), _classString);
    var loadingBlockStyle = bodyStyle.padding === 0 || bodyStyle.padding === '0px' ? {
      padding: 24
    } : undefined;
    var loadingBlock = h("div", {
      "class": "".concat(prefixCls, "-loading-content"),
      style: loadingBlockStyle
    }, [h(components_row, {
      attrs: {
        gutter: 8
      }
    }, [h(components_col, {
      attrs: {
        span: 22
      }
    }, [h("div", {
      "class": "".concat(prefixCls, "-loading-block")
    })])]), h(components_row, {
      attrs: {
        gutter: 8
      }
    }, [h(components_col, {
      attrs: {
        span: 8
      }
    }, [h("div", {
      "class": "".concat(prefixCls, "-loading-block")
    })]), h(components_col, {
      attrs: {
        span: 15
      }
    }, [h("div", {
      "class": "".concat(prefixCls, "-loading-block")
    })])]), h(components_row, {
      attrs: {
        gutter: 8
      }
    }, [h(components_col, {
      attrs: {
        span: 6
      }
    }, [h("div", {
      "class": "".concat(prefixCls, "-loading-block")
    })]), h(components_col, {
      attrs: {
        span: 18
      }
    }, [h("div", {
      "class": "".concat(prefixCls, "-loading-block")
    })])]), h(components_row, {
      attrs: {
        gutter: 8
      }
    }, [h(components_col, {
      attrs: {
        span: 13
      }
    }, [h("div", {
      "class": "".concat(prefixCls, "-loading-block")
    })]), h(components_col, {
      attrs: {
        span: 9
      }
    }, [h("div", {
      "class": "".concat(prefixCls, "-loading-block")
    })])]), h(components_row, {
      attrs: {
        gutter: 8
      }
    }, [h(components_col, {
      attrs: {
        span: 4
      }
    }, [h("div", {
      "class": "".concat(prefixCls, "-loading-block")
    })]), h(components_col, {
      attrs: {
        span: 3
      }
    }, [h("div", {
      "class": "".concat(prefixCls, "-loading-block")
    })]), h(components_col, {
      attrs: {
        span: 16
      }
    }, [h("div", {
      "class": "".concat(prefixCls, "-loading-block")
    })])]), h(components_row, {
      attrs: {
        gutter: 8
      }
    }, [h(components_col, {
      attrs: {
        span: 8
      }
    }, [h("div", {
      "class": "".concat(prefixCls, "-loading-block")
    })]), h(components_col, {
      attrs: {
        span: 6
      }
    }, [h("div", {
      "class": "".concat(prefixCls, "-loading-block")
    })]), h(components_col, {
      attrs: {
        span: 8
      }
    }, [h("div", {
      "class": "".concat(prefixCls, "-loading-block")
    })])])]);
    var hasActiveTabKey = activeTabKey !== undefined;
    var tabsProps = {
      props: Card_defineProperty({
        size: 'large'
      }, hasActiveTabKey ? 'activeKey' : 'defaultActiveKey', hasActiveTabKey ? activeTabKey : defaultActiveTabKey),
      on: {
        change: this.onHandleTabChange
      },
      "class": "".concat(prefixCls, "-head-tabs")
    };
    var head;
    var tabs = tabList && tabList.length ? h(components_tabs, tabsProps, [tabList.map(function (item) {
      var temp = item.tab,
          _item$scopedSlots = item.scopedSlots,
          scopedSlots = _item$scopedSlots === void 0 ? {} : _item$scopedSlots;
      var name = scopedSlots.tab;
      var tab = temp !== undefined ? temp : $scopedSlots[name] ? $scopedSlots[name](item) : null;
      return h(Card_TabPane, {
        attrs: {
          tab: tab,
          disabled: item.disabled
        },
        key: item.key
      });
    })]) : null;
    var titleDom = Object(props_util["g" /* getComponentFromProp */])(this, 'title');
    var extraDom = Object(props_util["g" /* getComponentFromProp */])(this, 'extra');

    if (titleDom || extraDom || tabs) {
      head = h("div", {
        "class": "".concat(prefixCls, "-head"),
        style: headStyle
      }, [h("div", {
        "class": "".concat(prefixCls, "-head-wrapper")
      }, [titleDom && h("div", {
        "class": "".concat(prefixCls, "-head-title")
      }, [titleDom]), extraDom && h("div", {
        "class": "".concat(prefixCls, "-extra")
      }, [extraDom])]), tabs]);
    }

    var children = $slots["default"];
    var cover = Object(props_util["g" /* getComponentFromProp */])(this, 'cover');
    var coverDom = cover ? h("div", {
      "class": "".concat(prefixCls, "-cover")
    }, [cover]) : null;
    var body = h("div", {
      "class": "".concat(prefixCls, "-body"),
      style: bodyStyle
    }, [loading ? loadingBlock : children]);
    var actions = Object(props_util["c" /* filterEmpty */])(this.$slots.actions);
    var actionDom = actions && actions.length ? h("ul", {
      "class": "".concat(prefixCls, "-actions")
    }, [this.getAction(actions)]) : null;
    return h("div", babel_helper_vue_jsx_merge_props_default()([{
      "class": classString,
      ref: 'cardContainerRef'
    }, {
      on: Object(es["a" /* default */])($listeners, ['tabChange', 'tab-change'])
    }]), [head, coverDom, children ? body : null, actionDom]);
  }
});
// CONCATENATED MODULE: ./src/components/card/Meta.jsx


function Meta_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/* harmony default export */ var Meta = ({
  name: 'TaCardMeta',
  props: {
    prefixCls: vue_types["a" /* default */].string.def('ant-card'),
    title: vue_types["a" /* default */].any,
    description: vue_types["a" /* default */].any
  },
  render: function render() {
    var h = arguments[0];
    var _this$$props$prefixCl = this.$props.prefixCls,
        prefixCls = _this$$props$prefixCl === void 0 ? 'ant-card' : _this$$props$prefixCl;

    var classString = Meta_defineProperty({}, "".concat(prefixCls, "-meta"), true);

    var avatar = Object(props_util["g" /* getComponentFromProp */])(this, 'avatar');
    var title = Object(props_util["g" /* getComponentFromProp */])(this, 'title');
    var description = Object(props_util["g" /* getComponentFromProp */])(this, 'description');
    var avatarDom = avatar ? h("div", {
      "class": "".concat(prefixCls, "-meta-avatar")
    }, [avatar]) : null;
    var titleDom = title ? h("div", {
      "class": "".concat(prefixCls, "-meta-title")
    }, [title]) : null;
    var descriptionDom = description ? h("div", {
      "class": "".concat(prefixCls, "-meta-description")
    }, [description]) : null;
    var MetaDetail = titleDom || descriptionDom ? h("div", {
      "class": "".concat(prefixCls, "-meta-detail")
    }, [titleDom, descriptionDom]) : null;
    return h("div", babel_helper_vue_jsx_merge_props_default()([{
      on: this.$listeners
    }, {
      "class": classString
    }]), [avatarDom, MetaDetail]);
  }
});
// CONCATENATED MODULE: ./src/components/card/Grid.jsx


function Grid_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/* harmony default export */ var Grid = ({
  name: 'TaCardGrid',
  __ANT_CARD_GRID: true,
  props: {
    prefixCls: vue_types["a" /* default */].string.def('ant-card')
  },
  render: function render() {
    var h = arguments[0];
    var _this$$props$prefixCl = this.$props.prefixCls,
        prefixCls = _this$$props$prefixCl === void 0 ? 'ant-card' : _this$$props$prefixCl;

    var classString = Grid_defineProperty({}, "".concat(prefixCls, "-grid"), true);

    return h("div", babel_helper_vue_jsx_merge_props_default()([{
      on: this.$listeners
    }, {
      "class": classString
    }]), [this.$slots["default"]]);
  }
});
// CONCATENATED MODULE: ./src/components/card/index.js



Card.Meta = Meta;
Card.Grid = Grid;
/* istanbul ignore next */

Card.install = function (Vue) {
  Vue.component(Card.name, Card);
  Vue.component(Meta.name, Meta);
  Vue.component(Grid.name, Grid);
};

/* harmony default export */ var card = (Card);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/color-picker/src/colorPicker.vue?vue&type=template&id=715cc45a&scoped=true&lang=html&
var colorPickervue_type_template_id_715cc45a_scoped_true_lang_html_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"colorPicker",staticClass:"m-colorPicker",on:{"click":function (event) { event.stopPropagation() }}},[(_vm.chooseType=='input')?_c('ta-input',{staticClass:"chooseColor",attrs:{"value":("" + _vm.showColor)},on:{"blur":function($event){_vm.openStatus=false},"focus":function($event){_vm.openStatus = !_vm.disabled}}},[_c('ta-icon',{style:(("color: " + _vm.showColor + ";background-color: " + _vm.showColor + ";font-size:22px;")),attrs:{"slot":"addonAfter","type":"eye"},slot:"addonAfter"})],1):_vm._e(),_vm._v(" "),(_vm.chooseType=='box')?_c('div',{staticClass:"colorBtn",class:{ disabled: _vm.disabled },style:(("background-color: " + _vm.showColor + ";")),on:{"click":function($event){_vm.openStatus = !_vm.disabled}}}):_vm._e(),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.html5Color),expression:"html5Color"}],ref:"html5Color",attrs:{"type":"color"},domProps:{"value":(_vm.html5Color)},on:{"change":function($event){return _vm.updataValue(_vm.html5Color)},"input":function($event){if($event.target.composing){ return; }_vm.html5Color=$event.target.value}}}),_vm._v(" "),_c('div',{staticClass:"box",class:{ open: _vm.openStatus },style:(_vm.panelPositionStyle)},[_c('div',{staticClass:"hd"},[_c('div',{staticClass:"colorView",style:(("background-color: " + _vm.showPanelColor))}),_vm._v(" "),_c('div',{staticClass:"defaultColor",on:{"click":_vm.handleDefaultColor,"mouseover":function($event){_vm.hoveColor = _vm.defaultColor},"mouseout":function($event){_vm.hoveColor = null}}},[_vm._v("默认颜色")])]),_vm._v(" "),_c('div',{staticClass:"bd"},[_c('h3',[_vm._v("主题颜色")]),_vm._v(" "),_c('ul',{staticClass:"tColor"},_vm._l((_vm.tColor),function(color){return _c('li',{key:color,style:({ backgroundColor: color }),on:{"mouseover":function($event){_vm.hoveColor = color},"mouseout":function($event){_vm.hoveColor = null},"click":function($event){return _vm.updataValue(color)}}})}),0),_vm._v(" "),_c('ul',{staticClass:"bColor"},_vm._l((_vm.colorPanel),function(item,index){return _c('li',{key:index},[_c('ul',_vm._l((item),function(color){return _c('li',{key:color,style:({ backgroundColor: color }),on:{"mouseover":function($event){_vm.hoveColor = color},"mouseout":function($event){_vm.hoveColor = null},"click":function($event){return _vm.updataValue(color)}}})}),0)])}),0),_vm._v(" "),_c('h3',[_vm._v("标准颜色")]),_vm._v(" "),_c('ul',{staticClass:"tColor"},_vm._l((_vm.bColor),function(color){return _c('li',{key:color,style:({ backgroundColor: color }),on:{"mouseover":function($event){_vm.hoveColor = color},"mouseout":function($event){_vm.hoveColor = null},"click":function($event){return _vm.updataValue(color)}}})}),0),_vm._v(" "),_c('h3',{on:{"click":_vm.triggerHtml5Color}},[_vm._v("更多颜色...")])])])],1)}
var staticRenderFns = []


// CONCATENATED MODULE: ./src/components/color-picker/src/colorPicker.vue?vue&type=template&id=715cc45a&scoped=true&lang=html&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--1!./node_modules/babel-loader/lib??ref--12-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/color-picker/src/colorPicker.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ var colorPickervue_type_script_lang_js_ = ({
  name: 'TaColorPicker',
  props: {
    chooseType: {
      type: String,
      "default": 'input' // input 输入框模式选择, box 小方块显示颜色选择

    },
    // 当前颜色值
    value: {
      type: String
    },
    // 默认颜色
    defaultColor: {
      type: String,
      "default": ''
    },
    // 禁用状态
    disabled: {
      type: Boolean,
      "default": false
    },
    panelPosition: {
      type: String,
      "default": 'left' //left || right

    }
  },
  data: function data() {
    return {
      // 面板打开状态
      openStatus: false,
      // 鼠标经过的颜色块
      hoveColor: null,
      // 主题颜色
      tColor: ['#000', '#fff', '#eeece1', '#1e497b', '#4e81bb', '#e2534d', '#9aba60', '#8165a0', '#47acc5', '#f9974c'],
      // 颜色面板
      colorConfig: [['#7f7f7f', '#f2f2f2'], ['#0d0d0d', '#808080'], ['#1c1a10', '#ddd8c3'], ['#0e243d', '#c6d9f0'], ['#233f5e', '#dae5f0'], ['#632623', '#f2dbdb'], ['#4d602c', '#eaf1de'], ['#3f3150', '#e6e0ec'], ['#1e5867', '#d9eef3'], ['#99490f', '#fee9da']],
      // 标准颜色
      bColor: ['#c21401', '#ff1e02', '#ffc12a', '#ffff3a', '#90cf5b', '#00af57', '#00afee', '#0071be', '#00215f', '#72349d'],
      html5Color: this.value
    };
  },
  computed: {
    //颜色面板位置
    panelPositionStyle: function panelPositionStyle() {
      if (this.panelPosition == 'left') {
        return {
          left: '0px'
        };
      } else {
        return {
          right: '0px'
        };
      }
    },
    // 显示面板颜色
    showPanelColor: function showPanelColor() {
      if (this.hoveColor) {
        return this.hoveColor;
      } else {
        return this.showColor;
      }
    },
    // 显示颜色
    showColor: function showColor() {
      if (this.value) {
        return this.value;
      } else {
        return this.defaultColor;
      }
    },
    // 颜色面板
    colorPanel: function colorPanel() {
      var colorArr = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.colorConfig[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var color = _step.value;
          colorArr.push(this.gradient(color[1], color[0], 5));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return colorArr;
    }
  },
  methods: {
    triggerHtml5Color: function triggerHtml5Color() {
      this.$refs.html5Color.click();
    },
    // 更新组件的值 value
    updataValue: function updataValue(value) {
      this.$emit('input', value);
      this.$emit('change', value);
      this.openStatus = false;
    },
    // 设置默认颜色
    handleDefaultColor: function handleDefaultColor() {
      this.updataValue(this.defaultColor);
    },
    // 格式化 hex 颜色值
    parseColor: function parseColor(hexStr) {
      if (hexStr.length === 4) {
        hexStr = '#' + hexStr[1] + hexStr[1] + hexStr[2] + hexStr[2] + hexStr[3] + hexStr[3];
      } else {
        return hexStr;
      }
    },
    // RGB 颜色 转 HEX 颜色
    rgbToHex: function rgbToHex(r, g, b) {
      var hex = (r << 16 | g << 8 | b).toString(16);
      return '#' + new Array(Math.abs(hex.length - 7)).join('0') + hex;
    },
    // HEX 转 RGB 颜色
    hexToRgb: function hexToRgb(hex) {
      hex = this.parseColor(hex);
      var rgb = [];

      for (var i = 1; i < 7; i += 2) {
        rgb.push(parseInt('0x' + hex.slice(i, i + 2)));
      }

      return rgb;
    },
    // 计算渐变过渡颜色
    gradient: function gradient(startColor, endColor, step) {
      // 讲 hex 转换为 rgb
      var sColor = this.hexToRgb(startColor);
      var eColor = this.hexToRgb(endColor); // 计算R\G\B每一步的差值

      var rStep = (eColor[0] - sColor[0]) / step;
      var gStep = (eColor[1] - sColor[1]) / step;
      var bStep = (eColor[2] - sColor[2]) / step;
      var gradientColorArr = []; // 计算每一步的hex值

      for (var i = 0; i < step; i++) {
        gradientColorArr.push(this.rgbToHex(parseInt(rStep * i + sColor[0]), parseInt(gStep * i + sColor[1]), parseInt(bStep * i + sColor[2])));
      }

      return gradientColorArr;
    }
  },
  mounted: function mounted() {
    var _this = this; // 点击页面上其他地方，关闭弹窗


    document.onclick = function (e) {
      _this.openStatus = false;
    };
  }
});
// CONCATENATED MODULE: ./src/components/color-picker/src/colorPicker.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_colorPickervue_type_script_lang_js_ = (colorPickervue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/components/color-picker/src/colorPicker.vue?vue&type=style&index=0&id=715cc45a&lang=scss&scoped=true&
var colorPickervue_type_style_index_0_id_715cc45a_lang_scss_scoped_true_ = __webpack_require__(583);

// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(18);

// CONCATENATED MODULE: ./src/components/color-picker/src/colorPicker.vue






/* normalize component */

var colorPicker_component = Object(componentNormalizer["a" /* default */])(
  src_colorPickervue_type_script_lang_js_,
  colorPickervue_type_template_id_715cc45a_scoped_true_lang_html_render,
  staticRenderFns,
  false,
  null,
  "715cc45a",
  null
  
)

/* harmony default export */ var colorPicker = (colorPicker_component.exports);
// CONCATENATED MODULE: ./src/components/color-picker/index.js

/* istanbul ignore next */

colorPicker.install = function (Vue) {
  Vue.component(colorPicker.name, colorPicker);
};

/* harmony default export */ var color_picker = (colorPicker);
// CONCATENATED MODULE: ./src/components/_util/openAnimation.js



function animate(node, show, done) {
  var height;
  var requestAnimationFrameId;
  return Object(css_animation["a" /* default */])(node, 'ant-motion-collapse', {
    start: function start() {
      if (!show) {
        node.style.height = "".concat(node.offsetHeight, "px");
        node.style.opacity = 1;
      } else {
        height = node.offsetHeight;
        node.style.height = 0;
        node.style.opacity = 0;
      }
    },
    active: function active() {
      if (requestAnimationFrameId) {
        raf_default.a.cancel(requestAnimationFrameId);
      }

      requestAnimationFrameId = raf_default()(function () {
        node.style.height = "".concat(show ? height : 0, "px");
        node.style.opacity = show ? 1 : 0;
      });
    },
    end: function end() {
      if (requestAnimationFrameId) {
        raf_default.a.cancel(requestAnimationFrameId);
      }

      node.style.height = '';
      node.style.opacity = '';
      done();
    }
  });
}

var openAnimation_animation = {
  enter: function enter(node, done) {
    return animate(node, true, done);
  },
  leave: function leave(node, done) {
    return animate(node, false, done);
  }
};
/* harmony default export */ var _util_openAnimation = (openAnimation_animation);
// CONCATENATED MODULE: ./src/components/vc-collapse/src/PanelContent.jsx
function PanelContent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/* harmony default export */ var PanelContent = ({
  name: 'PanelContent',
  props: {
    prefixCls: vue_types["a" /* default */].string,
    isActive: vue_types["a" /* default */].bool,
    destroyInactivePanel: vue_types["a" /* default */].bool,
    forceRender: vue_types["a" /* default */].bool,
    role: vue_types["a" /* default */].any
  },
  data: function data() {
    return {
      _isActive: undefined
    };
  },
  render: function render() {
    var _contentCls;

    var h = arguments[0];
    this._isActive = this.forceRender || this._isActive || this.isActive;

    if (!this._isActive) {
      return null;
    }

    var _this$$props = this.$props,
        prefixCls = _this$$props.prefixCls,
        isActive = _this$$props.isActive,
        destroyInactivePanel = _this$$props.destroyInactivePanel,
        forceRender = _this$$props.forceRender,
        role = _this$$props.role;
    var $slots = this.$slots;
    var contentCls = (_contentCls = {}, PanelContent_defineProperty(_contentCls, "".concat(prefixCls, "-content"), true), PanelContent_defineProperty(_contentCls, "".concat(prefixCls, "-content-active"), isActive), _contentCls);
    var child = !forceRender && !isActive && destroyInactivePanel ? null : h("div", {
      "class": "".concat(prefixCls, "-content-box")
    }, [$slots["default"]]);
    return h("div", {
      "class": contentCls,
      attrs: {
        role: role
      }
    }, [child]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-collapse/src/commonProps.js

var collapseProps = {
  prefixCls: vue_types["a" /* default */].string,
  activeKey: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string)]),
  defaultActiveKey: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string)]),
  accordion: vue_types["a" /* default */].bool,
  destroyInactivePanel: vue_types["a" /* default */].bool,
  bordered: vue_types["a" /* default */].bool,
  expandIcon: vue_types["a" /* default */].func,
  openAnimation: vue_types["a" /* default */].object
};
var panelProps = {
  openAnimation: vue_types["a" /* default */].object,
  prefixCls: vue_types["a" /* default */].string,
  header: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number, vue_types["a" /* default */].node]),
  headerClass: vue_types["a" /* default */].string,
  showArrow: vue_types["a" /* default */].bool,
  isActive: vue_types["a" /* default */].bool,
  destroyInactivePanel: vue_types["a" /* default */].bool,
  disabled: vue_types["a" /* default */].bool,
  accordion: vue_types["a" /* default */].bool,
  forceRender: vue_types["a" /* default */].bool,
  expandIcon: vue_types["a" /* default */].func
};

// CONCATENATED MODULE: ./src/components/vc-collapse/src/Panel.jsx
function Panel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Panel_defineProperty(target, key, source[key]); }); } return target; }

function Panel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





/* harmony default export */ var Panel = ({
  name: 'Panel',
  props: Object(props_util["q" /* initDefaultProps */])(panelProps, {
    showArrow: true,
    isActive: false,
    destroyInactivePanel: false,
    headerClass: '',
    forceRender: false
  }),
  methods: {
    handleItemClick: function handleItemClick() {
      this.$emit('itemClick');
    },
    handleKeyPress: function handleKeyPress(e) {
      if (e.key === 'Enter' || e.keyCode === 13 || e.which === 13) {
        this.handleItemClick();
      }
    }
  },
  render: function render() {
    var _headerCls, _itemCls;

    var h = arguments[0];
    var _this$$props = this.$props,
        prefixCls = _this$$props.prefixCls,
        headerClass = _this$$props.headerClass,
        isActive = _this$$props.isActive,
        showArrow = _this$$props.showArrow,
        destroyInactivePanel = _this$$props.destroyInactivePanel,
        disabled = _this$$props.disabled,
        openAnimation = _this$$props.openAnimation,
        accordion = _this$$props.accordion,
        forceRender = _this$$props.forceRender,
        expandIcon = _this$$props.expandIcon;
    var $slots = this.$slots;
    var transitionProps = {
      props: Object.assign({
        appear: true,
        css: false
      }),
      on: Panel_objectSpread({}, openAnimation)
    };
    var headerCls = (_headerCls = {}, Panel_defineProperty(_headerCls, "".concat(prefixCls, "-header"), true), Panel_defineProperty(_headerCls, headerClass, headerClass), _headerCls);
    var header = Object(props_util["g" /* getComponentFromProp */])(this, 'header');
    var itemCls = (_itemCls = {}, Panel_defineProperty(_itemCls, "".concat(prefixCls, "-item"), true), Panel_defineProperty(_itemCls, "".concat(prefixCls, "-item-active"), isActive), Panel_defineProperty(_itemCls, "".concat(prefixCls, "-item-disabled"), disabled), _itemCls);
    var icon = null;

    if (showArrow && typeof expandIcon === 'function') {
      icon = Object(vnode["a" /* cloneElement */])(expandIcon, Panel_objectSpread({}, this.$props));
    }

    return h("div", {
      "class": itemCls,
      attrs: {
        role: 'tablist'
      }
    }, [h("div", {
      "class": headerCls,
      on: {
        "click": this.handleItemClick.bind(this),
        "keypress": this.handleKeyPress
      },
      attrs: {
        role: accordion ? 'tab' : 'button',
        tabIndex: disabled ? -1 : 0,
        "aria-expanded": isActive
      }
    }, [showArrow && (icon || h("i", {
      "class": 'arrow'
    })), header]), h("transition", transitionProps, [h(PanelContent, {
      directives: [{
        name: "show",
        value: isActive
      }],
      attrs: {
        prefixCls: prefixCls,
        isActive: isActive,
        destroyInactivePanel: destroyInactivePanel,
        forceRender: forceRender,
        role: accordion ? 'tabpanel' : null
      }
    }, [$slots["default"]])])]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-collapse/src/openAnimationFactory.js


function openAnimationFactory_animate(node, show, transitionName, done) {
  var height;
  return Object(css_animation["a" /* default */])(node, transitionName, {
    start: function start() {
      if (!show) {
        node.style.height = "".concat(node.offsetHeight, "px");
      } else {
        height = node.offsetHeight;
        node.style.height = 0;
      }
    },
    active: function active() {
      node.style.height = "".concat(show ? height : 0, "px");
    },
    end: function end() {
      node.style.height = '';
      done();
    }
  });
}

function openAnimationFactory_animation(prefixCls) {
  return {
    enter: function enter(node, done) {
      return openAnimationFactory_animate(node, true, "".concat(prefixCls, "-anim"), done);
    },
    leave: function leave(node, done) {
      return openAnimationFactory_animate(node, false, "".concat(prefixCls, "-anim"), done);
    }
  };
}

/* harmony default export */ var openAnimationFactory = (openAnimationFactory_animation);
// CONCATENATED MODULE: ./src/components/vc-collapse/src/Collapse.jsx
function Collapse_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Collapse_defineProperty(target, key, source[key]); }); } return target; }

function Collapse_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Collapse_toConsumableArray(arr) { return Collapse_arrayWithoutHoles(arr) || Collapse_iterableToArray(arr) || Collapse_nonIterableSpread(); }

function Collapse_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function Collapse_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function Collapse_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }







function _toArray(activeKey) {
  var currentActiveKey = activeKey;

  if (!Array.isArray(currentActiveKey)) {
    currentActiveKey = currentActiveKey ? [currentActiveKey] : [];
  }

  return currentActiveKey;
}

/* harmony default export */ var Collapse = ({
  name: 'Collapse',
  mixins: [BaseMixin["a" /* default */]],
  model: {
    prop: 'activeKey',
    event: 'change'
  },
  props: Object(props_util["q" /* initDefaultProps */])(collapseProps, {
    prefixCls: 'rc-collapse',
    accordion: false,
    destroyInactivePanel: false
  }),
  data: function data() {
    var _this$$props = this.$props,
        activeKey = _this$$props.activeKey,
        defaultActiveKey = _this$$props.defaultActiveKey,
        openAnimation = _this$$props.openAnimation,
        prefixCls = _this$$props.prefixCls;
    var currentActiveKey = defaultActiveKey;

    if (Object(props_util["p" /* hasProp */])(this, 'activeKey')) {
      currentActiveKey = activeKey;
    }

    var currentOpenAnimations = openAnimation || openAnimationFactory(prefixCls);
    return {
      currentOpenAnimations: currentOpenAnimations,
      stateActiveKey: _toArray(currentActiveKey)
    };
  },
  methods: {
    onClickItem: function onClickItem(key) {
      var activeKey = this.stateActiveKey;

      if (this.accordion) {
        activeKey = activeKey[0] === key ? [] : [key];
      } else {
        activeKey = Collapse_toConsumableArray(activeKey);
        var index = activeKey.indexOf(key);
        var isActive = index > -1;

        if (isActive) {
          // remove active state
          activeKey.splice(index, 1);
        } else {
          activeKey.push(key);
        }
      }

      this.setActiveKey(activeKey);
    },
    getItems: function getItems() {
      var _this = this;

      var activeKey = this.stateActiveKey;
      var _this$$props2 = this.$props,
          prefixCls = _this$$props2.prefixCls,
          accordion = _this$$props2.accordion,
          destroyInactivePanel = _this$$props2.destroyInactivePanel,
          expandIcon = _this$$props2.expandIcon;
      var newChildren = [];
      this.$slots["default"].forEach(function (child, index) {
        if (Object(props_util["r" /* isEmptyElement */])(child)) return;

        var _getPropsData = Object(props_util["k" /* getPropsData */])(child),
            header = _getPropsData.header,
            headerClass = _getPropsData.headerClass,
            disabled = _getPropsData.disabled;

        var isActive = false;
        var key = child.key || String(index);

        if (accordion) {
          isActive = activeKey[0] === key;
        } else {
          isActive = activeKey.indexOf(key) > -1;
        }

        var panelEvents = {};

        if (!disabled && disabled !== '') {
          panelEvents = {
            itemClick: function itemClick() {
              _this.onClickItem(key);
            }
          };
        }

        var props = {
          props: {
            header: header,
            headerClass: headerClass,
            isActive: isActive,
            prefixCls: prefixCls,
            destroyInactivePanel: destroyInactivePanel,
            openAnimation: _this.currentOpenAnimations,
            accordion: accordion,
            expandIcon: expandIcon
          },
          on: Collapse_objectSpread({}, panelEvents)
        };
        newChildren.push(Object(vnode["a" /* cloneElement */])(child, props));
      });
      return newChildren;
    },
    setActiveKey: function setActiveKey(activeKey) {
      this.setState({
        stateActiveKey: activeKey
      });
      this.$emit('change', this.accordion ? activeKey[0] : activeKey);
    }
  },
  watch: {
    activeKey: function activeKey(val) {
      this.setState({
        stateActiveKey: _toArray(val)
      });
    },
    openAnimation: function openAnimation(val) {
      this.setState({
        currentOpenAnimations: val
      });
    }
  },
  render: function render() {
    var h = arguments[0];
    var _this$$props3 = this.$props,
        prefixCls = _this$$props3.prefixCls,
        accordion = _this$$props3.accordion;

    var collapseClassName = Collapse_defineProperty({}, prefixCls, true);

    return h("div", {
      "class": collapseClassName,
      attrs: {
        role: accordion ? 'tablist' : null
      }
    }, [this.getItems()]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-collapse/index.js
// based on rc-collapse 1.10.0



Collapse.Panel = Panel;

/* harmony default export */ var vc_collapse = (Collapse);
// CONCATENATED MODULE: ./src/components/collapse/Collapse.jsx
function collapse_Collapse_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { collapse_Collapse_defineProperty(target, key, source[key]); }); } return target; }

function collapse_Collapse_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





/* harmony default export */ var collapse_Collapse = ({
  name: 'TaCollapse',
  model: {
    prop: 'activeKey',
    event: 'change'
  },
  props: Object(props_util["q" /* initDefaultProps */])(collapseProps, {
    prefixCls: 'ant-collapse',
    bordered: true,
    openAnimation: _util_openAnimation
  }),
  render: function render() {
    var h = arguments[0];
    var prefixCls = this.prefixCls,
        bordered = this.bordered,
        $listeners = this.$listeners;

    var collapseClassName = collapse_Collapse_defineProperty({}, "".concat(prefixCls, "-borderless"), !bordered);

    var rcCollapeProps = {
      props: collapse_Collapse_objectSpread({}, Object(props_util["j" /* getOptionProps */])(this)),
      "class": collapseClassName,
      on: $listeners
    };
    return h(vc_collapse, rcCollapeProps, [this.$slots["default"]]);
  }
});
// CONCATENATED MODULE: ./src/components/collapse/CollapsePanel.jsx
function CollapsePanel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { CollapsePanel_defineProperty(target, key, source[key]); }); } return target; }

function CollapsePanel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/* harmony default export */ var CollapsePanel = ({
  name: 'TaCollapsePanel',
  props: CollapsePanel_objectSpread({}, panelProps),
  render: function render() {
    var h = arguments[0];
    var prefixCls = this.prefixCls,
        _this$showArrow = this.showArrow,
        showArrow = _this$showArrow === void 0 ? true : _this$showArrow,
        $listeners = this.$listeners;

    var collapsePanelClassName = CollapsePanel_defineProperty({}, "".concat(prefixCls, "-no-arrow"), !showArrow);

    var rcCollapePanelProps = {
      props: CollapsePanel_objectSpread({}, Object(props_util["j" /* getOptionProps */])(this)),
      "class": collapsePanelClassName,
      on: $listeners
    };
    var header = Object(props_util["g" /* getComponentFromProp */])(this, 'header');
    return h(vc_collapse.Panel, rcCollapePanelProps, [this.$slots["default"], header ? h("template", {
      slot: 'header'
    }, [header]) : null]);
  }
});
// CONCATENATED MODULE: ./src/components/collapse/index.js


collapse_Collapse.Panel = CollapsePanel;
/* istanbul ignore next */

collapse_Collapse.install = function (Vue) {
  Vue.component(collapse_Collapse.name, collapse_Collapse);
  Vue.component(CollapsePanel.name, CollapsePanel);
};

/* harmony default export */ var collapse = (collapse_Collapse);
// CONCATENATED MODULE: ./src/components/carousel/index.jsx


function carousel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { carousel_defineProperty(target, key, source[key]); }); } return target; }

function carousel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



 // matchMedia polyfill for
// https://github.com/WickyNilliams/enquire.js/issues/82

if (typeof window !== 'undefined') {
  var carousel_matchMediaPolyfill = function matchMediaPolyfill(mediaQuery) {
    return {
      media: mediaQuery,
      matches: false,
      addListener: function addListener() {},
      removeListener: function removeListener() {}
    };
  };

  window.matchMedia = window.matchMedia || carousel_matchMediaPolyfill;
} // Use require over import (will be lifted up)
// make sure matchMedia polyfill run before require('vc-slick')
// Fix https://github.com/ant-design/ant-design/issues/6560
// Fix https://github.com/ant-design/ant-design/issues/3308


var SlickCarousel = __webpack_require__(974)["default"];

var CarouselEffect = vue_types["a" /* default */].oneOf(['scrollx', 'fade']); // Carousel

var CarouselProps = {
  effect: CarouselEffect,
  dots: vue_types["a" /* default */].bool,
  vertical: vue_types["a" /* default */].bool,
  autoplay: vue_types["a" /* default */].bool,
  easing: vue_types["a" /* default */].string,
  beforeChange: vue_types["a" /* default */].func,
  afterChange: vue_types["a" /* default */].func,
  // style: PropTypes.React.CSSProperties,
  prefixCls: vue_types["a" /* default */].string,
  accessibility: vue_types["a" /* default */].bool,
  nextArrow: vue_types["a" /* default */].any,
  prevArrow: vue_types["a" /* default */].any,
  pauseOnHover: vue_types["a" /* default */].bool,
  // className: PropTypes.string,
  adaptiveHeight: vue_types["a" /* default */].bool,
  arrows: vue_types["a" /* default */].bool,
  autoplaySpeed: vue_types["a" /* default */].number,
  centerMode: vue_types["a" /* default */].bool,
  centerPadding: vue_types["a" /* default */].string,
  cssEase: vue_types["a" /* default */].string,
  dotsClass: vue_types["a" /* default */].string,
  draggable: vue_types["a" /* default */].bool,
  fade: vue_types["a" /* default */].bool,
  focusOnSelect: vue_types["a" /* default */].bool,
  infinite: vue_types["a" /* default */].bool,
  initialSlide: vue_types["a" /* default */].number,
  lazyLoad: vue_types["a" /* default */].bool,
  rtl: vue_types["a" /* default */].bool,
  slide: vue_types["a" /* default */].string,
  slidesToShow: vue_types["a" /* default */].number,
  slidesToScroll: vue_types["a" /* default */].number,
  speed: vue_types["a" /* default */].number,
  swipe: vue_types["a" /* default */].bool,
  swipeToSlide: vue_types["a" /* default */].bool,
  touchMove: vue_types["a" /* default */].bool,
  touchThreshold: vue_types["a" /* default */].number,
  variableWidth: vue_types["a" /* default */].bool,
  useCSS: vue_types["a" /* default */].bool,
  slickGoTo: vue_types["a" /* default */].number
};
var Carousel = {
  name: 'TaCarousel',
  props: Object(props_util["q" /* initDefaultProps */])(CarouselProps, {
    dots: true,
    arrows: false,
    prefixCls: 'ant-carousel',
    draggable: false
  }),
  // innerSlider: any;
  // private slick: any;
  beforeMount: function beforeMount() {
    this.onWindowResized = debounce_default()(this.onWindowResized, 500, {
      leading: false
    });
  },
  mounted: function mounted() {
    var autoplay = this.autoplay;

    if (autoplay) {
      window.addEventListener('resize', this.onWindowResized);
    } // https://github.com/ant-design/ant-design/issues/7191


    this.innerSlider = this.$refs.slick && this.$refs.slick.innerSlider;
  },
  beforeDestroy: function beforeDestroy() {
    var autoplay = this.autoplay;

    if (autoplay) {
      window.removeEventListener('resize', this.onWindowResized);
      this.onWindowResized.cancel();
    }
  },
  methods: {
    onWindowResized: function onWindowResized() {
      // Fix https://github.com/ant-design/ant-design/issues/2550
      var autoplay = this.autoplay;

      if (autoplay && this.$refs.slick && this.$refs.slick.innerSlider && this.$refs.slick.innerSlider.autoPlay) {
        this.$refs.slick.innerSlider.autoPlay();
      }
    },
    next: function next() {
      this.$refs.slick.slickNext();
    },
    prev: function prev() {
      this.$refs.slick.slickPrev();
    },
    goTo: function goTo(slide) {
      this.$refs.slick.slickGoTo(slide);
    }
  },
  render: function render() {
    var h = arguments[0];

    var props = carousel_objectSpread({}, this.$props);

    var $slots = this.$slots,
        $listeners = this.$listeners;

    if (props.effect === 'fade') {
      props.fade = true;
    }

    var className = props.prefixCls;

    if (props.vertical) {
      className = "".concat(className, " ").concat(className, "-vertical");
    }

    var SlickCarouselProps = {
      props: carousel_objectSpread({}, props, {
        nextArrow: Object(props_util["g" /* getComponentFromProp */])(this, 'nextArrow'),
        prevArrow: Object(props_util["g" /* getComponentFromProp */])(this, 'prevArrow')
      }),
      on: $listeners,
      scopedSlots: this.$scopedSlots
    };
    return h("div", {
      "class": className
    }, [h(SlickCarousel, babel_helper_vue_jsx_merge_props_default()([{
      ref: 'slick'
    }, SlickCarouselProps]), [Object(props_util["c" /* filterEmpty */])($slots["default"])])]);
  }
};
/* istanbul ignore next */

Carousel.install = function (Vue) {
  Vue.component(Carousel.name, Carousel);
};

/* harmony default export */ var carousel = (Carousel);
// EXTERNAL MODULE: ./node_modules/array-tree-filter/lib/index.js
var array_tree_filter_lib = __webpack_require__(88);
var array_tree_filter_lib_default = /*#__PURE__*/__webpack_require__.n(array_tree_filter_lib);

// CONCATENATED MODULE: ./src/components/vc-cascader/Menus.jsx



/* harmony default export */ var Menus = ({
  mixins: [BaseMixin["a" /* default */]],
  props: {
    value: vue_types["a" /* default */].array.def([]),
    activeValue: vue_types["a" /* default */].array.def([]),
    options: vue_types["a" /* default */].array.isRequired,
    prefixCls: vue_types["a" /* default */].string.def('rc-cascader-menus'),
    expandTrigger: vue_types["a" /* default */].string.def('click'),
    // onSelect: PropTypes.func,
    visible: vue_types["a" /* default */].bool.def(false),
    dropdownMenuColumnStyle: vue_types["a" /* default */].object,
    defaultFieldNames: vue_types["a" /* default */].object,
    fieldNames: vue_types["a" /* default */].object
  },
  data: function data() {
    this.menuItems = {};
    return {};
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.scrollActiveItemToView();
    });
  },
  watch: {
    visible: function visible(val) {
      var _this2 = this;

      if (val) {
        this.$nextTick(function () {
          _this2.scrollActiveItemToView();
        });
      }
    }
  },
  methods: {
    getFieldName: function getFieldName(name) {
      var _this$$props = this.$props,
          fieldNames = _this$$props.fieldNames,
          defaultFieldNames = _this$$props.defaultFieldNames; // 防止只设置单个属性的名字

      return fieldNames[name] || defaultFieldNames[name];
    },
    getOption: function getOption(option, menuIndex) {
      var _this3 = this;

      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          expandTrigger = this.expandTrigger;

      var onSelect = function onSelect(e) {
        _this3.__emit('select', option, menuIndex, e);
      };

      var expandProps = {
        attrs: {},
        on: {
          click: onSelect
        },
        key: option[this.getFieldName('value')]
      };
      var menuItemCls = "".concat(prefixCls, "-menu-item");
      var hasChildren = option[this.getFieldName('children')] && option[this.getFieldName('children')].length > 0;

      if (hasChildren || option.isLeaf === false) {
        menuItemCls += " ".concat(prefixCls, "-menu-item-expand");
      }

      if (expandTrigger === 'hover' && hasChildren) {
        expandProps.on = {
          mouseenter: this.delayOnSelect.bind(this, onSelect),
          mouseleave: this.delayOnSelect.bind(this),
          click: onSelect
        };
      }

      if (this.isActiveOption(option, menuIndex)) {
        menuItemCls += " ".concat(prefixCls, "-menu-item-active");
        expandProps.ref = this.getMenuItemRef(menuIndex);
      }

      if (option.disabled) {
        menuItemCls += " ".concat(prefixCls, "-menu-item-disabled");
      }

      if (option.loading) {
        menuItemCls += " ".concat(prefixCls, "-menu-item-loading");
      }

      var title = '';

      if (option.title) {
        title = option.title;
      } else if (typeof option[this.getFieldName('label')] === 'string') {
        title = option[this.getFieldName('label')];
      }

      expandProps.attrs.title = title;
      expandProps["class"] = menuItemCls;
      return h("li", expandProps, [option[this.getFieldName('label')]]);
    },
    getActiveOptions: function getActiveOptions(values) {
      var _this4 = this;

      var activeValue = values || this.activeValue;
      var options = this.options;
      return array_tree_filter_lib_default()(options, function (o, level) {
        return o[_this4.getFieldName('value')] === activeValue[level];
      }, {
        childrenKeyName: this.getFieldName('children')
      });
    },
    getShowOptions: function getShowOptions() {
      var _this5 = this;

      var options = this.options;
      var result = this.getActiveOptions().map(function (activeOption) {
        return activeOption[_this5.getFieldName('children')];
      }).filter(function (activeOption) {
        return !!activeOption;
      });
      result.unshift(options);
      return result;
    },
    delayOnSelect: function delayOnSelect(onSelect) {
      var _this6 = this;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (this.delayTimer) {
        clearTimeout(this.delayTimer);
        this.delayTimer = null;
      }

      if (typeof onSelect === 'function') {
        this.delayTimer = setTimeout(function () {
          onSelect(args);
          _this6.delayTimer = null;
        }, 150);
      }
    },
    scrollActiveItemToView: function scrollActiveItemToView() {
      // scroll into view
      var optionsLength = this.getShowOptions().length;

      for (var i = 0; i < optionsLength; i++) {
        var itemComponent = this.$refs["menuItems_".concat(i)];

        if (itemComponent) {
          var target = itemComponent;
          target.parentNode.scrollTop = target.offsetTop;
        }
      }
    },
    isActiveOption: function isActiveOption(option, menuIndex) {
      var _this$activeValue = this.activeValue,
          activeValue = _this$activeValue === void 0 ? [] : _this$activeValue;
      return activeValue[menuIndex] === option[this.getFieldName('value')];
    },
    getMenuItemRef: function getMenuItemRef(index) {
      return "menuItems_".concat(index);
    }
  },
  render: function render() {
    var _this7 = this;

    var h = arguments[0];
    var prefixCls = this.prefixCls,
        dropdownMenuColumnStyle = this.dropdownMenuColumnStyle;
    return h("div", [this.getShowOptions().map(function (options, menuIndex) {
      return h("ul", {
        "class": "".concat(prefixCls, "-menu"),
        key: menuIndex,
        style: dropdownMenuColumnStyle
      }, [options.map(function (option) {
        return _this7.getOption(option, menuIndex);
      })]);
    })]);
  }
});
// EXTERNAL MODULE: ./node_modules/shallow-equal/arrays/index.js
var arrays = __webpack_require__(408);
var arrays_default = /*#__PURE__*/__webpack_require__.n(arrays);

// CONCATENATED MODULE: ./src/components/vc-cascader/Cascader.jsx
function Cascader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Cascader_defineProperty(target, key, source[key]); }); } return target; }

function Cascader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Cascader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Cascader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Cascader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function Cascader_toConsumableArray(arr) { return Cascader_arrayWithoutHoles(arr) || Cascader_iterableToArray(arr) || Cascader_nonIterableSpread(); }

function Cascader_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function Cascader_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function Cascader_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }










var Cascader_BUILT_IN_PLACEMENTS = {
  bottomLeft: {
    points: ['tl', 'bl'],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ['bl', 'tl'],
    offset: [0, -4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomRight: {
    points: ['tr', 'br'],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topRight: {
    points: ['br', 'tr'],
    offset: [0, -4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  }
};
/* harmony default export */ var Cascader = ({
  props: {
    value: vue_types["a" /* default */].array,
    defaultValue: vue_types["a" /* default */].array,
    options: vue_types["a" /* default */].array.def([]).isRequired,
    url: vue_types["a" /* default */].string.def(''),
    treeId: vue_types["a" /* default */].string.def(''),
    // onChange: PropTypes.func,
    // onPopupVisibleChange: PropTypes.func,
    popupVisible: vue_types["a" /* default */].bool,
    disabled: vue_types["a" /* default */].bool.def(false),
    transitionName: vue_types["a" /* default */].string.def(''),
    popupClassName: vue_types["a" /* default */].string.def(''),
    popupStyle: vue_types["a" /* default */].object.def({}),
    popupPlacement: vue_types["a" /* default */].string.def('bottomLeft'),
    prefixCls: vue_types["a" /* default */].string.def('rc-cascader'),
    dropdownMenuColumnStyle: vue_types["a" /* default */].object,
    builtinPlacements: vue_types["a" /* default */].object.def(Cascader_BUILT_IN_PLACEMENTS),
    loadData: vue_types["a" /* default */].func,
    changeOnSelect: vue_types["a" /* default */].bool,
    // onKeyDown: PropTypes.func,
    expandTrigger: vue_types["a" /* default */].string.def('click'),
    fieldNames: vue_types["a" /* default */].object.def({
      label: 'label',
      value: 'value',
      children: 'children'
    })
  },
  mixins: [BaseMixin["a" /* default */]],
  model: {
    prop: 'value',
    event: 'change'
  },
  data: function data() {
    var initialValue = [];
    var value = this.value,
        defaultValue = this.defaultValue,
        popupVisible = this.popupVisible;

    if (Object(props_util["p" /* hasProp */])(this, 'value')) {
      initialValue = value || [];
    } else if (Object(props_util["p" /* hasProp */])(this, 'defaultValue')) {
      initialValue = defaultValue || [];
    } // warning(!('filedNames' in props),
    //   '`filedNames` of Cascader is a typo usage and deprecated, please use `fieldNames` intead.');


    return {
      sPopupVisible: popupVisible,
      sActiveValue: initialValue,
      sValue: initialValue
    };
  },
  watch: {
    value: function value(val, oldValue) {
      if (!arrays_default()(val, oldValue)) {
        var newValues = {
          sValue: val || [],
          sActiveValue: val || [] // allow activeValue diff from value
          // https://github.com/ant-design/ant-design/issues/2767

        };

        if (Object(props_util["p" /* hasProp */])(this, 'loadData')) {
          delete newValues.sActiveValue;
        }

        this.setState(newValues);
      }
    },
    popupVisible: function popupVisible(val) {
      this.setState({
        sPopupVisible: val
      });
    }
  },
  methods: {
    getPopupDOMNode: function getPopupDOMNode() {
      return this.$refs.trigger.getPopupDomNode();
    },
    getFieldName: function getFieldName(name) {
      var defaultFieldNames = this.defaultFieldNames,
          fieldNames = this.fieldNames;
      return fieldNames[name] || defaultFieldNames[name];
    },
    getFieldNames: function getFieldNames() {
      return this.fieldNames;
    },
    getCurrentLevelOptions: function getCurrentLevelOptions() {
      var _this = this;

      var options = this.options,
          _this$sActiveValue = this.sActiveValue,
          sActiveValue = _this$sActiveValue === void 0 ? [] : _this$sActiveValue;
      var result = array_tree_filter_lib_default()(options, function (o, level) {
        return o[_this.getFieldName('value')] === sActiveValue[level];
      }, {
        childrenKeyName: this.getFieldName('children')
      });

      if (result[result.length - 2]) {
        return result[result.length - 2][this.getFieldName('children')];
      }

      return Cascader_toConsumableArray(options).filter(function (o) {
        return !o.disabled;
      });
    },
    getActiveOptions: function getActiveOptions(activeValue) {
      var _this2 = this;

      return array_tree_filter_lib_default()(this.options, function (o, level) {
        return o[_this2.getFieldName('value')] === activeValue[level];
      }, {
        childrenKeyName: this.getFieldName('children')
      });
    },
    setPopupVisible: function setPopupVisible(popupVisible) {
      if (!Object(props_util["p" /* hasProp */])(this, 'popupVisible')) {
        this.setState({
          sPopupVisible: popupVisible
        });
      } // sync activeValue with value when panel open


      if (popupVisible && !this.sPopupVisible) {
        this.setState({
          sActiveValue: this.sValue
        });
      }

      this.__emit('popupVisibleChange', popupVisible);
    },
    handleChange: function handleChange(options, setProps, e) {
      var _this3 = this;

      if (e.type !== 'keydown' || e.keyCode === _util_KeyCode.ENTER) {
        this.__emit('change', options.map(function (o) {
          return o[_this3.getFieldName('value')];
        }), options);

        this.setPopupVisible(setProps.visible);
      }
    },
    handlePopupVisibleChange: function handlePopupVisibleChange(popupVisible) {
      this.setPopupVisible(popupVisible);
    },
    handleMenuSelect: function handleMenuSelect(targetOption, menuIndex, e) {
      // Keep focused state for keyboard support
      var triggerNode = this.$refs.trigger.getRootDomNode();

      if (triggerNode && triggerNode.focus) {
        triggerNode.focus();
      }

      var changeOnSelect = this.changeOnSelect,
          loadData = this.loadData,
          expandTrigger = this.expandTrigger;

      if (!targetOption || targetOption.disabled) {
        return;
      }

      var sActiveValue = this.sActiveValue;
      sActiveValue = sActiveValue.slice(0, menuIndex + 1);
      sActiveValue[menuIndex] = targetOption[this.getFieldName('value')];
      var activeOptions = this.getActiveOptions(sActiveValue);

      if (targetOption.isLeaf === false && !targetOption[this.getFieldName('children')] && loadData) {
        if (changeOnSelect && targetOption.isChooseSelf !== false) {
          this.handleChange(activeOptions, {
            visible: true
          }, e);
        }

        this.setState({
          sActiveValue: sActiveValue
        });
        loadData(activeOptions);
        return;
      }

      var newState = {};

      if (!targetOption[this.getFieldName('children')] || !targetOption[this.getFieldName('children')].length) {
        this.handleChange(activeOptions, {
          visible: false
        }, e); // set value to activeValue when select leaf option

        newState.sValue = sActiveValue; // add e.type judgement to prevent `onChange` being triggered by mouseEnter
      } else if (changeOnSelect && (e.type === 'click' || e.type === 'keydown')) {
        if (targetOption.isChooseSelf !== false) {
          if (expandTrigger === 'hover') {
            this.handleChange(activeOptions, {
              visible: false
            }, e);
          } else {
            this.handleChange(activeOptions, {
              visible: true
            }, e);
          }
        } // set value to activeValue on every select


        newState.sValue = sActiveValue;
      }

      newState.sActiveValue = sActiveValue; //  not change the value by keyboard

      if (Object(props_util["p" /* hasProp */])(this, 'value') || e.type === 'keydown' && e.keyCode !== _util_KeyCode.ENTER) {
        delete newState.sValue;
      }

      this.setState(newState);
    },
    handleKeyDown: function handleKeyDown(e) {
      var _this4 = this;

      var $slots = this.$slots;
      var children = $slots["default"] && $slots["default"][0]; // https://github.com/ant-design/ant-design/issues/6717
      // Don't bind keyboard support when children specify the onKeyDown

      if (children) {
        var keydown = Object(props_util["h" /* getEvents */])(children).keydown;

        if (keydown) {
          keydown(e);
          return;
        }
      }

      var activeValue = Cascader_toConsumableArray(this.sActiveValue);

      var currentLevel = activeValue.length - 1 < 0 ? 0 : activeValue.length - 1;
      var currentOptions = this.getCurrentLevelOptions();
      var currentIndex = currentOptions.map(function (o) {
        return o[_this4.getFieldName('value')];
      }).indexOf(activeValue[currentLevel]);

      if (e.keyCode !== _util_KeyCode.DOWN && e.keyCode !== _util_KeyCode.UP && e.keyCode !== _util_KeyCode.LEFT && e.keyCode !== _util_KeyCode.RIGHT && e.keyCode !== _util_KeyCode.ENTER && e.keyCode !== _util_KeyCode.BACKSPACE && e.keyCode !== _util_KeyCode.ESC) {
        return;
      } // Press any keys above to reopen menu


      if (!this.sPopupVisible && e.keyCode !== _util_KeyCode.BACKSPACE && e.keyCode !== _util_KeyCode.LEFT && e.keyCode !== _util_KeyCode.RIGHT && e.keyCode !== _util_KeyCode.ESC) {
        this.setPopupVisible(true);
        return;
      }

      if (e.keyCode === _util_KeyCode.DOWN || e.keyCode === _util_KeyCode.UP) {
        var nextIndex = currentIndex;

        if (nextIndex !== -1) {
          if (e.keyCode === _util_KeyCode.DOWN) {
            nextIndex += 1;
            nextIndex = nextIndex >= currentOptions.length ? 0 : nextIndex;
          } else {
            nextIndex -= 1;
            nextIndex = nextIndex < 0 ? currentOptions.length - 1 : nextIndex;
          }
        } else {
          nextIndex = 0;
        }

        activeValue[currentLevel] = currentOptions[nextIndex][this.getFieldName('value')];
      } else if (e.keyCode === _util_KeyCode.LEFT || e.keyCode === _util_KeyCode.BACKSPACE) {
        activeValue.splice(activeValue.length - 1, 1);
      } else if (e.keyCode === _util_KeyCode.RIGHT) {
        if (currentOptions[currentIndex] && currentOptions[currentIndex][this.getFieldName('children')]) {
          activeValue.push(currentOptions[currentIndex][this.getFieldName('children')][0][this.getFieldName('value')]);
        }
      } else if (e.keyCode === _util_KeyCode.ESC) {
        this.setPopupVisible(false);
        return;
      }

      if (!activeValue || activeValue.length === 0) {
        this.setPopupVisible(false);
      }

      var activeOptions = this.getActiveOptions(activeValue);
      var targetOption = activeOptions[activeOptions.length - 1];
      this.handleMenuSelect(targetOption, activeOptions.length - 1, e);

      this.__emit('keydown', e);
    }
  },
  render: function render() {
    var h = arguments[0];
    var $props = this.$props,
        $slots = this.$slots,
        sActiveValue = this.sActiveValue,
        handleMenuSelect = this.handleMenuSelect,
        sPopupVisible = this.sPopupVisible,
        handlePopupVisibleChange = this.handlePopupVisibleChange,
        handleKeyDown = this.handleKeyDown,
        $listeners = this.$listeners;

    var prefixCls = $props.prefixCls,
        transitionName = $props.transitionName,
        popupClassName = $props.popupClassName,
        options = $props.options,
        url = $props.url,
        disabled = $props.disabled,
        builtinPlacements = $props.builtinPlacements,
        popupPlacement = $props.popupPlacement,
        restProps = Cascader_objectWithoutProperties($props, ["prefixCls", "transitionName", "popupClassName", "options", "url", "disabled", "builtinPlacements", "popupPlacement"]); // Did not show popup when there is no options


    var menus = h("div");
    var emptyMenuClassName = '';

    if (options && options.length > 0) {
      var menusProps = {
        props: Cascader_objectSpread({}, $props, {
          fieldNames: this.getFieldNames(),
          defaultFieldNames: this.defaultFieldNames,
          activeValue: sActiveValue,
          visible: sPopupVisible
        }),
        on: Cascader_objectSpread({}, $listeners, {
          select: handleMenuSelect
        })
      };
      menus = h(Menus, menusProps);
    } else {
      emptyMenuClassName = " ".concat(prefixCls, "-menus-empty");
    }

    var triggerProps = {
      props: Cascader_objectSpread({}, restProps, {
        disabled: disabled,
        popupPlacement: popupPlacement,
        builtinPlacements: builtinPlacements,
        popupTransitionName: transitionName,
        action: disabled ? [] : ['click'],
        popupVisible: disabled ? false : sPopupVisible,
        prefixCls: "".concat(prefixCls, "-menus"),
        popupClassName: popupClassName + emptyMenuClassName
      }),
      on: Cascader_objectSpread({}, $listeners, {
        popupVisibleChange: handlePopupVisibleChange
      }),
      ref: 'trigger'
    };
    return h(components_trigger, triggerProps, [$slots["default"] && Object(vnode["a" /* cloneElement */])($slots["default"][0], {
      on: {
        keydown: handleKeyDown
      },
      attrs: {
        tabIndex: disabled ? undefined : 0
      }
    }), h("template", {
      slot: 'popup'
    }, [menus])]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-cascader/index.js
// based on rc-cascader 0.14.0

/* harmony default export */ var vc_cascader = (Cascader);
// CONCATENATED MODULE: ./src/components/cascader/index.jsx
function cascader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { cascader_defineProperty(target, key, source[key]); }); } return target; }

function cascader_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = cascader_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function cascader_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function cascader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function cascader_toConsumableArray(arr) { return cascader_arrayWithoutHoles(arr) || cascader_iterableToArray(arr) || cascader_nonIterableSpread(); }

function cascader_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function cascader_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function cascader_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }











var CascaderOptionType = vue_types["a" /* default */].shape({
  value: vue_types["a" /* default */].string,
  label: vue_types["a" /* default */].any,
  disabled: vue_types["a" /* default */].bool,
  children: vue_types["a" /* default */].array,
  key: vue_types["a" /* default */].string
}).loose;
var FieldNamesType = vue_types["a" /* default */].shape({
  value: vue_types["a" /* default */].string.isRequired,
  label: vue_types["a" /* default */].string.isRequired,
  children: vue_types["a" /* default */].string
}).loose;
var CascaderExpandTrigger = vue_types["a" /* default */].oneOf(['click', 'hover']);
var ShowSearchType = vue_types["a" /* default */].shape({
  filter: vue_types["a" /* default */].func,
  render: vue_types["a" /* default */].func,
  sort: vue_types["a" /* default */].func,
  matchInputWidth: vue_types["a" /* default */].bool
}).loose;

function cascader_noop() {}

var CascaderProps = {
  /** 可选项数据源 */
  options: vue_types["a" /* default */].arrayOf(CascaderOptionType).def([]),

  /**添加url,如果使用url那么 options一定添加.sync add by cy*/
  url: vue_types["a" /* default */].string.def(''),

  /**添加url后必填的.sync add by cy*/
  treeId: vue_types["a" /* default */].string.def(''),

  /**有url异步请求树初次请求数据成功之后的回调 add by cy*/
  loadedDataCallBack: vue_types["a" /* default */].func,

  /** 默认的选中项 */
  defaultValue: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),

  /** 指定选中项 */
  value: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),

  /** 选择完成后的回调 */
  // onChange?: (value: string[], selectedOptions?: CascaderOptionType[]) => void;

  /** 选择后展示的渲染函数 */
  displayRender: vue_types["a" /* default */].func,
  transitionName: vue_types["a" /* default */].string.def('slide-up'),
  popupStyle: vue_types["a" /* default */].object.def({}),

  /** 自定义浮层类名 */
  popupClassName: vue_types["a" /* default */].string,

  /** 浮层预设位置：`bottomLeft` `bottomRight` `topLeft` `topRight` */
  popupPlacement: vue_types["a" /* default */].oneOf(['bottomLeft', 'bottomRight', 'topLeft', 'topRight']).def('bottomLeft'),

  /** 输入框占位文本 */
  placeholder: vue_types["a" /* default */].string.def('Please select'),

  /** 输入框大小，可选 `large` `default` `small` */
  size: vue_types["a" /* default */].oneOf(['large', 'default', 'small']),

  /** 禁用 */
  disabled: vue_types["a" /* default */].bool.def(false),

  /** 是否支持清除 */
  allowClear: vue_types["a" /* default */].bool.def(true),
  showSearch: vue_types["a" /* default */].oneOfType([Boolean, ShowSearchType]),
  notFoundContent: vue_types["a" /* default */].any.def('Not Found'),
  loadData: vue_types["a" /* default */].func,

  /** 次级菜单的展开方式，可选 'click' 和 'hover' */
  expandTrigger: CascaderExpandTrigger,

  /** 当此项为 true 时，点选每级菜单选项值都会发生变化 */
  changeOnSelect: vue_types["a" /* default */].bool,

  /** 浮层可见变化时回调 */
  // onPopupVisibleChange?: (popupVisible: boolean) => void;
  prefixCls: vue_types["a" /* default */].string.def('ant-cascader'),
  inputPrefixCls: vue_types["a" /* default */].string.def('ant-input'),
  getPopupContainer: vue_types["a" /* default */].func,
  popupVisible: vue_types["a" /* default */].bool,
  fieldNames: FieldNamesType,
  autoFocus: vue_types["a" /* default */].bool
};

function defaultFilterOption(inputValue, path, names) {
  return path.some(function (option) {
    return option[names.label].indexOf(inputValue) > -1;
  });
}

function defaultSortFilteredOption(a, b, inputValue, names) {
  function callback(elem) {
    return elem[names.label].indexOf(inputValue) > -1;
  }

  return a.findIndex(callback) - b.findIndex(callback);
}

function getFilledFieldNames() {
  var fieldNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var names = {
    children: fieldNames.children || 'children',
    label: fieldNames.label || 'label',
    value: fieldNames.value || 'value'
  };
  return names;
}

var defaultDisplayRender = function defaultDisplayRender(_ref) {
  var labels = _ref.labels;
  return labels.join(' / ');
};

var cascader_Cascader = {
  inheritAttrs: false,
  name: 'TaCascader',
  mixins: [BaseMixin["a" /* default */]],
  props: CascaderProps,
  model: {
    prop: 'value',
    event: 'change'
  },
  data: function data() {
    this.cachedOptions = [];
    var value = this.value,
        defaultValue = this.defaultValue,
        popupVisible = this.popupVisible,
        showSearch = this.showSearch,
        options = this.options,
        changeOnSelect = this.changeOnSelect,
        flattenTree = this.flattenTree,
        fieldNames = this.fieldNames;
    return {
      sValue: value || defaultValue || [],
      inputValue: '',
      inputFocused: false,
      sPopupVisible: popupVisible,
      flattenOptions: showSearch ? flattenTree(options, changeOnSelect, fieldNames) : undefined
    };
  },
  created: function created() {
    this.initOptions();
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      if (_this.autoFocus && !_this.showSearch && !_this.disabled) {
        _this.$refs.picker.focus();
      }
    });
  },
  watch: {
    value: function value(val) {
      this.setState({
        sValue: val || []
      });
    },
    popupVisible: function popupVisible(val) {
      this.setState({
        sPopupVisible: val
      });
    },
    options: function options(val) {
      if (this.showSearch) {
        this.setState({
          flattenOptions: this.flattenTree(this.options, this.changeOnSelect, this.fieldNames)
        });
      }
    }
  },
  methods: {
    //通过url初始化 options
    initOptions: function initOptions() {
      var _this2 = this;

      if (this.url && this.treeId) {
        this.Base.submit(null, {
          url: this.url
        }, {
          successCallback: function successCallback(data) {
            var ops = [];

            try {
              ops = data.data[_this2.treeId];
            } catch (e) {}

            _this2.$emit('update:options', ops);

            _this2.$nextTick(function () {
              if (_this2.loadedDataCallBack) {
                _this2.loadedDataCallBack(data);
              }
            });
          }
        });
      }
    },
    //通过url异步获取 options的子节点
    getOptions: function getOptions(selectedOptions) {
      var _this3 = this;

      if (this.url && this.treeId) {
        var targetOption = selectedOptions[selectedOptions.length - 1];
        targetOption.loading = true;
        var param = {};
        param[this.fieldNames.value] = targetOption[this.fieldNames.value];
        this.Base.submit(null, {
          url: this.url,
          data: param
        }, {
          successCallback: function successCallback(data) {
            targetOption.loading = false;
            targetOption.children = data.data[_this3.treeId] || [];

            _this3.$emit('update:options', cascader_toConsumableArray(_this3.options));
          }
        });
      }
    },
    highlightKeyword: function highlightKeyword(str, keyword, prefixCls) {
      var h = this.$createElement;
      return str.split(keyword).map(function (node, index) {
        return index === 0 ? node : [h("span", {
          "class": "".concat(prefixCls, "-menu-item-keyword")
        }, [keyword]), node];
      });
    },
    defaultRenderFilteredOption: function defaultRenderFilteredOption(_ref2) {
      var _this4 = this;

      var inputValue = _ref2.inputValue,
          path = _ref2.path,
          prefixCls = _ref2.prefixCls,
          names = _ref2.names;
      return path.map(function (option, index) {
        var label = option[names.label];
        var node = label.indexOf(inputValue) > -1 ? _this4.highlightKeyword(label, inputValue, prefixCls) : label;
        return index === 0 ? node : [' / ', node];
      });
    },
    handleChange: function handleChange(value, selectedOptions) {
      this.setState({
        inputValue: ''
      });

      if (selectedOptions[0].__IS_FILTERED_OPTION) {
        var unwrappedValue = value[0];
        var unwrappedSelectedOptions = selectedOptions[0].path;
        this.setValue(unwrappedValue, unwrappedSelectedOptions);
        return;
      }

      this.setValue(value, selectedOptions);
    },
    handlePopupVisibleChange: function handlePopupVisibleChange(popupVisible) {
      if (!Object(props_util["p" /* hasProp */])(this, 'popupVisible')) {
        this.setState({
          sPopupVisible: popupVisible,
          inputFocused: popupVisible,
          inputValue: popupVisible ? this.inputValue : ''
        });
      }

      this.$emit('popupVisibleChange', popupVisible);
    },
    handleInputFocus: function handleInputFocus(e) {
      this.$emit('focus', e);
    },
    handleInputBlur: function handleInputBlur(e) {
      this.setState({
        inputFocused: false
      });
      this.$emit('blur', e);
    },
    handleInputClick: function handleInputClick(e) {
      var inputFocused = this.inputFocused,
          sPopupVisible = this.sPopupVisible; // Prevent `Trigger` behaviour.

      if (inputFocused || sPopupVisible) {
        e.stopPropagation();

        if (e.nativeEvent && e.nativeEvent.stopImmediatePropagation) {
          e.nativeEvent.stopImmediatePropagation();
        }
      }
    },
    handleKeyDown: function handleKeyDown(e) {
      if (e.keyCode === _util_KeyCode.BACKSPACE) {
        e.stopPropagation();
      }
    },
    handleInputChange: function handleInputChange(e) {
      var inputValue = e.target.value;
      this.setState({
        inputValue: inputValue
      });
    },
    setValue: function setValue(value, selectedOptions) {
      if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
        this.setState({
          sValue: value
        });
      }

      this.$emit('change', value, selectedOptions);
    },
    getLabel: function getLabel() {
      var options = this.options,
          $scopedSlots = this.$scopedSlots,
          fieldNames = this.fieldNames;
      var names = getFilledFieldNames(fieldNames);
      var displayRender = this.displayRender || $scopedSlots.displayRender || defaultDisplayRender;
      var value = this.sValue;
      var unwrappedValue = Array.isArray(value[0]) ? value[0] : value;
      var selectedOptions = array_tree_filter_lib_default()(options, function (o, level) {
        return o[names.value] === unwrappedValue[level];
      }, {
        childrenKeyName: names.children
      });
      var labels = selectedOptions.map(function (o) {
        return o[names.label];
      });
      return displayRender({
        labels: labels,
        selectedOptions: selectedOptions
      });
    },
    clearSelection: function clearSelection(e) {
      e.preventDefault();
      e.stopPropagation();

      if (!this.inputValue) {
        this.setValue([]);
        this.handlePopupVisibleChange(false);
      } else {
        this.setState({
          inputValue: ''
        });
      }
    },
    flattenTree: function flattenTree(options, changeOnSelect, fieldNames) {
      var _this5 = this;

      var ancestor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      var names = getFilledFieldNames(fieldNames);
      var flattenOptions = [];
      var childrenName = names.children;
      options.forEach(function (option) {
        var path = ancestor.concat(option);

        if (changeOnSelect || !option[childrenName] || !option[childrenName].length) {
          flattenOptions.push(path);
        }

        if (option[childrenName]) {
          flattenOptions = flattenOptions.concat(_this5.flattenTree(option[childrenName], changeOnSelect, fieldNames, path));
        }
      });
      return flattenOptions;
    },
    generateFilteredOptions: function generateFilteredOptions(prefixCls) {
      var _ref4;

      var showSearch = this.showSearch,
          notFoundContent = this.notFoundContent,
          $scopedSlots = this.$scopedSlots,
          fieldNames = this.fieldNames;
      var names = getFilledFieldNames(fieldNames);
      var _showSearch$filter = showSearch.filter,
          filter = _showSearch$filter === void 0 ? defaultFilterOption : _showSearch$filter,
          _showSearch$sort = showSearch.sort,
          sort = _showSearch$sort === void 0 ? defaultSortFilteredOption : _showSearch$sort;
      var _this$$data = this.$data,
          _this$$data$flattenOp = _this$$data.flattenOptions,
          flattenOptions = _this$$data$flattenOp === void 0 ? [] : _this$$data$flattenOp,
          inputValue = _this$$data.inputValue;
      var render = showSearch.render || $scopedSlots.showSearchRender || this.defaultRenderFilteredOption;
      var filtered = flattenOptions.filter(function (path) {
        return filter(inputValue, path, names);
      }).sort(function (a, b) {
        return sort(a, b, inputValue, names);
      });

      if (filtered.length > 0) {
        return filtered.map(function (path) {
          var _ref3;

          return _ref3 = {
            __IS_FILTERED_OPTION: true,
            path: path
          }, cascader_defineProperty(_ref3, names.label, render({
            inputValue: inputValue,
            path: path,
            prefixCls: prefixCls,
            names: names
          })), cascader_defineProperty(_ref3, names.value, path.map(function (o) {
            return o[names.value];
          })), cascader_defineProperty(_ref3, "disabled", path.some(function (o) {
            return !!o.disabled;
          })), _ref3;
        });
      }

      return [(_ref4 = {}, cascader_defineProperty(_ref4, names.label, notFoundContent), cascader_defineProperty(_ref4, names.value, 'ANT_CASCADER_NOT_FOUND'), cascader_defineProperty(_ref4, "disabled", true), _ref4)];
    },
    focus: function focus() {
      if (this.showSearch) {
        this.$refs.input.focus();
      } else {
        this.$refs.picker.focus();
      }
    },
    blur: function blur() {
      if (this.showSearch) {
        this.$refs.input.blur();
      } else {
        this.$refs.picker.blur();
      }
    }
  },
  render: function render() {
    var _classNames, _classNames2, _classNames3;

    var h = arguments[0];
    var $slots = this.$slots,
        sPopupVisible = this.sPopupVisible,
        inputValue = this.inputValue,
        $listeners = this.$listeners;
    var _this$$data2 = this.$data,
        value = _this$$data2.sValue,
        inputFocused = _this$$data2.inputFocused;
    var props = Object(props_util["j" /* getOptionProps */])(this);

    var prefixCls = props.prefixCls,
        inputPrefixCls = props.inputPrefixCls,
        placeholder = props.placeholder,
        size = props.size,
        disabled = props.disabled,
        allowClear = props.allowClear,
        _props$showSearch = props.showSearch,
        showSearch = _props$showSearch === void 0 ? false : _props$showSearch,
        otherProps = cascader_objectWithoutProperties(props, ["prefixCls", "inputPrefixCls", "placeholder", "size", "disabled", "allowClear", "showSearch"]);

    var sizeCls = classnames_default()((_classNames = {}, cascader_defineProperty(_classNames, "".concat(inputPrefixCls, "-lg"), size === 'large'), cascader_defineProperty(_classNames, "".concat(inputPrefixCls, "-sm"), size === 'small'), _classNames));
    var clearIcon = allowClear && !disabled && value.length > 0 || inputValue ? h(components_icon, {
      attrs: {
        type: 'cross-circle'
      },
      "class": "".concat(prefixCls, "-picker-clear"),
      on: {
        "click": this.clearSelection
      },
      key: 'clear-icon'
    }) : null;
    var arrowCls = classnames_default()((_classNames2 = {}, cascader_defineProperty(_classNames2, "".concat(prefixCls, "-picker-arrow"), true), cascader_defineProperty(_classNames2, "".concat(prefixCls, "-picker-arrow-expand"), sPopupVisible), _classNames2));
    var pickerCls = classnames_default()(Object(props_util["f" /* getClass */])(this), "".concat(prefixCls, "-picker"), (_classNames3 = {}, cascader_defineProperty(_classNames3, "".concat(prefixCls, "-picker-with-value"), inputValue), cascader_defineProperty(_classNames3, "".concat(prefixCls, "-picker-disabled"), disabled), cascader_defineProperty(_classNames3, "".concat(prefixCls, "-picker-").concat(size), !!size), cascader_defineProperty(_classNames3, "".concat(prefixCls, "-picker-show-search"), !!showSearch), cascader_defineProperty(_classNames3, "".concat(prefixCls, "-picker-focused"), inputFocused), _classNames3)); // Fix bug of https://github.com/facebook/react/pull/5004
    // and https://fb.me/react-unknown-prop

    var tempInputProps = Object(es["a" /* default */])(otherProps, ['options', 'popupPlacement', 'transitionName', 'displayRender', 'changeOnSelect', 'expandTrigger', 'popupVisible', 'getPopupContainer', 'loadData', 'popupClassName', 'filterOption', 'renderFilteredOption', 'sortFilteredOption', 'notFoundContent', 'defaultValue', 'fieldNames']);
    var options = props.options;

    if (inputValue) {
      options = this.generateFilteredOptions(prefixCls);
    } // Dropdown menu should keep previous status until it is fully closed.


    if (!sPopupVisible) {
      options = this.cachedOptions;
    } else {
      this.cachedOptions = options;
    }

    var dropdownMenuColumnStyle = {};
    var isNotFound = (options || []).length === 1 && options[0].value === 'ANT_CASCADER_NOT_FOUND';

    if (isNotFound) {
      dropdownMenuColumnStyle.height = 'auto'; // Height of one row.
    } // The default value of `matchInputWidth` is `true`


    var resultListMatchInputWidth = showSearch.matchInputWidth !== false;

    if (resultListMatchInputWidth && inputValue && this.input) {
      dropdownMenuColumnStyle.width = this.input.input.offsetWidth;
    } // showSearch时，focus、blur在input上触发，反之在ref='picker'上触发


    var inputProps = {
      props: cascader_objectSpread({}, tempInputProps, {
        prefixCls: inputPrefixCls,
        placeholder: value && value.length > 0 ? undefined : placeholder,
        value: inputValue,
        disabled: disabled,
        readOnly: !showSearch,
        autoComplete: 'off'
      }),
      "class": "".concat(prefixCls, "-input ").concat(sizeCls),
      ref: 'input',
      on: {
        focus: showSearch ? this.handleInputFocus : cascader_noop,
        click: showSearch ? this.handleInputClick : cascader_noop,
        blur: showSearch ? this.handleInputBlur : cascader_noop,
        keydown: this.handleKeyDown,
        change: showSearch ? this.handleInputChange : cascader_noop
      },
      attrs: Object(props_util["e" /* getAttrs */])(this)
    };
    var children = Object(props_util["c" /* filterEmpty */])($slots["default"]);
    var input = children.length ? children : h("span", {
      "class": pickerCls,
      style: Object(props_util["n" /* getStyle */])(this),
      ref: 'picker'
    }, [showSearch ? h("span", {
      "class": "".concat(prefixCls, "-picker-label")
    }, [this.getLabel()]) : null, h(components_input, inputProps), !showSearch ? h("span", {
      "class": "".concat(prefixCls, "-picker-label")
    }, [this.getLabel()]) : null, clearIcon, h(components_icon, {
      attrs: {
        type: 'down'
      },
      key: 'down-icon',
      "class": arrowCls
    })]);
    var cascaderProps = {
      props: cascader_objectSpread({
        loadData: this.getOptions
      }, props, {
        options: options,
        value: value,
        popupVisible: sPopupVisible,
        dropdownMenuColumnStyle: dropdownMenuColumnStyle
      }),
      on: cascader_objectSpread({}, $listeners, {
        popupVisibleChange: this.handlePopupVisibleChange,
        change: this.handleChange
      })
    };
    return h(vc_cascader, cascaderProps, [input]);
  }
};
/* istanbul ignore next */

cascader_Cascader.install = function (Vue) {
  Vue.component(cascader_Cascader.name, cascader_Cascader);
};

/* harmony default export */ var cascader = (cascader_Cascader);
// CONCATENATED MODULE: ./src/components/checkbox/Checkbox.jsx


function checkbox_Checkbox_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { checkbox_Checkbox_defineProperty(target, key, source[key]); }); } return target; }

function checkbox_Checkbox_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function checkbox_Checkbox_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = checkbox_Checkbox_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function checkbox_Checkbox_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






function Checkbox_noop() {}

/* harmony default export */ var checkbox_Checkbox = ({
  inheritAttrs: false,
  name: 'TaCheckbox',
  props: {
    prefixCls: {
      "default": 'ant-checkbox',
      type: String
    },
    defaultChecked: vue_types["a" /* default */].bool,
    checked: vue_types["a" /* default */].bool,
    disabled: vue_types["a" /* default */].bool,
    isGroup: Boolean,
    value: vue_types["a" /* default */].any,
    name: String,
    id: String,
    indeterminate: Boolean,
    type: vue_types["a" /* default */].string.def('checkbox'),
    autoFocus: Boolean
  },
  model: {
    prop: 'checked'
  },
  inject: {
    checkboxGroupContext: {
      "default": null
    }
  },
  methods: {
    handleChange: function handleChange(event) {
      var targetChecked = event.target.checked;
      this.$emit('input', targetChecked);
      this.$emit('change', event);
    },
    focus: function focus() {
      this.$refs.vcCheckbox.focus();
    },
    blur: function blur() {
      this.$refs.vcCheckbox.blur();
    }
  },
  render: function render() {
    var h = arguments[0];
    var checkboxGroup = this.checkboxGroupContext,
        $listeners = this.$listeners,
        $slots = this.$slots;
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var children = $slots["default"];

    var _$listeners$mouseente = $listeners.mouseenter,
        mouseenter = _$listeners$mouseente === void 0 ? Checkbox_noop : _$listeners$mouseente,
        _$listeners$mouseleav = $listeners.mouseleave,
        mouseleave = _$listeners$mouseleav === void 0 ? Checkbox_noop : _$listeners$mouseleav,
        restListeners = checkbox_Checkbox_objectWithoutProperties($listeners, ["mouseenter", "mouseleave"]);

    var prefixCls = props.prefixCls,
        indeterminate = props.indeterminate,
        restProps = checkbox_Checkbox_objectWithoutProperties(props, ["prefixCls", "indeterminate"]);

    var checkboxProps = {
      props: checkbox_Checkbox_objectSpread({}, restProps, {
        prefixCls: prefixCls
      }),
      on: restListeners,
      attrs: Object(props_util["e" /* getAttrs */])(this)
    };

    if (checkboxGroup) {
      checkboxProps.on.change = function () {
        return checkboxGroup.toggleOption({
          label: children,
          value: props.value
        });
      };

      checkboxProps.props.checked = checkboxGroup.sValue.indexOf(props.value) !== -1;
      checkboxProps.props.disabled = props.disabled || checkboxGroup.disabled;
    } else {
      checkboxProps.on.change = this.handleChange;
    }

    var classString = classnames_default()(checkbox_Checkbox_defineProperty({}, "".concat(prefixCls, "-wrapper"), true));
    var checkboxClass = classnames_default()(checkbox_Checkbox_defineProperty({}, "".concat(prefixCls, "-indeterminate"), indeterminate));
    return h("label", {
      "class": classString,
      on: {
        "mouseenter": mouseenter,
        "mouseleave": mouseleave
      }
    }, [h(vc_checkbox_src, babel_helper_vue_jsx_merge_props_default()([checkboxProps, {
      "class": checkboxClass,
      ref: 'vcCheckbox'
    }])), children !== undefined ? h("span", [children]) : null]);
  }
});
// CONCATENATED MODULE: ./src/components/checkbox/Group.jsx
function Group_toConsumableArray(arr) { return Group_arrayWithoutHoles(arr) || Group_iterableToArray(arr) || Group_nonIterableSpread(); }

function Group_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function Group_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function Group_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }



/* harmony default export */ var checkbox_Group = ({
  name: 'TaCheckboxGroup',
  props: {
    prefixCls: {
      "default": 'ant-checkbox',
      type: String
    },
    defaultValue: {
      "default": undefined,
      type: Array
    },
    value: {
      "default": undefined,
      type: Array
    },
    options: {
      "default": function _default() {
        return [];
      },
      type: Array
    },
    disabled: Boolean
  },
  model: {
    prop: 'value'
  },
  provide: function provide() {
    return {
      checkboxGroupContext: this
    };
  },
  data: function data() {
    var value = this.value,
        defaultValue = this.defaultValue;
    return {
      sValue: value || defaultValue || []
    };
  },
  watch: {
    value: function value(val) {
      this.sValue = val;
    }
  },
  methods: {
    getOptions: function getOptions() {
      var options = this.$props.options;
      return options.map(function (option) {
        if (typeof option === 'string') {
          return {
            label: option,
            value: option
          };
        }

        return option;
      });
    },
    toggleOption: function toggleOption(option) {
      var optionIndex = this.sValue.indexOf(option.value);

      var value = Group_toConsumableArray(this.sValue);

      if (optionIndex === -1) {
        value.push(option.value);
      } else {
        value.splice(optionIndex, 1);
      }

      if (!Object(props_util["b" /* default */])(this, 'value')) {
        this.sValue = value;
      }

      this.$emit('input', value);
      this.$emit('change', value);
    }
  },
  render: function render() {
    var _this = this;

    var h = arguments[0];
    var props = this.$props,
        state = this.$data,
        $slots = this.$slots;
    var prefixCls = props.prefixCls,
        options = props.options;
    var children = $slots["default"];
    var groupPrefixCls = "".concat(prefixCls, "-group");

    if (options && options.length > 0) {
      children = this.getOptions().map(function (option) {
        return h(checkbox_Checkbox, {
          attrs: {
            prefixCls: prefixCls,
            disabled: 'disabled' in option ? option.disabled : props.disabled,
            value: option.value,
            checked: state.sValue.indexOf(option.value) !== -1
          },
          key: option.value.toString(),
          on: {
            "change": function change() {
              return _this.toggleOption(option);
            }
          },
          "class": "".concat(groupPrefixCls, "-item")
        }, [option.label]);
      });
    }

    return h("div", {
      "class": groupPrefixCls
    }, [children]);
  }
});
// CONCATENATED MODULE: ./src/components/checkbox/index.js


checkbox_Checkbox.Group = checkbox_Group;
/* istanbul ignore next */

checkbox_Checkbox.install = function (Vue) {
  Vue.component(checkbox_Checkbox.name, checkbox_Checkbox);
  Vue.component(checkbox_Group.name, checkbox_Group);
};

/* harmony default export */ var components_checkbox = (checkbox_Checkbox);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/month/MonthPanel.jsx





function goYear(direction) {
  var next = this.sValue.clone();
  next.add(direction, 'year');
  this.setAndChangeValue(next);
}

function MonthPanel_noop() {}

var MonthPanel = {
  mixins: [BaseMixin["a" /* default */]],
  props: {
    value: vue_types["a" /* default */].any,
    defaultValue: vue_types["a" /* default */].any,
    cellRender: vue_types["a" /* default */].any,
    contentRender: vue_types["a" /* default */].any,
    locale: vue_types["a" /* default */].any,
    rootPrefixCls: vue_types["a" /* default */].string,
    // onChange: PropTypes.func,
    disabledDate: vue_types["a" /* default */].func // onSelect: PropTypes.func,

  },
  data: function data() {
    var value = this.value,
        defaultValue = this.defaultValue; // bind methods

    this.nextYear = goYear.bind(this, 1);
    this.previousYear = goYear.bind(this, -1);
    return {
      sValue: value || defaultValue
    };
  },
  watch: {
    value: function value(val) {
      this.setState({
        sValue: val
      });
    }
  },
  methods: {
    setAndChangeValue: function setAndChangeValue(value) {
      this.setValue(value);

      this.__emit('change', value);
    },
    setAndSelectValue: function setAndSelectValue(value) {
      this.setValue(value);

      this.__emit('select', value);
    },
    setValue: function setValue(value) {
      if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
        this.setState({
          sValue: value
        });
      }
    }
  },
  render: function render() {
    var h = arguments[0];
    var sValue = this.sValue,
        cellRender = this.cellRender,
        contentRender = this.contentRender,
        locale = this.locale,
        rootPrefixCls = this.rootPrefixCls,
        disabledDate = this.disabledDate,
        _this$$listeners = this.$listeners,
        $listeners = _this$$listeners === void 0 ? {} : _this$$listeners;
    var year = sValue.year();
    var prefixCls = "".concat(rootPrefixCls, "-month-panel");
    return h("div", {
      "class": prefixCls
    }, [h("div", [h("div", {
      "class": "".concat(prefixCls, "-header")
    }, [h("a", {
      "class": "".concat(prefixCls, "-prev-year-btn"),
      attrs: {
        role: 'button',
        title: locale.previousYear
      },
      on: {
        "click": this.previousYear
      }
    }), h("a", {
      "class": "".concat(prefixCls, "-year-select"),
      attrs: {
        role: 'button',
        title: locale.yearSelect
      },
      on: {
        "click": $listeners.yearPanelShow || MonthPanel_noop
      }
    }, [h("span", {
      "class": "".concat(prefixCls, "-year-select-content")
    }, [year]), h("span", {
      "class": "".concat(prefixCls, "-year-select-arrow")
    }, ["x"])]), h("a", {
      "class": "".concat(prefixCls, "-next-year-btn"),
      attrs: {
        role: 'button',
        title: locale.nextYear
      },
      on: {
        "click": this.nextYear
      }
    })]), h("div", {
      "class": "".concat(prefixCls, "-body")
    }, [h(month_MonthTable, {
      attrs: {
        disabledDate: disabledDate,
        locale: locale,
        value: sValue,
        cellRender: cellRender,
        contentRender: contentRender,
        prefixCls: prefixCls
      },
      on: {
        "select": this.setAndSelectValue
      }
    })])])]);
  }
};
/* harmony default export */ var month_MonthPanel = (MonthPanel);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/year/YearPanel.jsx
function YearPanel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var YearPanel_ROW = 4;
var YearPanel_COL = 3;

function YearPanel_noop() {}

function YearPanel_goYear(direction) {
  var value = this.sValue.clone();
  value.add(direction, 'year');
  this.setState({
    sValue: value
  });
}

function chooseYear(year) {
  var value = this.sValue.clone();
  value.year(year);
  value.month(this.sValue.month());

  this.__emit('select', value);
}

/* harmony default export */ var YearPanel = ({
  mixins: [BaseMixin["a" /* default */]],
  props: {
    rootPrefixCls: vue_types["a" /* default */].string,
    value: vue_types["a" /* default */].object,
    defaultValue: vue_types["a" /* default */].object,
    locale: vue_types["a" /* default */].object
  },
  data: function data() {
    this.nextDecade = YearPanel_goYear.bind(this, 10);
    this.previousDecade = YearPanel_goYear.bind(this, -10);
    return {
      sValue: this.value || this.defaultValue
    };
  },
  methods: {
    years: function years() {
      var value = this.sValue;
      var currentYear = value.year();
      var startYear = parseInt(currentYear / 10, 10) * 10;
      var previousYear = startYear - 1;
      var years = [];
      var index = 0;

      for (var rowIndex = 0; rowIndex < YearPanel_ROW; rowIndex++) {
        years[rowIndex] = [];

        for (var colIndex = 0; colIndex < YearPanel_COL; colIndex++) {
          var year = previousYear + index;
          var content = String(year);
          years[rowIndex][colIndex] = {
            content: content,
            year: year,
            title: content
          };
          index++;
        }
      }

      return years;
    }
  },
  render: function render() {
    var _this = this;

    var h = arguments[0];
    var value = this.sValue,
        locale = this.locale,
        _this$$listeners = this.$listeners,
        $listeners = _this$$listeners === void 0 ? {} : _this$$listeners;
    var decadePanelShow = $listeners.decadePanelShow || YearPanel_noop;
    var years = this.years();
    var currentYear = value.year();
    var startYear = parseInt(currentYear / 10, 10) * 10;
    var endYear = startYear + 9;
    var prefixCls = "".concat(this.rootPrefixCls, "-year-panel");
    var yeasEls = years.map(function (row, index) {
      var tds = row.map(function (yearData) {
        var _classNameMap;

        var classNameMap = (_classNameMap = {}, YearPanel_defineProperty(_classNameMap, "".concat(prefixCls, "-cell"), 1), YearPanel_defineProperty(_classNameMap, "".concat(prefixCls, "-selected-cell"), yearData.year === currentYear), YearPanel_defineProperty(_classNameMap, "".concat(prefixCls, "-last-decade-cell"), yearData.year < startYear), YearPanel_defineProperty(_classNameMap, "".concat(prefixCls, "-next-decade-cell"), yearData.year > endYear), _classNameMap);
        var clickHandler = YearPanel_noop;

        if (yearData.year < startYear) {
          clickHandler = _this.previousDecade;
        } else if (yearData.year > endYear) {
          clickHandler = _this.nextDecade;
        } else {
          clickHandler = chooseYear.bind(_this, yearData.year);
        }

        return h("td", {
          attrs: {
            role: 'gridcell',
            title: yearData.title
          },
          key: yearData.content,
          on: {
            "click": clickHandler
          },
          "class": classNameMap
        }, [h("a", {
          "class": "".concat(prefixCls, "-year")
        }, [yearData.content])]);
      });
      return h("tr", {
        key: index,
        attrs: {
          role: 'row'
        }
      }, [tds]);
    });
    return h("div", {
      "class": prefixCls
    }, [h("div", [h("div", {
      "class": "".concat(prefixCls, "-header")
    }, [h("a", {
      "class": "".concat(prefixCls, "-prev-decade-btn"),
      attrs: {
        role: 'button',
        title: locale.previousDecade
      },
      on: {
        "click": this.previousDecade
      }
    }), h("a", {
      "class": "".concat(prefixCls, "-decade-select"),
      attrs: {
        role: 'button',
        title: locale.decadeSelect
      },
      on: {
        "click": decadePanelShow
      }
    }, [h("span", {
      "class": "".concat(prefixCls, "-decade-select-content")
    }, [startYear, "-", endYear]), h("span", {
      "class": "".concat(prefixCls, "-decade-select-arrow")
    }, ["x"])]), h("a", {
      "class": "".concat(prefixCls, "-next-decade-btn"),
      attrs: {
        role: 'button',
        title: locale.nextDecade
      },
      on: {
        "click": this.nextDecade
      }
    })]), h("div", {
      "class": "".concat(prefixCls, "-body")
    }, [h("table", {
      "class": "".concat(prefixCls, "-table"),
      attrs: {
        cellSpacing: '0',
        role: 'grid'
      }
    }, [h("tbody", {
      "class": "".concat(prefixCls, "-tbody")
    }, [yeasEls])])])])]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-calendar/src/decade/DecadePanel.jsx
function DecadePanel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var DecadePanel_ROW = 4;
var DecadePanel_COL = 3;

function DecadePanel_noop() {}

function DecadePanel_goYear(direction) {
  var next = this.sValue.clone();
  next.add(direction, 'years');
  this.setState({
    sValue: next
  });
}

function chooseDecade(year, event) {
  var next = this.sValue.clone();
  next.year(year);
  next.month(this.sValue.month());

  this.__emit('select', next);

  event.preventDefault();
}

/* harmony default export */ var DecadePanel = ({
  mixins: [BaseMixin["a" /* default */]],
  props: {
    locale: vue_types["a" /* default */].object,
    value: vue_types["a" /* default */].object,
    defaultValue: vue_types["a" /* default */].object,
    rootPrefixCls: vue_types["a" /* default */].string
  },
  data: function data() {
    this.nextCentury = DecadePanel_goYear.bind(this, 100);
    this.previousCentury = DecadePanel_goYear.bind(this, -100);
    return {
      sValue: this.value || this.defaultValue
    };
  },
  render: function render() {
    var _this = this;

    var h = arguments[0];
    var value = this.sValue;
    var locale = this.locale;
    var currentYear = value.year();
    var startYear = parseInt(currentYear / 100, 10) * 100;
    var preYear = startYear - 10;
    var endYear = startYear + 99;
    var decades = [];
    var index = 0;
    var prefixCls = "".concat(this.rootPrefixCls, "-decade-panel");

    for (var rowIndex = 0; rowIndex < DecadePanel_ROW; rowIndex++) {
      decades[rowIndex] = [];

      for (var colIndex = 0; colIndex < DecadePanel_COL; colIndex++) {
        var startDecade = preYear + index * 10;
        var endDecade = preYear + index * 10 + 9;
        decades[rowIndex][colIndex] = {
          startDecade: startDecade,
          endDecade: endDecade
        };
        index++;
      }
    }

    var decadesEls = decades.map(function (row, decadeIndex) {
      var tds = row.map(function (decadeData) {
        var _classNameMap;

        var dStartDecade = decadeData.startDecade;
        var dEndDecade = decadeData.endDecade;
        var isLast = dStartDecade < startYear;
        var isNext = dEndDecade > endYear;
        var classNameMap = (_classNameMap = {}, DecadePanel_defineProperty(_classNameMap, "".concat(prefixCls, "-cell"), 1), DecadePanel_defineProperty(_classNameMap, "".concat(prefixCls, "-selected-cell"), dStartDecade <= currentYear && currentYear <= dEndDecade), DecadePanel_defineProperty(_classNameMap, "".concat(prefixCls, "-last-century-cell"), isLast), DecadePanel_defineProperty(_classNameMap, "".concat(prefixCls, "-next-century-cell"), isNext), _classNameMap);
        var content = "".concat(dStartDecade, "-").concat(dEndDecade);
        var clickHandler = DecadePanel_noop;

        if (isLast) {
          clickHandler = _this.previousCentury;
        } else if (isNext) {
          clickHandler = _this.nextCentury;
        } else {
          clickHandler = chooseDecade.bind(_this, dStartDecade);
        }

        return h("td", {
          key: dStartDecade,
          on: {
            "click": clickHandler
          },
          attrs: {
            role: 'gridcell'
          },
          "class": classNameMap
        }, [h("a", {
          "class": "".concat(prefixCls, "-decade")
        }, [content])]);
      });
      return h("tr", {
        key: decadeIndex,
        attrs: {
          role: 'row'
        }
      }, [tds]);
    });
    return h("div", {
      "class": prefixCls
    }, [h("div", {
      "class": "".concat(prefixCls, "-header")
    }, [h("a", {
      "class": "".concat(prefixCls, "-prev-century-btn"),
      attrs: {
        role: 'button',
        title: locale.previousCentury
      },
      on: {
        "click": this.previousCentury
      }
    }), h("div", {
      "class": "".concat(prefixCls, "-century")
    }, [startYear, "-", endYear]), h("a", {
      "class": "".concat(prefixCls, "-next-century-btn"),
      attrs: {
        role: 'button',
        title: locale.nextCentury
      },
      on: {
        "click": this.nextCentury
      }
    })]), h("div", {
      "class": "".concat(prefixCls, "-body")
    }, [h("table", {
      "class": "".concat(prefixCls, "-table"),
      attrs: {
        cellSpacing: '0',
        role: 'grid'
      }
    }, [h("tbody", {
      "class": "".concat(prefixCls, "-tbody")
    }, [decadesEls])])])]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-calendar/src/calendar/CalendarHeader.jsx







function CalendarHeader_noop() {}

function goMonth(direction) {
  var next = this.value.clone();
  next.add(direction, 'months');

  this.__emit('valueChange', next);
}

function CalendarHeader_goYear(direction) {
  var next = this.value.clone();
  next.add(direction, 'years');

  this.__emit('valueChange', next);
}

function showIf(condition, el) {
  return condition ? el : null;
}

var CalendarHeader_CalendarHeader = {
  mixins: [BaseMixin["a" /* default */]],
  props: {
    prefixCls: vue_types["a" /* default */].string,
    value: vue_types["a" /* default */].object,
    // onValueChange: PropTypes.func,
    showTimePicker: vue_types["a" /* default */].bool,
    // onPanelChange: PropTypes.func,
    locale: vue_types["a" /* default */].object,
    enablePrev: vue_types["a" /* default */].any.def(1),
    enableNext: vue_types["a" /* default */].any.def(1),
    disabledMonth: vue_types["a" /* default */].func,
    mode: vue_types["a" /* default */].any,
    monthCellRender: vue_types["a" /* default */].func,
    monthCellContentRender: vue_types["a" /* default */].func
  },
  data: function data() {
    this.nextMonth = goMonth.bind(this, 1);
    this.previousMonth = goMonth.bind(this, -1);
    this.nextYear = CalendarHeader_goYear.bind(this, 1);
    this.previousYear = CalendarHeader_goYear.bind(this, -1);
    return {
      yearPanelReferer: null
    };
  },
  methods: {
    onMonthSelect: function onMonthSelect(value) {
      this.__emit('panelChange', value, 'date');

      if (this.$listeners.monthSelect) {
        this.__emit('monthSelect', value);
      } else {
        this.__emit('valueChange', value);
      }
    },
    onYearSelect: function onYearSelect(value) {
      var referer = this.yearPanelReferer;
      this.setState({
        yearPanelReferer: null
      });

      this.__emit('panelChange', value, referer);

      this.__emit('valueChange', value);
    },
    onDecadeSelect: function onDecadeSelect(value) {
      this.__emit('panelChange', value, 'year');

      this.__emit('valueChange', value);
    },
    monthYearElement: function monthYearElement(showTimePicker) {
      var _this = this;

      var h = this.$createElement;
      var props = this.$props;
      var prefixCls = props.prefixCls;
      var locale = props.locale;
      var value = props.value;
      var localeData = value.localeData();
      var monthBeforeYear = locale.monthBeforeYear;
      var selectClassName = "".concat(prefixCls, "-").concat(monthBeforeYear ? 'my-select' : 'ym-select');
      var year = h("a", {
        "class": "".concat(prefixCls, "-year-select"),
        attrs: {
          role: 'button',
          title: locale.yearSelect
        },
        on: {
          "click": showTimePicker ? CalendarHeader_noop : function () {
            return _this.showYearPanel('date');
          }
        }
      }, [value.format(locale.yearFormat)]);
      var month = h("a", {
        "class": "".concat(prefixCls, "-month-select"),
        attrs: {
          role: 'button',
          title: locale.monthSelect
        },
        on: {
          "click": showTimePicker ? CalendarHeader_noop : this.showMonthPanel
        }
      }, [locale.monthFormat ? value.format(locale.monthFormat) : localeData.monthsShort(value)]);
      var day;

      if (showTimePicker) {
        day = h("a", {
          "class": "".concat(prefixCls, "-day-select"),
          attrs: {
            role: 'button'
          }
        }, [value.format(locale.dayFormat)]);
      }

      var my = [];

      if (monthBeforeYear) {
        my = [month, day, year];
      } else {
        my = [year, month, day];
      }

      return h("span", {
        "class": selectClassName
      }, [my]);
    },
    showMonthPanel: function showMonthPanel() {
      // null means that users' interaction doesn't change value
      this.__emit('panelChange', null, 'month');
    },
    showYearPanel: function showYearPanel(referer) {
      this.setState({
        yearPanelReferer: referer
      });

      this.__emit('panelChange', null, 'year');
    },
    showDecadePanel: function showDecadePanel() {
      this.__emit('panelChange', null, 'decade');
    }
  },
  render: function render() {
    var _this2 = this;

    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var prefixCls = props.prefixCls,
        locale = props.locale,
        mode = props.mode,
        value = props.value,
        showTimePicker = props.showTimePicker,
        enableNext = props.enableNext,
        enablePrev = props.enablePrev,
        disabledMonth = props.disabledMonth;
    var panel = null;

    if (mode === 'month') {
      panel = h(month_MonthPanel, {
        attrs: {
          locale: locale,
          defaultValue: value,
          rootPrefixCls: prefixCls,
          disabledDate: disabledMonth,
          cellRender: props.monthCellRender,
          contentRender: props.monthCellContentRender
        },
        on: {
          "select": this.onMonthSelect,
          "yearPanelShow": function yearPanelShow() {
            return _this2.showYearPanel('month');
          }
        }
      });
    }

    if (mode === 'year') {
      panel = h(YearPanel, {
        attrs: {
          locale: locale,
          defaultValue: value,
          rootPrefixCls: prefixCls
        },
        on: {
          "select": this.onYearSelect,
          "decadePanelShow": this.showDecadePanel
        }
      });
    }

    if (mode === 'decade') {
      panel = h(DecadePanel, {
        attrs: {
          locale: locale,
          defaultValue: value,
          rootPrefixCls: prefixCls
        },
        on: {
          "select": this.onDecadeSelect
        }
      });
    }

    return h("div", {
      "class": "".concat(prefixCls, "-header")
    }, [h("div", {
      style: {
        position: 'relative'
      }
    }, [showIf(enablePrev && !showTimePicker, h("a", {
      "class": "".concat(prefixCls, "-prev-year-btn"),
      attrs: {
        role: 'button',
        title: locale.previousYear
      },
      on: {
        "click": this.previousYear
      }
    })), showIf(enablePrev && !showTimePicker, h("a", {
      "class": "".concat(prefixCls, "-prev-month-btn"),
      attrs: {
        role: 'button',
        title: locale.previousMonth
      },
      on: {
        "click": this.previousMonth
      }
    })), this.monthYearElement(showTimePicker), showIf(enableNext && !showTimePicker, h("a", {
      "class": "".concat(prefixCls, "-next-month-btn"),
      on: {
        "click": this.nextMonth
      },
      attrs: {
        title: locale.nextMonth
      }
    })), showIf(enableNext && !showTimePicker, h("a", {
      "class": "".concat(prefixCls, "-next-year-btn"),
      on: {
        "click": this.nextYear
      },
      attrs: {
        title: locale.nextYear
      }
    }))]), panel]);
  }
};
/* harmony default export */ var calendar_CalendarHeader = (CalendarHeader_CalendarHeader);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/calendar/TodayButton.jsx


function TodayButton_noop() {}

/* harmony default export */ var TodayButton = ({
  functional: true,
  render: function render(createElement, context) {
    var h = arguments[0];
    var props = context.props,
        _context$listeners = context.listeners,
        listeners = _context$listeners === void 0 ? {} : _context$listeners;
    var prefixCls = props.prefixCls,
        locale = props.locale,
        value = props.value,
        timePicker = props.timePicker,
        disabled = props.disabled,
        disabledDate = props.disabledDate,
        text = props.text;
    var _listeners$today = listeners.today,
        today = _listeners$today === void 0 ? TodayButton_noop : _listeners$today;
    var localeNow = (!text && timePicker ? locale.now : text) || locale.today;
    var disabledToday = disabledDate && !util_isAllowedDate(getTodayTime(value), disabledDate);
    var isDisabled = disabledToday || disabled;
    var disabledTodayClass = isDisabled ? "".concat(prefixCls, "-today-btn-disabled") : '';
    return h("a", {
      "class": "".concat(prefixCls, "-today-btn ").concat(disabledTodayClass),
      attrs: {
        role: 'button',
        title: getTodayTimeStr(value)
      },
      on: {
        "click": isDisabled ? TodayButton_noop : today
      }
    }, [localeNow]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-calendar/src/calendar/OkButton.jsx
function OkButton_noop() {}

/* harmony default export */ var OkButton = ({
  functional: true,
  render: function render(createElement, context) {
    var h = arguments[0];
    var props = context.props,
        _context$listeners = context.listeners,
        listeners = _context$listeners === void 0 ? {} : _context$listeners;
    var prefixCls = props.prefixCls,
        locale = props.locale,
        okDisabled = props.okDisabled;
    var _listeners$ok = listeners.ok,
        ok = _listeners$ok === void 0 ? OkButton_noop : _listeners$ok;
    var className = "".concat(prefixCls, "-ok-btn");

    if (okDisabled) {
      className += " ".concat(prefixCls, "-ok-btn-disabled");
    }

    return h("a", {
      "class": className,
      attrs: {
        role: 'button'
      },
      on: {
        "click": okDisabled ? OkButton_noop : ok
      }
    }, [locale.ok]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-calendar/src/calendar/TimePickerButton.jsx
function TimePickerButton_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function TimePickerButton_noop() {}

/* harmony default export */ var TimePickerButton = ({
  functional: true,
  render: function render(h, context) {
    var _className;

    var props = context.props,
        _context$listeners = context.listeners,
        listeners = _context$listeners === void 0 ? {} : _context$listeners;
    var prefixCls = props.prefixCls,
        locale = props.locale,
        showTimePicker = props.showTimePicker,
        timePickerDisabled = props.timePickerDisabled;
    var _listeners$closeTimeP = listeners.closeTimePicker,
        closeTimePicker = _listeners$closeTimeP === void 0 ? TimePickerButton_noop : _listeners$closeTimeP,
        _listeners$openTimePi = listeners.openTimePicker,
        openTimePicker = _listeners$openTimePi === void 0 ? TimePickerButton_noop : _listeners$openTimePi;
    var className = (_className = {}, TimePickerButton_defineProperty(_className, "".concat(prefixCls, "-time-picker-btn"), true), TimePickerButton_defineProperty(_className, "".concat(prefixCls, "-time-picker-btn-disabled"), timePickerDisabled), _className);
    var onClick = TimePickerButton_noop;

    if (!timePickerDisabled) {
      onClick = showTimePicker ? closeTimePicker : openTimePicker;
    }

    return h("a", {
      "class": className,
      attrs: {
        role: 'button'
      },
      on: {
        "click": onClick
      }
    }, [showTimePicker ? locale.dateSelect : locale.timeSelect]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-calendar/src/calendar/CalendarFooter.jsx
function CalendarFooter_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { CalendarFooter_defineProperty(target, key, source[key]); }); } return target; }

function CalendarFooter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var CalendarFooter = {
  mixins: [BaseMixin["a" /* default */]],
  props: {
    prefixCls: vue_types["a" /* default */].string,
    showDateInput: vue_types["a" /* default */].bool,
    disabledTime: vue_types["a" /* default */].any,
    timePicker: vue_types["a" /* default */].any,
    selectedValue: vue_types["a" /* default */].any,
    showOk: vue_types["a" /* default */].bool,
    // onSelect: PropTypes.func,
    value: vue_types["a" /* default */].object,
    renderFooter: vue_types["a" /* default */].func,
    defaultValue: vue_types["a" /* default */].object,
    locale: vue_types["a" /* default */].object,
    showToday: vue_types["a" /* default */].bool,
    disabledDate: vue_types["a" /* default */].func,
    showTimePicker: vue_types["a" /* default */].bool,
    okDisabled: vue_types["a" /* default */].bool
  },
  methods: {
    onSelect: function onSelect(value) {
      this.__emit('select', value);
    },
    getRootDOMNode: function getRootDOMNode() {
      return this.$el;
    }
  },
  render: function render() {
    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var $listeners = this.$listeners;
    var value = props.value,
        prefixCls = props.prefixCls,
        showOk = props.showOk,
        timePicker = props.timePicker,
        renderFooter = props.renderFooter,
        showToday = props.showToday;
    var footerEl = null;
    var extraFooter = renderFooter();

    if (showToday || timePicker || extraFooter) {
      var _cls;

      var btnProps = {
        props: CalendarFooter_objectSpread({}, props, {
          value: value
        }),
        on: $listeners
      };
      var nowEl = null;

      if (showToday) {
        nowEl = h(TodayButton, btnProps);
      }

      delete btnProps.props.value;
      var okBtn = null;

      if (showOk === true || showOk !== false && !!timePicker) {
        okBtn = h(OkButton, btnProps);
      }

      var timePickerBtn = null;

      if (timePicker) {
        timePickerBtn = h(TimePickerButton, btnProps);
      }

      var footerBtn;

      if (nowEl || timePickerBtn || okBtn) {
        footerBtn = h("span", {
          "class": "".concat(prefixCls, "-footer-btn")
        }, [nowEl, timePickerBtn, okBtn]);
      }

      var cls = (_cls = {}, CalendarFooter_defineProperty(_cls, "".concat(prefixCls, "-footer"), true), CalendarFooter_defineProperty(_cls, "".concat(prefixCls, "-footer-show-ok"), !!okBtn), _cls);
      footerEl = h("div", {
        "class": cls
      }, [extraFooter, footerBtn]);
    }

    return footerEl;
  }
};
/* harmony default export */ var calendar_CalendarFooter = (CalendarFooter);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/date/DateInput.jsx



var DateInput = {
  mixins: [BaseMixin["a" /* default */]],
  props: {
    prefixCls: vue_types["a" /* default */].string,
    timePicker: vue_types["a" /* default */].object,
    value: vue_types["a" /* default */].object,
    disabledTime: vue_types["a" /* default */].any,
    format: vue_types["a" /* default */].string,
    locale: vue_types["a" /* default */].object,
    disabledDate: vue_types["a" /* default */].func,
    // onChange: PropTypes.func,
    // onClear: PropTypes.func,
    placeholder: vue_types["a" /* default */].string,
    // onSelect: PropTypes.func,
    selectedValue: vue_types["a" /* default */].object
  },
  data: function data() {
    var selectedValue = this.selectedValue;
    return {
      str: selectedValue && selectedValue.format(this.format) || '',
      invalid: false
    };
  },
  watch: {
    selectedValue: function selectedValue() {
      this.updateState();
    },
    format: function format() {
      this.updateState();
    }
  },
  updated: function updated() {
    var _this = this;

    this.$nextTick(function () {
      if (!_this.invalid) {
        _this.$refs.dateInputInstance.setSelectionRange(_this.cachedSelectionStart, _this.cachedSelectionEnd);
      }
    });
  },
  methods: {
    updateState: function updateState() {
      this.cachedSelectionStart = this.$refs.dateInputInstance.selectionStart;
      this.cachedSelectionEnd = this.$refs.dateInputInstance.selectionEnd; // when popup show, click body will call this, bug!

      var selectedValue = this.selectedValue;
      this.setState({
        str: selectedValue && selectedValue.format(this.format) || '',
        invalid: false
      });
    },
    onInputChange: function onInputChange(event) {
      var str = event.target.value;
      this.setState({
        str: str
      });
      var value;
      var disabledDate = this.disabledDate,
          format = this.format;

      if (str) {
        var parsed = external_moment_default()(str, format, true);

        if (!parsed.isValid()) {
          this.setState({
            invalid: true
          });
          return;
        }

        value = this.value.clone();
        value.year(parsed.year()).month(parsed.month()).date(parsed.date()).hour(parsed.hour()).minute(parsed.minute()).second(parsed.second());

        if (value && (!disabledDate || !disabledDate(value))) {
          var originalValue = this.selectedValue;

          if (originalValue && value) {
            if (!originalValue.isSame(value)) {
              this.__emit('change', value);
            }
          } else if (originalValue !== value) {
            this.__emit('change', value);
          }
        } else {
          this.setState({
            invalid: true
          });
          return;
        }
      } else {
        this.__emit('change', null);
      }

      this.setState({
        invalid: false
      });
    },
    onClear: function onClear() {
      this.setState({
        str: ''
      });

      this.__emit('clear', null);
    },
    getRootDOMNode: function getRootDOMNode() {
      return this.$el;
    },
    focus: function focus() {
      if (this.$refs.dateInputInstance) {
        this.$refs.dateInputInstance.focus();
      }
    }
  },
  render: function render() {
    var h = arguments[0];
    var invalid = this.invalid,
        str = this.str,
        locale = this.locale,
        prefixCls = this.prefixCls,
        placeholder = this.placeholder,
        disabled = this.disabled,
        showClear = this.showClear;
    var invalidClass = invalid ? "".concat(prefixCls, "-input-invalid") : '';
    return h("div", {
      "class": "".concat(prefixCls, "-input-wrap")
    }, [h("div", {
      "class": "".concat(prefixCls, "-date-input-wrap")
    }, [h("input", {
      ref: 'dateInputInstance',
      "class": "".concat(prefixCls, "-input ").concat(invalidClass),
      domProps: {
        "value": str
      },
      attrs: {
        disabled: disabled,
        placeholder: placeholder
      },
      on: {
        "input": this.onInputChange
      }
    })]), showClear ? h("a", {
      "class": "".concat(prefixCls, "-clear-btn"),
      attrs: {
        role: 'button',
        title: locale.clear
      },
      on: {
        "click": this.onClear
      }
    }) : null]);
  }
};
/* harmony default export */ var date_DateInput = (DateInput);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/util/toTime.js
function goStartMonth(time) {
  return time.clone().startOf('month');
}
function goEndMonth(time) {
  return time.clone().endOf('month');
}
function toTime_goTime(time, direction, unit) {
  return time.clone().add(direction, unit);
}
function includesTime() {
  var timeList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var time = arguments.length > 1 ? arguments[1] : undefined;
  var unit = arguments.length > 2 ? arguments[2] : undefined;
  return timeList.some(function (t) {
    return t.isSame(time, unit);
  });
}
// CONCATENATED MODULE: ./src/components/vc-calendar/src/Calendar.jsx
function Calendar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Calendar_defineProperty(target, key, source[key]); }); } return target; }

function Calendar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
















external_moment_["locale"]('zh-cn');

function Calendar_isMoment(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || value.findIndex(function (val) {
      return val === undefined || external_moment_["isMoment"](val);
    }) !== -1;
  } else {
    return value === undefined || external_moment_["isMoment"](value);
  }
}

var Calendar_MomentType = vue_types["a" /* default */].custom(Calendar_isMoment);
var Calendar_Calendar = {
  props: {
    locale: vue_types["a" /* default */].object.def(zh_CN),
    format: vue_types["a" /* default */].string,
    visible: vue_types["a" /* default */].bool.def(true),
    prefixCls: vue_types["a" /* default */].string.def('rc-calendar'),
    // prefixCls: PropTypes.string,
    defaultValue: Calendar_MomentType,
    value: Calendar_MomentType,
    selectedValue: Calendar_MomentType,
    mode: vue_types["a" /* default */].oneOf(['time', 'date', 'month', 'year', 'decade']),
    // locale: PropTypes.object,
    showDateInput: vue_types["a" /* default */].bool.def(true),
    showWeekNumber: vue_types["a" /* default */].bool,
    showToday: vue_types["a" /* default */].bool.def(true),
    showOk: vue_types["a" /* default */].bool,
    // onSelect: PropTypes.func,
    // onOk: PropTypes.func,
    // onKeyDown: PropTypes.func,
    timePicker: vue_types["a" /* default */].any,
    dateInputPlaceholder: vue_types["a" /* default */].any,
    // onClear: PropTypes.func,
    // onChange: PropTypes.func,
    // onPanelChange: PropTypes.func,
    disabledDate: vue_types["a" /* default */].func,
    disabledTime: vue_types["a" /* default */].any,
    renderFooter: vue_types["a" /* default */].func.def(function () {
      return null;
    }),
    renderSidebar: vue_types["a" /* default */].func.def(function () {
      return null;
    }),
    dateRender: vue_types["a" /* default */].func
  },
  mixins: [BaseMixin["a" /* default */], CommonMixin, mixin_CalendarMixin],
  data: function data() {
    return {
      sMode: this.mode || 'date'
    };
  },
  watch: {
    mode: function mode(val) {
      this.setState({
        sMode: val
      });
    }
  },
  methods: {
    onKeyDown: function onKeyDown(event) {
      if (event.target.nodeName.toLowerCase() === 'input') {
        return undefined;
      }

      var keyCode = event.keyCode; // mac

      var ctrlKey = event.ctrlKey || event.metaKey;
      var disabledDate = this.disabledDate,
          value = this.sValue;

      switch (keyCode) {
        case _util_KeyCode.DOWN:
          this.goTime(1, 'weeks');
          event.preventDefault();
          return 1;

        case _util_KeyCode.UP:
          this.goTime(-1, 'weeks');
          event.preventDefault();
          return 1;

        case _util_KeyCode.LEFT:
          if (ctrlKey) {
            this.goTime(-1, 'years');
          } else {
            this.goTime(-1, 'days');
          }

          event.preventDefault();
          return 1;

        case _util_KeyCode.RIGHT:
          if (ctrlKey) {
            this.goTime(1, 'years');
          } else {
            this.goTime(1, 'days');
          }

          event.preventDefault();
          return 1;

        case _util_KeyCode.HOME:
          this.setValue(goStartMonth(value));
          event.preventDefault();
          return 1;

        case _util_KeyCode.END:
          this.setValue(goEndMonth(value));
          event.preventDefault();
          return 1;

        case _util_KeyCode.PAGE_DOWN:
          this.goTime(1, 'month');
          event.preventDefault();
          return 1;

        case _util_KeyCode.PAGE_UP:
          this.goTime(-1, 'month');
          event.preventDefault();
          return 1;

        case _util_KeyCode.ENTER:
          if (!disabledDate || !disabledDate(value)) {
            this.onSelect(value, {
              source: 'keyboard'
            });
          }

          event.preventDefault();
          return 1;

        default:
          this.__emit('keydown', event);

          return 1;
      }
    },
    onClear: function onClear() {
      this.onSelect(null);

      this.__emit('clear');
    },
    onOk: function onOk() {
      var sSelectedValue = this.sSelectedValue;

      if (this.isAllowedDate(sSelectedValue)) {
        this.__emit('ok', sSelectedValue);
      }
    },
    onDateInputChange: function onDateInputChange(value) {
      this.onSelect(value, {
        source: 'dateInput'
      });
    },
    onDateTableSelect: function onDateTableSelect(value) {
      var timePicker = this.timePicker,
          sSelectedValue = this.sSelectedValue;

      if (!sSelectedValue && timePicker) {
        var timePickerProps = Object(props_util["j" /* getOptionProps */])(timePicker);
        var timePickerDefaultValue = timePickerProps.defaultValue;

        if (timePickerDefaultValue) {
          syncTime(timePickerDefaultValue, value);
        }
      }

      this.onSelect(value);
    },
    onToday: function onToday() {
      var sValue = this.sValue;
      var now = getTodayTime(sValue);
      this.onSelect(now, {
        source: 'todayButton'
      });
    },
    onPanelChange: function onPanelChange(value, mode) {
      var sValue = this.sValue;

      if (!Object(props_util["p" /* hasProp */])(this, 'mode')) {
        this.setState({
          sMode: mode
        });
      }

      this.__emit('panelChange', value || sValue, mode);
    },
    getRootDOMNode: function getRootDOMNode() {
      return this.$el;
    },
    openTimePicker: function openTimePicker() {
      this.onPanelChange(null, 'time');
    },
    closeTimePicker: function closeTimePicker() {
      this.onPanelChange(null, 'date');
    },
    goTime: function goTime(direction, unit) {
      this.setValue(toTime_goTime(this.sValue, direction, unit));
    }
  },
  render: function render() {
    var h = arguments[0];
    var locale = this.locale,
        prefixCls = this.prefixCls,
        disabledDate = this.disabledDate,
        dateInputPlaceholder = this.dateInputPlaceholder,
        timePicker = this.timePicker,
        disabledTime = this.disabledTime,
        showDateInput = this.showDateInput,
        renderSidebar = this.renderSidebar,
        sValue = this.sValue,
        sSelectedValue = this.sSelectedValue,
        sMode = this.sMode,
        props = this.$props;
    var showTimePicker = sMode === 'time';
    var disabledTimeConfig = showTimePicker && disabledTime && timePicker ? getTimeConfig(sSelectedValue, disabledTime) : null;
    var timePickerEle = null;

    if (timePicker && showTimePicker) {
      var timePickerOriginProps = Object(props_util["j" /* getOptionProps */])(timePicker);
      var timePickerProps = {
        props: Calendar_objectSpread({
          showHour: true,
          showSecond: true,
          showMinute: true
        }, timePickerOriginProps, disabledTimeConfig, {
          value: sSelectedValue,
          disabledTime: disabledTime
        }),
        on: {
          change: this.onDateInputChange
        }
      };

      if (timePickerOriginProps.defaultValue !== undefined) {
        timePickerProps.props.defaultOpenValue = timePickerOriginProps.defaultValue;
      }

      timePickerEle = Object(vnode["a" /* cloneElement */])(timePicker, timePickerProps);
    }

    var dateInputElement = showDateInput ? h(date_DateInput, {
      attrs: {
        format: this.getFormat(),
        value: sValue,
        locale: locale,
        placeholder: dateInputPlaceholder,
        showClear: true,
        disabledTime: disabledTime,
        disabledDate: disabledDate,
        prefixCls: prefixCls,
        selectedValue: sSelectedValue
      },
      key: 'date-input',
      on: {
        "clear": this.onClear,
        "change": this.onDateInputChange
      }
    }) : null;
    var children = [renderSidebar(), h("div", {
      "class": "".concat(prefixCls, "-panel"),
      key: 'panel'
    }, [dateInputElement, h("div", {
      "class": "".concat(prefixCls, "-date-panel")
    }, [h(calendar_CalendarHeader, {
      attrs: {
        locale: locale,
        mode: sMode,
        value: sValue,
        showTimePicker: showTimePicker,
        prefixCls: prefixCls
      },
      on: {
        "valueChange": this.setValue,
        "panelChange": this.onPanelChange
      }
    }), timePicker && showTimePicker ? h("div", {
      "class": "".concat(prefixCls, "-time-picker")
    }, [h("div", {
      "class": "".concat(prefixCls, "-time-picker-panel")
    }, [timePickerEle])]) : null, h("div", {
      "class": "".concat(prefixCls, "-body")
    }, [h(DateTable, {
      attrs: {
        locale: locale,
        value: sValue,
        selectedValue: sSelectedValue,
        prefixCls: prefixCls,
        dateRender: props.dateRender,
        disabledDate: disabledDate,
        showWeekNumber: props.showWeekNumber
      },
      on: {
        "select": this.onDateTableSelect
      }
    })]), h(calendar_CalendarFooter, {
      attrs: {
        showOk: props.showOk,
        renderFooter: props.renderFooter,
        locale: locale,
        prefixCls: prefixCls,
        showToday: props.showToday,
        disabledTime: disabledTime,
        showTimePicker: showTimePicker,
        showDateInput: props.showDateInput,
        timePicker: timePicker,
        selectedValue: sSelectedValue,
        value: sValue,
        disabledDate: disabledDate,
        okDisabled: !this.isAllowedDate(sSelectedValue)
      },
      on: {
        "ok": this.onOk,
        "select": this.onSelect,
        "today": this.onToday,
        "openTimePicker": this.openTimePicker,
        "closeTimePicker": this.closeTimePicker
      }
    })])])];
    return this.renderRoot({
      children: children,
      "class": props.showWeekNumber ? "".concat(prefixCls, "-week-number") : ''
    });
  }
};
/* harmony default export */ var src_Calendar = (Calendar_Calendar);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/index.js

/* harmony default export */ var vc_calendar_src = (src_Calendar);
// CONCATENATED MODULE: ./src/components/vc-calendar/index.js
// based on rc-calendar 9.6.2

/* harmony default export */ var vc_calendar = (vc_calendar_src);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/MonthCalendar.jsx








var MonthCalendar = {
  props: {
    locale: vue_types["a" /* default */].object.def(zh_CN),
    format: vue_types["a" /* default */].string,
    visible: vue_types["a" /* default */].bool.def(true),
    prefixCls: vue_types["a" /* default */].string.def('rc-calendar'),
    monthCellRender: vue_types["a" /* default */].func,
    dateCellRender: vue_types["a" /* default */].func,
    disabledDate: vue_types["a" /* default */].func,
    monthCellContentRender: vue_types["a" /* default */].func,
    renderFooter: vue_types["a" /* default */].func.def(function () {
      return null;
    }),
    renderSidebar: vue_types["a" /* default */].func.def(function () {
      return null;
    })
  },
  mixins: [BaseMixin["a" /* default */], CommonMixin, mixin_CalendarMixin],
  data: function data() {
    return {
      mode: 'month'
    };
  },
  methods: {
    onKeyDown: function onKeyDown(event) {
      var keyCode = event.keyCode;
      var ctrlKey = event.ctrlKey || event.metaKey;
      var stateValue = this.sValue;
      var disabledDate = this.disabledDate;
      var value = stateValue;

      switch (keyCode) {
        case _util_KeyCode.DOWN:
          value = stateValue.clone();
          value.add(3, 'months');
          break;

        case _util_KeyCode.UP:
          value = stateValue.clone();
          value.add(-3, 'months');
          break;

        case _util_KeyCode.LEFT:
          value = stateValue.clone();

          if (ctrlKey) {
            value.add(-1, 'years');
          } else {
            value.add(-1, 'months');
          }

          break;

        case _util_KeyCode.RIGHT:
          value = stateValue.clone();

          if (ctrlKey) {
            value.add(1, 'years');
          } else {
            value.add(1, 'months');
          }

          break;

        case _util_KeyCode.ENTER:
          if (!disabledDate || !disabledDate(stateValue)) {
            this.onSelect(stateValue);
          }

          event.preventDefault();
          return 1;

        default:
          return undefined;
      }

      if (value !== stateValue) {
        this.setValue(value);
        event.preventDefault();
        return 1;
      }
    },
    handlePanelChange: function handlePanelChange(_, mode) {
      if (mode !== 'date') {
        this.setState({
          mode: mode
        });
      }
    }
  },
  render: function render() {
    var h = arguments[0];
    var mode = this.mode,
        value = this.sValue,
        props = this.$props,
        $scopedSlots = this.$scopedSlots;
    var prefixCls = props.prefixCls,
        locale = props.locale,
        disabledDate = props.disabledDate;
    var monthCellRender = this.monthCellRender || $scopedSlots.monthCellRender;
    var monthCellContentRender = this.monthCellContentRender || $scopedSlots.monthCellContentRender;
    var renderFooter = this.renderFooter || $scopedSlots.renderFooter;
    var children = h("div", {
      "class": "".concat(prefixCls, "-month-calendar-content")
    }, [h("div", {
      "class": "".concat(prefixCls, "-month-header-wrap")
    }, [h(calendar_CalendarHeader, {
      attrs: {
        prefixCls: prefixCls,
        mode: mode,
        value: value,
        locale: locale,
        disabledMonth: disabledDate,
        monthCellRender: monthCellRender,
        monthCellContentRender: monthCellContentRender
      },
      on: {
        "monthSelect": this.onSelect,
        "valueChange": this.setValue,
        "panelChange": this.handlePanelChange
      }
    })]), h(calendar_CalendarFooter, {
      attrs: {
        prefixCls: prefixCls,
        renderFooter: renderFooter
      }
    })]);
    return this.renderRoot({
      "class": "".concat(props.prefixCls, "-month-calendar"),
      children: children
    });
  }
};
/* harmony default export */ var src_MonthCalendar = (MonthCalendar);
// EXTERNAL MODULE: ./node_modules/lodash/omit.js
var omit = __webpack_require__(191);
var omit_default = /*#__PURE__*/__webpack_require__.n(omit);

// CONCATENATED MODULE: ./src/components/_util/createChainedFunction.js
/**
 * Safe chained function
 *
 * Will only create a new function if needed,
 * otherwise will pass back existing functions or null.
 *
 * @returns {function|null}
 */
function createChainedFunction() {
  var args = [].slice.call(arguments, 0);

  if (args.length === 1) {
    return args[0];
  }

  return function chainedFunction() {
    for (var i = 0; i < args.length; i++) {
      if (args[i] && args[i].apply) {
        args[i].apply(this, arguments);
      }
    }
  };
}
// CONCATENATED MODULE: ./src/components/vc-calendar/src/picker/placements.js
var picker_placements_autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var placements_targetOffset = [0, 0];
var placements_placements = {
  bottomLeft: {
    points: ['tl', 'tl'],
    overflow: picker_placements_autoAdjustOverflow,
    offset: [0, -3],
    targetOffset: placements_targetOffset
  },
  bottomRight: {
    points: ['tr', 'tr'],
    overflow: picker_placements_autoAdjustOverflow,
    offset: [0, -3],
    targetOffset: placements_targetOffset
  },
  topRight: {
    points: ['br', 'br'],
    overflow: picker_placements_autoAdjustOverflow,
    offset: [0, 3],
    targetOffset: placements_targetOffset
  },
  topLeft: {
    points: ['bl', 'bl'],
    overflow: picker_placements_autoAdjustOverflow,
    offset: [0, 3],
    targetOffset: placements_targetOffset
  }
};
/* harmony default export */ var picker_placements = (placements_placements);
// EXTERNAL MODULE: ./node_modules/timers-browserify/main.js
var main = __webpack_require__(409);

// CONCATENATED MODULE: ./src/components/vc-calendar/src/Picker.jsx











function Picker_isMoment(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || value.findIndex(function (val) {
      return val === undefined || external_moment_default.a.isMoment(val);
    }) !== -1;
  } else {
    return value === undefined || external_moment_default.a.isMoment(value);
  }
}

var Picker_MomentType = vue_types["a" /* default */].custom(Picker_isMoment);
var Picker_Picker = {
  props: {
    animation: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].func, vue_types["a" /* default */].string]),
    disabled: vue_types["a" /* default */].bool,
    transitionName: vue_types["a" /* default */].string,
    format: vue_types["a" /* default */].string,
    // onChange: PropTypes.func,
    // onOpenChange: PropTypes.func,
    children: vue_types["a" /* default */].func,
    getCalendarContainer: vue_types["a" /* default */].func,
    calendar: vue_types["a" /* default */].any,
    open: vue_types["a" /* default */].bool,
    defaultOpen: vue_types["a" /* default */].bool.def(false),
    prefixCls: vue_types["a" /* default */].string.def('rc-calendar-picker'),
    placement: vue_types["a" /* default */].any.def('bottomLeft'),
    value: vue_types["a" /* default */].oneOfType([Picker_MomentType, vue_types["a" /* default */].arrayOf(Picker_MomentType)]),
    defaultValue: vue_types["a" /* default */].oneOfType([Picker_MomentType, vue_types["a" /* default */].arrayOf(Picker_MomentType)]),
    align: vue_types["a" /* default */].object.def({}),
    dropdownClassName: vue_types["a" /* default */].string
  },
  mixins: [BaseMixin["a" /* default */]],
  data: function data() {
    var props = this.$props;
    var open;

    if (Object(props_util["p" /* hasProp */])(this, 'open')) {
      open = props.open;
    } else {
      open = props.defaultOpen;
    }

    var value = props.value || props.defaultValue;
    return {
      sOpen: open,
      sValue: value
    };
  },
  watch: {
    value: function value(val) {
      this.setState({
        sValue: val
      });
    },
    open: function open(val) {
      this.setState({
        sOpen: val
      });
    }
  },
  mounted: function mounted() {
    this.preSOpen = this.sOpen;
  },
  updated: function updated() {
    if (!this.preSOpen && this.sOpen) {
      // setTimeout is for making sure saveCalendarRef happen before focusCalendar
      this.focusTimeout = Object(main["setTimeout"])(this.focusCalendar, 0);
    }

    this.preSOpen = this.sOpen;
  },
  beforeDestroy: function beforeDestroy() {
    clearTimeout(this.focusTimeout);
  },
  methods: {
    onCalendarKeyDown: function onCalendarKeyDown(event) {
      if (event.keyCode === _util_KeyCode.ESC) {
        event.stopPropagation();
        this.closeCalendar(this.focus);
      }
    },
    onCalendarSelect: function onCalendarSelect(value) {
      var cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var props = this.$props;

      if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
        this.setState({
          sValue: value
        });
      }

      var calendarProps = Object(props_util["j" /* getOptionProps */])(props.calendar);

      if (cause.source === 'keyboard' || !calendarProps.timePicker && cause.source !== 'dateInput' || cause.source === 'todayButton') {
        this.closeCalendar(this.focus);
      }

      this.__emit('change', value);
    },
    onKeyDown: function onKeyDown(event) {
      if (event.keyCode === _util_KeyCode.DOWN && !this.sOpen) {
        this.openCalendar();
        event.preventDefault();
      }
    },
    onCalendarOk: function onCalendarOk() {
      this.closeCalendar(this.focus);
    },
    onCalendarClear: function onCalendarClear() {
      this.closeCalendar(this.focus);
    },
    onVisibleChange: function onVisibleChange(open) {
      this.setOpen(open);
    },
    getCalendarElement: function getCalendarElement() {
      var props = this.$props;
      var calendarProps = Object(props_util["j" /* getOptionProps */])(props.calendar);
      var calendarEvents = Object(props_util["h" /* getEvents */])(props.calendar);
      var value = this.sValue;
      var defaultValue = value;
      var extraProps = {
        ref: 'calendarInstance',
        props: {
          defaultValue: defaultValue || calendarProps.defaultValue,
          selectedValue: value
        },
        on: {
          keydown: this.onCalendarKeyDown,
          ok: createChainedFunction(calendarEvents.ok, this.onCalendarOk),
          select: createChainedFunction(calendarEvents.select, this.onCalendarSelect),
          clear: createChainedFunction(calendarEvents.clear, this.onCalendarClear)
        }
      };
      return Object(vnode["a" /* cloneElement */])(props.calendar, extraProps);
    },
    setOpen: function setOpen(open, callback) {
      if (this.sOpen !== open) {
        if (!Object(props_util["p" /* hasProp */])(this, 'open')) {
          this.setState({
            sOpen: open
          }, callback);
        }

        this.__emit('openChange', open);
      }
    },
    openCalendar: function openCalendar(callback) {
      this.setOpen(true, callback);
    },
    closeCalendar: function closeCalendar(callback) {
      this.setOpen(false, callback);
    },
    focus: function focus() {
      if (!this.sOpen) {
        this.$el.focus();
      }
    },
    focusCalendar: function focusCalendar() {
      if (this.sOpen && this.calendarInstance && this.calendarInstance.componentInstance) {
        this.calendarInstance.componentInstance.focus();
      }
    }
  },
  render: function render() {
    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var style = Object(props_util["n" /* getStyle */])(this);
    var prefixCls = props.prefixCls,
        placement = props.placement,
        getCalendarContainer = props.getCalendarContainer,
        align = props.align,
        animation = props.animation,
        disabled = props.disabled,
        dropdownClassName = props.dropdownClassName,
        transitionName = props.transitionName;
    var sValue = this.sValue,
        sOpen = this.sOpen;
    var children = this.$scopedSlots["default"];
    var childrenState = {
      value: sValue,
      open: sOpen
    };

    if (this.sOpen || !this.calendarInstance) {
      this.calendarInstance = this.getCalendarElement();
    }

    return h(components_trigger, {
      attrs: {
        popupAlign: align,
        builtinPlacements: picker_placements,
        popupPlacement: placement,
        action: disabled && !sOpen ? [] : ['click'],
        destroyPopupOnHide: true,
        getPopupContainer: getCalendarContainer,
        popupStyle: style,
        popupAnimation: animation,
        popupTransitionName: transitionName,
        popupVisible: sOpen,
        prefixCls: prefixCls,
        popupClassName: dropdownClassName
      },
      on: {
        "popupVisibleChange": this.onVisibleChange
      }
    }, [h("template", {
      slot: 'popup'
    }, [this.calendarInstance]), Object(vnode["a" /* cloneElement */])(children(childrenState, props), {
      on: {
        keydown: this.onKeyDown
      }
    })]);
  }
};
/* harmony default export */ var src_Picker = (Picker_Picker);
// CONCATENATED MODULE: ./src/components/date-picker/createPicker.js
function createPicker_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      createPicker_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function createPicker_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}









 // export const PickerProps = {
//   value?: moment.Moment;
//   prefixCls: string;
// }

function createPicker_noop() {}

function createPicker(TheCalendar, props) {
  return {
    // static defaultProps = {
    //   prefixCls: 'ant-calendar',
    //   allowClear: true,
    //   showToday: true,
    // };
    // private input: any;
    props: Object(props_util["q" /* initDefaultProps */])(props, {
      prefixCls: 'ant-calendar',
      allowClear: true,
      showToday: true
    }),
    mixins: [BaseMixin["a" /* default */]],
    model: {
      prop: 'value',
      event: 'change'
    },
    data: function data() {
      var value = this.value || this.defaultValue;

      if (value && !interopDefault(external_moment_).isMoment(value)) {
        throw new Error('The value/defaultValue of DatePicker or MonthPicker must be ' + 'a moment object');
      }

      return {
        sValue: value,
        showDate: value
      };
    },
    watch: {
      value: function value(val) {
        this.setState({
          sValue: val,
          showDate: val
        });
      }
    },
    methods: {
      renderFooter: function renderFooter() {
        var h = this.$createElement;
        var prefixCls = this.prefixCls,
            $scopedSlots = this.$scopedSlots,
            $slots = this.$slots;
        var renderExtraFooter = this.renderExtraFooter || $scopedSlots.renderExtraFooter || $slots.renderExtraFooter;
        return renderExtraFooter ? h("div", {
          "class": "".concat(prefixCls, "-footer-extra")
        }, [typeof renderExtraFooter === 'function' ? renderExtraFooter.apply(void 0, arguments) : renderExtraFooter]) : null;
      },
      clearSelection: function clearSelection(e) {
        e.preventDefault();
        e.stopPropagation();
        this.handleChange(null);
      },
      handleChange: function handleChange(value) {
        if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
          this.setState({
            sValue: value,
            showDate: value
          });
        }

        this.$emit('change', value, value && value.format(this.format) || '');
      },
      handleCalendarChange: function handleCalendarChange(value) {
        this.setState({
          showDate: value
        });
      },
      focus: function focus() {
        this.$refs.input.focus();
      },
      blur: function blur() {
        this.$refs.input.blur();
      },
      onMouseEnter: function onMouseEnter(e) {
        this.$emit('mouseenter', e);
      },
      onMouseLeave: function onMouseLeave(e) {
        this.$emit('mouseleave', e);
      }
    },
    render: function render() {
      var _classNames;

      var h = arguments[0];
      var value = this.sValue,
          showDate = this.showDate,
          $listeners = this.$listeners,
          $scopedSlots = this.$scopedSlots;
      var _$listeners$panelChan = $listeners.panelChange,
          panelChange = _$listeners$panelChan === void 0 ? createPicker_noop : _$listeners$panelChan,
          _$listeners$focus = $listeners.focus,
          focus = _$listeners$focus === void 0 ? createPicker_noop : _$listeners$focus,
          _$listeners$blur = $listeners.blur,
          blur = _$listeners$blur === void 0 ? createPicker_noop : _$listeners$blur,
          _$listeners$ok = $listeners.ok,
          ok = _$listeners$ok === void 0 ? createPicker_noop : _$listeners$ok;
      var props = Object(props_util["j" /* getOptionProps */])(this);
      var prefixCls = props.prefixCls,
          locale = props.locale,
          localeCode = props.localeCode;
      var dateRender = props.dateRender || $scopedSlots.dateRender;
      var monthCellContentRender = props.monthCellContentRender || $scopedSlots.monthCellContentRender;
      var placeholder = 'placeholder' in props ? props.placeholder : locale.lang.placeholder;
      var disabledTime = props.showTime ? props.disabledTime : null;
      var calendarClassName = classnames_default()((_classNames = {}, createPicker_defineProperty(_classNames, "".concat(prefixCls, "-time"), props.showTime), createPicker_defineProperty(_classNames, "".concat(prefixCls, "-month"), src_MonthCalendar === TheCalendar), _classNames));

      if (value && localeCode) {
        value.locale(localeCode);
      }

      var pickerProps = {
        props: {},
        on: {}
      };
      var calendarProps = {
        props: {},
        on: {}
      };

      if (props.showTime) {
        // fix https://github.com/ant-design/ant-design/issues/1902
        calendarProps.on.select = this.handleChange;
      } else {
        pickerProps.on.change = this.handleChange;
      }

      if ('mode' in props) {
        calendarProps.props.mode = props.mode;
      }

      var theCalendarProps = Object(props_util["t" /* mergeProps */])(calendarProps, {
        props: {
          disabledDate: props.disabledDate,
          disabledTime: disabledTime,
          locale: locale.lang,
          timePicker: props.timePicker,
          defaultValue: props.defaultPickerValue || interopDefault(external_moment_)(),
          dateInputPlaceholder: placeholder,
          prefixCls: prefixCls,
          dateRender: dateRender,
          format: props.format,
          showToday: props.showToday,
          monthCellContentRender: monthCellContentRender,
          renderFooter: this.renderFooter,
          value: showDate
        },
        on: {
          ok: ok,
          panelChange: panelChange,
          change: this.handleCalendarChange
        },
        "class": calendarClassName,
        scopedSlots: $scopedSlots
      });
      var calendar = h(TheCalendar, theCalendarProps);
      var clearIcon = !props.disabled && props.allowClear && value ? h(components_icon, {
        attrs: {
          type: 'cross-circle'
        },
        "class": "".concat(prefixCls, "-picker-clear"),
        on: {
          "click": this.clearSelection
        }
      }) : null;

      var input = function input(_ref) {
        var inputValue = _ref.value;
        return h("div", [h("input", {
          ref: 'input',
          attrs: {
            disabled: props.disabled,
            readOnly: true,
            placeholder: placeholder
          },
          on: {
            "focus": focus,
            "blur": blur
          },
          domProps: {
            "value": inputValue && inputValue.format(props.format) || ''
          },
          "class": props.pickerInputClass
        }), clearIcon, h("span", {
          "class": "".concat(prefixCls, "-picker-icon")
        })]);
      };

      var vcDatePickerProps = {
        props: createPicker_objectSpread({}, props, pickerProps.props, {
          calendar: calendar,
          value: value,
          prefixCls: "".concat(prefixCls, "-picker-container")
        }),
        on: createPicker_objectSpread({}, omit_default()($listeners, 'change'), pickerProps.on),
        style: props.popupStyle
      };
      return h("span", {
        "class": props.pickerClass // tabIndex={props.disabled ? -1 : 0}
        // onFocus={focus}
        // onBlur={blur}
        ,
        on: {
          "mouseenter": this.onMouseEnter,
          "mouseleave": this.onMouseLeave
        }
      }, [h(src_Picker, vcDatePickerProps, [input])]);
    }
  };
}
// CONCATENATED MODULE: ./src/components/vc-time-picker/Header.jsx



var Header_Header = {
  mixins: [BaseMixin["a" /* default */]],
  props: {
    format: vue_types["a" /* default */].string,
    prefixCls: vue_types["a" /* default */].string,
    disabledDate: vue_types["a" /* default */].func,
    placeholder: vue_types["a" /* default */].string,
    clearText: vue_types["a" /* default */].string,
    value: vue_types["a" /* default */].object,
    inputReadOnly: vue_types["a" /* default */].bool.def(false),
    hourOptions: vue_types["a" /* default */].array,
    minuteOptions: vue_types["a" /* default */].array,
    secondOptions: vue_types["a" /* default */].array,
    disabledHours: vue_types["a" /* default */].func,
    disabledMinutes: vue_types["a" /* default */].func,
    disabledSeconds: vue_types["a" /* default */].func,
    // onChange: PropTypes.func,
    // onClear: PropTypes.func,
    // onEsc: PropTypes.func,
    allowEmpty: vue_types["a" /* default */].bool,
    defaultOpenValue: vue_types["a" /* default */].object,
    currentSelectPanel: vue_types["a" /* default */].string,
    focusOnOpen: vue_types["a" /* default */].bool,
    // onKeyDown: PropTypes.func,
    showStr: vue_types["a" /* default */].bool.def(true)
  },
  data: function data() {
    var value = this.value,
        format = this.format;
    return {
      str: value && value.format(format) || '',
      invalid: false
    };
  },
  mounted: function mounted() {
    var _this = this;

    if (this.focusOnOpen) {
      // Wait one frame for the panel to be positioned before focusing
      var requestAnimationFrame = window.requestAnimationFrame || window.setTimeout;
      requestAnimationFrame(function () {
        _this.$refs.input.focus();

        _this.$refs.input.select();
      });
    }
  },
  watch: {
    '$props': {
      handler: function handler(nextProps) {
        var value = nextProps.value,
            format = nextProps.format;
        this.setState({
          str: value && value.format(format) || '',
          invalid: false
        });
      },
      deep: true
    }
  },
  methods: {
    onInputChange: function onInputChange(event) {
      var str = event.target.value;
      this.showStr = true;
      this.setState({
        str: str
      });
      var format = this.format,
          hourOptions = this.hourOptions,
          minuteOptions = this.minuteOptions,
          secondOptions = this.secondOptions,
          disabledHours = this.disabledHours,
          disabledMinutes = this.disabledMinutes,
          disabledSeconds = this.disabledSeconds,
          allowEmpty = this.allowEmpty,
          originalValue = this.value;

      if (str) {
        var value = this.getProtoValue().clone();
        var parsed = external_moment_default()(str, format, true);

        if (!parsed.isValid()) {
          this.setState({
            invalid: true
          });
          return;
        }

        value.hour(parsed.hour()).minute(parsed.minute()).second(parsed.second()); // if time value not allowed, response warning.

        if (hourOptions.indexOf(value.hour()) < 0 || minuteOptions.indexOf(value.minute()) < 0 || secondOptions.indexOf(value.second()) < 0) {
          this.setState({
            invalid: true
          });
          return;
        } // if time value is disabled, response warning.


        var disabledHourOptions = disabledHours();
        var disabledMinuteOptions = disabledMinutes(value.hour());
        var disabledSecondOptions = disabledSeconds(value.hour(), value.minute());

        if (disabledHourOptions && disabledHourOptions.indexOf(value.hour()) >= 0 || disabledMinuteOptions && disabledMinuteOptions.indexOf(value.minute()) >= 0 || disabledSecondOptions && disabledSecondOptions.indexOf(value.second()) >= 0) {
          this.setState({
            invalid: true
          });
          return;
        }

        if (originalValue) {
          if (originalValue.hour() !== value.hour() || originalValue.minute() !== value.minute() || originalValue.second() !== value.second()) {
            // keep other fields for rc-calendar
            var changedValue = originalValue.clone();
            changedValue.hour(value.hour());
            changedValue.minute(value.minute());
            changedValue.second(value.second());

            this.__emit('change', changedValue);
          }
        } else if (originalValue !== value) {
          this.__emit('change', value);
        }
      } else if (allowEmpty) {
        this.__emit('change', null);
      } else {
        this.setState({
          invalid: true
        });
        return;
      }

      this.setState({
        invalid: false
      });
    },
    onKeyDown: function onKeyDown(e) {
      if (e.keyCode === 27) {
        this.__emit('esc');
      }

      this.__emit('keydown', e);
    },
    onClear: function onClear() {
      this.__emit('clear');

      this.setState({
        str: ''
      });
    },
    getClearButton: function getClearButton() {
      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          allowEmpty = this.allowEmpty,
          clearText = this.clearText;

      if (!allowEmpty) {
        return null;
      }

      return h("a", {
        "class": "".concat(prefixCls, "-clear-btn"),
        attrs: {
          role: 'button',
          title: clearText
        },
        on: {
          "mousedown": this.onClear
        }
      });
    },
    getProtoValue: function getProtoValue() {
      return this.value || this.defaultOpenValue;
    },
    getInput: function getInput() {
      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          placeholder = this.placeholder,
          inputReadOnly = this.inputReadOnly,
          invalid = this.invalid,
          str = this.str,
          showStr = this.showStr;
      var invalidClass = invalid ? "".concat(prefixCls, "-input-invalid") : '';
      return h("input", {
        "class": "".concat(prefixCls, "-input  ").concat(invalidClass),
        ref: 'input',
        on: {
          "keydown": this.onKeyDown,
          "input": this.onInputChange
        },
        domProps: {
          "value": showStr ? str : ''
        },
        attrs: {
          placeholder: placeholder,
          readOnly: !!inputReadOnly
        }
      });
    }
  },
  render: function render() {
    var h = arguments[0];
    var prefixCls = this.prefixCls;
    return h("div", {
      "class": "".concat(prefixCls, "-input-wrap")
    }, [this.getInput(), this.getClearButton()]);
  }
};
/* harmony default export */ var vc_time_picker_Header = (Header_Header);
// CONCATENATED MODULE: ./src/components/vc-time-picker/Select.jsx
function vc_time_picker_Select_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





function vc_time_picker_Select_noop() {}

var Select_scrollTo = function scrollTo(element, to, duration) {
  var requestAnimationFrame = window.requestAnimationFrame || function requestAnimationFrameTimeout() {
    return setTimeout(arguments[0], 10);
  }; // jump to target if duration zero


  if (duration <= 0) {
    element.scrollTop = to;
    return;
  }

  var difference = to - element.scrollTop;
  var perTick = difference / duration * 10;
  requestAnimationFrame(function () {
    element.scrollTop = element.scrollTop + perTick;
    if (element.scrollTop === to) return;
    scrollTo(element, to, duration - 10);
  });
};

var vc_time_picker_Select_Select = {
  mixins: [BaseMixin["a" /* default */]],
  props: {
    prefixCls: vue_types["a" /* default */].string,
    options: vue_types["a" /* default */].array,
    selectedIndex: vue_types["a" /* default */].number,
    type: vue_types["a" /* default */].string // onSelect: PropTypes.func,
    // onMouseEnter: PropTypes.func,

  },
  data: function data() {
    return {
      active: false
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      // jump to selected option
      _this.scrollToSelected(0);
    });
  },
  watch: {
    selectedIndex: function selectedIndex(val) {
      var _this2 = this;

      this.$nextTick(function () {
        // smooth scroll to selected option
        _this2.scrollToSelected(120);
      });
    }
  },
  methods: {
    onSelect: function onSelect(value) {
      var type = this.type;

      this.__emit('select', type, value);
    },
    getOptions: function getOptions() {
      var _this3 = this;

      var h = this.$createElement;
      var options = this.options,
          selectedIndex = this.selectedIndex,
          prefixCls = this.prefixCls;
      return options.map(function (item, index) {
        var _classnames;

        var cls = classnames_default()((_classnames = {}, vc_time_picker_Select_defineProperty(_classnames, "".concat(prefixCls, "-select-option-selected"), selectedIndex === index), vc_time_picker_Select_defineProperty(_classnames, "".concat(prefixCls, "-select-option-disabled"), item.disabled), _classnames));
        var onClick = vc_time_picker_Select_noop;

        if (!item.disabled) {
          onClick = _this3.onSelect.bind(_this3, item.value);
        }

        return h("li", {
          "class": cls,
          key: index,
          on: {
            "click": onClick
          },
          attrs: {
            disabled: item.disabled
          }
        }, [item.value]);
      });
    },
    scrollToSelected: function scrollToSelected(duration) {
      // move to selected item
      var select = this.$el;
      var list = this.$refs.list;

      if (!list) {
        return;
      }

      var index = this.selectedIndex;

      if (index < 0) {
        index = 0;
      }

      var topOption = list.children[index];
      var to = topOption.offsetTop;
      Select_scrollTo(select, to, duration);
    },
    handleMouseEnter: function handleMouseEnter(e) {
      this.setState({
        active: true
      });

      this.__emit('mouseenter', e);
    },
    handleMouseLeave: function handleMouseLeave() {
      this.setState({
        active: false
      });
    }
  },
  render: function render() {
    var _cls;

    var h = arguments[0];

    if (this.options.length === 0) {
      return null;
    }

    var prefixCls = this.prefixCls;
    var cls = (_cls = {}, vc_time_picker_Select_defineProperty(_cls, "".concat(prefixCls, "-select"), 1), vc_time_picker_Select_defineProperty(_cls, "".concat(prefixCls, "-select-active"), this.active), _cls);
    return h("div", {
      "class": cls,
      on: {
        "mouseenter": this.handleMouseEnter,
        "mouseleave": this.handleMouseLeave
      }
    }, [h("ul", {
      ref: 'list'
    }, [this.getOptions()])]);
  }
};
/* harmony default export */ var vc_time_picker_Select = (vc_time_picker_Select_Select);
// CONCATENATED MODULE: ./src/components/vc-time-picker/Combobox.jsx




var formatOption = function formatOption(option, disabledOptions) {
  var value = "".concat(option);

  if (option < 10) {
    value = "0".concat(option);
  }

  var disabled = false;

  if (disabledOptions && disabledOptions.indexOf(option) >= 0) {
    disabled = true;
  }

  return {
    value: value,
    disabled: disabled
  };
};

var Combobox = {
  mixins: [BaseMixin["a" /* default */]],
  name: 'Combobox',
  props: {
    format: vue_types["a" /* default */].string,
    defaultOpenValue: vue_types["a" /* default */].object,
    prefixCls: vue_types["a" /* default */].string,
    value: vue_types["a" /* default */].object,
    // onChange: PropTypes.func,
    showHour: vue_types["a" /* default */].bool,
    showMinute: vue_types["a" /* default */].bool,
    showSecond: vue_types["a" /* default */].bool,
    hourOptions: vue_types["a" /* default */].array,
    minuteOptions: vue_types["a" /* default */].array,
    secondOptions: vue_types["a" /* default */].array,
    disabledHours: vue_types["a" /* default */].func,
    disabledMinutes: vue_types["a" /* default */].func,
    disabledSeconds: vue_types["a" /* default */].func,
    // onCurrentSelectPanelChange: PropTypes.func,
    use12Hours: vue_types["a" /* default */].bool,
    isAM: vue_types["a" /* default */].bool
  },
  methods: {
    onItemChange: function onItemChange(type, itemValue) {
      var defaultOpenValue = this.defaultOpenValue,
          use12Hours = this.use12Hours,
          isAM = this.isAM;
      var value = (this.value || defaultOpenValue).clone();

      if (type === 'hour') {
        if (use12Hours) {
          if (isAM) {
            value.hour(+itemValue % 12);
          } else {
            value.hour(+itemValue % 12 + 12);
          }
        } else {
          value.hour(+itemValue);
        }
      } else if (type === 'minute') {
        value.minute(+itemValue);
      } else if (type === 'ampm') {
        var ampm = itemValue.toUpperCase();

        if (use12Hours) {
          if (ampm === 'PM' && value.hour() < 12) {
            value.hour(value.hour() % 12 + 12);
          }

          if (ampm === 'AM') {
            if (value.hour() >= 12) {
              value.hour(value.hour() - 12);
            }
          }
        }
      } else {
        value.second(+itemValue);
      }

      this.__emit('change', value);
    },
    onEnterSelectPanel: function onEnterSelectPanel(range) {
      this.__emit('currentSelectPanelChange', range);
    },
    getHourSelect: function getHourSelect(hour) {
      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          hourOptions = this.hourOptions,
          disabledHours = this.disabledHours,
          showHour = this.showHour,
          use12Hours = this.use12Hours;

      if (!showHour) {
        return null;
      }

      var disabledOptions = disabledHours();
      var hourOptionsAdj;
      var hourAdj;

      if (use12Hours) {
        hourOptionsAdj = [12].concat(hourOptions.filter(function (h) {
          return h < 12 && h > 0;
        }));
        hourAdj = hour % 12 || 12;
      } else {
        hourOptionsAdj = hourOptions;
        hourAdj = hour;
      }

      return h(vc_time_picker_Select, {
        attrs: {
          prefixCls: prefixCls,
          options: hourOptionsAdj.map(function (option) {
            return formatOption(option, disabledOptions);
          }),
          selectedIndex: hourOptionsAdj.indexOf(hourAdj),
          type: 'hour'
        },
        on: {
          "select": this.onItemChange,
          "mouseenter": this.onEnterSelectPanel.bind(this, 'hour')
        }
      });
    },
    getMinuteSelect: function getMinuteSelect(minute) {
      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          minuteOptions = this.minuteOptions,
          disabledMinutes = this.disabledMinutes,
          defaultOpenValue = this.defaultOpenValue,
          showMinute = this.showMinute;

      if (!showMinute) {
        return null;
      }

      var value = this.value || defaultOpenValue;
      var disabledOptions = disabledMinutes(value.hour());
      return h(vc_time_picker_Select, {
        attrs: {
          prefixCls: prefixCls,
          options: minuteOptions.map(function (option) {
            return formatOption(option, disabledOptions);
          }),
          selectedIndex: minuteOptions.indexOf(minute),
          type: 'minute'
        },
        on: {
          "select": this.onItemChange,
          "mouseenter": this.onEnterSelectPanel.bind(this, 'minute')
        }
      });
    },
    getSecondSelect: function getSecondSelect(second) {
      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          secondOptions = this.secondOptions,
          disabledSeconds = this.disabledSeconds,
          showSecond = this.showSecond,
          defaultOpenValue = this.defaultOpenValue;

      if (!showSecond) {
        return null;
      }

      var value = this.value || defaultOpenValue;
      var disabledOptions = disabledSeconds(value.hour(), value.minute());
      return h(vc_time_picker_Select, {
        attrs: {
          prefixCls: prefixCls,
          options: secondOptions.map(function (option) {
            return formatOption(option, disabledOptions);
          }),
          selectedIndex: secondOptions.indexOf(second),
          type: 'second'
        },
        on: {
          "select": this.onItemChange,
          "mouseenter": this.onEnterSelectPanel.bind(this, 'second')
        }
      });
    },
    getAMPMSelect: function getAMPMSelect() {
      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          use12Hours = this.use12Hours,
          format = this.format,
          isAM = this.isAM;

      if (!use12Hours) {
        return null;
      }

      var AMPMOptions = ['am', 'pm'] // If format has A char, then we should uppercase AM/PM
      .map(function (c) {
        return format.match(/\sA/) ? c.toUpperCase() : c;
      }).map(function (c) {
        return {
          value: c
        };
      });
      var selected = isAM ? 0 : 1;
      return h(vc_time_picker_Select, {
        attrs: {
          prefixCls: prefixCls,
          options: AMPMOptions,
          selectedIndex: selected,
          type: 'ampm'
        },
        on: {
          "select": this.onItemChange,
          "mouseenter": this.onEnterSelectPanel.bind(this, 'ampm')
        }
      });
    }
  },
  render: function render() {
    var h = arguments[0];
    var prefixCls = this.prefixCls,
        defaultOpenValue = this.defaultOpenValue;
    var value = this.value || defaultOpenValue;
    return h("div", {
      "class": "".concat(prefixCls, "-combobox")
    }, [this.getHourSelect(value.hour()), this.getMinuteSelect(value.minute()), this.getSecondSelect(value.second()), this.getAMPMSelect(value.hour())]);
  }
};
/* harmony default export */ var vc_time_picker_Combobox = (Combobox);
// CONCATENATED MODULE: ./src/components/vc-time-picker/Panel.jsx






function Panel_noop() {}

function generateOptions(length, disabledOptions, hideDisabledOptions) {
  var step = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var arr = [];

  for (var value = 0; value < length; value += step) {
    if (!disabledOptions || disabledOptions.indexOf(value) < 0 || !hideDisabledOptions) {
      arr.push(value);
    }
  }

  return arr;
}

var Panel_Panel = {
  mixins: [BaseMixin["a" /* default */]],
  props: {
    clearText: vue_types["a" /* default */].string,
    prefixCls: vue_types["a" /* default */].string.def('rc-time-picker-panel'),
    defaultOpenValue: {
      type: Object,
      "default": function _default() {
        return external_moment_default()();
      }
    },
    value: vue_types["a" /* default */].any,
    defaultValue: vue_types["a" /* default */].any,
    placeholder: vue_types["a" /* default */].string,
    format: vue_types["a" /* default */].string,
    inputReadOnly: vue_types["a" /* default */].bool.def(false),
    disabledHours: vue_types["a" /* default */].func.def(Panel_noop),
    disabledMinutes: vue_types["a" /* default */].func.def(Panel_noop),
    disabledSeconds: vue_types["a" /* default */].func.def(Panel_noop),
    hideDisabledOptions: vue_types["a" /* default */].bool,
    // onChange: PropTypes.func,
    // onEsc: PropTypes.func,
    allowEmpty: vue_types["a" /* default */].bool,
    showHour: vue_types["a" /* default */].bool,
    showMinute: vue_types["a" /* default */].bool,
    showSecond: vue_types["a" /* default */].bool,
    // onClear: PropTypes.func,
    use12Hours: vue_types["a" /* default */].bool.def(false),
    hourStep: vue_types["a" /* default */].number,
    minuteStep: vue_types["a" /* default */].number,
    secondStep: vue_types["a" /* default */].number,
    focusOnOpen: vue_types["a" /* default */].bool // onKeydown: PropTypes.func,

  },
  data: function data() {
    return {
      sValue: this.value,
      selectionRange: [],
      currentSelectPanel: '',
      showStr: true
    };
  },
  watch: {
    value: function value(val) {
      if (val) {
        this.setState({
          sValue: val,
          showStr: true
        });
      } else {
        this.setState({
          showStr: false
        });
      }
    }
  },
  methods: {
    onChange: function onChange(newValue) {
      this.setState({
        sValue: newValue
      });

      this.__emit('change', newValue);
    },
    onCurrentSelectPanelChange: function onCurrentSelectPanelChange(currentSelectPanel) {
      this.setState({
        currentSelectPanel: currentSelectPanel
      });
    },
    // https://github.com/ant-design/ant-design/issues/5829
    close: function close() {
      this.__emit('esc');
    },
    disabledHours2: function disabledHours2() {
      var use12Hours = this.use12Hours,
          disabledHours = this.disabledHours;
      var disabledOptions = disabledHours();

      if (use12Hours && Array.isArray(disabledOptions)) {
        if (this.isAM()) {
          disabledOptions = disabledOptions.filter(function (h) {
            return h < 12;
          }).map(function (h) {
            return h === 0 ? 12 : h;
          });
        } else {
          disabledOptions = disabledOptions.map(function (h) {
            return h === 12 ? 12 : h - 12;
          });
        }
      }

      return disabledOptions;
    },
    isAM: function isAM() {
      var value = this.sValue || this.defaultOpenValue;
      return value.hour() >= 0 && value.hour() < 12;
    }
  },
  render: function render() {
    var h = arguments[0];
    var prefixCls = this.prefixCls,
        placeholder = this.placeholder,
        disabledMinutes = this.disabledMinutes,
        disabledSeconds = this.disabledSeconds,
        hideDisabledOptions = this.hideDisabledOptions,
        allowEmpty = this.allowEmpty,
        showHour = this.showHour,
        showMinute = this.showMinute,
        showSecond = this.showSecond,
        format = this.format,
        defaultOpenValue = this.defaultOpenValue,
        clearText = this.clearText,
        use12Hours = this.use12Hours,
        focusOnOpen = this.focusOnOpen,
        hourStep = this.hourStep,
        minuteStep = this.minuteStep,
        secondStep = this.secondStep,
        inputReadOnly = this.inputReadOnly,
        sValue = this.sValue,
        currentSelectPanel = this.currentSelectPanel,
        showStr = this.showStr,
        _this$$listeners = this.$listeners,
        $listeners = _this$$listeners === void 0 ? {} : _this$$listeners;
    var _$listeners$esc = $listeners.esc,
        esc = _$listeners$esc === void 0 ? Panel_noop : _$listeners$esc,
        _$listeners$clear = $listeners.clear,
        clear = _$listeners$clear === void 0 ? Panel_noop : _$listeners$clear,
        _$listeners$keydown = $listeners.keydown,
        keydown = _$listeners$keydown === void 0 ? Panel_noop : _$listeners$keydown;
    var disabledHourOptions = this.disabledHours2();
    var disabledMinuteOptions = disabledMinutes(sValue ? sValue.hour() : null);
    var disabledSecondOptions = disabledSeconds(sValue ? sValue.hour() : null, sValue ? sValue.minute() : null);
    var hourOptions = generateOptions(24, disabledHourOptions, hideDisabledOptions, hourStep);
    var minuteOptions = generateOptions(60, disabledMinuteOptions, hideDisabledOptions, minuteStep);
    var secondOptions = generateOptions(60, disabledSecondOptions, hideDisabledOptions, secondStep);
    return h("div", {
      "class": "".concat(prefixCls, "-inner")
    }, [h(vc_time_picker_Header, {
      attrs: {
        clearText: clearText,
        prefixCls: prefixCls,
        defaultOpenValue: defaultOpenValue,
        value: sValue,
        currentSelectPanel: currentSelectPanel,
        format: format,
        placeholder: placeholder,
        hourOptions: hourOptions,
        minuteOptions: minuteOptions,
        secondOptions: secondOptions,
        disabledHours: this.disabledHours2,
        disabledMinutes: disabledMinutes,
        disabledSeconds: disabledSeconds,
        allowEmpty: allowEmpty,
        focusOnOpen: focusOnOpen,
        inputReadOnly: inputReadOnly,
        showStr: showStr
      },
      on: {
        "esc": esc,
        "change": this.onChange,
        "clear": clear,
        "keydown": keydown
      }
    }), h(vc_time_picker_Combobox, {
      attrs: {
        prefixCls: prefixCls,
        value: sValue,
        defaultOpenValue: defaultOpenValue,
        format: format,
        showHour: showHour,
        showMinute: showMinute,
        showSecond: showSecond,
        hourOptions: hourOptions,
        minuteOptions: minuteOptions,
        secondOptions: secondOptions,
        disabledHours: this.disabledHours2,
        disabledMinutes: disabledMinutes,
        disabledSeconds: disabledSeconds,
        use12Hours: use12Hours,
        isAM: this.isAM()
      },
      on: {
        "change": this.onChange,
        "currentSelectPanelChange": this.onCurrentSelectPanelChange
      }
    }), this.$slots["default"]]);
  }
};
/* harmony default export */ var vc_time_picker_Panel = (Panel_Panel);
// CONCATENATED MODULE: ./src/components/vc-time-picker/placements.js
var vc_time_picker_placements_autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var vc_time_picker_placements_targetOffset = [0, 0];
var vc_time_picker_placements_placements = {
  bottomLeft: {
    points: ['tl', 'tl'],
    overflow: vc_time_picker_placements_autoAdjustOverflow,
    offset: [0, -3],
    targetOffset: vc_time_picker_placements_targetOffset
  },
  bottomRight: {
    points: ['tr', 'tr'],
    overflow: vc_time_picker_placements_autoAdjustOverflow,
    offset: [0, -3],
    targetOffset: vc_time_picker_placements_targetOffset
  },
  topRight: {
    points: ['br', 'br'],
    overflow: vc_time_picker_placements_autoAdjustOverflow,
    offset: [0, 3],
    targetOffset: vc_time_picker_placements_targetOffset
  },
  topLeft: {
    points: ['bl', 'bl'],
    overflow: vc_time_picker_placements_autoAdjustOverflow,
    offset: [0, 3],
    targetOffset: vc_time_picker_placements_targetOffset
  }
};
/* harmony default export */ var vc_time_picker_placements = (vc_time_picker_placements_placements);
// CONCATENATED MODULE: ./src/components/vc-time-picker/TimePicker.jsx








function TimePicker_noop() {}

/* harmony default export */ var TimePicker = ({
  mixins: [BaseMixin["a" /* default */]],
  name: 'VcTimePicker',
  props: Object(props_util["q" /* initDefaultProps */])({
    prefixCls: vue_types["a" /* default */].string,
    clearText: vue_types["a" /* default */].string,
    value: vue_types["a" /* default */].any,
    defaultOpenValue: {
      type: Object,
      "default": function _default() {
        return external_moment_default()();
      }
    },
    inputReadOnly: vue_types["a" /* default */].bool,
    disabled: vue_types["a" /* default */].bool,
    allowEmpty: vue_types["a" /* default */].bool,
    defaultValue: vue_types["a" /* default */].any,
    open: vue_types["a" /* default */].bool,
    defaultOpen: vue_types["a" /* default */].bool,
    align: vue_types["a" /* default */].object,
    placement: vue_types["a" /* default */].any,
    transitionName: vue_types["a" /* default */].string,
    getPopupContainer: vue_types["a" /* default */].func,
    placeholder: vue_types["a" /* default */].string,
    format: vue_types["a" /* default */].string,
    showHour: vue_types["a" /* default */].bool,
    showMinute: vue_types["a" /* default */].bool,
    showSecond: vue_types["a" /* default */].bool,
    popupClassName: vue_types["a" /* default */].string,
    disabledHours: vue_types["a" /* default */].func,
    disabledMinutes: vue_types["a" /* default */].func,
    disabledSeconds: vue_types["a" /* default */].func,
    hideDisabledOptions: vue_types["a" /* default */].bool,
    // onChange: PropTypes.func,
    // onOpen: PropTypes.func,
    // onClose: PropTypes.func,
    // onFocus: PropTypes.func,
    // onBlur: PropTypes.func,
    name: vue_types["a" /* default */].string,
    autoComplete: vue_types["a" /* default */].string,
    use12Hours: vue_types["a" /* default */].bool,
    hourStep: vue_types["a" /* default */].number,
    minuteStep: vue_types["a" /* default */].number,
    secondStep: vue_types["a" /* default */].number,
    focusOnOpen: vue_types["a" /* default */].bool,
    // onKeyDown: PropTypes.func,
    autoFocus: vue_types["a" /* default */].bool,
    id: vue_types["a" /* default */].string
  }, {
    clearText: 'clear',
    prefixCls: 'rc-time-picker',
    defaultOpen: false,
    inputReadOnly: false,
    popupClassName: '',
    align: {},
    id: '',
    allowEmpty: true,
    showHour: true,
    showMinute: true,
    showSecond: true,
    disabledHours: TimePicker_noop,
    disabledMinutes: TimePicker_noop,
    disabledSeconds: TimePicker_noop,
    hideDisabledOptions: false,
    placement: 'bottomLeft',
    use12Hours: false,
    focusOnOpen: false
  }),
  data: function data() {
    var defaultOpen = this.defaultOpen,
        defaultValue = this.defaultValue,
        _this$open = this.open,
        open = _this$open === void 0 ? defaultOpen : _this$open,
        _this$value = this.value,
        value = _this$value === void 0 ? defaultValue : _this$value;
    return {
      sOpen: open,
      sValue: value
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      if (_this.autoFocus) {
        _this.focus();
      }
    });
  },
  watch: {
    value: function value(val) {
      this.setState({
        sValue: val
      });
    },
    open: function open(val) {
      if (val !== undefined) {
        this.setState({
          sOpen: val
        });
      }
    }
  },
  methods: {
    onPanelChange: function onPanelChange(value) {
      this.setValue(value);
    },
    onPanelClear: function onPanelClear() {
      this.setValue(null);
      this.setOpen(false);
    },
    onVisibleChange: function onVisibleChange(open) {
      this.setOpen(open);
    },
    onEsc: function onEsc() {
      this.setOpen(false);
      this.focus();
    },
    onKeyDown: function onKeyDown(e) {
      if (e.keyCode === 40) {
        this.setOpen(true);
      }
    },
    onKeyDown2: function onKeyDown2(e) {
      this.__emit('keydown', e);
    },
    setValue: function setValue(value) {
      if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
        this.setState({
          sValue: value
        });
      }

      this.__emit('change', value);
    },
    getFormat: function getFormat() {
      var format = this.format,
          showHour = this.showHour,
          showMinute = this.showMinute,
          showSecond = this.showSecond,
          use12Hours = this.use12Hours;

      if (format) {
        return format;
      }

      if (use12Hours) {
        var fmtString = [showHour ? 'h' : '', showMinute ? 'mm' : '', showSecond ? 'ss' : ''].filter(function (item) {
          return !!item;
        }).join(':');
        return fmtString.concat(' a');
      }

      return [showHour ? 'HH' : '', showMinute ? 'mm' : '', showSecond ? 'ss' : ''].filter(function (item) {
        return !!item;
      }).join(':');
    },
    getPanelElement: function getPanelElement() {
      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          placeholder = this.placeholder,
          disabledHours = this.disabledHours,
          disabledMinutes = this.disabledMinutes,
          disabledSeconds = this.disabledSeconds,
          hideDisabledOptions = this.hideDisabledOptions,
          inputReadOnly = this.inputReadOnly,
          allowEmpty = this.allowEmpty,
          showHour = this.showHour,
          showMinute = this.showMinute,
          showSecond = this.showSecond,
          defaultOpenValue = this.defaultOpenValue,
          clearText = this.clearText,
          use12Hours = this.use12Hours,
          focusOnOpen = this.focusOnOpen,
          onKeyDown2 = this.onKeyDown2,
          hourStep = this.hourStep,
          minuteStep = this.minuteStep,
          secondStep = this.secondStep,
          sValue = this.sValue;
      return h(vc_time_picker_Panel, {
        attrs: {
          clearText: clearText,
          prefixCls: "".concat(prefixCls, "-panel"),
          value: sValue,
          inputReadOnly: inputReadOnly,
          defaultOpenValue: defaultOpenValue,
          showHour: showHour,
          showMinute: showMinute,
          showSecond: showSecond,
          allowEmpty: allowEmpty,
          format: this.getFormat(),
          placeholder: placeholder,
          disabledHours: disabledHours,
          disabledMinutes: disabledMinutes,
          disabledSeconds: disabledSeconds,
          hideDisabledOptions: hideDisabledOptions,
          use12Hours: use12Hours,
          hourStep: hourStep,
          minuteStep: minuteStep,
          secondStep: secondStep,
          focusOnOpen: focusOnOpen
        },
        ref: 'panel',
        on: {
          "change": this.onPanelChange,
          "clear": this.onPanelClear,
          "esc": this.onEsc,
          "keyDown": onKeyDown2
        }
      }, [this.$slots.addon]);
    },
    getPopupClassName: function getPopupClassName() {
      var showHour = this.showHour,
          showMinute = this.showMinute,
          showSecond = this.showSecond,
          use12Hours = this.use12Hours,
          prefixCls = this.prefixCls;
      var popupClassName = this.popupClassName; // Keep it for old compatibility

      if ((!showHour || !showMinute || !showSecond) && !use12Hours) {
        popupClassName += " ".concat(prefixCls, "-panel-narrow");
      }

      var selectColumnCount = 0;

      if (showHour) {
        selectColumnCount += 1;
      }

      if (showMinute) {
        selectColumnCount += 1;
      }

      if (showSecond) {
        selectColumnCount += 1;
      }

      if (use12Hours) {
        selectColumnCount += 1;
      }

      popupClassName += " ".concat(prefixCls, "-panel-column-").concat(selectColumnCount);
      return popupClassName;
    },
    setOpen: function setOpen(open) {
      if (this.sOpen !== open) {
        if (!Object(props_util["p" /* hasProp */])(this, 'open')) {
          this.setState({
            sOpen: open
          });
        }

        if (open) {
          this.__emit('open', {
            open: open
          });
        } else {
          this.__emit('close', {
            open: open
          });
        }
      }
    },
    focus: function focus() {
      this.$refs.picker.focus();
    },
    blur: function blur() {
      this.$refs.picker.blur();
    },
    onFocus: function onFocus(e) {
      this.__emit('focus', e);
    },
    onBlur: function onBlur(e) {
      this.__emit('blur', e);
    }
  },
  render: function render() {
    var h = arguments[0];
    var prefixCls = this.prefixCls,
        placeholder = this.placeholder,
        placement = this.placement,
        align = this.align,
        id = this.id,
        disabled = this.disabled,
        transitionName = this.transitionName,
        getPopupContainer = this.getPopupContainer,
        name = this.name,
        autoComplete = this.autoComplete,
        autoFocus = this.autoFocus,
        inputReadOnly = this.inputReadOnly,
        sOpen = this.sOpen,
        sValue = this.sValue,
        onFocus = this.onFocus,
        onBlur = this.onBlur;
    var popupClassName = this.getPopupClassName();
    return h(components_trigger, {
      attrs: {
        prefixCls: "".concat(prefixCls, "-panel"),
        popupClassName: popupClassName,
        popupAlign: align,
        builtinPlacements: vc_time_picker_placements,
        popupPlacement: placement,
        action: disabled ? [] : ['click'],
        destroyPopupOnHide: true,
        getPopupContainer: getPopupContainer,
        popupTransitionName: transitionName,
        popupVisible: sOpen
      },
      on: {
        "popupVisibleChange": this.onVisibleChange
      }
    }, [h("template", {
      slot: 'popup'
    }, [this.getPanelElement()]), h("span", {
      "class": "".concat(prefixCls)
    }, [h("input", {
      "class": "".concat(prefixCls, "-input"),
      ref: 'picker',
      attrs: {
        type: 'text',
        placeholder: placeholder,
        name: name,
        disabled: disabled,
        autoComplete: autoComplete,
        autoFocus: autoFocus,
        readOnly: !!inputReadOnly,
        id: id
      },
      on: {
        "keydown": this.onKeyDown,
        "focus": onFocus,
        "blur": onBlur
      },
      domProps: {
        "value": sValue && sValue.format(this.getFormat()) || ''
      }
    }), h("span", {
      "class": "".concat(prefixCls, "-icon")
    })])]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-time-picker/index.js
// based on rc-time-picker 3.3.1

// CONCATENATED MODULE: ./src/components/time-picker/index.jsx
function time_picker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { time_picker_defineProperty(target, key, source[key]); }); } return target; }

function time_picker_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









function generateShowHourMinuteSecond(format) {
  // Ref: http://momentjs.com/docs/#/parsing/string-format/
  return {
    showHour: format.indexOf('H') > -1 || format.indexOf('h') > -1 || format.indexOf('k') > -1,
    showMinute: format.indexOf('m') > -1,
    showSecond: format.indexOf('s') > -1
  };
}

function time_picker_isMoment(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || value.findIndex(function (val) {
      return val === undefined || external_moment_["isMoment"](val);
    }) !== -1;
  } else {
    return value === undefined || external_moment_["isMoment"](value);
  }
}

var time_picker_MomentType = vue_types["a" /* default */].custom(time_picker_isMoment);
var time_picker_TimePickerProps = function TimePickerProps() {
  return {
    size: vue_types["a" /* default */].oneOf(['large', 'default', 'small']),
    value: time_picker_MomentType,
    defaultValue: time_picker_MomentType,
    open: vue_types["a" /* default */].bool,
    format: vue_types["a" /* default */].string,
    disabled: vue_types["a" /* default */].bool,
    placeholder: vue_types["a" /* default */].string,
    prefixCls: vue_types["a" /* default */].string,
    hideDisabledOptions: vue_types["a" /* default */].bool,
    disabledHours: vue_types["a" /* default */].func,
    disabledMinutes: vue_types["a" /* default */].func,
    disabledSeconds: vue_types["a" /* default */].func,
    getPopupContainer: vue_types["a" /* default */].func,
    use12Hours: vue_types["a" /* default */].bool,
    focusOnOpen: vue_types["a" /* default */].bool,
    hourStep: vue_types["a" /* default */].number,
    minuteStep: vue_types["a" /* default */].number,
    secondStep: vue_types["a" /* default */].number,
    allowEmpty: vue_types["a" /* default */].bool,
    inputReadOnly: vue_types["a" /* default */].bool,
    clearText: vue_types["a" /* default */].string,
    defaultOpenValue: vue_types["a" /* default */].object,
    popupClassName: vue_types["a" /* default */].string,
    align: vue_types["a" /* default */].object,
    placement: vue_types["a" /* default */].any,
    transitionName: vue_types["a" /* default */].string,
    autoFocus: vue_types["a" /* default */].bool,
    addon: vue_types["a" /* default */].any
  };
};
var time_picker_TimePicker = {
  name: 'TaTimePicker',
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(time_picker_TimePickerProps(), {
    prefixCls: 'ant-time-picker',
    align: {
      offset: [0, -2]
    },
    disabled: false,
    disabledHours: undefined,
    disabledMinutes: undefined,
    disabledSeconds: undefined,
    hideDisabledOptions: false,
    placement: 'bottomLeft',
    transitionName: 'slide-up',
    focusOnOpen: true
  }),
  model: {
    prop: 'value',
    event: 'change'
  },
  data: function data() {
    var value = this.value || this.defaultValue;

    if (value && !interopDefault(external_moment_).isMoment(value)) {
      throw new Error('The value/defaultValue of TimePicker must be a moment object, ');
    }

    return {
      sValue: value
    };
  },
  watch: {
    value: function value(val) {
      this.setState({
        sValue: val
      });
    }
  },
  methods: {
    handleChange: function handleChange(value) {
      if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
        this.setState({
          sValue: value
        });
      }

      var _this$format = this.format,
          format = _this$format === void 0 ? 'HH:mm:ss' : _this$format;
      this.$emit('change', value, value && value.format(format) || '');
    },
    handleOpenClose: function handleOpenClose(_ref) {
      var open = _ref.open;
      this.$emit('openChange', open);
      this.$emit('update:open', open);
    },
    focus: function focus() {
      this.$refs.timePicker.focus();
    },
    blur: function blur() {
      this.$refs.timePicker.blur();
    },
    getDefaultFormat: function getDefaultFormat() {
      var format = this.format,
          use12Hours = this.use12Hours;

      if (format) {
        return format;
      } else if (use12Hours) {
        return 'h:mm:ss a';
      }

      return 'HH:mm:ss';
    },
    renderTimePicker: function renderTimePicker(locale) {
      var h = this.$createElement;
      var props = Object(props_util["j" /* getOptionProps */])(this);
      delete props.defaultValue;
      var format = this.getDefaultFormat();

      var className = time_picker_defineProperty({}, "".concat(props.prefixCls, "-").concat(props.size), !!props.size);

      var tempAddon = Object(props_util["g" /* getComponentFromProp */])(this, 'addon');
      var timeProps = {
        props: time_picker_objectSpread({}, generateShowHourMinuteSecond(format), props, {
          format: format,
          value: this.sValue,
          placeholder: props.placeholder === undefined ? locale.placeholder : props.placeholder
        }),
        "class": className,
        ref: 'timePicker',
        on: time_picker_objectSpread({}, this.$listeners, {
          change: this.handleChange,
          open: this.handleOpenClose,
          close: this.handleOpenClose
        })
      };
      return h(TimePicker, timeProps, [tempAddon ? h("template", {
        slot: 'addon'
      }, [h("div", {
        "class": "".concat(props.prefixCls, "-panel-addon")
      }, [tempAddon])]) : null]);
    }
  },
  render: function render() {
    var h = arguments[0];
    return h(LocaleReceiver, {
      attrs: {
        componentName: 'TimePicker',
        defaultLocale: time_picker_locale_en_US
      },
      scopedSlots: {
        "default": this.renderTimePicker
      }
    });
  }
};
/* istanbul ignore next */

time_picker_TimePicker.install = function (Vue) {
  Vue.component(time_picker_TimePicker.name, time_picker_TimePicker);
};

/* harmony default export */ var time_picker = (time_picker_TimePicker);
// CONCATENATED MODULE: ./src/components/date-picker/wrapPicker.js
function wrapPicker_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      wrapPicker_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function wrapPicker_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}








function wrapPicker_getColumns(_ref) {
  var showHour = _ref.showHour,
      showMinute = _ref.showMinute,
      showSecond = _ref.showSecond,
      use12Hours = _ref.use12Hours;
  var column = 0;

  if (showHour) {
    column += 1;
  }

  if (showMinute) {
    column += 1;
  }

  if (showSecond) {
    column += 1;
  }

  if (use12Hours) {
    column += 1;
  }

  return column;
}

function wrapPicker(Picker, props, defaultFormat) {
  return {
    name: Picker.name,
    props: Object(props_util["q" /* initDefaultProps */])(props, {
      format: defaultFormat || 'YYYY-MM-DD',
      transitionName: 'slide-up',
      popupStyle: {},
      locale: {},
      prefixCls: 'ant-calendar',
      inputPrefixCls: 'ant-input'
    }),
    model: {
      prop: 'value',
      event: 'change'
    },
    mounted: function mounted() {
      var _this = this;

      var autoFocus = this.autoFocus,
          disabled = this.disabled;

      if (autoFocus && !disabled) {
        this.$nextTick(function () {
          _this.focus();
        });
      }
    },
    methods: {
      handleOpenChange: function handleOpenChange(open) {
        this.$emit('openChange', open);
      },
      handleFocus: function handleFocus(e) {
        this.$emit('focus', e);
      },
      handleBlur: function handleBlur(e) {
        this.$emit('blur', e);
      },
      handleMouseEnter: function handleMouseEnter(e) {
        this.$emit('mouseenter', e);
      },
      handleMouseLeave: function handleMouseLeave(e) {
        this.$emit('mouseleave', e);
      },
      focus: function focus() {
        this.$refs.picker.focus();
      },
      blur: function blur() {
        this.$refs.picker.blur();
      },
      getDefaultLocale: function getDefaultLocale() {
        var result = wrapPicker_objectSpread({}, date_picker_locale_zh_CN, this.locale);

        result.lang = wrapPicker_objectSpread({}, result.lang, (this.locale || {}).lang);
        return result;
      },
      renderPicker: function renderPicker(locale, localeCode) {
        var _classNames2;

        var h = this.$createElement;
        var props = Object(props_util["j" /* getOptionProps */])(this);
        var prefixCls = props.prefixCls,
            inputPrefixCls = props.inputPrefixCls,
            size = props.size,
            showTime = props.showTime,
            disabled = props.disabled;
        var pickerClass = classnames_default()("".concat(prefixCls, "-picker"), wrapPicker_defineProperty({}, "".concat(prefixCls, "-picker-").concat(size), !!size));
        var pickerInputClass = classnames_default()("".concat(prefixCls, "-picker-input"), inputPrefixCls, (_classNames2 = {}, wrapPicker_defineProperty(_classNames2, "".concat(inputPrefixCls, "-lg"), size === 'large'), wrapPicker_defineProperty(_classNames2, "".concat(inputPrefixCls, "-sm"), size === 'small'), wrapPicker_defineProperty(_classNames2, "".concat(inputPrefixCls, "-disabled"), disabled), _classNames2));
        var timeFormat = showTime && showTime.format || 'HH:mm:ss';

        var vcTimePickerProps = wrapPicker_objectSpread({}, generateShowHourMinuteSecond(timeFormat), {
          format: timeFormat,
          use12Hours: showTime && showTime.use12Hours
        });

        var columns = wrapPicker_getColumns(vcTimePickerProps);
        var timePickerCls = "".concat(prefixCls, "-time-picker-column-").concat(columns);
        var timePickerPanelProps = {
          props: wrapPicker_objectSpread({}, vcTimePickerProps, showTime, {
            prefixCls: "".concat(prefixCls, "-time-picker"),
            placeholder: locale.timePickerLocale.placeholder,
            transitionName: 'slide-up'
          }),
          "class": timePickerCls
        };
        var timePicker = showTime ? h(vc_time_picker_Panel, timePickerPanelProps) : null;
        var pickerProps = {
          props: wrapPicker_objectSpread({}, props, {
            pickerClass: pickerClass,
            pickerInputClass: pickerInputClass,
            locale: locale,
            localeCode: localeCode,
            timePicker: timePicker
          }),
          on: wrapPicker_objectSpread({}, this.$listeners, {
            openChange: this.handleOpenChange,
            focus: this.handleFocus,
            blur: this.handleBlur,
            mouseenter: this.handleMouseEnter,
            mouseleave: this.handleMouseLeave
          }),
          ref: 'picker',
          scopedSlots: this.$scopedSlots || {}
        };
        return h(Picker, pickerProps, [h("template", {
          slot: 'renderExtraFooter'
        }, [this.$slots.renderExtraFooter])]);
      }
    },
    render: function render() {
      var h = arguments[0];
      return h(LocaleReceiver, {
        attrs: {
          componentName: 'DatePicker',
          defaultLocale: this.getDefaultLocale
        },
        scopedSlots: {
          "default": this.renderPicker
        }
      });
    }
  };
}
// CONCATENATED MODULE: ./src/components/vc-calendar/src/range-calendar/CalendarPart.jsx
function CalendarPart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { CalendarPart_defineProperty(target, key, source[key]); }); } return target; }

function CalendarPart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










function CalendarPart_noop() {}

var CalendarPart = {
  mixins: [BaseMixin["a" /* default */]],
  props: {
    prefixCls: vue_types["a" /* default */].string,
    value: vue_types["a" /* default */].any,
    hoverValue: vue_types["a" /* default */].any,
    selectedValue: vue_types["a" /* default */].any,
    direction: vue_types["a" /* default */].any,
    locale: vue_types["a" /* default */].any,
    showDateInput: vue_types["a" /* default */].bool,
    showTimePicker: vue_types["a" /* default */].bool,
    showWeekNumber: vue_types["a" /* default */].bool,
    format: vue_types["a" /* default */].any,
    placeholder: vue_types["a" /* default */].any,
    disabledDate: vue_types["a" /* default */].any,
    timePicker: vue_types["a" /* default */].any,
    disabledTime: vue_types["a" /* default */].any,
    disabledMonth: vue_types["a" /* default */].any,
    mode: vue_types["a" /* default */].any,
    // onInputSelect: PropTypes.func,
    timePickerDisabledTime: vue_types["a" /* default */].object,
    enableNext: vue_types["a" /* default */].any,
    enablePrev: vue_types["a" /* default */].any,
    dateRender: vue_types["a" /* default */].func
  },
  render: function render() {
    var h = arguments[0];
    var props = this.$props,
        _this$$listeners = this.$listeners,
        $listeners = _this$$listeners === void 0 ? {} : _this$$listeners;
    var prefixCls = props.prefixCls,
        value = props.value,
        hoverValue = props.hoverValue,
        selectedValue = props.selectedValue,
        mode = props.mode,
        direction = props.direction,
        locale = props.locale,
        format = props.format,
        placeholder = props.placeholder,
        disabledDate = props.disabledDate,
        timePicker = props.timePicker,
        disabledTime = props.disabledTime,
        timePickerDisabledTime = props.timePickerDisabledTime,
        showTimePicker = props.showTimePicker,
        enablePrev = props.enablePrev,
        enableNext = props.enableNext,
        disabledMonth = props.disabledMonth,
        showDateInput = props.showDateInput,
        dateRender = props.dateRender,
        showWeekNumber = props.showWeekNumber;
    var _$listeners$inputSele = $listeners.inputSelect,
        inputSelect = _$listeners$inputSele === void 0 ? CalendarPart_noop : _$listeners$inputSele,
        _$listeners$valueChan = $listeners.valueChange,
        valueChange = _$listeners$valueChan === void 0 ? CalendarPart_noop : _$listeners$valueChan,
        _$listeners$panelChan = $listeners.panelChange,
        panelChange = _$listeners$panelChan === void 0 ? CalendarPart_noop : _$listeners$panelChan,
        _$listeners$select = $listeners.select,
        select = _$listeners$select === void 0 ? CalendarPart_noop : _$listeners$select,
        _$listeners$dayHover = $listeners.dayHover,
        dayHover = _$listeners$dayHover === void 0 ? CalendarPart_noop : _$listeners$dayHover;
    var shouldShowTimePicker = showTimePicker && timePicker;
    var disabledTimeConfig = shouldShowTimePicker && disabledTime ? getTimeConfig(selectedValue, disabledTime) : null;
    var rangeClassName = "".concat(prefixCls, "-range");
    var newProps = {
      locale: locale,
      value: value,
      prefixCls: prefixCls,
      showTimePicker: showTimePicker
    };
    var index = direction === 'left' ? 0 : 1;
    var timePickerEle = null;

    if (shouldShowTimePicker) {
      var timePickerProps = Object(props_util["j" /* getOptionProps */])(timePicker);
      timePickerEle = Object(vnode["a" /* cloneElement */])(timePicker, {
        props: CalendarPart_objectSpread({
          showHour: true,
          showMinute: true,
          showSecond: true
        }, timePickerProps, disabledTimeConfig, timePickerDisabledTime, {
          defaultOpenValue: value,
          value: selectedValue[index]
        }),
        on: {
          change: inputSelect
        }
      });
    }

    var dateInputElement = showDateInput && h(date_DateInput, {
      attrs: {
        format: format,
        locale: locale,
        prefixCls: prefixCls,
        timePicker: timePicker,
        disabledDate: disabledDate,
        placeholder: placeholder,
        disabledTime: disabledTime,
        value: value,
        showClear: false,
        selectedValue: selectedValue[index]
      },
      on: {
        "change": inputSelect
      }
    });
    var headerProps = {
      props: CalendarPart_objectSpread({}, newProps, {
        mode: mode,
        enableNext: enableNext,
        enablePrev: enablePrev,
        disabledMonth: disabledMonth
      }),
      on: {
        valueChange: valueChange,
        panelChange: panelChange
      }
    };
    var tableProps = {
      props: CalendarPart_objectSpread({}, newProps, {
        hoverValue: hoverValue,
        selectedValue: selectedValue,
        dateRender: dateRender,
        disabledDate: disabledDate,
        showWeekNumber: showWeekNumber
      }),
      on: {
        select: select,
        dayHover: dayHover
      }
    };
    return h("div", {
      "class": "".concat(rangeClassName, "-part ").concat(rangeClassName, "-").concat(direction)
    }, [dateInputElement, h("div", {
      style: {
        outline: 'none'
      }
    }, [h(calendar_CalendarHeader, headerProps), showTimePicker ? h("div", {
      "class": "".concat(prefixCls, "-time-picker")
    }, [h("div", {
      "class": "".concat(prefixCls, "-time-picker-panel")
    }, [timePickerEle])]) : null, h("div", {
      "class": "".concat(prefixCls, "-body")
    }, [h(DateTable, tableProps)])])]);
  }
};
/* harmony default export */ var range_calendar_CalendarPart = (CalendarPart);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/RangeCalendar.jsx
function RangeCalendar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function RangeCalendar_toConsumableArray(arr) { return RangeCalendar_arrayWithoutHoles(arr) || RangeCalendar_iterableToArray(arr) || RangeCalendar_nonIterableSpread(); }

function RangeCalendar_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function RangeCalendar_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function RangeCalendar_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function RangeCalendar_slicedToArray(arr, i) { return RangeCalendar_arrayWithHoles(arr) || RangeCalendar_iterableToArrayLimit(arr, i) || RangeCalendar_nonIterableRest(); }

function RangeCalendar_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function RangeCalendar_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function RangeCalendar_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }















function RangeCalendar_noop() {}

function isEmptyArray(arr) {
  return Array.isArray(arr) && (arr.length === 0 || arr.every(function (i) {
    return !i;
  }));
}

function isArraysEqual(a, b) {
  if (a === b) return true;

  if (a === null || typeof a === 'undefined' || b === null || typeof b === 'undefined') {
    return false;
  }

  if (a.length !== b.length) return false;

  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }

  return true;
}

function getValueFromSelectedValue(selectedValue) {
  var _selectedValue = RangeCalendar_slicedToArray(selectedValue, 2),
      start = _selectedValue[0],
      end = _selectedValue[1];

  var newEnd = end && end.isSame(start, 'month') ? end.clone().add(1, 'month') : end;
  return [start, newEnd];
}

function normalizeAnchor(props, init) {
  var selectedValue = props.selectedValue || init && props.defaultSelectedValue;
  var value = props.value || init && props.defaultValue;
  var normalizedValue = value ? getValueFromSelectedValue(value) : getValueFromSelectedValue(selectedValue);
  return !isEmptyArray(normalizedValue) ? normalizedValue : init && [external_moment_default()(), external_moment_default()().add(1, 'months')];
}

function RangeCalendar_generateOptions(length, extraOptionGen) {
  var arr = extraOptionGen ? extraOptionGen().concat() : [];

  for (var value = 0; value < length; value++) {
    if (arr.indexOf(value) === -1) {
      arr.push(value);
    }
  }

  return arr;
}

function onInputSelect(direction, value) {
  if (!value) {
    return;
  }

  var originalValue = this.sSelectedValue;
  var selectedValue = originalValue.concat();
  var index = direction === 'left' ? 0 : 1;
  selectedValue[index] = value;

  if (selectedValue[0] && this.compare(selectedValue[0], selectedValue[1]) > 0) {
    selectedValue[1 - index] = this.showTimePicker ? selectedValue[index] : undefined;
  }

  this.__emit('inputSelect', selectedValue);

  this.fireSelectValueChange(selectedValue);
}

var RangeCalendar = {
  props: {
    locale: vue_types["a" /* default */].object.def(zh_CN),
    visible: vue_types["a" /* default */].bool.def(true),
    prefixCls: vue_types["a" /* default */].string.def('rc-calendar'),
    dateInputPlaceholder: vue_types["a" /* default */].any,
    defaultValue: vue_types["a" /* default */].any,
    value: vue_types["a" /* default */].any,
    hoverValue: vue_types["a" /* default */].any,
    mode: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].oneOf(['date', 'month', 'year', 'decade'])),
    showDateInput: vue_types["a" /* default */].bool.def(true),
    timePicker: vue_types["a" /* default */].any,
    showOk: vue_types["a" /* default */].bool,
    showToday: vue_types["a" /* default */].bool.def(true),
    defaultSelectedValue: vue_types["a" /* default */].array.def([]),
    selectedValue: vue_types["a" /* default */].array,
    showClear: vue_types["a" /* default */].bool,
    showWeekNumber: vue_types["a" /* default */].bool,
    // locale: PropTypes.object,
    // onChange: PropTypes.func,
    // onSelect: PropTypes.func,
    // onValueChange: PropTypes.func,
    // onHoverChange: PropTypes.func,
    // onPanelChange: PropTypes.func,
    format: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].object, vue_types["a" /* default */].string]),
    // onClear: PropTypes.func,
    type: vue_types["a" /* default */].any.def('both'),
    disabledDate: vue_types["a" /* default */].func,
    disabledTime: vue_types["a" /* default */].func.def(RangeCalendar_noop),
    renderFooter: vue_types["a" /* default */].func.def(function () {
      return null;
    }),
    renderSidebar: vue_types["a" /* default */].func.def(function () {
      return null;
    }),
    dateRender: vue_types["a" /* default */].func
  },
  mixins: [BaseMixin["a" /* default */], CommonMixin],
  data: function data() {
    var props = this.$props;
    var selectedValue = props.selectedValue || props.defaultSelectedValue;
    var value = normalizeAnchor(props, 1);
    return {
      sSelectedValue: selectedValue,
      prevSelectedValue: selectedValue,
      firstSelectedValue: null,
      sHoverValue: props.hoverValue || [],
      sValue: value,
      showTimePicker: false,
      sMode: props.mode || ['date', 'date']
    };
  },
  watch: {
    value: function value(val) {
      var newState = {};
      newState.sValue = normalizeAnchor(this.$props, 0);
      this.setState(newState);
    },
    hoverValue: function hoverValue(val) {
      if (!isArraysEqual(this.sHoverValue, val)) {
        this.setState({
          sHoverValue: val
        });
      }
    },
    selectedValue: function selectedValue(val) {
      var newState = {};
      newState.sSelectedValue = val;
      newState.prevSelectedValue = val;
      this.setState(newState);
    },
    mode: function mode(val) {
      if (!isArraysEqual(this.sMode, val)) {
        this.setState({
          sMode: val
        });
      }
    }
  },
  methods: {
    onDatePanelEnter: function onDatePanelEnter() {
      if (this.hasSelectedValue()) {
        this.fireHoverValueChange(this.sSelectedValue.concat());
      }
    },
    onDatePanelLeave: function onDatePanelLeave() {
      if (this.hasSelectedValue()) {
        this.fireHoverValueChange([]);
      }
    },
    onSelect: function onSelect(value) {
      var type = this.type,
          sSelectedValue = this.sSelectedValue,
          prevSelectedValue = this.prevSelectedValue,
          firstSelectedValue = this.firstSelectedValue;
      var nextSelectedValue;

      if (type === 'both') {
        if (!firstSelectedValue) {
          syncTime(prevSelectedValue[0], value);
          nextSelectedValue = [value];
        } else if (this.compare(firstSelectedValue, value) < 0) {
          syncTime(prevSelectedValue[1], value);
          nextSelectedValue = [firstSelectedValue, value];
        } else {
          syncTime(prevSelectedValue[0], value);
          syncTime(prevSelectedValue[1], firstSelectedValue);
          nextSelectedValue = [value, firstSelectedValue];
        }
      } else if (type === 'start') {
        syncTime(prevSelectedValue[0], value);
        var endValue = sSelectedValue[1];
        nextSelectedValue = endValue && this.compare(endValue, value) > 0 ? [value, endValue] : [value];
      } else {
        // type === 'end'
        var startValue = sSelectedValue[0];

        if (startValue && this.compare(startValue, value) <= 0) {
          syncTime(prevSelectedValue[1], value);
          nextSelectedValue = [startValue, value];
        } else {
          syncTime(prevSelectedValue[0], value);
          nextSelectedValue = [value];
        }
      }

      this.fireSelectValueChange(nextSelectedValue);
    },
    onKeyDown: function onKeyDown(event) {
      var _this = this;

      if (event.target.nodeName.toLowerCase() === 'input') {
        return;
      }

      var keyCode = event.keyCode;
      var ctrlKey = event.ctrlKey || event.metaKey;
      var _this$$data = this.$data,
          selectedValue = _this$$data.sSelectedValue,
          hoverValue = _this$$data.sHoverValue,
          firstSelectedValue = _this$$data.firstSelectedValue,
          value = _this$$data.sValue;
      var disabledDate = this.$props.disabledDate; // Update last time of the picker

      var updateHoverPoint = function updateHoverPoint(func) {
        // Change hover to make focus in UI
        var currentHoverTime;
        var nextHoverTime;
        var nextHoverValue;

        if (!firstSelectedValue) {
          currentHoverTime = hoverValue[0] || selectedValue[0] || value[0] || external_moment_default()();
          nextHoverTime = func(currentHoverTime);
          nextHoverValue = [nextHoverTime];

          _this.fireHoverValueChange(nextHoverValue);
        } else {
          if (hoverValue.length === 1) {
            currentHoverTime = hoverValue[0].clone();
            nextHoverTime = func(currentHoverTime);
            nextHoverValue = _this.onDayHover(nextHoverTime);
          } else {
            currentHoverTime = hoverValue[0].isSame(firstSelectedValue, 'day') ? hoverValue[1] : hoverValue[0];
            nextHoverTime = func(currentHoverTime);
            nextHoverValue = _this.onDayHover(nextHoverTime);
          }
        } // Find origin hover time on value index


        if (nextHoverValue.length >= 2) {
          var miss = nextHoverValue.some(function (ht) {
            return !includesTime(value, ht, 'month');
          });

          if (miss) {
            var newValue = nextHoverValue.slice().sort(function (t1, t2) {
              return t1.valueOf() - t2.valueOf();
            });

            if (newValue[0].isSame(newValue[1], 'month')) {
              newValue[1] = newValue[0].clone().add(1, 'month');
            }

            _this.fireValueChange(newValue);
          }
        } else if (nextHoverValue.length === 1) {
          // If only one value, let's keep the origin panel
          var oriValueIndex = value.findIndex(function (time) {
            return time.isSame(currentHoverTime, 'month');
          });
          if (oriValueIndex === -1) oriValueIndex = 0;

          if (value.every(function (time) {
            return !time.isSame(nextHoverTime, 'month');
          })) {
            var _newValue = value.slice();

            _newValue[oriValueIndex] = nextHoverTime.clone();

            _this.fireValueChange(_newValue);
          }
        }

        event.preventDefault();
        return nextHoverTime;
      };

      switch (keyCode) {
        case _util_KeyCode.DOWN:
          updateHoverPoint(function (time) {
            return toTime_goTime(time, 1, 'weeks');
          });
          return;

        case _util_KeyCode.UP:
          updateHoverPoint(function (time) {
            return toTime_goTime(time, -1, 'weeks');
          });
          return;

        case _util_KeyCode.LEFT:
          if (ctrlKey) {
            updateHoverPoint(function (time) {
              return toTime_goTime(time, -1, 'years');
            });
          } else {
            updateHoverPoint(function (time) {
              return toTime_goTime(time, -1, 'days');
            });
          }

          return;

        case _util_KeyCode.RIGHT:
          if (ctrlKey) {
            updateHoverPoint(function (time) {
              return toTime_goTime(time, 1, 'years');
            });
          } else {
            updateHoverPoint(function (time) {
              return toTime_goTime(time, 1, 'days');
            });
          }

          return;

        case _util_KeyCode.HOME:
          updateHoverPoint(function (time) {
            return goStartMonth(time);
          });
          return;

        case _util_KeyCode.END:
          updateHoverPoint(function (time) {
            return goEndMonth(time);
          });
          return;

        case _util_KeyCode.PAGE_DOWN:
          updateHoverPoint(function (time) {
            return toTime_goTime(time, 1, 'month');
          });
          return;

        case _util_KeyCode.PAGE_UP:
          updateHoverPoint(function (time) {
            return toTime_goTime(time, -1, 'month');
          });
          return;

        case _util_KeyCode.ENTER:
          {
            var lastValue;

            if (hoverValue.length === 0) {
              lastValue = updateHoverPoint(function (time) {
                return time;
              });
            } else if (hoverValue.length === 1) {
              lastValue = hoverValue[0];
            } else {
              lastValue = hoverValue[0].isSame(firstSelectedValue, 'day') ? hoverValue[1] : hoverValue[0];
            }

            if (lastValue && (!disabledDate || !disabledDate(lastValue))) {
              this.onSelect(lastValue);
            }

            event.preventDefault();
            return;
          }

        default:
          this.__emit('keydown', event);

      }
    },
    onDayHover: function onDayHover(value) {
      var hoverValue = [];
      var sSelectedValue = this.sSelectedValue,
          firstSelectedValue = this.firstSelectedValue,
          type = this.type;

      if (type === 'start' && sSelectedValue[1]) {
        hoverValue = this.compare(value, sSelectedValue[1]) < 0 ? [value, sSelectedValue[1]] : [value];
      } else if (type === 'end' && sSelectedValue[0]) {
        hoverValue = this.compare(value, sSelectedValue[0]) > 0 ? [sSelectedValue[0], value] : [];
      } else {
        if (!firstSelectedValue) {
          if (this.sHoverValue.length) {
            this.setState({
              sHoverValue: []
            });
          }

          return hoverValue;
        }

        hoverValue = this.compare(value, firstSelectedValue) < 0 ? [value, firstSelectedValue] : [firstSelectedValue, value];
      }

      this.fireHoverValueChange(hoverValue);
      return hoverValue;
    },
    onToday: function onToday() {
      var startValue = getTodayTime(this.sValue[0]);
      var endValue = startValue.clone().add(1, 'months');
      this.setState({
        sValue: [startValue, endValue]
      });
    },
    onOpenTimePicker: function onOpenTimePicker() {
      this.setState({
        showTimePicker: true
      });
    },
    onCloseTimePicker: function onCloseTimePicker() {
      this.setState({
        showTimePicker: false
      });
    },
    onOk: function onOk() {
      var sSelectedValue = this.sSelectedValue;

      if (this.isAllowedDateAndTime(sSelectedValue)) {
        this.__emit('ok', sSelectedValue);
      }
    },
    onStartInputSelect: function onStartInputSelect() {
      for (var _len = arguments.length, oargs = new Array(_len), _key = 0; _key < _len; _key++) {
        oargs[_key] = arguments[_key];
      }

      var args = ['left'].concat(oargs);
      return onInputSelect.apply(this, args);
    },
    onEndInputSelect: function onEndInputSelect() {
      for (var _len2 = arguments.length, oargs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        oargs[_key2] = arguments[_key2];
      }

      var args = ['right'].concat(oargs);
      return onInputSelect.apply(this, args);
    },
    onStartValueChange: function onStartValueChange(leftValue) {
      var value = RangeCalendar_toConsumableArray(this.sValue);

      value[0] = leftValue;
      return this.fireValueChange(value);
    },
    onEndValueChange: function onEndValueChange(rightValue) {
      var value = RangeCalendar_toConsumableArray(this.sValue);

      value[1] = rightValue;
      return this.fireValueChange(value);
    },
    onStartPanelChange: function onStartPanelChange(value, mode) {
      var sMode = this.sMode,
          sValue = this.sValue;
      var newMode = [mode, sMode[1]];
      var newValue = [value || sValue[0], sValue[1]];

      this.__emit('panelChange', newValue, newMode);

      if (!Object(props_util["p" /* hasProp */])(this, 'mode')) {
        this.setState({
          sMode: newMode
        });
      }
    },
    onEndPanelChange: function onEndPanelChange(value, mode) {
      var sMode = this.sMode,
          sValue = this.sValue;
      var newMode = [sMode[0], mode];
      var newValue = [sValue[0], value || sValue[1]];

      this.__emit('panelChange', newValue, newMode);

      if (!Object(props_util["p" /* hasProp */])(this, 'mode')) {
        this.setState({
          sMode: newMode
        });
      }
    },
    getStartValue: function getStartValue() {
      var value = this.sValue[0];
      var selectedValue = this.sSelectedValue; // keep selectedTime when select date

      if (selectedValue[0] && this.timePicker) {
        value = value.clone();
        syncTime(selectedValue[0], value);
      }

      if (this.showTimePicker && selectedValue[0]) {
        return selectedValue[0];
      }

      return value;
    },
    getEndValue: function getEndValue() {
      var sValue = this.sValue,
          sSelectedValue = this.sSelectedValue,
          showTimePicker = this.showTimePicker;
      var endValue = sValue[1] ? sValue[1].clone() : sValue[0].clone().add(1, 'month'); // keep selectedTime when select date

      if (sSelectedValue[1] && this.timePicker) {
        syncTime(sSelectedValue[1], endValue);
      }

      if (showTimePicker) {
        return sSelectedValue[1] ? sSelectedValue[1] : this.getStartValue();
      }

      return endValue;
    },
    // get disabled hours for second picker
    getEndDisableTime: function getEndDisableTime() {
      var sSelectedValue = this.sSelectedValue,
          sValue = this.sValue,
          disabledTime = this.disabledTime;
      var userSettingDisabledTime = disabledTime(sSelectedValue, 'end') || {};
      var startValue = sSelectedValue && sSelectedValue[0] || sValue[0].clone(); // if startTime and endTime is same day..
      // the second time picker will not able to pick time before first time picker

      if (!sSelectedValue[1] || startValue.isSame(sSelectedValue[1], 'day')) {
        var hours = startValue.hour();
        var minutes = startValue.minute();
        var second = startValue.second();
        var _disabledHours = userSettingDisabledTime.disabledHours,
            _disabledMinutes = userSettingDisabledTime.disabledMinutes,
            _disabledSeconds = userSettingDisabledTime.disabledSeconds;
        var oldDisabledMinutes = _disabledMinutes ? _disabledMinutes() : [];
        var olddisabledSeconds = _disabledSeconds ? _disabledSeconds() : [];
        _disabledHours = RangeCalendar_generateOptions(hours, _disabledHours);
        _disabledMinutes = RangeCalendar_generateOptions(minutes, _disabledMinutes);
        _disabledSeconds = RangeCalendar_generateOptions(second, _disabledSeconds);
        return {
          disabledHours: function disabledHours() {
            return _disabledHours;
          },
          disabledMinutes: function disabledMinutes(hour) {
            if (hour === hours) {
              return _disabledMinutes;
            }

            return oldDisabledMinutes;
          },
          disabledSeconds: function disabledSeconds(hour, minute) {
            if (hour === hours && minute === minutes) {
              return _disabledSeconds;
            }

            return olddisabledSeconds;
          }
        };
      }

      return userSettingDisabledTime;
    },
    isAllowedDateAndTime: function isAllowedDateAndTime(selectedValue) {
      return util_isAllowedDate(selectedValue[0], this.disabledDate, this.disabledStartTime) && util_isAllowedDate(selectedValue[1], this.disabledDate, this.disabledEndTime);
    },
    isMonthYearPanelShow: function isMonthYearPanelShow(mode) {
      return ['month', 'year', 'decade'].indexOf(mode) > -1;
    },
    hasSelectedValue: function hasSelectedValue() {
      var sSelectedValue = this.sSelectedValue;
      return !!sSelectedValue[1] && !!sSelectedValue[0];
    },
    compare: function compare(v1, v2) {
      if (this.timePicker) {
        return v1.diff(v2);
      }

      return v1.diff(v2, 'days');
    },
    fireSelectValueChange: function fireSelectValueChange(selectedValue, direct) {
      var timePicker = this.timePicker,
          prevSelectedValue = this.prevSelectedValue;

      if (timePicker) {
        var timePickerProps = Object(props_util["j" /* getOptionProps */])(timePicker);

        if (timePickerProps.defaultValue) {
          var timePickerDefaultValue = timePickerProps.defaultValue;

          if (!prevSelectedValue[0] && selectedValue[0]) {
            syncTime(timePickerDefaultValue[0], selectedValue[0]);
          }

          if (!prevSelectedValue[1] && selectedValue[1]) {
            syncTime(timePickerDefaultValue[1], selectedValue[1]);
          }
        }
      } // 尚未选择过时间，直接输入的话


      if (!this.sSelectedValue[0] || !this.sSelectedValue[1]) {
        var startValue = selectedValue[0] || external_moment_default()();
        var endValue = selectedValue[1] || startValue.clone().add(1, 'months');
        this.setState({
          sSelectedValue: selectedValue,
          sValue: selectedValue && selectedValue.length === 2 ? getValueFromSelectedValue([startValue, endValue]) : this.sValue
        });
      }

      if (selectedValue[0] && !selectedValue[1]) {
        this.setState({
          firstSelectedValue: selectedValue[0]
        });
        this.fireHoverValueChange(selectedValue.concat());
      }

      this.__emit('change', selectedValue);

      if (direct || selectedValue[0] && selectedValue[1]) {
        this.setState({
          prevSelectedValue: selectedValue,
          firstSelectedValue: null
        });
        this.fireHoverValueChange([]);

        this.__emit('select', selectedValue);
      }

      if (!Object(props_util["p" /* hasProp */])(this, 'selectedValue')) {
        this.setState({
          sSelectedValue: selectedValue
        });
      }
    },
    fireValueChange: function fireValueChange(value) {
      if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
        this.setState({
          sValue: value
        });
      }

      this.__emit('valueChange', value);
    },
    fireHoverValueChange: function fireHoverValueChange(hoverValue) {
      if (!Object(props_util["p" /* hasProp */])(this, 'hoverValue')) {
        this.setState({
          sHoverValue: hoverValue
        });
      }

      this.__emit('hoverChange', hoverValue);
    },
    clear: function clear() {
      this.fireSelectValueChange([], true);

      this.__emit('clear');
    },
    disabledStartTime: function disabledStartTime(time) {
      return this.disabledTime(time, 'start');
    },
    disabledEndTime: function disabledEndTime(time) {
      return this.disabledTime(time, 'end');
    },
    disabledStartMonth: function disabledStartMonth(month) {
      var sValue = this.sValue;
      return month.isSameOrAfter(sValue[1], 'month');
    },
    disabledEndMonth: function disabledEndMonth(month) {
      var sValue = this.sValue;
      return month.isSameOrBefore(sValue[0], 'month');
    }
  },
  render: function render() {
    var _className, _cls;

    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var prefixCls = props.prefixCls,
        dateInputPlaceholder = props.dateInputPlaceholder,
        timePicker = props.timePicker,
        showOk = props.showOk,
        locale = props.locale,
        showClear = props.showClear,
        showToday = props.showToday,
        type = props.type;
    var sHoverValue = this.sHoverValue,
        sSelectedValue = this.sSelectedValue,
        sMode = this.sMode,
        showTimePicker = this.showTimePicker,
        sValue = this.sValue,
        $listeners = this.$listeners;
    var className = (_className = {}, RangeCalendar_defineProperty(_className, prefixCls, 1), RangeCalendar_defineProperty(_className, "".concat(prefixCls, "-hidden"), !props.visible), RangeCalendar_defineProperty(_className, "".concat(prefixCls, "-range"), 1), RangeCalendar_defineProperty(_className, "".concat(prefixCls, "-show-time-picker"), showTimePicker), RangeCalendar_defineProperty(_className, "".concat(prefixCls, "-week-number"), props.showWeekNumber), _className);
    var baseProps = {
      props: props,
      on: $listeners
    };
    var newProps = {
      props: {
        selectedValue: sSelectedValue
      },
      on: {
        select: this.onSelect,
        dayHover: type === 'start' && sSelectedValue[1] || type === 'end' && sSelectedValue[0] || !!sHoverValue.length ? this.onDayHover : RangeCalendar_noop
      }
    };
    var placeholder1;
    var placeholder2;

    if (dateInputPlaceholder) {
      if (Array.isArray(dateInputPlaceholder)) {
        var _dateInputPlaceholder = RangeCalendar_slicedToArray(dateInputPlaceholder, 2);

        placeholder1 = _dateInputPlaceholder[0];
        placeholder2 = _dateInputPlaceholder[1];
      } else {
        placeholder1 = placeholder2 = dateInputPlaceholder;
      }
    }

    var showOkButton = showOk === true || showOk !== false && !!timePicker;
    var cls = (_cls = {}, RangeCalendar_defineProperty(_cls, "".concat(prefixCls, "-footer"), true), RangeCalendar_defineProperty(_cls, "".concat(prefixCls, "-range-bottom"), true), RangeCalendar_defineProperty(_cls, "".concat(prefixCls, "-footer-show-ok"), showOkButton), _cls);
    var startValue = this.getStartValue();
    var endValue = this.getEndValue();
    var todayTime = getTodayTime(startValue);
    var thisMonth = todayTime.month();
    var thisYear = todayTime.year();
    var isTodayInView = startValue.year() === thisYear && startValue.month() === thisMonth || endValue.year() === thisYear && endValue.month() === thisMonth;
    var nextMonthOfStart = startValue.clone().add(1, 'months');
    var isClosestMonths = nextMonthOfStart.year() === endValue.year() && nextMonthOfStart.month() === endValue.month();
    var leftPartProps = Object(props_util["t" /* mergeProps */])(baseProps, newProps, {
      props: {
        hoverValue: sHoverValue,
        direction: 'left',
        disabledTime: this.disabledStartTime,
        disabledMonth: this.disabledStartMonth,
        format: this.getFormat(),
        value: startValue,
        mode: sMode[0],
        placeholder: placeholder1,
        showDateInput: this.showDateInput,
        timePicker: timePicker,
        showTimePicker: showTimePicker,
        enablePrev: true,
        enableNext: !isClosestMonths || this.isMonthYearPanelShow(sMode[1])
      },
      on: {
        inputSelect: this.onStartInputSelect,
        valueChange: this.onStartValueChange,
        panelChange: this.onStartPanelChange
      }
    });
    var rightPartProps = Object(props_util["t" /* mergeProps */])(baseProps, newProps, {
      props: {
        hoverValue: sHoverValue,
        direction: 'right',
        format: this.getFormat(),
        timePickerDisabledTime: this.getEndDisableTime(),
        placeholder: placeholder2,
        value: endValue,
        mode: sMode[1],
        showDateInput: this.showDateInput,
        timePicker: timePicker,
        showTimePicker: showTimePicker,
        disabledTime: this.disabledEndTime,
        disabledMonth: this.disabledEndMonth,
        enablePrev: !isClosestMonths || this.isMonthYearPanelShow(sMode[0]),
        enableNext: true
      },
      on: {
        inputSelect: this.onEndInputSelect,
        valueChange: this.onEndValueChange,
        panelChange: this.onEndPanelChange
      }
    });
    var TodayButtonNode = null;

    if (showToday) {
      var todayButtonProps = Object(props_util["t" /* mergeProps */])(baseProps, {
        props: {
          disabled: isTodayInView,
          value: sValue[0],
          text: locale.backToToday
        },
        on: {
          today: this.onToday
        }
      });
      TodayButtonNode = h(TodayButton, todayButtonProps);
    }

    var TimePickerButtonNode = null;

    if (props.timePicker) {
      var timePickerButtonProps = Object(props_util["t" /* mergeProps */])(baseProps, {
        props: {
          showTimePicker: showTimePicker,
          timePickerDisabled: !this.hasSelectedValue() || sHoverValue.length
        },
        on: {
          openTimePicker: this.onOpenTimePicker,
          closeTimePicker: this.onCloseTimePicker
        }
      });
      TimePickerButtonNode = h(TimePickerButton, timePickerButtonProps);
    }

    var OkButtonNode = null;

    if (showOkButton) {
      var okButtonProps = Object(props_util["t" /* mergeProps */])(baseProps, {
        props: {
          okDisabled: !this.isAllowedDateAndTime(sSelectedValue) || !this.hasSelectedValue() || sHoverValue.length
        },
        on: {
          ok: this.onOk
        }
      });
      OkButtonNode = h(OkButton, okButtonProps);
    }

    return h("div", {
      ref: 'rootInstance',
      "class": className,
      attrs: {
        tabIndex: '0'
      },
      on: {
        "keydown": this.onKeyDown
      }
    }, [props.renderSidebar(), h("div", {
      "class": "".concat(prefixCls, "-panel")
    }, [showClear && sSelectedValue[0] && sSelectedValue[1] ? h("a", {
      "class": "".concat(prefixCls, "-clear-btn"),
      attrs: {
        role: 'button',
        title: locale.clear
      },
      on: {
        "click": this.clear
      }
    }) : null, h("div", {
      "class": "".concat(prefixCls, "-date-panel"),
      on: {
        "mouseleave": type !== 'both' ? this.onDatePanelLeave : RangeCalendar_noop,
        "mouseenter": type !== 'both' ? this.onDatePanelEnter : RangeCalendar_noop
      }
    }, [h(range_calendar_CalendarPart, leftPartProps), h("span", {
      "class": "".concat(prefixCls, "-range-middle")
    }, ["~"]), h(range_calendar_CalendarPart, rightPartProps)]), h("div", {
      "class": cls
    }, [props.renderFooter(), showToday || props.timePicker || showOkButton ? h("div", {
      "class": "".concat(prefixCls, "-footer-btn")
    }, [TodayButtonNode, TimePickerButtonNode, OkButtonNode]) : null])])]);
  }
};
/* harmony default export */ var src_RangeCalendar = (RangeCalendar);
// CONCATENATED MODULE: ./src/components/tag/Tag.jsx


function Tag_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Tag_defineProperty(target, key, source[key]); }); } return target; }

function Tag_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








/* harmony default export */ var tag_Tag = ({
  name: 'TaTag',
  mixins: [BaseMixin["a" /* default */]],
  props: {
    prefixCls: vue_types["a" /* default */].string.def('ant-tag'),
    color: vue_types["a" /* default */].string,
    closable: vue_types["a" /* default */].bool,
    visible: vue_types["a" /* default */].bool,
    afterClose: vue_types["a" /* default */].func
  },
  model: {
    prop: 'visible',
    event: 'close.visible'
  },
  data: function data() {
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var state = {};

    if ('visible' in props) {
      state = {
        _visible: props.visible,
        _closed: !props.visible
      };
    }

    state = Tag_objectSpread({
      _closing: false,
      _closed: false,
      _visible: true
    }, state);
    this.pre_visible = state._visible;
    return state;
  },
  watch: {
    visible: function visible(val) {
      this.setState({
        _visible: val
      });
    }
  },
  updated: function updated() {
    var _this = this;

    this.$nextTick(function () {
      var preVisible = _this.pre_visible;
      _this.pre_visible = _this.$data._visible;

      if (preVisible && !_this.$data._visible) {
        _this.close();
      } else if (!preVisible && _this.$data._visible) {
        _this.show();
      }
    });
  },
  methods: {
    handleIconClick: function handleIconClick(e) {
      this.$emit('close', e);
      this.$emit('close.visible', false);

      if (e.defaultPrevented || Object(props_util["p" /* hasProp */])(this, 'visible')) {
        return;
      }

      this.setState({
        _visible: false
      });
      this.$forceUpdate();
    },
    close: function close() {
      if (this.$data._closing || this.$data._closed) {
        return;
      }

      var dom = this.$el;
      dom.style.width = "".concat(dom.getBoundingClientRect().width, "px"); // It's Magic Code, don't know why

      dom.style.width = "".concat(dom.getBoundingClientRect().width, "px");
      this.setState({
        _closing: true
      });
    },
    show: function show() {
      this.setState({
        _closed: false
      });
    },
    animationEnd: function animationEnd(_, existed) {
      if (!existed && !this.$data._closed) {
        this.setState({
          _closed: true,
          _closing: false
        });
        var afterClose = this.afterClose;

        if (afterClose) {
          afterClose();
        }
      } else {
        this.setState({
          _closed: false
        });
      }
    },
    isPresetColor: function isPresetColor(color) {
      if (!color) {
        return false;
      }

      return /^(pink|red|yellow|orange|cyan|green|blue|purple|geekblue|magenta|volcano|gold|lime)(-inverse)?$/.test(color);
    }
  },
  render: function render() {
    var _cls,
        _this2 = this;

    var h = arguments[0];
    var _this$$props = this.$props,
        prefixCls = _this$$props.prefixCls,
        closable = _this$$props.closable,
        color = _this$$props.color;
    var closeIcon = closable ? h(components_icon, {
      attrs: {
        type: 'close'
      },
      on: {
        "click": this.handleIconClick
      }
    }) : '';
    var isPresetColor = this.isPresetColor(color);
    var cls = (_cls = {}, Tag_defineProperty(_cls, "".concat(prefixCls), true), Tag_defineProperty(_cls, "".concat(prefixCls, "-").concat(color), isPresetColor), Tag_defineProperty(_cls, "".concat(prefixCls, "-has-color"), color && !isPresetColor), Tag_defineProperty(_cls, "".concat(prefixCls, "-close"), this.$data._closing), _cls);
    var tagStyle = {
      backgroundColor: color && !isPresetColor ? color : null
    };
    var tag = h("div", babel_helper_vue_jsx_merge_props_default()([{
      directives: [{
        name: "show",
        value: !this.$data._closing
      }],
      attrs: {
        "data-show": !this.$data._closing
      }
    }, {
      on: Object(es["a" /* default */])(this.$listeners, ['close'])
    }, {
      "class": cls,
      style: tagStyle
    }]), [this.$slots["default"], closeIcon]);
    var transitionProps = Object(getTransitionProps["a" /* default */])("".concat(prefixCls, "-zoom"), {
      afterLeave: function afterLeave() {
        return _this2.animationEnd(undefined, false);
      },
      afterEnter: function afterEnter() {
        return _this2.animationEnd(undefined, true);
      }
    });
    return h(wave, [this.$data._closed ? h("span") : h("transition", transitionProps, [tag])]);
  }
});
// CONCATENATED MODULE: ./src/components/tag/CheckableTag.jsx
function CheckableTag_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* harmony default export */ var CheckableTag = ({
  name: 'TaCheckableTag',
  model: {
    prop: 'checked'
  },
  props: {
    prefixCls: {
      "default": 'ant-tag',
      type: String
    },
    checked: Boolean
  },
  computed: {
    classes: function classes() {
      var _ref;

      var prefixCls = this.prefixCls,
          checked = this.checked;
      return _ref = {}, CheckableTag_defineProperty(_ref, "".concat(prefixCls), true), CheckableTag_defineProperty(_ref, "".concat(prefixCls, "-checkable"), true), CheckableTag_defineProperty(_ref, "".concat(prefixCls, "-checkable-checked"), checked), _ref;
    }
  },
  methods: {
    handleClick: function handleClick() {
      var checked = this.checked;
      this.$emit('input', !checked);
      this.$emit('change', !checked);
    }
  },
  render: function render() {
    var h = arguments[0];
    var classes = this.classes,
        handleClick = this.handleClick,
        $slots = this.$slots;
    return h("div", {
      "class": classes,
      on: {
        "click": handleClick
      }
    }, [$slots["default"]]);
  }
});
// CONCATENATED MODULE: ./src/components/tag/index.js


tag_Tag.CheckableTag = CheckableTag;
/* istanbul ignore next */

tag_Tag.install = function (Vue) {
  Vue.component(tag_Tag.name, tag_Tag);
  Vue.component(tag_Tag.CheckableTag.name, tag_Tag.CheckableTag);
};

/* harmony default export */ var components_tag = (tag_Tag);
// CONCATENATED MODULE: ./src/components/date-picker/interface.js
function interface_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      interface_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function interface_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

 // import { TimePickerProps } from '../time-picker'


var interface_MomentType = {
  type: Object,
  validator: function validator(value) {
    return value === undefined || external_moment_["isMoment"](value);
  }
};
var interface_PickerProps = function PickerProps() {
  return {
    transitionName: vue_types["a" /* default */].string,
    prefixCls: vue_types["a" /* default */].string,
    inputPrefixCls: vue_types["a" /* default */].string,
    format: vue_types["a" /* default */].string,
    disabled: vue_types["a" /* default */].bool,
    allowClear: vue_types["a" /* default */].bool,
    popupStyle: vue_types["a" /* default */].object,
    dropdownClassName: vue_types["a" /* default */].string,
    locale: vue_types["a" /* default */].any,
    localeCode: vue_types["a" /* default */].string,
    size: vue_types["a" /* default */].oneOf(['large', 'small', 'default']),
    getCalendarContainer: vue_types["a" /* default */].func,
    open: vue_types["a" /* default */].bool,
    // onOpenChange: PropTypes.(status: bool) => void,
    disabledDate: vue_types["a" /* default */].func,
    renderExtraFooter: vue_types["a" /* default */].any,
    showToday: vue_types["a" /* default */].bool,
    dateRender: vue_types["a" /* default */].any,
    // (current: moment.Moment, today: moment.Moment) => React.ReactNode,
    pickerClass: vue_types["a" /* default */].string,
    pickerInputClass: vue_types["a" /* default */].string,
    timePicker: vue_types["a" /* default */].any,
    autoFocus: vue_types["a" /* default */].bool,
    tagPrefixCls: vue_types["a" /* default */].string
  };
};
var SinglePickerProps = function SinglePickerProps() {
  return {
    value: interface_MomentType,
    defaultValue: interface_MomentType,
    defaultPickerValue: interface_MomentType // onChange?: (date: moment.Moment, dateString: string) => void;

  };
};
var interface_DatePickerProps = function DatePickerProps() {
  return interface_objectSpread({}, interface_PickerProps(), SinglePickerProps(), {
    showTime: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].object, vue_types["a" /* default */].bool]),
    open: vue_types["a" /* default */].bool,
    disabledTime: vue_types["a" /* default */].func,
    // onOpenChange?: (status: bool) => void;
    // onOk?: (selectedTime: moment.Moment) => void;
    placeholder: vue_types["a" /* default */].string
  });
};
var interface_MonthPickerProps = function MonthPickerProps() {
  return interface_objectSpread({}, interface_PickerProps(), SinglePickerProps(), {
    placeholder: vue_types["a" /* default */].string,
    monthCellContentRender: vue_types["a" /* default */].func
  });
};

function interface_isMomentArray(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || value.findIndex(function (val) {
      return val === undefined || external_moment_["isMoment"](val);
    }) !== -1;
  }

  return false;
}

var RangePickerValue = vue_types["a" /* default */].custom(interface_isMomentArray); // export const RangePickerPresetRange = PropTypes.oneOfType([RangePickerValue, PropTypes.func])

var interface_RangePickerProps = function RangePickerProps() {
  return interface_objectSpread({}, interface_PickerProps(), {
    value: RangePickerValue,
    defaultValue: RangePickerValue,
    defaultPickerValue: RangePickerValue,
    // onChange?: (dates: RangePickerValue, dateStrings: [string, string]) => void;
    // onCalendarChange?: (dates: RangePickerValue, dateStrings: [string, string]) => void;
    // onOk?: (selectedTime: moment.Moment) => void;
    showTime: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].object, vue_types["a" /* default */].bool]),
    ranges: vue_types["a" /* default */].object,
    placeholder: vue_types["a" /* default */].arrayOf(String),
    mode: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].arrayOf(String)]),
    disabledTime: vue_types["a" /* default */].func,
    showToday: vue_types["a" /* default */].bool // onPanelChange?: (value?: RangePickerValue, mode?: string | string[]) => void;

  });
};
var interface_WeekPickerProps = function WeekPickerProps() {
  return interface_objectSpread({}, interface_PickerProps(), SinglePickerProps(), {
    placeholder: vue_types["a" /* default */].string
  });
}; // export interface DatePickerDecorator extends React.ClassicComponentClass<DatePickerProps> {
//   RangePicker: React.ClassicComponentClass<RangePickerProps>;
//   MonthPicker: React.ClassicComponentClass<MonthPickerProps>;
//   WeekPicker: React.ClassicComponentClass<WeexPickerProps>;
// }
// CONCATENATED MODULE: ./src/components/date-picker/RangePicker.jsx
function RangePicker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { RangePicker_defineProperty(target, key, source[key]); }); } return target; }

function RangePicker_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function RangePicker_slicedToArray(arr, i) { return RangePicker_arrayWithHoles(arr) || RangePicker_iterableToArrayLimit(arr, i) || RangePicker_nonIterableRest(); }

function RangePicker_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function RangePicker_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function RangePicker_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }













function RangePicker_noop() {}

function getShowDateFromValue(value) {
  var _value = RangePicker_slicedToArray(value, 2),
      start = _value[0],
      end = _value[1]; // value could be an empty array, then we should not reset showDate


  if (!start && !end) {
    return;
  }

  var newEnd = end && end.isSame(start, 'month') ? end.clone().add(1, 'month') : end;
  return [start, newEnd];
}

function formatValue(value, format) {
  return value && value.format(format) || '';
}

function pickerValueAdapter(value) {
  if (!value) {
    return;
  }

  if (Array.isArray(value)) {
    return value;
  }

  return [value, value.clone().add(1, 'month')];
}

function RangePicker_isEmptyArray(arr) {
  if (Array.isArray(arr)) {
    return arr.length === 0 || arr.every(function (i) {
      return !i;
    });
  }

  return false;
}

function fixLocale(value, localeCode) {
  if (!localeCode) {
    return;
  }

  if (!value || value.length === 0) {
    return;
  }

  if (value[0]) {
    value[0].locale(localeCode);
  }

  if (value[1]) {
    value[1].locale(localeCode);
  }
}

/* harmony default export */ var RangePicker = ({
  mixins: [BaseMixin["a" /* default */]],
  name: 'TaRangePicker',
  props: Object(props_util["q" /* initDefaultProps */])(interface_RangePickerProps(), {
    prefixCls: 'ant-calendar',
    tagPrefixCls: 'ant-tag',
    allowClear: true,
    showToday: false
  }),
  model: {
    prop: 'value',
    event: 'change'
  },
  data: function data() {
    var value = this.value || this.defaultValue || [];

    if (value[0] && !interopDefault(external_moment_).isMoment(value[0]) || value[1] && !interopDefault(external_moment_).isMoment(value[1])) {
      throw new Error('The value/defaultValue of RangePicker must be a moment object array after `antd@2.0`, ' + 'see: https://u.ant.design/date-picker-value');
    }

    var pickerValue = !value || RangePicker_isEmptyArray(value) ? this.defaultPickerValue : value;
    return {
      sValue: value,
      sShowDate: pickerValueAdapter(pickerValue || interopDefault(external_moment_)()),
      sOpen: this.open,
      sHoverValue: []
    };
  },
  watch: {
    value: function value(val) {
      var value = val || [];
      var state = {
        sValue: value
      };

      if (!shallowequal_default()(val, this.sValue)) {
        state = RangePicker_objectSpread({}, state, {
          sShowDate: getShowDateFromValue(value) || this.sShowDate
        });
      }

      this.setState(state);
    },
    open: function open(val) {
      this.setState({
        sOpen: val
      });
    }
  },
  methods: {
    clearSelection: function clearSelection(e) {
      e.preventDefault();
      e.stopPropagation();
      this.setState({
        sValue: []
      });
      this.handleChange([]);
    },
    clearHoverValue: function clearHoverValue() {
      this.setState({
        sHoverValue: []
      });
    },
    handleChange: function handleChange(value) {
      if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
        this.setState(function (_ref) {
          var sShowDate = _ref.sShowDate;
          return {
            sValue: value,
            sShowDate: getShowDateFromValue(value) || sShowDate
          };
        });
      }

      this.$emit('change', value, [formatValue(value[0], this.format), formatValue(value[1], this.format)]);
    },
    handleOpenChange: function handleOpenChange(open) {
      if (!Object(props_util["p" /* hasProp */])(this, 'open')) {
        this.setState({
          sOpen: open
        });
      }

      if (open === false) {
        this.clearHoverValue();
      }

      this.$emit('openChange', open);
    },
    handleShowDateChange: function handleShowDateChange(showDate) {
      this.setState({
        sShowDate: showDate
      });
    },
    handleHoverChange: function handleHoverChange(hoverValue) {
      this.setState({
        sHoverValue: hoverValue
      });
    },
    handleRangeMouseLeave: function handleRangeMouseLeave() {
      if (this.sOpen) {
        this.clearHoverValue();
      }
    },
    handleCalendarInputSelect: function handleCalendarInputSelect(value) {
      if (!value[0]) {
        return;
      }

      this.setState(function (_ref2) {
        var sShowDate = _ref2.sShowDate;
        return {
          sValue: value,
          sShowDate: getShowDateFromValue(value) || sShowDate
        };
      });
    },
    handleRangeClick: function handleRangeClick(value) {
      if (typeof value === 'function') {
        value = value();
      }

      this.setValue(value, true);
      this.$emit('ok', value);
    },
    setValue: function setValue(value, hidePanel) {
      this.handleChange(value);

      if ((hidePanel || !this.showTime) && !Object(props_util["p" /* hasProp */])(this, 'open')) {
        this.setState({
          sOpen: false
        });
      }
    },
    onMouseEnter: function onMouseEnter(e) {
      this.$emit('mouseenter', e);
    },
    onMouseLeave: function onMouseLeave(e) {
      this.$emit('mouseleave', e);
    },
    focus: function focus() {
      this.$refs.picker.focus();
    },
    blur: function blur() {
      this.$refs.picker.blur();
    },
    renderFooter: function renderFooter() {
      var _this = this;

      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          ranges = this.ranges,
          $scopedSlots = this.$scopedSlots,
          $slots = this.$slots,
          tagPrefixCls = this.tagPrefixCls;
      var renderExtraFooter = this.renderExtraFooter || $scopedSlots.renderExtraFooter || $slots.renderExtraFooter;

      if (!ranges && !renderExtraFooter) {
        return null;
      }

      var customFooter = renderExtraFooter ? h("div", {
        "class": "".concat(prefixCls, "-footer-extra"),
        key: 'extra'
      }, [typeof renderExtraFooter === 'function' ? renderExtraFooter.apply(void 0, arguments) : renderExtraFooter]) : null;
      var operations = Object.keys(ranges || {}).map(function (range) {
        var value = ranges[range];
        return h(components_tag, {
          key: range,
          attrs: {
            prefixCls: tagPrefixCls,
            color: 'blue'
          },
          on: {
            "click": function click() {
              return _this.handleRangeClick(value);
            },
            "mouseenter": function mouseenter() {
              return _this.setState({
                sHoverValue: value
              });
            },
            "mouseleave": _this.handleRangeMouseLeave
          }
        }, [range]);
      });
      var rangeNode = h("div", {
        "class": "".concat(prefixCls, "-footer-extra ").concat(prefixCls, "-range-quick-selector"),
        key: 'range'
      }, [operations]);
      return [rangeNode, customFooter];
    }
  },
  render: function render() {
    var _classNames,
        _this2 = this;

    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var value = this.sValue,
        showDate = this.sShowDate,
        hoverValue = this.sHoverValue,
        open = this.sOpen,
        $listeners = this.$listeners,
        $scopedSlots = this.$scopedSlots;
    var _$listeners$calendarC = $listeners.calendarChange,
        calendarChange = _$listeners$calendarC === void 0 ? RangePicker_noop : _$listeners$calendarC,
        _$listeners$ok = $listeners.ok,
        ok = _$listeners$ok === void 0 ? RangePicker_noop : _$listeners$ok,
        _$listeners$focus = $listeners.focus,
        focus = _$listeners$focus === void 0 ? RangePicker_noop : _$listeners$focus,
        _$listeners$blur = $listeners.blur,
        blur = _$listeners$blur === void 0 ? RangePicker_noop : _$listeners$blur,
        _$listeners$panelChan = $listeners.panelChange,
        panelChange = _$listeners$panelChan === void 0 ? RangePicker_noop : _$listeners$panelChan;
    var prefixCls = props.prefixCls,
        popupStyle = props.popupStyle,
        disabledDate = props.disabledDate,
        disabledTime = props.disabledTime,
        showTime = props.showTime,
        showToday = props.showToday,
        ranges = props.ranges,
        locale = props.locale,
        localeCode = props.localeCode,
        format = props.format;
    var dateRender = props.dateRender || $scopedSlots.dateRender;
    fixLocale(value, localeCode);
    fixLocale(showDate, localeCode);
    var calendarClassName = classnames_default()((_classNames = {}, RangePicker_defineProperty(_classNames, "".concat(prefixCls, "-time"), showTime), RangePicker_defineProperty(_classNames, "".concat(prefixCls, "-range-with-ranges"), ranges), _classNames)); // 需要选择时间时，点击 ok 时才触发 onChange

    var pickerChangeHandler = {
      on: {
        change: this.handleChange
      }
    };
    var calendarProps = {
      on: {
        ok: this.handleChange
      },
      props: {}
    };

    if (props.timePicker) {
      pickerChangeHandler.on.change = function (changedValue) {
        return _this2.handleChange(changedValue);
      };
    } else {
      calendarProps = {
        on: {},
        props: {}
      };
    }

    if ('mode' in props) {
      calendarProps.props.mode = props.mode;
    }

    var startPlaceholder = 'placeholder' in props ? props.placeholder[0] : locale.lang.rangePlaceholder[0];
    var endPlaceholder = 'placeholder' in props ? props.placeholder[1] : locale.lang.rangePlaceholder[1];
    var rangeCalendarProps = Object(props_util["t" /* mergeProps */])(calendarProps, {
      props: {
        format: format,
        prefixCls: prefixCls,
        renderFooter: this.renderFooter,
        timePicker: props.timePicker,
        disabledDate: disabledDate,
        disabledTime: disabledTime,
        dateInputPlaceholder: [startPlaceholder, endPlaceholder],
        locale: locale.lang,
        dateRender: dateRender,
        value: showDate,
        hoverValue: hoverValue,
        showToday: showToday
      },
      on: {
        change: calendarChange,
        ok: ok,
        valueChange: this.handleShowDateChange,
        hoverChange: this.handleHoverChange,
        panelChange: panelChange,
        inputSelect: this.handleCalendarInputSelect
      },
      "class": calendarClassName,
      scopedSlots: $scopedSlots
    });
    var calendar = h(src_RangeCalendar, rangeCalendarProps); // default width for showTime

    var pickerStyle = {};

    if (props.showTime) {
      pickerStyle.width = '350px';
    }

    var clearIcon = !props.disabled && props.allowClear && value && (value[0] || value[1]) ? h(components_icon, {
      attrs: {
        type: 'cross-circle'
      },
      "class": "".concat(prefixCls, "-picker-clear"),
      on: {
        "click": this.clearSelection
      }
    }) : null;

    var input = function input(_ref3) {
      var inputValue = _ref3.value;
      var start = inputValue[0];
      var end = inputValue[1];
      return h("span", {
        "class": props.pickerInputClass
      }, [h("input", {
        attrs: {
          disabled: props.disabled,
          readOnly: true,
          placeholder: startPlaceholder,
          tabIndex: -1
        },
        domProps: {
          "value": start && start.format(props.format) || ''
        },
        "class": "".concat(prefixCls, "-range-picker-input")
      }), h("span", {
        "class": "".concat(prefixCls, "-range-picker-separator")
      }, [" ~ "]), h("input", {
        attrs: {
          disabled: props.disabled,
          readOnly: true,
          placeholder: endPlaceholder,
          tabIndex: -1
        },
        domProps: {
          "value": end && end.format(props.format) || ''
        },
        "class": "".concat(prefixCls, "-range-picker-input")
      }), clearIcon, h("span", {
        "class": "".concat(prefixCls, "-picker-icon")
      })]);
    };

    var vcDatePickerProps = Object(props_util["t" /* mergeProps */])({
      props: props,
      on: $listeners
    }, pickerChangeHandler, {
      props: {
        calendar: calendar,
        value: value,
        open: open,
        prefixCls: "".concat(prefixCls, "-picker-container")
      },
      on: {
        openChange: this.handleOpenChange
      },
      style: popupStyle
    });
    return h("span", {
      ref: 'picker',
      "class": props.pickerClass,
      style: pickerStyle,
      attrs: {
        tabIndex: props.disabled ? -1 : 0
      },
      on: {
        "focus": focus,
        "blur": blur,
        "mouseenter": this.onMouseEnter,
        "mouseleave": this.onMouseLeave
      }
    }, [h(src_Picker, vcDatePickerProps, [input])]);
  }
});
// CONCATENATED MODULE: ./src/components/date-picker/WeekPicker.jsx
function WeekPicker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { WeekPicker_defineProperty(target, key, source[key]); }); } return target; }

function WeekPicker_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










function WeekPicker_formatValue(value, format) {
  return value && value.format(format) || '';
}

function WeekPicker_noop() {}

/* harmony default export */ var WeekPicker = ({
  // static defaultProps = {
  //   format: 'YYYY-wo',
  //   allowClear: true,
  // };
  // private input: any;
  props: Object(props_util["q" /* initDefaultProps */])(interface_WeekPickerProps(), {
    format: 'gggg-wo',
    allowClear: true
  }),
  name: 'TaWeekPicker',
  mixins: [BaseMixin["a" /* default */]],
  model: {
    prop: 'value',
    event: 'change'
  },
  data: function data() {
    var value = this.value || this.defaultValue;

    if (value && !interopDefault(external_moment_).isMoment(value)) {
      throw new Error('The value/defaultValue of DatePicker or MonthPicker must be ' + 'a moment object');
    }

    return {
      sValue: value
    };
  },
  watch: {
    value: function value(val) {
      this.setState({
        sValue: val
      });
    }
  },
  methods: {
    weekDateRender: function weekDateRender(current) {
      var h = this.$createElement;
      var selectedValue = this.sValue;
      var prefixCls = this.prefixCls;

      if (selectedValue && current.year() === selectedValue.year() && current.week() === selectedValue.week()) {
        return h("div", {
          "class": "".concat(prefixCls, "-selected-day")
        }, [h("div", {
          "class": "".concat(prefixCls, "-date")
        }, [current.date()])]);
      }

      return h("div", {
        "class": "".concat(prefixCls, "-date")
      }, [current.date()]);
    },
    handleChange: function handleChange(value) {
      if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
        this.setState({
          sValue: value
        });
      }

      this.$emit('change', value, WeekPicker_formatValue(value, this.format));
    },
    clearSelection: function clearSelection(e) {
      e.preventDefault();
      e.stopPropagation();
      this.handleChange(null);
    },
    focus: function focus() {
      this.$refs.input.focus();
    },
    blur: function blur() {
      this.$refs.input.blur();
    }
  },
  render: function render() {
    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var prefixCls = this.prefixCls,
        disabled = this.disabled,
        pickerClass = this.pickerClass,
        popupStyle = this.popupStyle,
        pickerInputClass = this.pickerInputClass,
        format = this.format,
        allowClear = this.allowClear,
        locale = this.locale,
        localeCode = this.localeCode,
        disabledDate = this.disabledDate,
        pickerValue = this.sValue,
        $listeners = this.$listeners,
        $scopedSlots = this.$scopedSlots;
    var _$listeners$focus = $listeners.focus,
        focus = _$listeners$focus === void 0 ? WeekPicker_noop : _$listeners$focus,
        _$listeners$blur = $listeners.blur,
        blur = _$listeners$blur === void 0 ? WeekPicker_noop : _$listeners$blur;

    if (pickerValue && localeCode) {
      pickerValue.locale(localeCode);
    }

    var placeholder = Object(props_util["p" /* hasProp */])(this, 'placeholder') ? this.placeholder : locale.lang.placeholder;
    var weekDateRender = this.dateRender || $scopedSlots.dateRender || this.weekDateRender;
    var calendar = h(vc_calendar, {
      attrs: {
        showWeekNumber: true,
        dateRender: weekDateRender,
        prefixCls: prefixCls,
        format: format,
        locale: locale.lang,
        showDateInput: false,
        showToday: false,
        disabledDate: disabledDate
      }
    });
    var clearIcon = !disabled && allowClear && this.sValue ? h(components_icon, {
      attrs: {
        type: 'cross-circle'
      },
      "class": "".concat(prefixCls, "-picker-clear"),
      on: {
        "click": this.clearSelection
      }
    }) : null;

    var input = function input(_ref) {
      var value = _ref.value;
      return h("span", [h("input", {
        ref: 'input',
        attrs: {
          disabled: disabled,
          readOnly: true,
          placeholder: placeholder
        },
        domProps: {
          "value": value && value.format(format) || ''
        },
        "class": pickerInputClass,
        on: {
          "focus": focus,
          "blur": blur
        }
      }), clearIcon, h("span", {
        "class": "".concat(prefixCls, "-picker-icon")
      })]);
    };

    var vcDatePickerProps = {
      props: WeekPicker_objectSpread({}, props, {
        calendar: calendar,
        prefixCls: "".concat(prefixCls, "-picker-container"),
        value: pickerValue
      }),
      on: WeekPicker_objectSpread({}, $listeners, {
        change: this.handleChange
      }),
      style: popupStyle
    };
    return h("span", {
      "class": pickerClass
    }, [h(src_Picker, vcDatePickerProps, [input])]);
  }
});
// CONCATENATED MODULE: ./src/components/date-picker/index.js
function date_picker_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      date_picker_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function date_picker_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}








var DatePicker = wrapPicker(date_picker_objectSpread({}, createPicker(vc_calendar, interface_DatePickerProps()), {
  name: 'TaDatePicker'
}), interface_DatePickerProps());
var MonthPicker = wrapPicker(date_picker_objectSpread({}, createPicker(src_MonthCalendar, interface_MonthPickerProps()), {
  name: 'TaMonthPicker'
}), interface_MonthPickerProps(), 'YYYY-MM');
Object.assign(DatePicker, {
  RangePicker: wrapPicker(RangePicker, interface_RangePickerProps()),
  MonthPicker: MonthPicker,
  WeekPicker: wrapPicker(WeekPicker, interface_WeekPickerProps(), 'gggg-wo')
});
/* istanbul ignore next */

DatePicker.install = function (Vue) {
  Vue.component(DatePicker.name, DatePicker);
  Vue.component(DatePicker.RangePicker.name, DatePicker.RangePicker);
  Vue.component(DatePicker.MonthPicker.name, DatePicker.MonthPicker);
  Vue.component(DatePicker.WeekPicker.name, DatePicker.WeekPicker);
};

/* harmony default export */ var date_picker = (DatePicker);
// CONCATENATED MODULE: ./src/components/divider/index.jsx
function divider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var divider_Divider = {
  name: 'TaDivider',
  props: {
    prefixCls: vue_types["a" /* default */].string.def('ant'),
    type: vue_types["a" /* default */].oneOf(['horizontal', 'vertical', '']).def('horizontal'),
    dashed: vue_types["a" /* default */].bool,
    orientation: vue_types["a" /* default */].oneOf(['left', 'right'])
  },
  computed: {
    classString: function classString() {
      var _ref;

      var prefixCls = this.prefixCls,
          type = this.type,
          $slots = this.$slots,
          dashed = this.dashed,
          _this$orientation = this.orientation,
          orientation = _this$orientation === void 0 ? '' : _this$orientation;
      var orientationPrefix = orientation.length > 0 ? '-' + orientation : orientation;
      return _ref = {}, divider_defineProperty(_ref, "".concat(prefixCls, "-divider"), true), divider_defineProperty(_ref, "".concat(prefixCls, "-divider-").concat(type), true), divider_defineProperty(_ref, "".concat(prefixCls, "-divider-with-text").concat(orientationPrefix), $slots["default"]), divider_defineProperty(_ref, "".concat(prefixCls, "-divider-dashed"), !!dashed), _ref;
    }
  },
  render: function render() {
    var h = arguments[0];
    var classString = this.classString,
        prefixCls = this.prefixCls,
        $slots = this.$slots;
    return h("div", {
      "class": classString
    }, [$slots["default"] && h("span", {
      "class": "".concat(prefixCls, "-divider-inner-text")
    }, [$slots["default"]])]);
  }
};
/* istanbul ignore next */

divider_Divider.install = function (Vue) {
  Vue.component(divider_Divider.name, divider_Divider);
};

/* harmony default export */ var divider = (divider_Divider);
// CONCATENATED MODULE: ./src/components/dropdown/src/placements.js
var src_placements_autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var src_placements_targetOffset = [0, 0];
var src_placements_placements = {
  topLeft: {
    points: ['bl', 'tl'],
    overflow: src_placements_autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: src_placements_targetOffset
  },
  topCenter: {
    points: ['bc', 'tc'],
    overflow: src_placements_autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: src_placements_targetOffset
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: src_placements_autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: src_placements_targetOffset
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: src_placements_autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: src_placements_targetOffset
  },
  bottomCenter: {
    points: ['tc', 'bc'],
    overflow: src_placements_autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: src_placements_targetOffset
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: src_placements_autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: src_placements_targetOffset
  }
};
/* harmony default export */ var src_placements = (src_placements_placements);
// CONCATENATED MODULE: ./src/components/dropdown/src/Dropdown.jsx
function Dropdown_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Dropdown_defineProperty(target, key, source[key]); }); } return target; }

function Dropdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Dropdown_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Dropdown_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Dropdown_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







/* harmony default export */ var Dropdown = ({
  mixins: [BaseMixin["a" /* default */]],
  props: {
    minOverlayWidthMatchTrigger: vue_types["a" /* default */].bool.def(true),
    prefixCls: vue_types["a" /* default */].string.def('rc-dropdown'),
    transitionName: vue_types["a" /* default */].string,
    overlayClassName: vue_types["a" /* default */].string.def(''),
    animation: vue_types["a" /* default */].any,
    align: vue_types["a" /* default */].object,
    overlayStyle: vue_types["a" /* default */].object.def({}),
    placement: vue_types["a" /* default */].string.def('bottomLeft'),
    trigger: vue_types["a" /* default */].array.def(['hover']),
    showAction: vue_types["a" /* default */].array.def([]),
    hideAction: vue_types["a" /* default */].array.def([]),
    getPopupContainer: vue_types["a" /* default */].func,
    visible: vue_types["a" /* default */].bool,
    defaultVisible: vue_types["a" /* default */].bool.def(false),
    mouseEnterDelay: vue_types["a" /* default */].number.def(0.15),
    mouseLeaveDelay: vue_types["a" /* default */].number.def(0.1)
  },
  data: function data() {
    var sVisible = this.defaultVisible;

    if (Object(props_util["p" /* hasProp */])(this, 'visible')) {
      sVisible = this.visible;
    }

    return {
      sVisible: sVisible
    };
  },
  watch: {
    visible: function visible(val) {
      if (val !== undefined) {
        this.setState({
          sVisible: val
        });
      }
    }
  },
  methods: {
    onClick: function onClick(e) {
      // do no call onVisibleChange, if you need click to hide, use onClick and control visible
      if (!Object(props_util["p" /* hasProp */])(this, 'visible')) {
        this.setState({
          sVisible: false
        });
      }

      this.$emit('overlayClick', e);

      if (this.childOriginEvents.click) {
        this.childOriginEvents.click(e);
      }
    },
    onVisibleChange: function onVisibleChange(visible) {
      if (!Object(props_util["p" /* hasProp */])(this, 'visible')) {
        this.setState({
          sVisible: visible
        });
      }

      this.__emit('visibleChange', visible);
    },
    getMenuElement: function getMenuElement() {
      var _this = this;

      var onClick = this.onClick,
          prefixCls = this.prefixCls,
          $slots = this.$slots;
      this.childOriginEvents = Object(props_util["h" /* getEvents */])($slots.overlay[0]);
      var extraOverlayProps = {
        props: {
          prefixCls: "".concat(prefixCls, "-menu"),
          getPopupContainer: function getPopupContainer() {
            return _this.getPopupDomNode();
          }
        },
        on: {
          click: onClick
        }
      };
      return Object(vnode["a" /* cloneElement */])($slots.overlay[0], extraOverlayProps);
    },
    getPopupDomNode: function getPopupDomNode() {
      return this.$refs.trigger.getPopupDomNode();
    },
    afterVisibleChange: function afterVisibleChange(visible) {
      if (visible && this.$props.minOverlayWidthMatchTrigger) {
        var overlayNode = this.getPopupDomNode();
        var rootNode = this.$el;

        if (rootNode && overlayNode && rootNode.offsetWidth > overlayNode.offsetWidth) {
          overlayNode.style.minWidth = "".concat(rootNode.offsetWidth, "px");

          if (this.$refs.trigger && this.$refs.trigger._component && this.$refs.trigger._component.alignInstance) {
            this.$refs.trigger._component.alignInstance.forceAlign();
          }
        }
      }
    }
  },
  render: function render() {
    var h = arguments[0];

    var _this$$props = this.$props,
        prefixCls = _this$$props.prefixCls,
        transitionName = _this$$props.transitionName,
        animation = _this$$props.animation,
        align = _this$$props.align,
        placement = _this$$props.placement,
        getPopupContainer = _this$$props.getPopupContainer,
        showAction = _this$$props.showAction,
        hideAction = _this$$props.hideAction,
        overlayClassName = _this$$props.overlayClassName,
        overlayStyle = _this$$props.overlayStyle,
        trigger = _this$$props.trigger,
        otherProps = Dropdown_objectWithoutProperties(_this$$props, ["prefixCls", "transitionName", "animation", "align", "placement", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "trigger"]);

    var triggerProps = {
      props: Dropdown_objectSpread({}, otherProps, {
        prefixCls: prefixCls,
        popupClassName: overlayClassName,
        popupStyle: overlayStyle,
        builtinPlacements: src_placements,
        action: trigger,
        showAction: showAction,
        hideAction: hideAction,
        popupPlacement: placement,
        popupAlign: align,
        popupTransitionName: transitionName,
        popupAnimation: animation,
        popupVisible: this.sVisible,
        afterPopupVisibleChange: this.afterVisibleChange,
        getPopupContainer: getPopupContainer
      }),
      on: {
        popupVisibleChange: this.onVisibleChange
      },
      ref: 'trigger'
    };
    var child = this.$slots["default"] && this.$slots["default"][0];
    return h(components_trigger, triggerProps, [child && !child.tag ? h("span", [child]) : child, h("template", {
      slot: 'popup'
    }, [this.$slots.overlay && this.getMenuElement()])]);
  }
});
// CONCATENATED MODULE: ./src/components/dropdown/src/index.js

/* harmony default export */ var dropdown_src = (Dropdown);
// CONCATENATED MODULE: ./src/components/dropdown/getDropdownProps.js

/* harmony default export */ var getDropdownProps = (function () {
  return {
    trigger: vue_types["a" /* default */].array.def(['hover']),
    overlay: vue_types["a" /* default */].any,
    visible: vue_types["a" /* default */].bool,
    disabled: vue_types["a" /* default */].bool,
    align: vue_types["a" /* default */].object,
    getPopupContainer: vue_types["a" /* default */].func,
    prefixCls: vue_types["a" /* default */].string,
    transitionName: vue_types["a" /* default */].string,
    placement: vue_types["a" /* default */].oneOf(['topLeft', 'topCenter', 'topRight', 'bottomLeft', 'bottomCenter', 'bottomRight']),
    forceRender: vue_types["a" /* default */].bool
  };
});
// CONCATENATED MODULE: ./src/components/dropdown/dropdown-button.jsx


function dropdown_button_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = dropdown_button_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function dropdown_button_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function dropdown_button_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { dropdown_button_defineProperty(target, key, source[key]); }); } return target; }

function dropdown_button_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var DropdownProps = getDropdownProps();
var ButtonGroup = components_button.Group;

var DropdownButtonProps = dropdown_button_objectSpread({}, ButtonGroupProps, DropdownProps, {
  type: vue_types["a" /* default */].oneOf(['primary', 'ghost', 'dashed', 'danger', 'default']).def('default'),
  disabled: vue_types["a" /* default */].bool,
  prefixCls: vue_types["a" /* default */].string.def('ant-dropdown-button'),
  placement: DropdownProps.placement.def('bottomRight')
});


/* harmony default export */ var dropdown_button = ({
  name: 'TaDropdownButton',
  props: DropdownButtonProps,
  methods: {
    onClick: function onClick(e) {
      this.$emit('click', e);
    },
    onVisibleChange: function onVisibleChange(val) {
      this.$emit('visibleChange', val);
    }
  },
  model: {
    prop: 'visible',
    event: 'visibleChange'
  },
  render: function render() {
    var h = arguments[0];

    var _this$$props = this.$props,
        type = _this$$props.type,
        disabled = _this$$props.disabled,
        prefixCls = _this$$props.prefixCls,
        trigger = _this$$props.trigger,
        align = _this$$props.align,
        visible = _this$$props.visible,
        placement = _this$$props.placement,
        getPopupContainer = _this$$props.getPopupContainer,
        restProps = dropdown_button_objectWithoutProperties(_this$$props, ["type", "disabled", "prefixCls", "trigger", "align", "visible", "placement", "getPopupContainer"]);

    var dropdownProps = {
      props: {
        align: align,
        disabled: disabled,
        trigger: disabled ? [] : trigger,
        placement: placement,
        getPopupContainer: getPopupContainer
      },
      on: {
        visibleChange: this.onVisibleChange
      }
    };

    if (Object(props_util["p" /* hasProp */])(this, 'visible')) {
      dropdownProps.props.visible = visible;
    }

    return h(ButtonGroup, babel_helper_vue_jsx_merge_props_default()([restProps, {
      "class": prefixCls
    }]), [h(components_button, {
      attrs: {
        type: type,
        disabled: disabled
      },
      on: {
        "click": this.onClick
      }
    }, [this.$slots["default"]]), h(dropdown, dropdownProps, [h("template", {
      slot: 'overlay'
    }, [Object(props_util["g" /* getComponentFromProp */])(this, 'overlay')]), h(components_button, {
      attrs: {
        type: type,
        icon: 'ellipsis'
      }
    })])]);
  }
});
// CONCATENATED MODULE: ./src/components/dropdown/dropdown.jsx
function dropdown_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { dropdown_defineProperty(target, key, source[key]); }); } return target; }

function dropdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


 // import warning from '../_util/warning'





var dropdown_DropdownProps = getDropdownProps();
var dropdown_Dropdown = {
  name: 'TaDropdown',
  props: dropdown_objectSpread({}, dropdown_DropdownProps, {
    prefixCls: vue_types["a" /* default */].string.def('ant-dropdown'),
    mouseEnterDelay: vue_types["a" /* default */].number.def(0.15),
    mouseLeaveDelay: vue_types["a" /* default */].number.def(0.1),
    placement: dropdown_DropdownProps.placement.def('bottomLeft')
  }),
  model: {
    prop: 'visible',
    event: 'visibleChange'
  },
  methods: {
    getTransitionName: function getTransitionName() {
      var _this$$props = this.$props,
          _this$$props$placemen = _this$$props.placement,
          placement = _this$$props$placemen === void 0 ? '' : _this$$props$placemen,
          transitionName = _this$$props.transitionName;

      if (transitionName !== undefined) {
        return transitionName;
      }

      if (placement.indexOf('top') >= 0) {
        return 'slide-down';
      }

      return 'slide-up';
    }
  },
  render: function render() {
    var h = arguments[0];
    var $slots = this.$slots,
        prefixCls = this.prefixCls,
        trigger = this.trigger,
        disabled = this.disabled,
        $listeners = this.$listeners;
    var dropdownTrigger = Object(vnode["a" /* cloneElement */])($slots["default"], {
      "class": "".concat(prefixCls, "-trigger"),
      disabled: disabled
    });
    var overlay = this.overlay || $slots.overlay && $slots.overlay[0]; // menu cannot be selectable in dropdown defaultly
    // menu should be focusable in dropdown defaultly

    var overlayProps = overlay && Object(props_util["k" /* getPropsData */])(overlay);

    var _ref = overlayProps || {},
        _ref$selectable = _ref.selectable,
        selectable = _ref$selectable === void 0 ? false : _ref$selectable,
        _ref$focusable = _ref.focusable,
        focusable = _ref$focusable === void 0 ? true : _ref$focusable;

    var fixedModeOverlay = overlay && overlay.componentOptions ? Object(vnode["a" /* cloneElement */])(overlay, {
      props: {
        mode: 'vertical',
        selectable: selectable,
        focusable: focusable
      }
    }) : overlay;
    var triggerActions = disabled ? [] : trigger;
    var alignPoint;

    if (triggerActions && triggerActions.indexOf('contextmenu') !== -1) {
      alignPoint = true;
    }

    var dropdownProps = {
      props: dropdown_objectSpread({
        alignPoint: alignPoint
      }, Object(props_util["j" /* getOptionProps */])(this), {
        transitionName: this.getTransitionName(),
        trigger: triggerActions
      }),
      on: $listeners
    };
    return h(dropdown_src, dropdownProps, [dropdownTrigger, h("template", {
      slot: 'overlay'
    }, [fixedModeOverlay])]);
  }
};
dropdown_Dropdown.Button = dropdown_button;
/* harmony default export */ var dropdown = (dropdown_Dropdown);

// CONCATENATED MODULE: ./src/components/dropdown/index.js




dropdown.Button = dropdown_button;
/* istanbul ignore next */

dropdown.install = function (Vue) {
  Vue.component(dropdown.name, dropdown);
  Vue.component(dropdown_button.name, dropdown_button);
};

/* harmony default export */ var components_dropdown = (dropdown);
// EXTERNAL MODULE: ./node_modules/lodash/isRegExp.js
var isRegExp = __webpack_require__(410);
var isRegExp_default = /*#__PURE__*/__webpack_require__.n(isRegExp);

// EXTERNAL MODULE: ./node_modules/lodash/has.js
var has = __webpack_require__(411);
var has_default = /*#__PURE__*/__webpack_require__.n(has);

// EXTERNAL MODULE: ./node_modules/babel-runtime/helpers/extends.js
var helpers_extends = __webpack_require__(64);
var extends_default = /*#__PURE__*/__webpack_require__.n(helpers_extends);

// EXTERNAL MODULE: ./node_modules/babel-runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(49);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// CONCATENATED MODULE: ./node_modules/async-validator/es/util.js


var formatRegExp = /%[sdj%]/g;
var util_warning = function warning() {}; // don't print warning message when in production env or node runtime

if (false) {}

function util_format() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var i = 1;
  var f = args[0];
  var len = args.length;

  if (typeof f === 'function') {
    return f.apply(null, args.slice(1));
  }

  if (typeof f === 'string') {
    var str = String(f).replace(formatRegExp, function (x) {
      if (x === '%%') {
        return '%';
      }

      if (i >= len) {
        return x;
      }

      switch (x) {
        case '%s':
          return String(args[i++]);

        case '%d':
          return Number(args[i++]);

        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }

          break;

        default:
          return x;
      }
    });

    for (var arg = args[i]; i < len; arg = args[++i]) {
      str += ' ' + arg;
    }

    return str;
  }

  return f;
}

function isNativeStringType(type) {
  return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'pattern';
}

function isEmptyValue(value, type) {
  if (value === undefined || value === null) {
    return true;
  }

  if (type === 'array' && Array.isArray(value) && !value.length) {
    return true;
  }

  if (isNativeStringType(type) && typeof value === 'string' && !value) {
    return true;
  }

  return false;
}
function isEmptyObject(obj) {
  return Object.keys(obj).length === 0;
}

function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;

  function count(errors) {
    results.push.apply(results, errors);
    total++;

    if (total === arrLength) {
      callback(results);
    }
  }

  arr.forEach(function (a) {
    func(a, count);
  });
}

function asyncSerialArray(arr, func, callback) {
  var index = 0;
  var arrLength = arr.length;

  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }

    var original = index;
    index = index + 1;

    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }

  next([]);
}

function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function (k) {
    ret.push.apply(ret, objArr[k]);
  });
  return ret;
}

function asyncMap(objArr, option, func, callback) {
  if (option.first) {
    var flattenArr = flattenObjArr(objArr);
    return asyncSerialArray(flattenArr, func, callback);
  }

  var firstFields = option.firstFields || [];

  if (firstFields === true) {
    firstFields = Object.keys(objArr);
  }

  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];

  var next = function next(errors) {
    results.push.apply(results, errors);
    total++;

    if (total === objArrLength) {
      callback(results);
    }
  };

  objArrKeys.forEach(function (key) {
    var arr = objArr[key];

    if (firstFields.indexOf(key) !== -1) {
      asyncSerialArray(arr, func, next);
    } else {
      asyncParallelArray(arr, func, next);
    }
  });
}
function complementError(rule) {
  return function (oe) {
    if (oe && oe.message) {
      oe.field = oe.field || rule.fullField;
      return oe;
    }

    return {
      message: oe,
      field: oe.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value = source[s];

        if ((typeof value === 'undefined' ? 'undefined' : typeof_default()(value)) === 'object' && typeof_default()(target[s]) === 'object') {
          target[s] = extends_default()({}, target[s], value);
        } else {
          target[s] = value;
        }
      }
    }
  }

  return target;
}
// CONCATENATED MODULE: ./node_modules/async-validator/es/rule/required.js

/**
 *  Rule for validating required fields.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function required_required(rule, value, source, errors, options, type) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
    errors.push(util_format(options.messages.required, rule.fullField));
  }
}

/* harmony default export */ var rule_required = (required_required);
// CONCATENATED MODULE: ./node_modules/async-validator/es/rule/whitespace.js

/**
 *  Rule for validating whitespace.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function whitespace(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === '') {
    errors.push(util_format(options.messages.whitespace, rule.fullField));
  }
}

/* harmony default export */ var rule_whitespace = (whitespace);
// CONCATENATED MODULE: ./node_modules/async-validator/es/rule/type.js



/* eslint max-len:0 */

var pattern = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
  url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", 'i'),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function _float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }

    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function';
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }

    return typeof value === 'number';
  },
  object: function object(value) {
    return (typeof value === 'undefined' ? 'undefined' : typeof_default()(value)) === 'object' && !types.array(value);
  },
  method: function method(value) {
    return typeof value === 'function';
  },
  email: function email(value) {
    return typeof value === 'string' && !!value.match(pattern.email) && value.length < 255;
  },
  url: function url(value) {
    return typeof value === 'string' && !!value.match(pattern.url);
  },
  hex: function hex(value) {
    return typeof value === 'string' && !!value.match(pattern.hex);
  }
};
/**
 *  Rule for validating the type of a value.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function type_type(rule, value, source, errors, options) {
  if (rule.required && value === undefined) {
    rule_required(rule, value, source, errors, options);
    return;
  }

  var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];
  var ruleType = rule.type;

  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(util_format(options.messages.types[ruleType], rule.fullField, rule.type));
    } // straight typeof check

  } else if (ruleType && (typeof value === 'undefined' ? 'undefined' : typeof_default()(value)) !== rule.type) {
    errors.push(util_format(options.messages.types[ruleType], rule.fullField, rule.type));
  }
}

/* harmony default export */ var rule_type = (type_type);
// CONCATENATED MODULE: ./node_modules/async-validator/es/rule/range.js

/**
 *  Rule for validating minimum and maximum allowed values.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function range_range(rule, value, source, errors, options) {
  var len = typeof rule.len === 'number';
  var min = typeof rule.min === 'number';
  var max = typeof rule.max === 'number'; // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）

  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key = null;
  var num = typeof value === 'number';
  var str = typeof value === 'string';
  var arr = Array.isArray(value);

  if (num) {
    key = 'number';
  } else if (str) {
    key = 'string';
  } else if (arr) {
    key = 'array';
  } // if the value is not of a supported type for range validation
  // the validation rule rule should use the
  // type property to also test for a particular type


  if (!key) {
    return false;
  }

  if (arr) {
    val = value.length;
  }

  if (str) {
    // 处理码点大于U+010000的文字length属性不准确的bug，如"𠮷𠮷𠮷".lenght !== 3
    val = value.replace(spRegexp, '_').length;
  }

  if (len) {
    if (val !== rule.len) {
      errors.push(util_format(options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(util_format(options.messages[key].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(util_format(options.messages[key].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(util_format(options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
}

/* harmony default export */ var rule_range = (range_range);
// CONCATENATED MODULE: ./node_modules/async-validator/es/rule/enum.js

var ENUM = 'enum';
/**
 *  Rule for validating a value exists in an enumerable list.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function enumerable(rule, value, source, errors, options) {
  rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];

  if (rule[ENUM].indexOf(value) === -1) {
    errors.push(util_format(options.messages[ENUM], rule.fullField, rule[ENUM].join(', ')));
  }
}

/* harmony default export */ var rule_enum = (enumerable);
// CONCATENATED MODULE: ./node_modules/async-validator/es/rule/pattern.js

/**
 *  Rule for validating a regular expression pattern.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function pattern_pattern(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      // if a RegExp instance is passed, reset `lastIndex` in case its `global`
      // flag is accidentally set to `true`, which in a validation scenario
      // is not necessary and the result might be misleading
      rule.pattern.lastIndex = 0;

      if (!rule.pattern.test(value)) {
        errors.push(util_format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === 'string') {
      var _pattern = new RegExp(rule.pattern);

      if (!_pattern.test(value)) {
        errors.push(util_format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
}

/* harmony default export */ var rule_pattern = (pattern_pattern);
// CONCATENATED MODULE: ./node_modules/async-validator/es/rule/index.js






/* harmony default export */ var es_rule = ({
  required: rule_required,
  whitespace: rule_whitespace,
  type: rule_type,
  range: rule_range,
  'enum': rule_enum,
  pattern: rule_pattern
});
// CONCATENATED MODULE: ./node_modules/async-validator/es/validator/string.js


/**
 *  Performs validation for string types.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function string_string(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'string') && !rule.required) {
      return callback();
    }

    es_rule.required(rule, value, source, errors, options, 'string');

    if (!isEmptyValue(value, 'string')) {
      es_rule.type(rule, value, source, errors, options);
      es_rule.range(rule, value, source, errors, options);
      es_rule.pattern(rule, value, source, errors, options);

      if (rule.whitespace === true) {
        es_rule.whitespace(rule, value, source, errors, options);
      }
    }
  }

  callback(errors);
}

/* harmony default export */ var validator_string = (string_string);
// CONCATENATED MODULE: ./node_modules/async-validator/es/validator/method.js


/**
 *  Validates a function.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function method(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    es_rule.required(rule, value, source, errors, options);

    if (value !== undefined) {
      es_rule.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/* harmony default export */ var validator_method = (method);
// CONCATENATED MODULE: ./node_modules/async-validator/es/validator/number.js


/**
 *  Validates a number.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function number(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    es_rule.required(rule, value, source, errors, options);

    if (value !== undefined) {
      es_rule.type(rule, value, source, errors, options);
      es_rule.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/* harmony default export */ var validator_number = (number);
// CONCATENATED MODULE: ./node_modules/async-validator/es/validator/boolean.js


/**
 *  Validates a boolean.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function _boolean(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    es_rule.required(rule, value, source, errors, options);

    if (value !== undefined) {
      es_rule.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/* harmony default export */ var validator_boolean = (_boolean);
// CONCATENATED MODULE: ./node_modules/async-validator/es/validator/regexp.js


/**
 *  Validates the regular expression type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function regexp(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    es_rule.required(rule, value, source, errors, options);

    if (!isEmptyValue(value)) {
      es_rule.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/* harmony default export */ var validator_regexp = (regexp);
// CONCATENATED MODULE: ./node_modules/async-validator/es/validator/integer.js


/**
 *  Validates a number is an integer.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function integer(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    es_rule.required(rule, value, source, errors, options);

    if (value !== undefined) {
      es_rule.type(rule, value, source, errors, options);
      es_rule.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/* harmony default export */ var validator_integer = (integer);
// CONCATENATED MODULE: ./node_modules/async-validator/es/validator/float.js


/**
 *  Validates a number is a floating point number.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function floatFn(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    es_rule.required(rule, value, source, errors, options);

    if (value !== undefined) {
      es_rule.type(rule, value, source, errors, options);
      es_rule.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/* harmony default export */ var validator_float = (floatFn);
// CONCATENATED MODULE: ./node_modules/async-validator/es/validator/array.js


/**
 *  Validates an array.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function array_array(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'array') && !rule.required) {
      return callback();
    }

    es_rule.required(rule, value, source, errors, options, 'array');

    if (!isEmptyValue(value, 'array')) {
      es_rule.type(rule, value, source, errors, options);
      es_rule.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/* harmony default export */ var validator_array = (array_array);
// CONCATENATED MODULE: ./node_modules/async-validator/es/validator/object.js


/**
 *  Validates an object.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function object_object(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    es_rule.required(rule, value, source, errors, options);

    if (value !== undefined) {
      es_rule.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/* harmony default export */ var validator_object = (object_object);
// CONCATENATED MODULE: ./node_modules/async-validator/es/validator/enum.js


var enum_ENUM = 'enum';
/**
 *  Validates an enumerable list.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function enum_enumerable(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    es_rule.required(rule, value, source, errors, options);

    if (value) {
      es_rule[enum_ENUM](rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/* harmony default export */ var validator_enum = (enum_enumerable);
// CONCATENATED MODULE: ./node_modules/async-validator/es/validator/pattern.js


/**
 *  Validates a regular expression pattern.
 *
 *  Performs validation when a rule only contains
 *  a pattern property but is not declared as a string type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function validator_pattern_pattern(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'string') && !rule.required) {
      return callback();
    }

    es_rule.required(rule, value, source, errors, options);

    if (!isEmptyValue(value, 'string')) {
      es_rule.pattern(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/* harmony default export */ var validator_pattern = (validator_pattern_pattern);
// CONCATENATED MODULE: ./node_modules/async-validator/es/validator/date.js



function date(rule, value, callback, source, options) {
  // console.log('integer rule called %j', rule);
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    es_rule.required(rule, value, source, errors, options);

    if (!isEmptyValue(value)) {
      var dateObject = void 0;

      if (typeof value === 'number') {
        dateObject = new Date(value);
      } else {
        dateObject = value;
      }

      es_rule.type(rule, dateObject, source, errors, options);

      if (dateObject) {
        es_rule.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }

  callback(errors);
}

/* harmony default export */ var validator_date = (date);
// CONCATENATED MODULE: ./node_modules/async-validator/es/validator/required.js



function validator_required_required(rule, value, callback, source, options) {
  var errors = [];
  var type = Array.isArray(value) ? 'array' : typeof value === 'undefined' ? 'undefined' : typeof_default()(value);
  es_rule.required(rule, value, source, errors, options, type);
  callback(errors);
}

/* harmony default export */ var validator_required = (validator_required_required);
// CONCATENATED MODULE: ./node_modules/async-validator/es/validator/type.js



function validator_type_type(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }

    es_rule.required(rule, value, source, errors, options, ruleType);

    if (!isEmptyValue(value, ruleType)) {
      es_rule.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/* harmony default export */ var validator_type = (validator_type_type);
// CONCATENATED MODULE: ./node_modules/async-validator/es/validator/index.js














/* harmony default export */ var es_validator = ({
  string: validator_string,
  method: validator_method,
  number: validator_number,
  "boolean": validator_boolean,
  regexp: validator_regexp,
  integer: validator_integer,
  "float": validator_float,
  array: validator_array,
  object: validator_object,
  'enum': validator_enum,
  pattern: validator_pattern,
  date: validator_date,
  url: validator_type,
  hex: validator_type,
  email: validator_type,
  required: validator_required
});
// CONCATENATED MODULE: ./node_modules/async-validator/es/messages.js
function newMessages() {
  return {
    'default': 'Validation error on field %s',
    required: '%s is required',
    'enum': '%s must be one of %s',
    whitespace: '%s cannot be empty',
    date: {
      format: '%s date %s is invalid for format %s',
      parse: '%s date could not be parsed, %s is invalid ',
      invalid: '%s date %s is invalid'
    },
    types: {
      string: '%s is not a %s',
      method: '%s is not a %s (function)',
      array: '%s is not an %s',
      object: '%s is not an %s',
      number: '%s is not a %s',
      date: '%s is not a %s',
      "boolean": '%s is not a %s',
      integer: '%s is not an %s',
      "float": '%s is not a %s',
      regexp: '%s is not a valid %s',
      email: '%s is not a valid %s',
      url: '%s is not a valid %s',
      hex: '%s is not a valid %s'
    },
    string: {
      len: '%s must be exactly %s characters',
      min: '%s must be at least %s characters',
      max: '%s cannot be longer than %s characters',
      range: '%s must be between %s and %s characters'
    },
    number: {
      len: '%s must equal %s',
      min: '%s cannot be less than %s',
      max: '%s cannot be greater than %s',
      range: '%s must be between %s and %s'
    },
    array: {
      len: '%s must be exactly %s in length',
      min: '%s cannot be less than %s in length',
      max: '%s cannot be greater than %s in length',
      range: '%s must be between %s and %s in length'
    },
    pattern: {
      mismatch: '%s value %s does not match pattern %s'
    },
    clone: function clone() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages_messages = newMessages();
// CONCATENATED MODULE: ./node_modules/async-validator/es/index.js





/**
 *  Encapsulates a validation schema.
 *
 *  @param descriptor An object declaring validation rules
 *  for this schema.
 */

function Schema(descriptor) {
  this.rules = null;
  this._messages = messages_messages;
  this.define(descriptor);
}

Schema.prototype = {
  messages: function messages(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }

    return this._messages;
  },
  define: function define(rules) {
    if (!rules) {
      throw new Error('Cannot configure a schema with no rules');
    }

    if ((typeof rules === 'undefined' ? 'undefined' : typeof_default()(rules)) !== 'object' || Array.isArray(rules)) {
      throw new Error('Rules must be an object');
    }

    this.rules = {};
    var z = void 0;
    var item = void 0;

    for (z in rules) {
      if (rules.hasOwnProperty(z)) {
        item = rules[z];
        this.rules[z] = Array.isArray(item) ? item : [item];
      }
    }
  },
  validate: function validate(source_) {
    var _this = this;

    var o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var oc = arguments[2];
    var source = source_;
    var options = o;
    var callback = oc;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback();
      }

      return;
    }

    function complete(results) {
      var i = void 0;
      var field = void 0;
      var errors = [];
      var fields = {};

      function add(e) {
        if (Array.isArray(e)) {
          errors = errors.concat.apply(errors, e);
        } else {
          errors.push(e);
        }
      }

      for (i = 0; i < results.length; i++) {
        add(results[i]);
      }

      if (!errors.length) {
        errors = null;
        fields = null;
      } else {
        for (i = 0; i < errors.length; i++) {
          field = errors[i].field;
          fields[field] = fields[field] || [];
          fields[field].push(errors[i]);
        }
      }

      callback(errors, fields);
    }

    if (options.messages) {
      var messages = this.messages();

      if (messages === messages_messages) {
        messages = newMessages();
      }

      deepMerge(messages, options.messages);
      options.messages = messages;
    } else {
      options.messages = this.messages();
    }

    var arr = void 0;
    var value = void 0;
    var series = {};
    var keys = options.keys || Object.keys(this.rules);
    keys.forEach(function (z) {
      arr = _this.rules[z];
      value = source[z];
      arr.forEach(function (r) {
        var rule = r;

        if (typeof rule.transform === 'function') {
          if (source === source_) {
            source = extends_default()({}, source);
          }

          value = source[z] = rule.transform(value);
        }

        if (typeof rule === 'function') {
          rule = {
            validator: rule
          };
        } else {
          rule = extends_default()({}, rule);
        }

        rule.validator = _this.getValidationMethod(rule);
        rule.field = z;
        rule.fullField = rule.fullField || z;
        rule.type = _this.getType(rule);

        if (!rule.validator) {
          return;
        }

        series[z] = series[z] || [];
        series[z].push({
          rule: rule,
          value: value,
          source: source,
          field: z
        });
      });
    });
    var errorFields = {};
    asyncMap(series, options, function (data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === 'object' || rule.type === 'array') && (typeof_default()(rule.fields) === 'object' || typeof_default()(rule.defaultField) === 'object');
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;

      function addFullfield(key, schema) {
        return extends_default()({}, schema, {
          fullField: rule.fullField + '.' + key
        });
      }

      function cb() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var errors = e;

        if (!Array.isArray(errors)) {
          errors = [errors];
        }

        if (errors.length) {
          util_warning('async-validator:', errors);
        }

        if (errors.length && rule.message) {
          errors = [].concat(rule.message);
        }

        errors = errors.map(complementError(rule));

        if (options.first && errors.length) {
          errorFields[rule.field] = 1;
          return doIt(errors);
        }

        if (!deep) {
          doIt(errors);
        } else {
          // if rule is required but the target object
          // does not exist fail at the rule level and don't
          // go deeper
          if (rule.required && !data.value) {
            if (rule.message) {
              errors = [].concat(rule.message).map(complementError(rule));
            } else if (options.error) {
              errors = [options.error(rule, util_format(options.messages.required, rule.field))];
            } else {
              errors = [];
            }

            return doIt(errors);
          }

          var fieldsSchema = {};

          if (rule.defaultField) {
            for (var k in data.value) {
              if (data.value.hasOwnProperty(k)) {
                fieldsSchema[k] = rule.defaultField;
              }
            }
          }

          fieldsSchema = extends_default()({}, fieldsSchema, data.rule.fields);

          for (var f in fieldsSchema) {
            if (fieldsSchema.hasOwnProperty(f)) {
              var fieldSchema = Array.isArray(fieldsSchema[f]) ? fieldsSchema[f] : [fieldsSchema[f]];
              fieldsSchema[f] = fieldSchema.map(addFullfield.bind(null, f));
            }
          }

          var schema = new Schema(fieldsSchema);
          schema.messages(options.messages);

          if (data.rule.options) {
            data.rule.options.messages = options.messages;
            data.rule.options.error = options.error;
          }

          schema.validate(data.value, data.rule.options || options, function (errs) {
            doIt(errs && errs.length ? errors.concat(errs) : errs);
          });
        }
      }

      var res = rule.validator(rule, data.value, cb, data.source, options);

      if (res && res.then) {
        res.then(function () {
          return cb();
        }, function (e) {
          return cb(e);
        });
      }
    }, function (results) {
      complete(results);
    });
  },
  getType: function getType(rule) {
    if (rule.type === undefined && rule.pattern instanceof RegExp) {
      rule.type = 'pattern';
    }

    if (typeof rule.validator !== 'function' && rule.type && !es_validator.hasOwnProperty(rule.type)) {
      throw new Error(util_format('Unknown rule type %s', rule.type));
    }

    return rule.type || 'string';
  },
  getValidationMethod: function getValidationMethod(rule) {
    if (typeof rule.validator === 'function') {
      return rule.validator;
    }

    var keys = Object.keys(rule);
    var messageIndex = keys.indexOf('message');

    if (messageIndex !== -1) {
      keys.splice(messageIndex, 1);
    }

    if (keys.length === 1 && keys[0] === 'required') {
      return es_validator.required;
    }

    return es_validator[this.getType(rule)] || false;
  }
};

Schema.register = function register(type, validator) {
  if (typeof validator !== 'function') {
    throw new Error('Cannot register a validator by type, validator is not a function');
  }

  es_validator[type] = validator;
};

Schema.messages = messages_messages;
/* harmony default export */ var async_validator_es = (Schema);
// EXTERNAL MODULE: ./node_modules/lodash/get.js
var get = __webpack_require__(74);
var get_default = /*#__PURE__*/__webpack_require__.n(get);

// EXTERNAL MODULE: ./node_modules/lodash/set.js
var set = __webpack_require__(44);
var set_default = /*#__PURE__*/__webpack_require__.n(set);

// CONCATENATED MODULE: ./src/components/vc-form/src/createFormField.jsx
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Field = function Field(fields) {
  _classCallCheck(this, Field);

  Object.assign(this, fields);
};

function isFormField(obj) {
  return obj instanceof Field;
}
function createFormField(field) {
  if (isFormField(field)) {
    return field;
  }

  return new Field(field);
}
// CONCATENATED MODULE: ./src/components/vc-form/src/utils.js
function utils_typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { utils_typeof2 = function _typeof2(obj) { return typeof obj; }; } else { utils_typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return utils_typeof2(obj); }

function utils_typeof(obj) {
  if (typeof Symbol === "function" && utils_typeof2(Symbol.iterator) === "symbol") {
    utils_typeof = function _typeof(obj) {
      return utils_typeof2(obj);
    };
  } else {
    utils_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : utils_typeof2(obj);
    };
  }

  return utils_typeof(obj);
}

function src_utils_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      vc_form_src_utils_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function vc_form_src_utils_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function utils_getDisplayName(WrappedComponent) {
  return WrappedComponent.name || 'WrappedComponent';
}

function argumentContainer(Container, WrappedComponent) {
  /* eslint no-param-reassign:0 */
  Container.name = "Form_".concat(utils_getDisplayName(WrappedComponent));
  Container.WrappedComponent = WrappedComponent;
  Container.props = src_utils_objectSpread({}, Container.props, WrappedComponent.props);
  return Container;
}
function identity(obj) {
  return obj;
}
function flattenArray(arr) {
  return Array.prototype.concat.apply([], arr);
}
function treeTraverse() {
  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var tree = arguments.length > 1 ? arguments[1] : undefined;
  var isLeafNode = arguments.length > 2 ? arguments[2] : undefined;
  var errorMessage = arguments.length > 3 ? arguments[3] : undefined;
  var callback = arguments.length > 4 ? arguments[4] : undefined;

  if (isLeafNode(path, tree)) {
    callback(path, tree);
  } else if (tree === undefined || tree === null) {} else if (Array.isArray(tree)) {
    tree.forEach(function (subTree, index) {
      return treeTraverse("".concat(path, "[").concat(index, "]"), subTree, isLeafNode, errorMessage, callback);
    });
  } else {
    // It's object and not a leaf node
    if (utils_typeof(tree) !== 'object') {
      console.error(errorMessage);
      return;
    }

    Object.keys(tree).forEach(function (subTreeKey) {
      var subTree = tree[subTreeKey];
      treeTraverse("".concat(path).concat(path ? '.' : '').concat(subTreeKey), subTree, isLeafNode, errorMessage, callback);
    });
  }
}
function utils_flattenFields(maybeNestedFields, isLeafNode, errorMessage) {
  var fields = {};
  treeTraverse(undefined, maybeNestedFields, isLeafNode, errorMessage, function (path, node) {
    fields[path] = node;
  });
  return fields;
}
function normalizeValidateRules(validate, rules, validateTrigger) {
  var validateRules = validate.map(function (item) {
    var newItem = src_utils_objectSpread({}, item, {
      trigger: item.trigger || []
    });

    if (typeof newItem.trigger === 'string') {
      newItem.trigger = [newItem.trigger];
    }

    return newItem;
  });

  if (rules) {
    validateRules.push({
      trigger: validateTrigger ? [].concat(validateTrigger) : [],
      rules: rules
    });
  }

  return validateRules;
}
function getValidateTriggers(validateRules) {
  return validateRules.filter(function (item) {
    return !!item.rules && item.rules.length;
  }).map(function (item) {
    return item.trigger;
  }).reduce(function (pre, curr) {
    return pre.concat(curr);
  }, []);
}
function getValueFromEvent(e) {
  // To support custom element
  if (!e || !e.target) {
    return e;
  }

  var target = e.target;
  return target.type === 'checkbox' ? target.checked : target.value;
}
function getErrorStrs(errors) {
  if (errors) {
    return errors.map(function (e) {
      if (e && e.message) {
        return e.message;
      }

      return e;
    });
  }

  return errors;
}
function getParams(ns, opt, cb) {
  var names = ns;
  var options = opt;
  var callback = cb;

  if (cb === undefined) {
    if (typeof names === 'function') {
      callback = names;
      options = {};
      names = undefined;
    } else if (Array.isArray(names)) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
    } else {
      callback = options;
      options = names || {};
      names = undefined;
    }
  }

  return {
    names: names,
    options: options,
    callback: callback
  };
}
function utils_isEmptyObject(obj) {
  return Object.keys(obj).length === 0;
}
function hasRules(validate) {
  if (validate) {
    return validate.some(function (item) {
      return item.rules && item.rules.length;
    });
  }

  return false;
}
function startsWith(str, prefix) {
  return str.lastIndexOf(prefix, 0) === 0;
}
// CONCATENATED MODULE: ./src/components/vc-form/src/createFieldsStore.jsx
function createFieldsStore_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { createFieldsStore_defineProperty(target, key, source[key]); }); } return target; }

function createFieldsStore_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function createFieldsStore_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





function partOf(a, b) {
  return b.indexOf(a) === 0 && ['.', '['].indexOf(b[a.length]) !== -1;
}

var createFieldsStore_FieldsStore =
/*#__PURE__*/
function () {
  function FieldsStore(_fields) {
    var _this = this;

    createFieldsStore_classCallCheck(this, FieldsStore);

    createFieldsStore_defineProperty(this, "setFieldsInitialValue", function (initialValues) {
      var flattenedInitialValues = _this.flattenRegisteredFields(initialValues);

      var fieldsMeta = _this.fieldsMeta;
      Object.keys(flattenedInitialValues).forEach(function (name) {
        if (fieldsMeta[name]) {
          _this.setFieldMeta(name, createFieldsStore_objectSpread({}, _this.getFieldMeta(name), {
            initialValue: flattenedInitialValues[name]
          }));
        }
      });
    });

    createFieldsStore_defineProperty(this, "getAllValues", function () {
      var fieldsMeta = _this.fieldsMeta,
          fields = _this.fields;
      return Object.keys(fieldsMeta).reduce(function (acc, name) {
        return set_default()(acc, name, _this.getValueFromFields(name, fields));
      }, {});
    });

    createFieldsStore_defineProperty(this, "getFieldsValue", function (names) {
      return _this.getNestedFields(names, _this.getFieldValue);
    });

    createFieldsStore_defineProperty(this, "getFieldValue", function (name) {
      var fields = _this.fields;
      return _this.getNestedField(name, function (fullName) {
        return _this.getValueFromFields(fullName, fields);
      });
    });

    createFieldsStore_defineProperty(this, "getFieldsError", function (names) {
      return _this.getNestedFields(names, _this.getFieldError);
    });

    createFieldsStore_defineProperty(this, "getFieldError", function (name) {
      return _this.getNestedField(name, function (fullName) {
        return getErrorStrs(_this.getFieldMember(fullName, 'errors'));
      });
    });

    createFieldsStore_defineProperty(this, "isFieldValidating", function (name) {
      return _this.getFieldMember(name, 'validating');
    });

    createFieldsStore_defineProperty(this, "isFieldsValidating", function (ns) {
      var names = ns || _this.getValidFieldsName();

      return names.some(function (n) {
        return _this.isFieldValidating(n);
      });
    });

    createFieldsStore_defineProperty(this, "isFieldTouched", function (name) {
      return _this.getFieldMember(name, 'touched');
    });

    createFieldsStore_defineProperty(this, "isFieldsTouched", function (ns) {
      var names = ns || _this.getValidFieldsName();

      return names.some(function (n) {
        return _this.isFieldTouched(n);
      });
    });

    this.fields = this.flattenFields(_fields);
    this.fieldsMeta = {};
  }

  _createClass(FieldsStore, [{
    key: "updateFields",
    value: function updateFields(fields) {
      this.fields = this.flattenFields(fields);
    }
  }, {
    key: "flattenFields",
    value: function flattenFields(fields) {
      return utils_flattenFields(fields, function (_, node) {
        return isFormField(node);
      }, 'You must wrap field data with `createFormField`.');
    }
  }, {
    key: "flattenRegisteredFields",
    value: function flattenRegisteredFields(fields) {
      var validFieldsName = this.getAllFieldsName();
      return utils_flattenFields(fields, function (path) {
        return validFieldsName.indexOf(path) >= 0;
      }, 'You cannot set field before registering it.');
    }
  }, {
    key: "setFields",
    value: function setFields(fields) {
      var _this2 = this;

      var fieldsMeta = this.fieldsMeta;

      var nowFields = createFieldsStore_objectSpread({}, this.fields, fields);

      var nowValues = {};
      Object.keys(fieldsMeta).forEach(function (f) {
        nowValues[f] = _this2.getValueFromFields(f, nowFields);
      });
      Object.keys(nowValues).forEach(function (f) {
        var value = nowValues[f];

        var fieldMeta = _this2.getFieldMeta(f);

        if (fieldMeta && fieldMeta.normalize) {
          var nowValue = fieldMeta.normalize(value, _this2.getValueFromFields(f, _this2.fields), nowValues);

          if (nowValue !== value) {
            nowFields[f] = createFieldsStore_objectSpread({}, nowFields[f], {
              value: nowValue
            });
          }
        }
      });
      this.fields = nowFields;
    }
  }, {
    key: "resetFields",
    value: function resetFields(ns) {
      var fields = this.fields;
      var names = ns ? this.getValidFieldsFullName(ns) : this.getAllFieldsName();
      return names.reduce(function (acc, name) {
        var field = fields[name];

        if (field && 'value' in field) {
          acc[name] = {};
        }

        return acc;
      }, {});
    }
  }, {
    key: "setFieldMeta",
    value: function setFieldMeta(name, meta) {
      this.fieldsMeta[name] = meta;
    }
  }, {
    key: "getFieldMeta",
    value: function getFieldMeta(name) {
      this.fieldsMeta[name] = this.fieldsMeta[name] || {};
      return this.fieldsMeta[name];
    }
  }, {
    key: "getValueFromFields",
    value: function getValueFromFields(name, fields) {
      var field = fields[name];

      if (field && 'value' in field) {
        return field.value;
      }

      var fieldMeta = this.getFieldMeta(name);
      return fieldMeta && fieldMeta.initialValue;
    }
  }, {
    key: "getValidFieldsName",
    value: function getValidFieldsName() {
      var _this3 = this;

      var fieldsMeta = this.fieldsMeta;
      return fieldsMeta ? Object.keys(fieldsMeta).filter(function (name) {
        return !_this3.getFieldMeta(name).hidden;
      }) : [];
    }
  }, {
    key: "getAllFieldsName",
    value: function getAllFieldsName() {
      var fieldsMeta = this.fieldsMeta;
      return fieldsMeta ? Object.keys(fieldsMeta) : [];
    }
  }, {
    key: "getValidFieldsFullName",
    value: function getValidFieldsFullName(maybePartialName) {
      var maybePartialNames = Array.isArray(maybePartialName) ? maybePartialName : [maybePartialName];
      return this.getValidFieldsName().filter(function (fullName) {
        return maybePartialNames.some(function (partialName) {
          return fullName === partialName || startsWith(fullName, partialName) && ['.', '['].indexOf(fullName[partialName.length]) >= 0;
        });
      });
    }
  }, {
    key: "getFieldValuePropValue",
    value: function getFieldValuePropValue(fieldMeta) {
      var name = fieldMeta.name,
          getValueProps = fieldMeta.getValueProps,
          valuePropName = fieldMeta.valuePropName;
      var field = this.getField(name);
      var fieldValue = 'value' in field ? field.value : fieldMeta.initialValue;

      if (getValueProps) {
        return getValueProps(fieldValue);
      }

      return createFieldsStore_defineProperty({}, valuePropName, fieldValue);
    }
  }, {
    key: "getField",
    value: function getField(name) {
      return createFieldsStore_objectSpread({}, this.fields[name], {
        name: name
      });
    }
  }, {
    key: "getNotCollectedFields",
    value: function getNotCollectedFields() {
      var _this4 = this;

      return this.getValidFieldsName().filter(function (name) {
        return !_this4.fields[name];
      }).map(function (name) {
        return {
          name: name,
          dirty: false,
          value: _this4.getFieldMeta(name).initialValue
        };
      }).reduce(function (acc, field) {
        return set_default()(acc, field.name, createFormField(field));
      }, {});
    }
  }, {
    key: "getNestedAllFields",
    value: function getNestedAllFields() {
      var _this5 = this;

      return Object.keys(this.fields).reduce(function (acc, name) {
        return set_default()(acc, name, createFormField(_this5.fields[name]));
      }, this.getNotCollectedFields());
    }
  }, {
    key: "getFieldMember",
    value: function getFieldMember(name, member) {
      return this.getField(name)[member];
    }
  }, {
    key: "getNestedFields",
    value: function getNestedFields(names, getter) {
      var fields = names || this.getValidFieldsName();
      return fields.reduce(function (acc, f) {
        return set_default()(acc, f, getter(f));
      }, {});
    }
  }, {
    key: "getNestedField",
    value: function getNestedField(name, getter) {
      var fullNames = this.getValidFieldsFullName(name);

      if (fullNames.length === 0 || // Not registered
      fullNames.length === 1 && fullNames[0] === name // Name already is full name.
      ) {
          return getter(name);
        }

      var isArrayValue = fullNames[0][name.length] === '[';
      var suffixNameStartIndex = isArrayValue ? name.length : name.length + 1;
      return fullNames.reduce(function (acc, fullName) {
        return set_default()(acc, fullName.slice(suffixNameStartIndex), getter(fullName));
      }, isArrayValue ? [] : {});
    }
  }, {
    key: "isValidNestedFieldName",
    // @private
    // BG: `a` and `a.b` cannot be use in the same form
    value: function isValidNestedFieldName(name) {
      var names = this.getAllFieldsName();
      return names.every(function (n) {
        return !partOf(n, name) && !partOf(name, n);
      });
    }
  }, {
    key: "clearField",
    value: function clearField(name) {
      delete this.fields[name];
      delete this.fieldsMeta[name];
    }
  }]);

  return FieldsStore;
}();

function createFieldsStore(fields) {
  return new createFieldsStore_FieldsStore(fields);
}
// CONCATENATED MODULE: ./src/components/vc-form/src/createBaseForm.jsx
function createBaseForm_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { createBaseForm_typeof = function _typeof(obj) { return typeof obj; }; } else { createBaseForm_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return createBaseForm_typeof(obj); }

function createBaseForm_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = createBaseForm_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function createBaseForm_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function createBaseForm_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { createBaseForm_defineProperty(target, key, source[key]); }); } return target; }

function createBaseForm_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function createBaseForm_toConsumableArray(arr) { return createBaseForm_arrayWithoutHoles(arr) || createBaseForm_iterableToArray(arr) || createBaseForm_nonIterableSpread(); }

function createBaseForm_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function createBaseForm_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function createBaseForm_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }












var DEFAULT_TRIGGER = 'change';

function createBaseForm() {
  var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var mixins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var validateMessages = option.validateMessages,
      onFieldsChange = option.onFieldsChange,
      onValuesChange = option.onValuesChange,
      _option$mapProps = option.mapProps,
      mapProps = _option$mapProps === void 0 ? identity : _option$mapProps,
      mapPropsToFields = option.mapPropsToFields,
      fieldNameProp = option.fieldNameProp,
      fieldMetaProp = option.fieldMetaProp,
      fieldDataProp = option.fieldDataProp,
      _option$formPropName = option.formPropName,
      formPropName = _option$formPropName === void 0 ? 'form' : _option$formPropName,
      _option$props = option.props,
      props = _option$props === void 0 ? {} : _option$props,
      templateContext = option.templateContext;
  return function decorate(WrappedComponent) {
    var formProps = {};

    if (Array.isArray(props)) {
      props.forEach(function (prop) {
        formProps[prop] = vue_types["a" /* default */].any;
      });
    } else {
      formProps = props;
    }

    var Form = {
      mixins: [BaseMixin["a" /* default */]].concat(createBaseForm_toConsumableArray(mixins)),
      props: createBaseForm_objectSpread({}, formProps, {
        wrappedComponentRef: vue_types["a" /* default */].func.def(function () {})
      }),
      data: function data() {
        var _this = this;

        var fields = mapPropsToFields && mapPropsToFields(this.$props);
        this.fieldsStore = createFieldsStore(fields || {});
        this.instances = {};
        this.cachedBind = {};
        this.clearedFieldMetaCache = {}; // HACK: https://github.com/ant-design/ant-design/issues/6406

        ['getFieldsValue', 'getFieldValue', 'setFieldsInitialValue', 'getFieldsError', 'getFieldError', 'isFieldValidating', 'isFieldsValidating', 'isFieldsTouched', 'isFieldTouched'].forEach(function (key) {
          _this[key] = function () {
            var _this$fieldsStore;

            return (_this$fieldsStore = _this.fieldsStore)[key].apply(_this$fieldsStore, arguments);
          };
        });
        return {
          submitting: false
        };
      },
      watch: {
        '$props': {
          handler: function handler(nextProps) {
            if (mapPropsToFields) {
              this.fieldsStore.updateFields(mapPropsToFields(nextProps));
            }
          },
          deep: true
        }
      },
      mounted: function mounted() {
        this.wrappedComponentRef(this.$refs.WrappedComponent);
      },
      updated: function updated() {
        this.wrappedComponentRef(this.$refs.WrappedComponent);
      },
      destroyed: function destroyed() {
        this.wrappedComponentRef(null);
      },
      methods: {
        onCollectCommon: function onCollectCommon(name, action, args) {
          var fieldMeta = this.fieldsStore.getFieldMeta(name);

          if (fieldMeta[action]) {
            fieldMeta[action].apply(fieldMeta, createBaseForm_toConsumableArray(args));
          } else if (fieldMeta.originalProps && fieldMeta.originalProps[action]) {
            var _fieldMeta$originalPr;

            (_fieldMeta$originalPr = fieldMeta.originalProps)[action].apply(_fieldMeta$originalPr, createBaseForm_toConsumableArray(args));
          }

          var value = fieldMeta.getValueFromEvent ? fieldMeta.getValueFromEvent.apply(fieldMeta, createBaseForm_toConsumableArray(args)) : getValueFromEvent.apply(void 0, createBaseForm_toConsumableArray(args));

          if (onValuesChange && value !== this.fieldsStore.getFieldValue(name)) {
            var valuesAll = this.fieldsStore.getAllValues();
            var valuesAllSet = {};
            valuesAll[name] = value;
            Object.keys(valuesAll).forEach(function (key) {
              return set_default()(valuesAllSet, key, valuesAll[key]);
            });
            onValuesChange(this, set_default()({}, name, value), valuesAllSet);
          }

          var field = this.fieldsStore.getField(name);
          return {
            name: name,
            field: createBaseForm_objectSpread({}, field, {
              value: value,
              touched: true
            }),
            fieldMeta: fieldMeta
          };
        },
        onCollect: function onCollect(name_, action) {
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          var _this$onCollectCommon = this.onCollectCommon(name_, action, args),
              name = _this$onCollectCommon.name,
              field = _this$onCollectCommon.field,
              fieldMeta = _this$onCollectCommon.fieldMeta;

          var validate = fieldMeta.validate;

          var newField = createBaseForm_objectSpread({}, field, {
            dirty: hasRules(validate)
          });

          this.setFields(createBaseForm_defineProperty({}, name, newField));
        },
        onCollectValidate: function onCollectValidate(name_, action) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          var _this$onCollectCommon2 = this.onCollectCommon(name_, action, args),
              field = _this$onCollectCommon2.field,
              fieldMeta = _this$onCollectCommon2.fieldMeta;

          var newField = createBaseForm_objectSpread({}, field, {
            dirty: true
          });

          this.validateFieldsInternal([newField], {
            action: action,
            options: {
              firstFields: !!fieldMeta.validateFirst
            }
          });
        },
        getCacheBind: function getCacheBind(name, action, fn) {
          if (!this.cachedBind[name]) {
            this.cachedBind[name] = {};
          }

          var cache = this.cachedBind[name];

          if (!cache[action]) {
            cache[action] = fn.bind(this, name, action);
          }

          return cache[action];
        },
        recoverClearedField: function recoverClearedField(name) {
          if (this.clearedFieldMetaCache[name]) {
            this.fieldsStore.setFields(createBaseForm_defineProperty({}, name, this.clearedFieldMetaCache[name].field));
            this.fieldsStore.setFieldMeta(name, this.clearedFieldMetaCache[name].meta);
            delete this.clearedFieldMetaCache[name];
          }
        },
        getFieldDecorator: function getFieldDecorator(name, fieldOption) {
          var _this2 = this;

          var _this$getFieldProps = this.getFieldProps(name, fieldOption),
              props = _this$getFieldProps.props,
              restProps = createBaseForm_objectWithoutProperties(_this$getFieldProps, ["props"]);

          return function (fieldElem) {
            var fieldMeta = _this2.fieldsStore.getFieldMeta(name);

            var originalProps = Object(props_util["j" /* getOptionProps */])(fieldElem);
            var originalEvents = Object(props_util["h" /* getEvents */])(fieldElem);

            if (false) { var defaultValuePropName, valuePropName; }

            fieldMeta.originalProps = originalProps; // fieldMeta.ref = fieldElem.data && fieldElem.data.ref

            var newProps = createBaseForm_objectSpread({
              props: createBaseForm_objectSpread({}, props, _this2.fieldsStore.getFieldValuePropValue(fieldMeta))
            }, restProps);

            newProps.domProps.value = newProps.props.value;
            var newEvents = {};
            Object.keys(newProps.on).forEach(function (key) {
              if (originalEvents[key]) {
                var triggerEvents = newProps.on[key];

                newEvents[key] = function () {
                  originalEvents[key].apply(originalEvents, arguments);
                  triggerEvents.apply(void 0, arguments);
                };
              } else {
                newEvents[key] = newProps.on[key];
              }
            });
            return Object(vnode["a" /* cloneElement */])(fieldElem, createBaseForm_objectSpread({}, newProps, {
              on: newEvents
            }));
          };
        },
        getFieldProps: function getFieldProps(name) {
          var _this3 = this;

          var usersFieldOption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          if (!name) {
            throw new Error('Must call `getFieldProps` with valid name string!');
          }

          if (false) {}

          delete this.clearedFieldMetaCache[name];

          var fieldOption = createBaseForm_objectSpread({
            name: name,
            trigger: DEFAULT_TRIGGER,
            valuePropName: 'value',
            validate: []
          }, usersFieldOption);

          var rules = fieldOption.rules,
              trigger = fieldOption.trigger,
              _fieldOption$validate = fieldOption.validateTrigger,
              validateTrigger = _fieldOption$validate === void 0 ? trigger : _fieldOption$validate,
              validate = fieldOption.validate;
          var fieldMeta = this.fieldsStore.getFieldMeta(name);

          if ('initialValue' in fieldOption) {
            fieldMeta.initialValue = fieldOption.initialValue;
          }

          var inputProps = createBaseForm_objectSpread({}, this.fieldsStore.getFieldValuePropValue(fieldOption));

          var inputListeners = {};
          var inputAttrs = {};

          if (fieldNameProp) {
            inputProps[fieldNameProp] = name;
          }

          var validateRules = normalizeValidateRules(validate, rules, validateTrigger);
          var validateTriggers = getValidateTriggers(validateRules);
          validateTriggers.forEach(function (action) {
            if (inputListeners[action]) return;
            inputListeners[action] = _this3.getCacheBind(name, action, _this3.onCollectValidate);
          }); // make sure that the value will be collect

          if (trigger && validateTriggers.indexOf(trigger) === -1) {
            inputListeners[trigger] = this.getCacheBind(name, trigger, this.onCollect);
          }

          var meta = createBaseForm_objectSpread({}, fieldMeta, fieldOption, {
            validate: validateRules
          });

          this.fieldsStore.setFieldMeta(name, meta);

          if (fieldMetaProp) {
            inputAttrs[fieldMetaProp] = meta;
          }

          if (fieldDataProp) {
            inputAttrs[fieldDataProp] = this.fieldsStore.getField(name);
          }

          return {
            props: omit_default()(inputProps, ['id']),
            // id: inputProps.id,
            domProps: {
              value: inputProps.value
            },
            attrs: createBaseForm_objectSpread({}, inputAttrs, {
              id: inputProps.id
            }),
            directives: [{
              name: 'ant-ref',
              value: this.getCacheBind(name, "".concat(name, "__ref"), this.saveRef)
            }],
            on: inputListeners
          };
        },
        getFieldInstance: function getFieldInstance(name) {
          return this.instances[name];
        },
        getRules: function getRules(fieldMeta, action) {
          var actionRules = fieldMeta.validate.filter(function (item) {
            return !action || item.trigger.indexOf(action) >= 0;
          }).map(function (item) {
            return item.rules;
          });
          return flattenArray(actionRules);
        },
        setFields: function setFields(maybeNestedFields, callback) {
          var _this4 = this;

          var fields = this.fieldsStore.flattenRegisteredFields(maybeNestedFields);
          this.fieldsStore.setFields(fields);

          if (onFieldsChange) {
            var changedFields = Object.keys(fields).reduce(function (acc, name) {
              return set_default()(acc, name, _this4.fieldsStore.getField(name));
            }, {});
            onFieldsChange(this, changedFields, this.fieldsStore.getNestedAllFields());
          }

          if (templateContext) {
            templateContext.$forceUpdate();
          } else {
            this.$forceUpdate();
          }

          this.$nextTick(function () {
            callback && callback();
          });
        },
        resetFields: function resetFields(ns) {
          var _this5 = this;

          var newFields = this.fieldsStore.resetFields(ns);

          if (Object.keys(newFields).length > 0) {
            this.setFields(newFields);
          }

          if (ns) {
            var names = Array.isArray(ns) ? ns : [ns];
            names.forEach(function (name) {
              return delete _this5.clearedFieldMetaCache[name];
            });
          } else {
            this.clearedFieldMetaCache = {};
          }
        },
        setFieldsValue: function setFieldsValue(changedValues, callback) {
          var fieldsMeta = this.fieldsStore.fieldsMeta;
          var values = this.fieldsStore.flattenRegisteredFields(changedValues);
          var newFields = Object.keys(values).reduce(function (acc, name) {
            var isRegistered = fieldsMeta[name];

            if (false) {}

            if (isRegistered) {
              var value = values[name];
              acc[name] = {
                value: value
              };
            }

            return acc;
          }, {});
          this.setFields(newFields, callback);

          if (onValuesChange) {
            var allValues = this.fieldsStore.getAllValues();
            onValuesChange(this, changedValues, allValues);
          }
        },
        saveRef: function saveRef(name, _, component) {
          if (!component) {
            // after destroy, delete data
            this.clearedFieldMetaCache[name] = {
              field: this.fieldsStore.getField(name),
              meta: this.fieldsStore.getFieldMeta(name)
            };
            this.fieldsStore.clearField(name);
            delete this.instances[name];
            delete this.cachedBind[name];
            return;
          }

          this.recoverClearedField(name); // const fieldMeta = this.fieldsStore.getFieldMeta(name)
          // if (fieldMeta) {
          //   const ref = fieldMeta.ref
          //   if (ref) {
          //     if (typeof ref === 'string') {
          //       throw new Error(`can not set ref string for ${name}`)
          //     }
          //     ref(component)
          //   }
          // }

          this.instances[name] = component;
        },
        validateFieldsInternal: function validateFieldsInternal(fields, _ref, callback) {
          var _this6 = this;

          var fieldNames = _ref.fieldNames,
              action = _ref.action,
              _ref$options = _ref.options,
              options = _ref$options === void 0 ? {} : _ref$options;
          var allRules = {};
          var allValues = {};
          var allFields = {};
          var alreadyErrors = {};
          fields.forEach(function (field) {
            var name = field.name;

            if (options.force !== true && field.dirty === false) {
              if (field.errors) {
                set_default()(alreadyErrors, name, {
                  errors: field.errors
                });
              }

              return;
            }

            var fieldMeta = _this6.fieldsStore.getFieldMeta(name);

            var newField = createBaseForm_objectSpread({}, field);

            newField.errors = undefined;
            newField.validating = true;
            newField.dirty = true;
            allRules[name] = _this6.getRules(fieldMeta, action);
            allValues[name] = newField.value;
            allFields[name] = newField;
          });
          this.setFields(allFields); // in case normalize

          Object.keys(allValues).forEach(function (f) {
            allValues[f] = _this6.fieldsStore.getFieldValue(f);
          });

          if (callback && utils_isEmptyObject(allFields)) {
            callback(utils_isEmptyObject(alreadyErrors) ? null : alreadyErrors, this.fieldsStore.getFieldsValue(fieldNames));
            return;
          }

          var validator = new async_validator_es(allRules);

          if (validateMessages) {
            validator.messages(validateMessages);
          }

          validator.validate(allValues, options, function (errors) {
            var errorsGroup = createBaseForm_objectSpread({}, alreadyErrors);

            if (errors && errors.length) {
              errors.forEach(function (e) {
                var fieldName = e.field;
                var field = get_default()(errorsGroup, fieldName);

                if (createBaseForm_typeof(field) !== 'object' || Array.isArray(field)) {
                  set_default()(errorsGroup, fieldName, {
                    errors: []
                  });
                }

                var fieldErrors = get_default()(errorsGroup, fieldName.concat('.errors'));
                fieldErrors.push(e);
              });
            }

            var expired = [];
            var nowAllFields = {};
            Object.keys(allRules).forEach(function (name) {
              var fieldErrors = get_default()(errorsGroup, name);

              var nowField = _this6.fieldsStore.getField(name); // avoid concurrency problems


              if (nowField.value !== allValues[name]) {
                expired.push({
                  name: name
                });
              } else {
                nowField.errors = fieldErrors && fieldErrors.errors;
                nowField.value = allValues[name];
                nowField.validating = false;
                nowField.dirty = false;
                nowAllFields[name] = nowField;
              }
            });

            _this6.setFields(nowAllFields);

            if (callback) {
              if (expired.length) {
                expired.forEach(function (_ref2) {
                  var name = _ref2.name;
                  var fieldErrors = [{
                    message: "".concat(name, " need to revalidate"),
                    field: name
                  }];
                  set_default()(errorsGroup, name, {
                    expired: true,
                    errors: fieldErrors
                  });
                });
              }

              callback(utils_isEmptyObject(errorsGroup) ? null : errorsGroup, _this6.fieldsStore.getFieldsValue(fieldNames));
            }
          });
        },
        validateFields: function validateFields(ns, opt, cb) {
          var _this7 = this;

          var _getParams = getParams(ns, opt, cb),
              names = _getParams.names,
              callback = _getParams.callback,
              options = _getParams.options;

          var fieldNames = names ? this.fieldsStore.getValidFieldsFullName(names) : this.fieldsStore.getValidFieldsName();
          var fields = fieldNames.filter(function (name) {
            var fieldMeta = _this7.fieldsStore.getFieldMeta(name);

            return hasRules(fieldMeta.validate);
          }).map(function (name) {
            var field = _this7.fieldsStore.getField(name);

            field.value = _this7.fieldsStore.getFieldValue(name);
            return field;
          });

          if (!fields.length) {
            if (callback) {
              callback(null, this.fieldsStore.getFieldsValue(fieldNames));
            }

            return;
          }

          if (!('firstFields' in options)) {
            options.firstFields = fieldNames.filter(function (name) {
              var fieldMeta = _this7.fieldsStore.getFieldMeta(name);

              return !!fieldMeta.validateFirst;
            });
          }

          this.validateFieldsInternal(fields, {
            fieldNames: fieldNames,
            options: options
          }, callback);
        },
        isSubmitting: function isSubmitting() {
          if (false) {}

          return this.submitting;
        },
        submit: function submit(callback) {
          var _this8 = this;

          if (false) {}

          var fn = function fn() {
            _this8.setState({
              submitting: false
            });
          };

          this.setState({
            submitting: true
          });
          callback(fn);
        }
      },
      render: function render() {
        var h = arguments[0];
        var $listeners = this.$listeners,
            $slots = this.$slots;

        var formProps = createBaseForm_defineProperty({}, formPropName, this.getForm());

        var props = Object(props_util["j" /* getOptionProps */])(this);
        var wrappedComponentProps = {
          props: mapProps.call(this, createBaseForm_objectSpread({}, formProps, props)),
          on: $listeners,
          ref: 'WrappedComponent'
        };
        return h(WrappedComponent, wrappedComponentProps, [$slots["default"]]);
      }
    };

    if (Array.isArray(WrappedComponent.props)) {
      var newProps = {};
      WrappedComponent.props.forEach(function (prop) {
        newProps[prop] = vue_types["a" /* default */].any;
      });
      newProps[formPropName] = Object;
      WrappedComponent.props = newProps;
    } else {
      WrappedComponent.props = WrappedComponent.props || {};

      if (!(formPropName in WrappedComponent.props)) {
        WrappedComponent.props[formPropName] = Object;
      }
    }

    return argumentContainer(Form, WrappedComponent);
  };
}

/* harmony default export */ var src_createBaseForm = (createBaseForm);
// CONCATENATED MODULE: ./src/components/vc-form/src/createForm.jsx

var mixin = {
  methods: {
    getForm: function getForm() {
      return {
        getFieldsValue: this.fieldsStore.getFieldsValue,
        getFieldValue: this.fieldsStore.getFieldValue,
        getFieldInstance: this.getFieldInstance,
        setFieldsValue: this.setFieldsValue,
        setFields: this.setFields,
        setFieldsInitialValue: this.fieldsStore.setFieldsInitialValue,
        getFieldDecorator: this.getFieldDecorator,
        getFieldProps: this.getFieldProps,
        getFieldsError: this.fieldsStore.getFieldsError,
        getFieldError: this.fieldsStore.getFieldError,
        isFieldValidating: this.fieldsStore.isFieldValidating,
        isFieldsValidating: this.fieldsStore.isFieldsValidating,
        isFieldsTouched: this.fieldsStore.isFieldsTouched,
        isFieldTouched: this.fieldsStore.isFieldTouched,
        isSubmitting: this.isSubmitting,
        submit: this.submit,
        validateFields: this.validateFields,
        resetFields: this.resetFields
      };
    }
  }
};

function createForm(options) {
  return src_createBaseForm(options, [mixin]);
}

/* harmony default export */ var src_createForm = (createForm);
// CONCATENATED MODULE: ./src/components/vc-form/src/createDOMForm.jsx
function createDOMForm_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { createDOMForm_defineProperty(target, key, source[key]); }); } return target; }

function createDOMForm_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







function computedStyle(el, prop) {
  var getComputedStyle = window.getComputedStyle;
  var style = // If we have getComputedStyle
  getComputedStyle // Query it
  // TODO: From CSS-Query notes, we might need (node, null) for FF
  ? getComputedStyle(el) // Otherwise, we are in IE and use currentStyle
  : el.currentStyle;

  if (style) {
    return style[// Switch to camelCase for CSSOM
    // DEV: Grabbed from jQuery
    // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194
    // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597
    prop.replace(/-(\w)/gi, function (word, letter) {
      return letter.toUpperCase();
    })];
  }

  return undefined;
}

function getScrollableContainer(n) {
  var node = n;
  var nodeName;
  /* eslint no-cond-assign:0 */

  while ((nodeName = node.nodeName.toLowerCase()) !== 'body') {
    var overflowY = computedStyle(node, 'overflowY'); // https://stackoverflow.com/a/36900407/3040605

    if (node !== n && (overflowY === 'auto' || overflowY === 'scroll') && node.scrollHeight > node.clientHeight) {
      return node;
    }

    node = node.parentNode;
  }

  return nodeName === 'body' ? node.ownerDocument : node;
}

var createDOMForm_mixin = {
  methods: {
    getForm: function getForm() {
      return createDOMForm_objectSpread({}, mixin.methods.getForm.call(this), {
        validateFieldsAndScroll: this.validateFieldsAndScroll
      });
    },
    validateFieldsAndScroll: function validateFieldsAndScroll(ns, opt, cb) {
      var _this = this;

      var _getParams = getParams(ns, opt, cb),
          names = _getParams.names,
          callback = _getParams.callback,
          options = _getParams.options;

      var newCb = function newCb(error, values) {
        if (error) {
          var validNames = _this.fieldsStore.getValidFieldsName();

          var firstNode;
          var firstTop;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = validNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var name = _step.value;

              if (has_default()(error, name)) {
                var instance = _this.getFieldInstance(name);

                if (instance) {
                  var node = instance.$el || instance.elm;
                  var top = node.getBoundingClientRect().top;

                  if (node.type !== 'hidden' && (firstTop === undefined || firstTop > top)) {
                    firstTop = top;
                    firstNode = node;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          if (firstNode) {
            var c = options.container || getScrollableContainer(firstNode);
            dom_scroll_into_view_lib_default()(firstNode, c, createDOMForm_objectSpread({
              onlyScrollIfNeeded: true
            }, options.scroll));
          }
        }

        if (typeof callback === 'function') {
          callback(error, values);
        }
      };

      return this.validateFields(names, options, newCb);
    }
  }
};

function createDOMForm(option) {
  return src_createBaseForm(createDOMForm_objectSpread({}, option), [createDOMForm_mixin]);
}

/* harmony default export */ var src_createDOMForm = (createDOMForm);
// EXTERNAL MODULE: ./node_modules/intersperse/lib/intersperse.js
var intersperse = __webpack_require__(412);
var intersperse_default = /*#__PURE__*/__webpack_require__.n(intersperse);

// CONCATENATED MODULE: ./src/components/form/constants.jsx
var FIELD_META_PROP = 'data-__meta';
var FIELD_DATA_PROP = 'data-__field';
// CONCATENATED MODULE: ./src/components/form/FormItem.jsx


function FormItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function FormItem_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = FormItem_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function FormItem_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }












var FormItemProps = {
  id: vue_types["a" /* default */].string,
  prefixCls: vue_types["a" /* default */].string,
  label: vue_types["a" /* default */].any,
  labelCol: vue_types["a" /* default */].shape(ColProps).loose,
  wrapperCol: vue_types["a" /* default */].shape(ColProps).loose,
  help: vue_types["a" /* default */].any,
  extra: vue_types["a" /* default */].any,
  validateStatus: vue_types["a" /* default */].oneOf(['', 'success', 'warning', 'error', 'validating']),
  hasFeedback: vue_types["a" /* default */].bool,
  required: vue_types["a" /* default */].bool,
  colon: vue_types["a" /* default */].bool,
  fieldDecoratorId: vue_types["a" /* default */].string,
  fieldDecoratorOptions: vue_types["a" /* default */].object
};
/* harmony default export */ var FormItem = ({
  name: 'TaFormItem',
  __ANT_FORM_ITEM: true,
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(FormItemProps, {
    hasFeedback: false,
    prefixCls: 'ant-form',
    colon: true
  }),
  inject: {
    FormProps: {
      "default": {}
    },
    decoratorFormProps: {
      "default": {}
    }
  },
  data: function data() {
    return {
      helpShow: false
    };
  },
  mounted: function mounted() {
    _util_warning(this.getControls(this.slotDefault, true).length <= 1, '`Form.Item` cannot generate `validateStatus` and `help` automatically, ' + 'while there are more than one `getFieldDecorator` in it.');
  },
  methods: {
    getHelpMessage: function getHelpMessage() {
      var help = Object(props_util["g" /* getComponentFromProp */])(this, 'help');
      var onlyControl = this.getOnlyControl();

      if (help === undefined && onlyControl) {
        var errors = this.getField().errors;

        if (errors) {
          return intersperse_default()(errors.map(function (e, index) {
            return Object(props_util["s" /* isValidElement */])(e.message) ? Object(vnode["a" /* cloneElement */])(e.message, {
              key: index
            }) : e.message;
          }), ' ');
        } else {
          return '';
        }
      }

      return help;
    },
    getControls: function getControls() {
      var childrenArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var recursively = arguments.length > 1 ? arguments[1] : undefined;
      var controls = [];

      for (var i = 0; i < childrenArray.length; i++) {
        if (!recursively && controls.length > 0) {
          break;
        }

        var child = childrenArray[i];

        if (!child.tag && child.text.trim() === '') {
          continue;
        }

        if (Object(props_util["l" /* getSlotOptions */])(child).__ANT_FORM_ITEM) {
          continue;
        }

        var attrs = child.data && child.data.attrs;

        if (!attrs) {
          continue;
        }

        var slots = Object(props_util["m" /* getSlots */])(child);

        if (FIELD_META_PROP in attrs) {
          // And means FIELD_DATA_PROP in child.props, too.
          controls.push(child);
        } else if (slots["default"]) {
          controls = controls.concat(this.getControls(slots["default"], recursively));
        }
      }

      return controls;
    },
    getOnlyControl: function getOnlyControl() {
      var child = this.getControls(this.slotDefault, false)[0];
      return child !== undefined ? child : null;
    },
    getChildAttr: function getChildAttr(prop) {
      var child = this.getOnlyControl();
      var data = {};

      if (!child) {
        return undefined;
      }

      if (child.data) {
        data = child.data;
      } else if (child.$vnode && child.$vnode.data) {
        data = child.$vnode.data;
      }

      return data[prop] || data.attrs[prop];
    },
    getId: function getId() {
      return this.getChildAttr('id');
    },
    getMeta: function getMeta() {
      return this.getChildAttr(FIELD_META_PROP);
    },
    getField: function getField() {
      return this.getChildAttr(FIELD_DATA_PROP);
    },
    onHelpAnimEnd: function onHelpAnimEnd(_key, helpShow) {
      this.helpShow = helpShow;

      if (!helpShow) {
        this.$forceUpdate();
      }
    },
    renderHelp: function renderHelp() {
      var _this = this;

      var h = this.$createElement;
      var prefixCls = this.prefixCls;
      var help = this.getHelpMessage();
      var children = help ? h("div", {
        "class": "".concat(prefixCls, "-explain"),
        key: 'help'
      }, [help]) : null;

      if (children) {
        this.helpShow = !!children;
      }

      var transitionProps = Object(getTransitionProps["a" /* default */])('show-help', {
        afterEnter: function afterEnter() {
          return _this.onHelpAnimEnd('help', true);
        },
        afterLeave: function afterLeave() {
          return _this.onHelpAnimEnd('help', false);
        }
      });
      return h("transition", babel_helper_vue_jsx_merge_props_default()([transitionProps, {
        key: 'help'
      }]), [children]);
    },
    renderExtra: function renderExtra() {
      var h = this.$createElement;
      var prefixCls = this.prefixCls;
      var extra = Object(props_util["g" /* getComponentFromProp */])(this, 'extra');
      return extra ? h("div", {
        "class": "".concat(prefixCls, "-extra")
      }, [extra]) : null;
    },
    getValidateStatus: function getValidateStatus() {
      var onlyControl = this.getOnlyControl();

      if (!onlyControl) {
        return '';
      }

      var field = this.getField();

      if (field.validating) {
        return 'validating';
      }

      if (field.errors) {
        return 'error';
      }

      var fieldValue = 'value' in field ? field.value : this.getMeta().initialValue;

      if (fieldValue !== undefined && fieldValue !== null && fieldValue !== '') {
        return 'success';
      }

      return '';
    },
    renderValidateWrapper: function renderValidateWrapper(c1, c2, c3) {
      var h = this.$createElement;
      var props = this.$props;
      var onlyControl = this.getOnlyControl;
      var validateStatus = props.validateStatus === undefined && onlyControl ? this.getValidateStatus() : props.validateStatus;
      var classes = "".concat(props.prefixCls, "-item-control");

      if (validateStatus) {
        classes = classnames_default()("".concat(props.prefixCls, "-item-control"), {
          'has-feedback': props.hasFeedback || validateStatus === 'validating',
          'has-success': validateStatus === 'success',
          'has-warning': validateStatus === 'warning',
          'has-error': validateStatus === 'error',
          'is-validating': validateStatus === 'validating'
        });
      }

      return h("div", {
        "class": classes
      }, [h("span", {
        "class": "".concat(props.prefixCls, "-item-children")
      }, [c1]), c2, c3]);
    },
    renderWrapper: function renderWrapper(children) {
      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          _this$wrapperCol = this.wrapperCol,
          wrapperCol = _this$wrapperCol === void 0 ? {} : _this$wrapperCol;

      var cls = wrapperCol["class"],
          style = wrapperCol.style,
          id = wrapperCol.id,
          on = wrapperCol.on,
          restProps = FormItem_objectWithoutProperties(wrapperCol, ["class", "style", "id", "on"]);

      var className = classnames_default()("".concat(prefixCls, "-item-control-wrapper"), cls);
      var colProps = {
        props: restProps,
        "class": className,
        key: 'wrapper',
        style: style,
        id: id,
        on: on
      };
      return h(Col, colProps, [children]);
    },
    isRequired: function isRequired() {
      var required = this.required;

      if (required !== undefined) {
        return required;
      }

      if (this.getOnlyControl()) {
        var meta = this.getMeta() || {};
        var validate = meta.validate || [];
        return validate.filter(function (item) {
          return !!item.rules;
        }).some(function (item) {
          return item.rules.some(function (rule) {
            return rule.required;
          });
        });
      }

      return false;
    },
    // Resolve duplicated ids bug between different forms
    // https://github.com/ant-design/ant-design/issues/7351
    onLabelClick: function onLabelClick(e) {
      var label = Object(props_util["g" /* getComponentFromProp */])(this, 'label');
      var id = this.id || this.getId();

      if (!id) {
        return;
      }

      var controls = document.querySelectorAll("[id=\"".concat(id, "\"]"));

      if (controls.length !== 1) {
        // Only prevent in default situation
        // Avoid preventing event in `label={<a href="xx">link</a>}``
        if (typeof label === 'string') {
          e.preventDefault();
        }

        var control = this.$el.querySelector("[id=\"".concat(id, "\"]"));

        if (control && control.focus) {
          control.focus();
        }
      }
    },
    renderLabel: function renderLabel() {
      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          _this$labelCol = this.labelCol,
          labelCol = _this$labelCol === void 0 ? {} : _this$labelCol,
          colon = this.colon,
          id = this.id;
      var label = Object(props_util["g" /* getComponentFromProp */])(this, 'label');
      var required = this.isRequired();

      var labelColClass = labelCol["class"],
          labelColStyle = labelCol.style,
          labelColId = labelCol.id,
          on = labelCol.on,
          restProps = FormItem_objectWithoutProperties(labelCol, ["class", "style", "id", "on"]);

      var labelColClassName = classnames_default()("".concat(prefixCls, "-item-label"), labelColClass);
      var labelClassName = classnames_default()(FormItem_defineProperty({}, "".concat(prefixCls, "-item-required"), required));
      var labelChildren = label; // Keep label is original where there should have no colon

      var haveColon = colon && this.FormProps.layout !== 'vertical'; // Remove duplicated user input colon

      if (haveColon && typeof label === 'string' && label.trim() !== '') {
        labelChildren = label.replace(/[：|:]\s*$/, '');
      }

      var colProps = {
        props: restProps,
        "class": labelColClassName,
        key: 'label',
        style: labelColStyle,
        id: labelColId,
        on: on
      };
      return label ? h(Col, colProps, [h("label", {
        attrs: {
          "for": id || this.getId(),
          title: typeof label === 'string' ? label : ''
        },
        "class": labelClassName,
        on: {
          "click": this.onLabelClick
        }
      }, [labelChildren])]) : null;
    },
    renderChildren: function renderChildren() {
      return [this.renderLabel(), this.renderWrapper(this.renderValidateWrapper(this.slotDefault, this.renderHelp(), this.renderExtra()))];
    },
    renderFormItem: function renderFormItem(children) {
      var _itemClassName;

      var h = this.$createElement;
      var props = this.$props;
      var prefixCls = props.prefixCls;
      var itemClassName = (_itemClassName = {}, FormItem_defineProperty(_itemClassName, "".concat(prefixCls, "-item"), true), FormItem_defineProperty(_itemClassName, "".concat(prefixCls, "-item-with-help"), this.helpShow), FormItem_defineProperty(_itemClassName, "".concat(prefixCls, "-item-no-colon"), !props.colon), _itemClassName);
      return h(Row, {
        "class": classnames_default()(itemClassName)
      }, [children]);
    }
  },
  render: function render() {
    var $slots = this.$slots,
        decoratorFormProps = this.decoratorFormProps,
        fieldDecoratorId = this.fieldDecoratorId,
        _this$fieldDecoratorO = this.fieldDecoratorOptions,
        fieldDecoratorOptions = _this$fieldDecoratorO === void 0 ? {} : _this$fieldDecoratorO;
    var child = Object(props_util["c" /* filterEmpty */])($slots["default"] || []);

    if (decoratorFormProps.form && fieldDecoratorId && child.length) {
      var getFieldDecorator = decoratorFormProps.form.getFieldDecorator;
      child[0] = getFieldDecorator(fieldDecoratorId, fieldDecoratorOptions)(child[0]);
      _util_warning(!(child.length > 1), '`autoFormCreate` just `decorator` then first children. but you can use JSX to support multiple children');
    }

    this.slotDefault = child;
    var children = this.renderChildren();
    return this.renderFormItem(children);
  }
});
// CONCATENATED MODULE: ./src/components/form/Form.jsx
function Form_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Form_defineProperty(target, key, source[key]); }); } return target; }

function Form_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var FormCreateOption = {
  onFieldsChange: vue_types["a" /* default */].func,
  onValuesChange: vue_types["a" /* default */].func,
  mapPropsToFields: vue_types["a" /* default */].func,
  validateMessages: vue_types["a" /* default */].any,
  withRef: vue_types["a" /* default */].bool // function create

};
var WrappedFormUtils = {
  /** 获取一组输入控件的值，如不传入参数，则获取全部组件的值 */
  getFieldsValue: vue_types["a" /* default */].func,

  /** 获取一个输入控件的值 */
  getFieldValue: vue_types["a" /* default */].func,

  /** 设置一组输入控件的值 */
  setFieldsValue: vue_types["a" /* default */].func,

  /** 设置一组输入控件的值 */
  setFields: vue_types["a" /* default */].func,

  /** 校验并获取一组输入域的值与 Error */
  validateFields: vue_types["a" /* default */].func,
  // validateFields(fieldNames: Array<string>, options: Object, callback: ValidateCallback): void;
  // validateFields(fieldNames: Array<string>, callback: ValidateCallback): void;
  // validateFields(options: Object, callback: ValidateCallback): void;
  // validateFields(callback: ValidateCallback): void;
  // validateFields(): void;

  /** 与 `validateFields` 相似，但校验完后，如果校验不通过的菜单域不在可见范围内，则自动滚动进可见范围 */
  validateFieldsAndScroll: vue_types["a" /* default */].func,
  // validateFieldsAndScroll(fieldNames?: Array<string>, options?: Object, callback?: ValidateCallback): void;
  // validateFieldsAndScroll(fieldNames?: Array<string>, callback?: ValidateCallback): void;
  // validateFieldsAndScroll(options?: Object, callback?: ValidateCallback): void;
  // validateFieldsAndScroll(callback?: ValidateCallback): void;
  // validateFieldsAndScroll(): void;

  /** 获取某个输入控件的 Error */
  getFieldError: vue_types["a" /* default */].func,
  getFieldsError: vue_types["a" /* default */].func,

  /** 判断一个输入控件是否在校验状态 */
  isFieldValidating: vue_types["a" /* default */].func,
  isFieldTouched: vue_types["a" /* default */].func,
  isFieldsTouched: vue_types["a" /* default */].func,

  /** 重置一组输入控件的值与状态，如不传入参数，则重置所有组件 */
  resetFields: vue_types["a" /* default */].func,
  getFieldDecorator: vue_types["a" /* default */].func
};
var FormProps = {
  layout: vue_types["a" /* default */].oneOf(['horizontal', 'inline', 'vertical']),
  form: vue_types["a" /* default */].shape(WrappedFormUtils).loose,
  // onSubmit: React.FormEventHandler<any>;
  prefixCls: vue_types["a" /* default */].string,
  hideRequiredMark: vue_types["a" /* default */].bool,
  autoFormCreate: vue_types["a" /* default */].func,
  options: vue_types["a" /* default */].object
};
var ValidationRule = {
  /** validation error message */
  message: vue_types["a" /* default */].string,

  /** built-in validation type, available options: https://github.com/yiminghe/async-validator#type */
  type: vue_types["a" /* default */].string,

  /** indicates whether field is required */
  required: vue_types["a" /* default */]["boolean"],

  /** treat required fields that only contain whitespace as errors */
  whitespace: vue_types["a" /* default */]["boolean"],

  /** validate the exact length of a field */
  len: vue_types["a" /* default */].number,

  /** validate the min length of a field */
  min: vue_types["a" /* default */].number,

  /** validate the max length of a field */
  max: vue_types["a" /* default */].number,

  /** validate the value from a list of possible values */
  "enum": vue_types["a" /* default */].oneOfType([String, vue_types["a" /* default */].arrayOf(String)]),

  /** validate from a regular expression */
  pattern: vue_types["a" /* default */].custom(isRegExp_default.a),

  /** transform a value before validation */
  transform: vue_types["a" /* default */].func,

  /** custom validate function (Note: callback must be called) */
  validator: vue_types["a" /* default */].func // export type ValidateCallback = (errors: any, values: any) => void;
  // export type GetFieldDecoratorOptions = {
  //   /** 子节点的值的属性，如 Checkbox 的是 'checked' */
  //   valuePropName?: string;
  //   /** 子节点的初始值，类型、可选值均由子节点决定 */
  //   initialValue?: any;
  //   /** 收集子节点的值的时机 */
  //   trigger?: string;
  //   /** 可以把 onChange 的参数转化为控件的值，例如 DatePicker 可设为：(date, dateString) => dateString */
  //   getValueFromEvent?: (...args: any[]) => any;
  //   /** 校验子节点值的时机 */
  //   validateTrigger?: string | string[];
  //   /** 校验规则，参见 [async-validator](https://github.com/yiminghe/async-validator) */
  //   rules?: ValidationRule[];
  //   /** 是否和其他控件互斥，特别用于 Radio 单选控件 */
  //   exclusive?: boolean;
  //   /** Normalize value to form component */
  //   normalize?: (value: any, prevValue: any, allValues: any) => any;
  //   /** Whether stop validate on first rule of error for this field.  */
  //   validateFirst?: boolean;
  // };

};
/* harmony default export */ var form_Form = ({
  name: 'TaForm',
  props: Object(props_util["q" /* initDefaultProps */])(FormProps, {
    prefixCls: 'ant-form',
    layout: 'horizontal',
    hideRequiredMark: false
  }),
  // static defaultProps = {
  //   prefixCls: 'ant-form',
  //   layout: 'horizontal',
  //   hideRequiredMark: false,
  //   onSubmit (e) {
  //     e.preventDefault()
  //   },
  // };
  // static propTypes = {
  //   prefixCls: PropTypes.string,
  //   layout: PropTypes.oneOf(['horizontal', 'inline', 'vertical']),
  //   children: PropTypes.any,
  //   onSubmit: PropTypes.func,
  //   hideRequiredMark: PropTypes.bool,
  // };
  Item: FormItem,
  createFormField: createFormField,
  create: function create() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return src_createDOMForm(Form_objectSpread({
      fieldNameProp: 'id'
    }, options, {
      fieldMetaProp: FIELD_META_PROP,
      fieldDataProp: FIELD_DATA_PROP
    }));
  },
  provide: function provide() {
    return {
      FormProps: this.$props
    };
  },
  methods: {
    onSubmit: function onSubmit(e) {
      var $listeners = this.$listeners;

      if (!$listeners.submit) {
        e.preventDefault();
      } else {
        this.$emit('submit', e);
      }
    }
  },
  render: function render() {
    var _classNames,
        _this = this;

    var h = arguments[0];
    var prefixCls = this.prefixCls,
        hideRequiredMark = this.hideRequiredMark,
        layout = this.layout,
        onSubmit = this.onSubmit,
        $slots = this.$slots,
        autoFormCreate = this.autoFormCreate,
        _this$options = this.options,
        options = _this$options === void 0 ? {} : _this$options;
    var formClassName = classnames_default()(prefixCls, (_classNames = {}, Form_defineProperty(_classNames, "".concat(prefixCls, "-horizontal"), layout === 'horizontal'), Form_defineProperty(_classNames, "".concat(prefixCls, "-vertical"), layout === 'vertical'), Form_defineProperty(_classNames, "".concat(prefixCls, "-inline"), layout === 'inline'), Form_defineProperty(_classNames, "".concat(prefixCls, "-hide-required-mark"), hideRequiredMark), _classNames));

    if (autoFormCreate) {
      var DomForm = this.DomForm || src_createDOMForm(Form_objectSpread({
        fieldNameProp: 'id'
      }, options, {
        fieldMetaProp: FIELD_META_PROP,
        fieldDataProp: FIELD_DATA_PROP,
        templateContext: this.$vnode.context
      }))({
        provide: function provide() {
          return {
            decoratorFormProps: this.$props
          };
        },
        data: function data() {
          return {
            children: $slots["default"],
            formClassName: formClassName,
            submit: onSubmit
          };
        },
        created: function created() {
          autoFormCreate(this.form);
        },
        render: function render() {
          var h = arguments[0];
          var children = this.children,
              formClassName = this.formClassName,
              submit = this.submit;
          return h("form", {
            on: {
              "submit": submit
            },
            "class": formClassName
          }, [children]);
        }
      });

      if (this.domForm) {
        this.domForm.children = $slots["default"];
        this.domForm.submit = onSubmit;
        this.domForm.formClassName = formClassName;
      }

      this.DomForm = DomForm;
      return h(DomForm, {
        attrs: {
          wrappedComponentRef: function wrappedComponentRef(inst) {
            _this.domForm = inst;
          }
        }
      });
    }

    return h("form", {
      on: {
        "submit": onSubmit
      },
      "class": formClassName
    }, [$slots["default"]]);
  }
});
// CONCATENATED MODULE: ./src/components/form/index.jsx



external_Vue_default.a.use(antRefDirective["a" /* default */]);


/* istanbul ignore next */

form_Form.install = function (Vue) {
  Vue.component(form_Form.name, form_Form);
  Vue.component(form_Form.Item.name, form_Form.Item);
};

/* harmony default export */ var components_form = (form_Form);
// EXTERNAL MODULE: ./node_modules/is-negative-zero/index.js
var is_negative_zero = __webpack_require__(413);
var is_negative_zero_default = /*#__PURE__*/__webpack_require__.n(is_negative_zero);

// CONCATENATED MODULE: ./src/components/vc-m-feedback/src/PropTypes.jsx

var ITouchProps = {
  disabled: vue_types["a" /* default */].bool,
  activeClassName: vue_types["a" /* default */].string,
  activeStyle: vue_types["a" /* default */].any // onTouchStart: PropTypes.func,
  // onTouchEnd: PropTypes.func,
  // onTouchCancel: PropTypes.func,
  // onMouseDown: PropTypes.func,
  // onMouseUp: PropTypes.func,
  // onMouseLeave: PropTypes.func,

};
// CONCATENATED MODULE: ./src/components/vc-m-feedback/src/TouchFeedback.jsx
function TouchFeedback_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { TouchFeedback_defineProperty(target, key, source[key]); }); } return target; }

function TouchFeedback_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






/* harmony default export */ var TouchFeedback = ({
  name: 'TouchFeedback',
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(ITouchProps, {
    disabled: false
  }),
  data: function data() {
    return {
      active: false
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      if (_this.disabled && _this.active) {
        _this.setState({
          active: false
        });
      }
    });
  },
  methods: {
    triggerEvent: function triggerEvent(type, isActive, ev) {
      // const eventType = `on${type}`
      // if (this.props[eventType]) {
      //   this.props[eventType](ev)
      // }
      this.$emit(type, ev);

      if (isActive !== this.active) {
        this.setState({
          active: isActive
        });
      }
    },
    onTouchStart: function onTouchStart(e) {
      this.triggerEvent('touchstart', true, e);
    },
    onTouchMove: function onTouchMove(e) {
      this.triggerEvent('touchmove', false, e);
    },
    onTouchEnd: function onTouchEnd(e) {
      this.triggerEvent('touchend', false, e);
    },
    onTouchCancel: function onTouchCancel(e) {
      this.triggerEvent('touchcancel', false, e);
    },
    onMouseDown: function onMouseDown(e) {
      // todo
      // pc simulate mobile
      // if (this.props.onTouchStart) {
      this.triggerEvent('touchstart', true, e); // }

      this.triggerEvent('mousedown', true, e);
    },
    onMouseUp: function onMouseUp(e) {
      // if (this.props.onTouchEnd) {
      this.triggerEvent('touchend', false, e); // }

      this.triggerEvent('mouseup', false, e);
    },
    onMouseLeave: function onMouseLeave(e) {
      this.triggerEvent('mouseleave', false, e);
    }
  },
  render: function render() {
    var _this$$props = this.$props,
        disabled = _this$$props.disabled,
        _this$$props$activeCl = _this$$props.activeClassName,
        activeClassName = _this$$props$activeCl === void 0 ? '' : _this$$props$activeCl,
        _this$$props$activeSt = _this$$props.activeStyle,
        activeStyle = _this$$props$activeSt === void 0 ? {} : _this$$props$activeSt;
    var child = this.$slots["default"];

    if (child.length !== 1) {
      _util_warning(false, 'm-feedback组件只能包含一个子元素');
      return null;
    }

    var childProps = {
      on: disabled ? {} : {
        touchstart: this.onTouchStart,
        touchmove: this.onTouchMove,
        touchend: this.onTouchEnd,
        touchcancel: this.onTouchCancel,
        mousedown: this.onMouseDown,
        mouseup: this.onMouseUp,
        mouseleave: this.onMouseLeave
      }
    };

    if (!disabled && this.active) {
      childProps = TouchFeedback_objectSpread({}, childProps, {
        style: activeStyle,
        "class": activeClassName
      });
    }

    return Object(vnode["a" /* cloneElement */])(child, childProps);
  }
});
// CONCATENATED MODULE: ./src/components/vc-m-feedback/index.js

/* harmony default export */ var vc_m_feedback = (TouchFeedback);
// CONCATENATED MODULE: ./src/components/vc-input-number/src/InputHandler.js


var InputHandler = {
  props: {
    prefixCls: vue_types["a" /* default */].string,
    disabled: vue_types["a" /* default */].bool
  },
  render: function render() {
    var h = arguments[0];
    var _this$$props = this.$props,
        prefixCls = _this$$props.prefixCls,
        disabled = _this$$props.disabled;
    var touchableProps = {
      props: {
        disabled: disabled,
        activeClassName: "".concat(prefixCls, "-handler-active")
      },
      on: this.$listeners
    };
    var spanProps = {
      attrs: this.$attrs
    };
    return h(vc_m_feedback, touchableProps, [h("span", spanProps, [this.$slots["default"]])]);
  }
};
/* harmony default export */ var src_InputHandler = (InputHandler);
// CONCATENATED MODULE: ./src/components/vc-input-number/src/index.js
function src_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
} // based on rc-input-number 4.0.12










function src_noop() {}

function preventDefault(e) {
  e.preventDefault();
}

function defaultParser(input) {
  return input.replace(/[^\w\.-]+/g, '');
}
/**
 * When click and hold on a button - the speed of auto changin the value.
 */


var SPEED = 200;
/**
 * When click and hold on a button - the delay before auto changin the value.
 */

var DELAY = 600;
/**
 * Max Safe Integer -- on IE this is not available, so manually set the number in that case.
 * The reason this is used, instead of Infinity is because numbers above the MSI are unstable
 */

var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
var inputNumberProps = {
  value: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string]),
  defaultValue: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string]),
  focusOnUpDown: vue_types["a" /* default */].bool,
  autoFocus: vue_types["a" /* default */].bool,
  // onChange: PropTypes.func,
  // onKeyDown: PropTypes.func,
  // onKeyUp: PropTypes.func,
  prefixCls: vue_types["a" /* default */].string,
  tabIndex: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
  placeholder: vue_types["a" /* default */].string,
  disabled: vue_types["a" /* default */].bool,
  // onFocus: PropTypes.func,
  // onBlur: PropTypes.func,
  readOnly: vue_types["a" /* default */].bool,
  max: vue_types["a" /* default */].number,
  min: vue_types["a" /* default */].number,
  step: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string]),
  upHandler: vue_types["a" /* default */].any,
  downHandler: vue_types["a" /* default */].any,
  useTouch: vue_types["a" /* default */].bool,
  formatter: vue_types["a" /* default */].func,
  parser: vue_types["a" /* default */].func,
  // onMouseEnter: PropTypes.func,
  // onMouseLeave: PropTypes.func,
  // onMouseOver: PropTypes.func,
  // onMouseOut: PropTypes.func,
  precision: vue_types["a" /* default */].number,
  required: vue_types["a" /* default */].bool,
  pattern: vue_types["a" /* default */].string
};
/* harmony default export */ var vc_input_number_src = ({
  name: 'InputNumber',
  mixins: [BaseMixin["a" /* default */]],
  model: {
    prop: 'value',
    event: 'change'
  },
  props: Object(props_util["q" /* initDefaultProps */])(inputNumberProps, {
    focusOnUpDown: true,
    useTouch: false,
    prefixCls: 'rc-input-number',
    min: -MAX_SAFE_INTEGER,
    step: 1,
    parser: defaultParser,
    required: false
  }),
  data: function data() {
    var value;

    if (Object(props_util["p" /* hasProp */])(this, 'value')) {
      value = this.value;
    } else {
      value = this.defaultValue;
    }

    value = this.toNumber(value);
    return {
      inputValue: this.toPrecisionAsStep(value),
      sValue: value,
      focused: this.autoFocus
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      if (_this.autoFocus && !_this.disabled) {
        _this.focus();
      }

      _this.updatedFunc();
    });
  },
  beforeUpdate: function beforeUpdate() {
    var _this2 = this;

    this.$nextTick(function () {
      try {
        _this2.start = _this2.$refs.inputRef.selectionStart;
        _this2.end = _this2.$refs.inputRef.selectionEnd;
      } catch (e) {// Fix error in Chrome:
        // Failed to read the 'selectionStart' property from 'HTMLInputElement'
        // http://stackoverflow.com/q/21177489/3040605
      }
    });
  },
  updated: function updated() {
    var _this3 = this;

    this.$nextTick(function () {
      _this3.updatedFunc();
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.stop();
  },
  watch: {
    value: function value(val) {
      var value = this.focused ? val : this.getValidValue(val, this.min, this.max);
      this.setState({
        sValue: val,
        inputValue: this.inputting ? value : this.toPrecisionAsStep(value)
      });
    }
  },
  methods: {
    updatedFunc: function updatedFunc() {
      var inputElem = this.$refs.inputRef; // Restore cursor

      try {
        // Firefox set the input cursor after it get focused.
        // This caused that if an input didn't init with the selection,
        // set will cause cursor not correct when first focus.
        // Safari will focus input if set selection. We need skip this.
        if (this.cursorStart !== undefined && this.focused) {
          // In most cases, the string after cursor is stable.
          // We can move the cursor before it
          if ( // If not match full str, try to match part of str
          !this.partRestoreByAfter(this.cursorAfter)) {
            // If not match any of then, let's just keep the position
            // TODO: Logic should not reach here, need check if happens
            var pos = this.cursorStart + 1; // If not have last string, just position to the end

            if (!this.cursorAfter) {
              pos = inputElem.value.length;
            } else if (this.lastKeyCode === _util_KeyCode.BACKSPACE) {
              pos = this.cursorStart - 1;
            } else if (this.lastKeyCode === _util_KeyCode.DELETE) {
              pos = this.cursorStart;
            }

            this.fixCaret(pos, pos);
          } else if (this.currentValue === inputElem.value) {
            // Handle some special key code
            switch (this.lastKeyCode) {
              case _util_KeyCode.BACKSPACE:
                this.fixCaret(this.cursorStart - 1, this.cursorStart - 1);
                break;

              case _util_KeyCode.DELETE:
                this.fixCaret(this.cursorStart + 1, this.cursorStart + 1);
                break;

              default: // Do nothing

            }
          }
        }
      } catch (e) {} // Do nothing
      // Reset last key


      this.lastKeyCode = null; // pressingUpOrDown is true means that someone just click up or down button

      if (!this.pressingUpOrDown) {
        return;
      }

      if (this.focusOnUpDown && this.focused) {
        if (document.activeElement !== inputElem) {
          this.focus();
        }
      }

      this.pressingUpOrDown = false;
    },
    onKeyDown: function onKeyDown(e) {
      if (e.keyCode === _util_KeyCode.UP) {
        var ratio = this.getRatio(e);
        this.up(e, ratio);
        this.stop();
      } else if (e.keyCode === _util_KeyCode.DOWN) {
        var _ratio = this.getRatio(e);

        this.down(e, _ratio);
        this.stop();
      } // Trigger user key down


      this.recordCursorPosition();
      this.lastKeyCode = e.keyCode;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this.$emit.apply(this, ['keydown', e].concat(args));
    },
    onKeyUp: function onKeyUp(e) {
      this.stop();
      this.recordCursorPosition();

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      this.$emit.apply(this, ['keyup', e].concat(args));
    },
    onChange: function onChange(e) {
      if (this.focused) {
        this.inputting = true;
      }

      var input = this.parser(this.getValueFromEvent(e));
      this.setState({
        inputValue: input
      });
      this.$emit('change', this.toNumberWhenUserInput(input)); // valid number or invalid string
    },
    onFocus: function onFocus() {
      this.setState({
        focused: true
      });

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      this.$emit.apply(this, ['focus'].concat(args));
    },
    onBlur: function onBlur(e) {
      var _this4 = this;

      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }

      this.inputting = false;
      this.setState({
        focused: false
      });
      var value = this.getCurrentValidValue(this.inputValue); // todo
      // e.persist() // fix https://github.com/react-component/input-number/issues/51

      this.setValue(value, function () {
        _this4.$emit.apply(_this4, ['blur', e].concat(args));
      });
    },
    getCurrentValidValue: function getCurrentValidValue(value) {
      var val = value;

      if (val === '') {
        val = '';
      } else if (!this.isNotCompleteNumber(val)) {
        val = this.getValidValue(val);
      } else {
        val = this.sValue;
      }

      return this.toNumber(val);
    },
    getRatio: function getRatio(e) {
      var ratio = 1;

      if (e.metaKey || e.ctrlKey) {
        ratio = 0.1;
      } else if (e.shiftKey) {
        ratio = 10;
      }

      return ratio;
    },
    getValueFromEvent: function getValueFromEvent(e) {
      // optimize for chinese input expierence
      // https://github.com/ant-design/ant-design/issues/8196
      return e.target.value.trim().replace(/。/g, '.');
    },
    getValidValue: function getValidValue(value) {
      var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.min;
      var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.max;
      var val = parseFloat(value, 10); // https://github.com/ant-design/ant-design/issues/7358

      if (isNaN(val)) {
        return value;
      }

      if (val < min) {
        val = min;
      }

      if (val > max) {
        val = max;
      }

      return val;
    },
    setValue: function setValue(v, callback) {
      // trigger onChange
      var newValue = this.isNotCompleteNumber(parseFloat(v, 10)) ? undefined : parseFloat(v, 10);
      var changed = newValue !== this.sValue || "".concat(newValue) !== "".concat(this.inputValue); // https://github.com/ant-design/ant-design/issues/7363

      if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
        this.setState({
          sValue: newValue,
          inputValue: this.toPrecisionAsStep(v)
        }, callback);
      } else {
        // always set input value same as value
        this.setState({
          inputValue: this.toPrecisionAsStep(this.sValue)
        }, callback);
      }

      if (changed) {
        this.$emit('change', newValue);
      }
    },
    getPrecision: function getPrecision(value) {
      if (Object(props_util["p" /* hasProp */])(this, 'precision')) {
        return this.precision;
      }

      var valueString = value.toString();

      if (valueString.indexOf('e-') >= 0) {
        return parseInt(valueString.slice(valueString.indexOf('e-') + 2), 10);
      }

      var precision = 0;

      if (valueString.indexOf('.') >= 0) {
        precision = valueString.length - valueString.indexOf('.') - 1;
      }

      return precision;
    },
    // step={1.0} value={1.51}
    // press +
    // then value should be 2.51, rather than 2.5
    // if this.props.precision is undefined
    // https://github.com/react-component/input-number/issues/39
    getMaxPrecision: function getMaxPrecision(currentValue) {
      var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      if (Object(props_util["p" /* hasProp */])(this, 'precision')) {
        return this.precision;
      }

      var step = this.step;
      var ratioPrecision = this.getPrecision(ratio);
      var stepPrecision = this.getPrecision(step);
      var currentValuePrecision = this.getPrecision(currentValue);

      if (!currentValue) {
        return ratioPrecision + stepPrecision;
      }

      return Math.max(currentValuePrecision, ratioPrecision + stepPrecision);
    },
    getPrecisionFactor: function getPrecisionFactor(currentValue) {
      var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var precision = this.getMaxPrecision(currentValue, ratio);
      return Math.pow(10, precision);
    },
    getInputDisplayValue: function getInputDisplayValue() {
      var focused = this.focused,
          inputValue = this.inputValue,
          sValue = this.sValue;
      var inputDisplayValue;

      if (focused) {
        inputDisplayValue = inputValue;
      } else {
        inputDisplayValue = this.toPrecisionAsStep(sValue);
      }

      if (inputDisplayValue === undefined || inputDisplayValue === null) {
        inputDisplayValue = '';
      }

      return inputDisplayValue;
    },
    recordCursorPosition: function recordCursorPosition() {
      // Record position
      try {
        var inputElem = this.$refs.inputRef;
        this.cursorStart = inputElem.selectionStart;
        this.cursorEnd = inputElem.selectionEnd;
        this.currentValue = inputElem.value;
        this.cursorBefore = inputElem.value.substring(0, this.cursorStart);
        this.cursorAfter = inputElem.value.substring(this.cursorEnd);
      } catch (e) {// Fix error in Chrome:
        // Failed to read the 'selectionStart' property from 'HTMLInputElement'
        // http://stackoverflow.com/q/21177489/3040605
      }
    },
    fixCaret: function fixCaret(start, end) {
      if (start === undefined || end === undefined || !this.input || !this.input.value) {
        return;
      }

      try {
        var inputElem = this.$refs.inputRef;
        var currentStart = inputElem.selectionStart;
        var currentEnd = inputElem.selectionEnd;

        if (start !== currentStart || end !== currentEnd) {
          inputElem.setSelectionRange(start, end);
        }
      } catch (e) {// Fix error in Chrome:
        // Failed to read the 'selectionStart' property from 'HTMLInputElement'
        // http://stackoverflow.com/q/21177489/3040605
      }
    },
    restoreByAfter: function restoreByAfter(str) {
      if (str === undefined) return false;
      var fullStr = this.$refs.inputRef.value;
      var index = fullStr.lastIndexOf(str);
      if (index === -1) return false;

      if (index + str.length === fullStr.length) {
        this.fixCaret(index, index);
        return true;
      }

      return false;
    },
    partRestoreByAfter: function partRestoreByAfter(str) {
      var _this5 = this;

      if (str === undefined) return false; // For loop from full str to the str with last char to map. e.g. 123
      // -> 123
      // -> 23
      // -> 3

      return Array.prototype.some.call(str, function (_, start) {
        var partStr = str.substring(start);
        return _this5.restoreByAfter(partStr);
      });
    },
    focus: function focus() {
      this.$refs.inputRef.focus();
      this.recordCursorPosition();
    },
    blur: function blur() {
      this.$refs.inputRef.blur();
    },
    formatWrapper: function formatWrapper(num) {
      // http://2ality.com/2012/03/signedzero.html
      // https://github.com/ant-design/ant-design/issues/9439
      if (is_negative_zero_default()(num)) {
        return '-0';
      }

      if (this.formatter) {
        return this.formatter(num);
      }

      return num;
    },
    toPrecisionAsStep: function toPrecisionAsStep(num) {
      if (this.isNotCompleteNumber(num) || num === '') {
        return num;
      }

      var precision = Math.abs(this.getMaxPrecision(num));

      if (precision === 0) {
        return num.toString();
      }

      if (!isNaN(precision)) {
        return Number(num).toFixed(precision);
      }

      return num.toString();
    },
    // '1.' '1x' 'xx' '' => are not complete numbers
    isNotCompleteNumber: function isNotCompleteNumber(num) {
      return isNaN(num) || num === '' || num === null || num && num.toString().indexOf('.') === num.toString().length - 1;
    },
    toNumber: function toNumber(num) {
      if (this.isNotCompleteNumber(num)) {
        return num;
      }

      if (Object(props_util["p" /* hasProp */])(this, 'precision')) {
        return Number(Number(num).toFixed(this.precision));
      }

      return Number(num);
    },
    // '1.0' '1.00'  => may be a inputing number
    toNumberWhenUserInput: function toNumberWhenUserInput(num) {
      // num.length > 16 => prevent input large number will became Infinity
      if ((/\.\d*0$/.test(num) || num.length > 16) && this.focused) {
        return num;
      }

      return this.toNumber(num);
    },
    upStep: function upStep(val, rat) {
      var step = this.step,
          min = this.min;
      var precisionFactor = this.getPrecisionFactor(val, rat);
      var precision = Math.abs(this.getMaxPrecision(val, rat));
      var result;

      if (typeof val === 'number') {
        result = ((precisionFactor * val + precisionFactor * step * rat) / precisionFactor).toFixed(precision);
      } else {
        result = min === -Infinity ? step : min;
      }

      return this.toNumber(result);
    },
    downStep: function downStep(val, rat) {
      var step = this.step,
          min = this.min;
      var precisionFactor = this.getPrecisionFactor(val, rat);
      var precision = Math.abs(this.getMaxPrecision(val, rat));
      var result;

      if (typeof val === 'number') {
        result = ((precisionFactor * val - precisionFactor * step * rat) / precisionFactor).toFixed(precision);
      } else {
        result = min === -Infinity ? -step : min;
      }

      return this.toNumber(result);
    },
    stepFn: function stepFn(type, e) {
      var _this6 = this;

      var ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var recursive = arguments.length > 3 ? arguments[3] : undefined;
      this.stop();

      if (e) {
        // e.persist()
        e.preventDefault();
      }

      if (this.disabled) {
        return;
      }

      var max = this.max,
          min = this.min;
      var value = this.getCurrentValidValue(this.inputValue) || 0;

      if (this.isNotCompleteNumber(value)) {
        return;
      }

      var val = this["".concat(type, "Step")](value, ratio);
      var outOfRange = val > max || val < min;

      if (val > max) {
        val = max;
      } else if (val < min) {
        val = min;
      }

      this.setValue(val);
      this.setState({
        focused: true
      });

      if (outOfRange) {
        return;
      }

      this.autoStepTimer = setTimeout(function () {
        _this6[type](e, ratio, true);
      }, recursive ? SPEED : DELAY);
    },
    stop: function stop() {
      if (this.autoStepTimer) {
        clearTimeout(this.autoStepTimer);
      }
    },
    down: function down(e, ratio, recursive) {
      this.pressingUpOrDown = true;
      this.stepFn('down', e, ratio, recursive);
    },
    up: function up(e, ratio, recursive) {
      this.pressingUpOrDown = true;
      this.stepFn('up', e, ratio, recursive);
    },
    handleInputClick: function handleInputClick() {
      this.$emit('click');
    }
  },
  render: function render() {
    var _classNames;

    var h = arguments[0];
    var _this$$props = this.$props,
        prefixCls = _this$$props.prefixCls,
        disabled = _this$$props.disabled,
        readOnly = _this$$props.readOnly,
        useTouch = _this$$props.useTouch;
    var classes = classnames_default()((_classNames = {}, src_defineProperty(_classNames, prefixCls, true), src_defineProperty(_classNames, "".concat(prefixCls, "-disabled"), disabled), src_defineProperty(_classNames, "".concat(prefixCls, "-focused"), this.focused), _classNames));
    var upDisabledClass = '';
    var downDisabledClass = '';
    var sValue = this.sValue;

    if (sValue || sValue === 0) {
      if (!isNaN(sValue)) {
        var val = Number(sValue);

        if (val >= this.max) {
          upDisabledClass = "".concat(prefixCls, "-handler-up-disabled");
        }

        if (val <= this.min) {
          downDisabledClass = "".concat(prefixCls, "-handler-down-disabled");
        }
      } else {
        upDisabledClass = "".concat(prefixCls, "-handler-up-disabled");
        downDisabledClass = "".concat(prefixCls, "-handler-down-disabled");
      }
    }

    var editable = !this.readOnly && !this.disabled; // focus state, show input value
    // unfocus state, show valid value

    var inputDisplayValue;

    if (this.focused) {
      inputDisplayValue = this.inputValue;
    } else {
      inputDisplayValue = this.toPrecisionAsStep(this.sValue);
    }

    if (inputDisplayValue === undefined || inputDisplayValue === null) {
      inputDisplayValue = '';
    }

    var upEvents;
    var downEvents;

    if (useTouch) {
      upEvents = {
        touchstart: editable && !upDisabledClass ? this.up : src_noop,
        touchend: this.stop
      };
      downEvents = {
        touchstart: editable && !downDisabledClass ? this.down : src_noop,
        touchend: this.stop
      };
    } else {
      upEvents = {
        mousedown: editable && !upDisabledClass ? this.up : src_noop,
        mouseup: this.stop,
        mouseleave: this.stop
      };
      downEvents = {
        mousedown: editable && !downDisabledClass ? this.down : src_noop,
        mouseup: this.stop,
        mouseleave: this.stop
      };
    }

    var inputDisplayValueFormat = this.formatWrapper(inputDisplayValue);
    var isUpDisabled = !!upDisabledClass || disabled || readOnly;
    var isDownDisabled = !!downDisabledClass || disabled || readOnly;
    var _this$$listeners = this.$listeners,
        _this$$listeners$mous = _this$$listeners.mouseenter,
        mouseenter = _this$$listeners$mous === void 0 ? src_noop : _this$$listeners$mous,
        _this$$listeners$mous2 = _this$$listeners.mouseleave,
        mouseleave = _this$$listeners$mous2 === void 0 ? src_noop : _this$$listeners$mous2,
        _this$$listeners$mous3 = _this$$listeners.mouseover,
        mouseover = _this$$listeners$mous3 === void 0 ? src_noop : _this$$listeners$mous3,
        _this$$listeners$mous4 = _this$$listeners.mouseout,
        mouseout = _this$$listeners$mous4 === void 0 ? src_noop : _this$$listeners$mous4;
    var contentProps = {
      on: {
        mouseenter: mouseenter,
        mouseleave: mouseleave,
        mouseover: mouseover,
        mouseout: mouseout
      },
      "class": classes
    };
    var upHandlerProps = {
      props: {
        disabled: isUpDisabled,
        prefixCls: prefixCls
      },
      attrs: {
        unselectable: 'unselectable',
        role: 'button',
        'aria-label': 'Increase Value',
        'aria-disabled': !!isUpDisabled
      },
      "class": "".concat(prefixCls, "-handler ").concat(prefixCls, "-handler-up ").concat(upDisabledClass),
      on: upEvents,
      ref: 'up'
    };
    var downHandlerProps = {
      props: {
        disabled: isDownDisabled,
        prefixCls: prefixCls
      },
      attrs: {
        unselectable: 'unselectable',
        role: 'button',
        'aria-label': 'Decrease Value',
        'aria-disabled': !!isDownDisabled
      },
      "class": "".concat(prefixCls, "-handler ").concat(prefixCls, "-handler-down ").concat(downDisabledClass),
      on: downEvents,
      ref: 'down' // ref for test

    };
    return h("div", contentProps, [h("div", {
      "class": "".concat(prefixCls, "-handler-wrap")
    }, [h(src_InputHandler, upHandlerProps, [this.upHandler || h("span", {
      attrs: {
        unselectable: 'unselectable'
      },
      "class": "".concat(prefixCls, "-handler-up-inner"),
      on: {
        "click": preventDefault
      }
    })]), h(src_InputHandler, downHandlerProps, [this.downHandler || h("span", {
      attrs: {
        unselectable: 'unselectable'
      },
      "class": "".concat(prefixCls, "-handler-down-inner"),
      on: {
        "click": preventDefault
      }
    })])]), h("div", {
      "class": "".concat(prefixCls, "-input-wrap"),
      attrs: {
        role: 'spinbutton',
        "aria-valuemin": this.min,
        "aria-valuemax": this.max,
        "aria-valuenow": sValue
      }
    }, [h("input", {
      attrs: {
        required: this.required,
        type: this.type,
        placeholder: this.placeholder,
        tabIndex: this.tabIndex,
        autoComplete: 'off',
        maxLength: this.maxLength,
        readOnly: this.readOnly,
        disabled: this.disabled,
        max: this.max,
        min: this.min,
        step: this.step,
        name: this.name,
        id: this.id,
        pattern: this.pattern
      },
      on: {
        "click": this.handleInputClick,
        "focus": this.onFocus,
        "blur": this.onBlur,
        "keydown": editable ? this.onKeyDown : src_noop,
        "keyup": editable ? this.onKeyUp : src_noop,
        "input": this.onChange
      },
      "class": "".concat(prefixCls, "-input"),
      ref: 'inputRef',
      domProps: {
        "value": inputDisplayValueFormat
      }
    })])]);
  }
});
// CONCATENATED MODULE: ./src/components/input-number/index.jsx
function input_number_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { input_number_defineProperty(target, key, source[key]); }); } return target; }

function input_number_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function input_number_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = input_number_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function input_number_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





var InputNumberProps = {
  prefixCls: vue_types["a" /* default */].string,
  min: vue_types["a" /* default */].number,
  max: vue_types["a" /* default */].number,
  value: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string]),
  step: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string]),
  defaultValue: vue_types["a" /* default */].number,
  tabIndex: vue_types["a" /* default */].number,
  disabled: vue_types["a" /* default */].bool,
  size: vue_types["a" /* default */].oneOf(['large', 'small', 'default']),
  formatter: vue_types["a" /* default */].func,
  parser: vue_types["a" /* default */].func,
  placeholder: vue_types["a" /* default */].string,
  name: vue_types["a" /* default */].string,
  id: vue_types["a" /* default */].string,
  precision: vue_types["a" /* default */].number,
  autoFocus: vue_types["a" /* default */].bool
};
var InputNumber = {
  name: 'TaInputNumber',
  model: {
    prop: 'value',
    event: 'change'
  },
  props: Object(props_util["q" /* initDefaultProps */])(InputNumberProps, {
    prefixCls: 'ant-input-number',
    step: 1
  }),
  methods: {
    focus: function focus() {
      this.$refs.inputNumberRef.focus();
    },
    blur: function blur() {
      this.$refs.inputNumberRef.blur();
    }
  },
  render: function render() {
    var _classNames;

    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        size = _getOptionProps.size,
        others = input_number_objectWithoutProperties(_getOptionProps, ["size"]);

    var inputNumberClass = classnames_default()((_classNames = {}, input_number_defineProperty(_classNames, "".concat(this.prefixCls, "-lg"), size === 'large'), input_number_defineProperty(_classNames, "".concat(this.prefixCls, "-sm"), size === 'small'), _classNames));
    var vcInputNumberprops = {
      props: input_number_objectSpread({}, others),
      "class": inputNumberClass,
      ref: 'inputNumberRef',
      on: this.$listeners
    };
    return h(vc_input_number_src, vcInputNumberprops);
  }
};
/* istanbul ignore next */

InputNumber.install = function (Vue) {
  Vue.component(InputNumber.name, InputNumber);
};

/* harmony default export */ var input_number = (InputNumber);
// CONCATENATED MODULE: ./src/components/layout/layout.jsx
function layout_toConsumableArray(arr) { return layout_arrayWithoutHoles(arr) || layout_iterableToArray(arr) || layout_nonIterableSpread(); }

function layout_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function layout_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function layout_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function layout_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { layout_defineProperty(target, key, source[key]); }); } return target; }

function layout_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var BasicProps = {
  prefixCls: vue_types["a" /* default */].string,
  hasSider: vue_types["a" /* default */]["boolean"]
};

function generator(props, name) {
  return function (BasicComponent) {
    return {
      name: name,
      props: BasicComponent.props,
      render: function render() {
        var h = arguments[0];
        var prefixCls = props.prefixCls;
        var basicComponentProps = {
          props: layout_objectSpread({
            prefixCls: prefixCls
          }, Object(props_util["j" /* getOptionProps */])(this)),
          on: this.$listeners
        };
        return h(BasicComponent, basicComponentProps, [this.$slots["default"]]);
      }
    };
  };
}

var Basic = {
  props: BasicProps,
  render: function render() {
    var h = arguments[0];
    var prefixCls = this.prefixCls,
        $slots = this.$slots,
        $listeners = this.$listeners;
    var divProps = {
      "class": prefixCls,
      on: $listeners
    };
    return h("div", divProps, [$slots["default"]]);
  }
};
var BasicLayout = {
  props: BasicProps,
  data: function data() {
    return {
      siders: []
    };
  },
  provide: function provide() {
    var _this = this;

    return {
      siderHook: {
        addSider: function addSider(id) {
          _this.siders = [].concat(layout_toConsumableArray(_this.siders), [id]);
        },
        removeSider: function removeSider(id) {
          _this.siders = _this.siders.filter(function (currentId) {
            return currentId !== id;
          });
        }
      }
    };
  },
  render: function render() {
    var h = arguments[0];
    var prefixCls = this.prefixCls,
        $slots = this.$slots,
        hasSider = this.hasSider,
        $listeners = this.$listeners;
    var divCls = classnames_default()(prefixCls, layout_defineProperty({}, "".concat(prefixCls, "-has-sider"), hasSider || this.siders.length > 0));
    var divProps = {
      "class": divCls,
      on: $listeners
    };
    return h("div", divProps, [$slots["default"]]);
  }
};
var Layout = generator({
  prefixCls: 'ant-layout'
}, 'TaLayout')(BasicLayout);
var layout_Header = generator({
  prefixCls: 'ant-layout-header'
}, 'TaLayoutHeader')(Basic);
var Footer = generator({
  prefixCls: 'ant-layout-footer'
}, 'TaLayoutFooter')(Basic);
var Content = generator({
  prefixCls: 'ant-layout-content'
}, 'TaLayoutContent')(Basic);
Layout.Header = layout_Header;
Layout.Footer = Footer;
Layout.Content = Content;
/* harmony default export */ var layout_layout = (Layout);
// CONCATENATED MODULE: ./src/components/_util/isNumeric.js
var isNumeric = function isNumeric(value) {
  return !isNaN(parseFloat(value)) && isFinite(value);
};

/* harmony default export */ var _util_isNumeric = (isNumeric);
// CONCATENATED MODULE: ./src/components/layout/Sider.jsx
function Sider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// matchMedia polyfill for
// https://github.com/WickyNilliams/enquire.js/issues/82







if (typeof window !== 'undefined') {
  var Sider_matchMediaPolyfill = function matchMediaPolyfill(mediaQuery) {
    return {
      media: mediaQuery,
      matches: false,
      addListener: function addListener() {},
      removeListener: function removeListener() {}
    };
  };

  window.matchMedia = window.matchMedia || Sider_matchMediaPolyfill;
}

var dimensionMap = {
  xs: '480px',
  sm: '576px',
  md: '768px',
  lg: '992px',
  xl: '1200px',
  xxl: '1600px' // export type CollapseType = 'clickTrigger' | 'responsive';

};
var SiderProps = {
  prefixCls: vue_types["a" /* default */].string,
  collapsible: vue_types["a" /* default */].bool,
  collapsed: vue_types["a" /* default */].bool,
  defaultCollapsed: vue_types["a" /* default */].bool,
  reverseArrow: vue_types["a" /* default */].bool,
  // onCollapse?: (collapsed: boolean, type: CollapseType) => void;
  trigger: vue_types["a" /* default */].any,
  width: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string]),
  collapsedWidth: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string]),
  breakpoint: vue_types["a" /* default */].oneOf(['xs', 'sm', 'md', 'lg', 'xl', 'xxl']),
  theme: vue_types["a" /* default */].oneOf(['light', 'dark']).def('dark') // export interface SiderState {
  //   collapsed?: boolean;
  //   below: boolean;
  //   belowShow?: boolean;
  // }
  // export interface SiderContext {
  //   siderCollapsed: boolean;
  // }

};

var generateId = function () {
  var i = 0;
  return function () {
    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    i += 1;
    return "".concat(prefix).concat(i);
  };
}();

/* harmony default export */ var Sider = ({
  name: 'TaLayoutSider',
  __ANT_LAYOUT_SIDER: true,
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(SiderProps, {
    prefixCls: 'ant-layout-sider',
    collapsible: false,
    defaultCollapsed: false,
    reverseArrow: false,
    width: 200,
    collapsedWidth: 80
  }),
  // static childContextTypes = {
  //   siderCollapsed: PropTypes.bool,
  //   collapsedWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  // };
  // static contextTypes = {
  //   siderHook: PropTypes.object,
  // };
  // private mql: MediaQueryList;
  // private uniqueId: string;
  data: function data() {
    this.uniqueId = generateId('ant-sider-');
    var matchMedia;

    if (typeof window !== 'undefined') {
      matchMedia = window.matchMedia;
    }

    var props = Object(props_util["j" /* getOptionProps */])(this);

    if (matchMedia && props.breakpoint && props.breakpoint in dimensionMap) {
      this.mql = matchMedia("(max-width: ".concat(dimensionMap[props.breakpoint], ")"));
    }

    var sCollapsed;

    if ('collapsed' in props) {
      sCollapsed = props.collapsed;
    } else {
      sCollapsed = props.defaultCollapsed;
    }

    return {
      sCollapsed: sCollapsed,
      below: false,
      belowShow: false
    };
  },
  provide: function provide() {
    return {
      layoutSiderContext: this // menu组件中使用

    };
  },
  inject: {
    siderHook: {
      "default": {}
    }
  },
  // getChildContext() {
  //   return {
  //     siderCollapsed: this.state.collapsed,
  //     collapsedWidth: this.props.collapsedWidth,
  //   };
  // }
  watch: {
    collapsed: function collapsed(val) {
      this.setState({
        sCollapsed: val
      });
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      if (_this.mql) {
        _this.mql.addListener(_this.responsiveHandler);

        _this.responsiveHandler(_this.mql);
      }

      if (_this.siderHook.addSider) {
        _this.siderHook.addSider(_this.uniqueId);
      }
    });
  },
  beforeDestroy: function beforeDestroy() {
    if (this.mql) {
      this.mql.removeListener(this.responsiveHandler);
    }

    if (this.siderHook.removeSider) {
      this.siderHook.removeSider(this.uniqueId);
    }
  },
  model: {
    prop: 'collapsed',
    event: 'collapse'
  },
  methods: {
    responsiveHandler: function responsiveHandler(mql) {
      this.setState({
        below: mql.matches
      });
      this.$emit('breakpoint', mql.matches);

      if (this.sCollapsed !== mql.matches) {
        this.setCollapsed(mql.matches, 'responsive');
      }
    },
    setCollapsed: function setCollapsed(collapsed, type) {
      if (!Object(props_util["p" /* hasProp */])(this, 'collapsed')) {
        this.setState({
          sCollapsed: collapsed
        });
      }

      this.$emit('collapse', collapsed, type);
    },
    toggle: function toggle() {
      var collapsed = !this.sCollapsed;
      this.setCollapsed(collapsed, 'clickTrigger');
    },
    belowShowChange: function belowShowChange() {
      this.setState({
        belowShow: !this.belowShow
      });
    }
  },
  render: function render() {
    var _classNames;

    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        prefixCls = _getOptionProps.prefixCls,
        theme = _getOptionProps.theme,
        collapsible = _getOptionProps.collapsible,
        reverseArrow = _getOptionProps.reverseArrow,
        width = _getOptionProps.width,
        collapsedWidth = _getOptionProps.collapsedWidth;

    var trigger = Object(props_util["g" /* getComponentFromProp */])(this, 'trigger');
    var rawWidth = this.sCollapsed ? collapsedWidth : width; // use "px" as fallback unit for width

    var siderWidth = _util_isNumeric(rawWidth) ? "".concat(rawWidth, "px") : String(rawWidth); // special trigger when collapsedWidth == 0

    var zeroWidthTrigger = parseFloat(String(collapsedWidth || 0)) === 0 ? h("span", {
      on: {
        "click": this.toggle
      },
      "class": "".concat(prefixCls, "-zero-width-trigger")
    }, [h(components_icon, {
      attrs: {
        type: 'bars'
      }
    })]) : null;
    var iconObj = {
      'expanded': reverseArrow ? h(components_icon, {
        attrs: {
          type: 'right'
        }
      }) : h(components_icon, {
        attrs: {
          type: 'left'
        }
      }),
      'collapsed': reverseArrow ? h(components_icon, {
        attrs: {
          type: 'left'
        }
      }) : h(components_icon, {
        attrs: {
          type: 'right'
        }
      })
    };
    var status = this.sCollapsed ? 'collapsed' : 'expanded';
    var defaultTrigger = iconObj[status];
    var triggerDom = trigger !== null ? zeroWidthTrigger || h("div", {
      "class": "".concat(prefixCls, "-trigger"),
      on: {
        "click": this.toggle
      },
      style: {
        width: siderWidth
      }
    }, [trigger || defaultTrigger]) : null;
    var divStyle = {
      // ...style,
      flex: "0 0 ".concat(siderWidth),
      maxWidth: siderWidth,
      // Fix width transition bug in IE11
      minWidth: siderWidth,
      // https://github.com/ant-design/ant-design/issues/6349
      width: siderWidth
    };
    var siderCls = classnames_default()(prefixCls, "".concat(prefixCls, "-").concat(theme), (_classNames = {}, Sider_defineProperty(_classNames, "".concat(prefixCls, "-collapsed"), !!this.sCollapsed), Sider_defineProperty(_classNames, "".concat(prefixCls, "-has-trigger"), collapsible && trigger !== null && !zeroWidthTrigger), Sider_defineProperty(_classNames, "".concat(prefixCls, "-below"), !!this.below), Sider_defineProperty(_classNames, "".concat(prefixCls, "-zero-width"), parseFloat(siderWidth) === 0), _classNames));
    var divProps = {
      on: this.$listeners,
      "class": siderCls,
      style: divStyle
    };
    return h("div", divProps, [h("div", {
      "class": "".concat(prefixCls, "-children")
    }, [this.$slots["default"]]), collapsible || this.below && zeroWidthTrigger ? triggerDom : null]);
  }
});
// CONCATENATED MODULE: ./src/components/layout/index.js


layout_layout.Sider = Sider;
/* istanbul ignore next */

layout_layout.install = function (Vue) {
  Vue.component(layout_layout.name, layout_layout);
  Vue.component(layout_layout.Header.name, layout_layout.Header);
  Vue.component(layout_layout.Footer.name, layout_layout.Footer);
  Vue.component(layout_layout.Sider.name, layout_layout.Sider);
  Vue.component(layout_layout.Content.name, layout_layout.Content);
};

/* harmony default export */ var components_layout = (layout_layout);
// CONCATENATED MODULE: ./src/components/spin/Spin.jsx



function Spin_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Spin_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Spin_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Spin_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






var SpinSize = vue_types["a" /* default */].oneOf(['small', 'default', 'large']);
var Spin_SpinProps = function SpinProps() {
  return {
    prefixCls: vue_types["a" /* default */].string,
    spinning: vue_types["a" /* default */].bool,
    size: SpinSize,
    wrapperClassName: vue_types["a" /* default */].string,
    tip: vue_types["a" /* default */].string,
    delay: vue_types["a" /* default */].number,
    indicator: vue_types["a" /* default */].any
  };
}; // Render indicator

var defaultIndicator;
function setDefaultIndicator(content) {
  defaultIndicator = typeof content.indicator === 'function' ? content.indicator : function (h) {
    return h(content.indicator);
  };
}
/* harmony default export */ var Spin = ({
  name: 'TaSpin',
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(Spin_SpinProps(), {
    prefixCls: 'ant-spin',
    size: 'default',
    spinning: true,
    wrapperClassName: ''
  }),
  data: function data() {
    var spinning = this.spinning;
    return {
      stateSpinning: spinning,
      debounceTimeout: null,
      delayTimeout: null
    };
  },
  methods: {
    getChildren: function getChildren() {
      if (this.$slots && this.$slots["default"]) {
        return Object(props_util["c" /* filterEmpty */])(this.$slots["default"]);
      }

      return null;
    },
    renderIndicator: function renderIndicator(h, props) {
      // const h = this.$createElement
      var prefixCls = props.prefixCls;
      var dotClassName = "".concat(prefixCls, "-dot");
      var indicator = Object(props_util["g" /* getComponentFromProp */])(this, 'indicator');

      if (Array.isArray(indicator)) {
        indicator = Object(props_util["c" /* filterEmpty */])(indicator);
        indicator = indicator.length === 1 ? indicator[0] : indicator;
      }

      if (Object(props_util["s" /* isValidElement */])(indicator)) {
        return Object(vnode["a" /* cloneElement */])(indicator, {
          "class": dotClassName
        });
      }

      if (defaultIndicator && Object(props_util["s" /* isValidElement */])(defaultIndicator(h))) {
        return Object(vnode["a" /* cloneElement */])(defaultIndicator(h), {
          "class": dotClassName
        });
      }

      return h("span", {
        "class": "".concat(dotClassName, " ").concat(prefixCls, "-dot-spin")
      }, [h("i"), h("i"), h("i"), h("i")]);
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      var spinning = _this.spinning,
          delay = _this.delay;

      if (spinning && delay && !isNaN(Number(delay))) {
        _this.setState({
          stateSpinning: false
        });

        _this.delayTimeout = window.setTimeout(function () {
          return _this.setState({
            stateSpinning: spinning
          });
        }, delay);
      }
    });
  },
  beforeDestroy: function beforeDestroy() {
    if (this.debounceTimeout) {
      clearTimeout(this.debounceTimeout);
    }

    if (this.delayTimeout) {
      clearTimeout(this.delayTimeout);
    }
  },
  watch: {
    spinning: function spinning() {
      var _this2 = this;

      var delay = this.delay,
          spinning = this.spinning;

      if (this.debounceTimeout) {
        clearTimeout(this.debounceTimeout);
      }

      if (!spinning) {
        this.debounceTimeout = window.setTimeout(function () {
          return _this2.setState({
            stateSpinning: spinning
          });
        }, 200);

        if (this.delayTimeout) {
          clearTimeout(this.delayTimeout);
        }
      } else {
        if (spinning && delay && !isNaN(Number(delay))) {
          if (this.delayTimeout) {
            clearTimeout(this.delayTimeout);
          }

          this.delayTimeout = window.setTimeout(function () {
            return _this2.setState({
              stateSpinning: spinning
            });
          }, delay);
        } else {
          this.setState({
            stateSpinning: spinning
          });
        }
      }
    }
  },
  render: function render(h) {
    var _spinClassName;

    var _this$$props = this.$props,
        size = _this$$props.size,
        prefixCls = _this$$props.prefixCls,
        tip = _this$$props.tip,
        wrapperClassName = _this$$props.wrapperClassName,
        restProps = Spin_objectWithoutProperties(_this$$props, ["size", "prefixCls", "tip", "wrapperClassName"]);

    var stateSpinning = this.stateSpinning;
    var spinClassName = (_spinClassName = {}, Spin_defineProperty(_spinClassName, prefixCls, true), Spin_defineProperty(_spinClassName, "".concat(prefixCls, "-sm"), size === 'small'), Spin_defineProperty(_spinClassName, "".concat(prefixCls, "-lg"), size === 'large'), Spin_defineProperty(_spinClassName, "".concat(prefixCls, "-spinning"), stateSpinning), Spin_defineProperty(_spinClassName, "".concat(prefixCls, "-show-text"), !!tip), _spinClassName);
    var spinElement = h("div", babel_helper_vue_jsx_merge_props_default()([restProps, {
      "class": spinClassName
    }]), [this.renderIndicator(h, this.$props), tip ? h("div", {
      "class": "".concat(prefixCls, "-text")
    }, [tip]) : null]);
    var children = this.getChildren();

    if (children) {
      var _containerClassName;

      var animateClassName = prefixCls + '-nested-loading';

      if (wrapperClassName) {
        animateClassName += ' ' + wrapperClassName;
      }

      var containerClassName = (_containerClassName = {}, Spin_defineProperty(_containerClassName, "".concat(prefixCls, "-container"), true), Spin_defineProperty(_containerClassName, "".concat(prefixCls, "-blur"), stateSpinning), _containerClassName);
      return h("transition-group", babel_helper_vue_jsx_merge_props_default()([Object(getTransitionProps["a" /* default */])('fade', {
        appear: false
      }), {
        attrs: {
          tag: 'div'
        },
        "class": animateClassName
      }]), [stateSpinning && h("div", {
        key: 'loading'
      }, [spinElement]), h("div", {
        "class": containerClassName,
        key: 'container'
      }, [children])]);
    }

    return spinElement;
  }
});
// CONCATENATED MODULE: ./src/components/spin/index.js


Spin.setDefaultIndicator = setDefaultIndicator;
/* istanbul ignore next */

Spin.install = function (Vue) {
  Vue.component(Spin.name, Spin);
};

/* harmony default export */ var spin = (Spin);
// CONCATENATED MODULE: ./src/components/pagination/MiniSelect.jsx
function MiniSelect_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { MiniSelect_defineProperty(target, key, source[key]); }); } return target; }

function MiniSelect_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/* harmony default export */ var MiniSelect = ({
  props: MiniSelect_objectSpread({}, SelectProps),
  Option: components_select.Option,
  render: function render() {
    var h = arguments[0];
    var selectOptionsProps = Object(props_util["j" /* getOptionProps */])(this);
    var selelctProps = {
      props: MiniSelect_objectSpread({}, selectOptionsProps, {
        size: 'small'
      }),
      on: this.$listeners
    };
    return h(components_select, selelctProps, [Object(props_util["c" /* filterEmpty */])(this.$slots["default"])]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-pagination/locale/zh_CN.js
/* harmony default export */ var vc_pagination_locale_zh_CN = ({
  // Options.jsx
  items_per_page: '条/页',
  jump_to: '跳至',
  jump_to_confirm: '确定',
  page: '页',
  // Pagination.jsx
  prev_page: '上一页',
  next_page: '下一页',
  prev_5: '向前 5 页',
  next_5: '向后 5 页',
  prev_3: '向前 3 页',
  next_3: '向后 3 页'
});
// CONCATENATED MODULE: ./src/components/vc-pagination/Pager.jsx

/* harmony default export */ var Pager = ({
  name: 'Pager',
  props: {
    rootPrefixCls: vue_types["a" /* default */].string,
    page: vue_types["a" /* default */].number,
    active: vue_types["a" /* default */].bool,
    last: vue_types["a" /* default */].bool,
    locale: vue_types["a" /* default */].object,
    showTitle: vue_types["a" /* default */].bool,
    itemRender: {
      type: Function,
      "default": function _default() {}
    }
  },
  computed: {
    classes: function classes() {
      var prefixCls = "".concat(this.rootPrefixCls, "-item");
      var cls = "".concat(prefixCls, " ").concat(prefixCls, "-").concat(this.page);

      if (this.active) {
        cls = "".concat(cls, " ").concat(prefixCls, "-active");
      }

      return cls;
    }
  },
  methods: {
    handleClick: function handleClick() {
      this.$emit('click', this.page);
    },
    handleKeyPress: function handleKeyPress(event) {
      this.$emit('keypress', event, this.handleClick, this.page);
    }
  },
  render: function render() {
    var h = arguments[0];
    var rootPrefixCls = this.rootPrefixCls,
        page = this.page,
        active = this.active;
    var prefixCls = "".concat(rootPrefixCls, "-item");
    var cls = "".concat(prefixCls, " ").concat(prefixCls, "-").concat(page);

    if (active) {
      cls = "".concat(cls, " ").concat(prefixCls, "-active");
    }

    return h("li", {
      "class": cls,
      on: {
        "click": this.handleClick,
        "keypress": this.handleKeyPress
      },
      attrs: {
        title: this.showTitle ? this.page : null,
        tabIndex: '0'
      }
    }, [this.itemRender(this.page, 'page', h("a", [this.page]))]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-pagination/KeyCode.js
/* harmony default export */ var vc_pagination_KeyCode = ({
  ZERO: 48,
  NINE: 57,
  NUMPAD_ZERO: 96,
  NUMPAD_NINE: 105,
  BACKSPACE: 8,
  DELETE: 46,
  ENTER: 13,
  ARROW_UP: 38,
  ARROW_DOWN: 40
});
// CONCATENATED MODULE: ./src/components/vc-pagination/Options.jsx



/* harmony default export */ var Options = ({
  mixins: [BaseMixin["a" /* default */]],
  props: {
    rootPrefixCls: vue_types["a" /* default */].String,
    selectPrefixCls: vue_types["a" /* default */].String,
    changeSize: vue_types["a" /* default */].func,
    quickGo: vue_types["a" /* default */].func,
    selectComponentClass: vue_types["a" /* default */].any,
    current: vue_types["a" /* default */].number,
    pageSizeOptions: vue_types["a" /* default */].array.def(['10', '20', '30', '40']),
    pageSize: vue_types["a" /* default */].number,
    buildOptionText: vue_types["a" /* default */].func,
    locale: vue_types["a" /* default */].object,
    goButton: vue_types["a" /* default */].any
  },
  data: function data() {
    return {
      goInputText: ''
    };
  },
  methods: {
    defaultBuildOptionText: function defaultBuildOptionText(opt) {
      return "".concat(opt.value, " ").concat(this.locale.items_per_page);
    },
    handleChange: function handleChange(e) {
      this.setState({
        goInputText: e.target.value
      });
    },
    go: function go(e) {
      var val = this.goInputText;

      if (val === '') {
        return;
      }

      val = isNaN(val) ? this.current : Number(val);

      if (e.keyCode === vc_pagination_KeyCode.ENTER || e.type === 'click') {
        this.setState({
          goInputText: ''
        });
        this.quickGo(val);
      }
    }
  },
  render: function render() {
    var _this = this;

    var h = arguments[0];
    var rootPrefixCls = this.rootPrefixCls,
        locale = this.locale,
        changeSize = this.changeSize,
        quickGo = this.quickGo,
        goButton = this.goButton,
        Select = this.selectComponentClass,
        defaultBuildOptionText = this.defaultBuildOptionText;
    var prefixCls = "".concat(rootPrefixCls, "-options");
    var changeSelect = null;
    var goInput = null;
    var gotoButton = null;

    if (!(changeSize || quickGo)) {
      return null;
    }

    if (changeSize && Select) {
      var Option = Select.Option;
      var pageSize = this.pageSize || this.pageSizeOptions[0];
      var buildOptionText = this.buildOptionText || defaultBuildOptionText;
      var options = this.pageSizeOptions.map(function (opt, i) {
        return h(Option, {
          key: i,
          attrs: {
            value: opt
          }
        }, [buildOptionText({
          value: opt
        })]);
      });
      changeSelect = h(Select, {
        attrs: {
          prefixCls: this.selectPrefixCls,
          showSearch: false,
          optionLabelProp: 'children',
          dropdownMatchSelectWidth: false,
          value: pageSize.toString(),
          getPopupContainer: function getPopupContainer(triggerNode) {
            return triggerNode.parentNode;
          }
        },
        "class": "".concat(prefixCls, "-size-changer"),
        on: {
          "change": function change(value) {
            return _this.changeSize(Number(value));
          }
        }
      }, [options]);
    }

    if (quickGo) {
      if (goButton) {
        if (typeof goButton === 'boolean') {
          gotoButton = h("button", {
            attrs: {
              type: 'button'
            },
            on: {
              "click": this.go,
              "keyup": this.go
            }
          }, [locale.jump_to_confirm]);
        } else {
          gotoButton = h("span", {
            on: {
              "click": this.go,
              "keyup": this.go
            }
          }, [goButton]);
        }
      }

      goInput = h("div", {
        "class": "".concat(prefixCls, "-quick-jumper")
      }, [locale.jump_to, h("input", {
        attrs: {
          type: 'text'
        },
        domProps: {
          "value": this.goInputText
        },
        on: {
          "input": this.handleChange,
          "keyup": this.go
        }
      }), locale.page, gotoButton]);
    }

    return h("li", {
      "class": "".concat(prefixCls)
    }, [changeSelect, goInput]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-pagination/Pagination.jsx
function Pagination_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Pagination_defineProperty(target, key, source[key]); }); } return target; }

function Pagination_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









function Pagination_noop() {} // 是否是正整数


function isInteger(value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
}

function defaultItemRender(page, type, element) {
  return element;
}

/* harmony default export */ var Pagination = ({
  name: 'Pagination',
  mixins: [BaseMixin["a" /* default */]],
  props: {
    prefixCls: vue_types["a" /* default */].string.def('rc-pagination'),
    selectPrefixCls: vue_types["a" /* default */].string.def('rc-select'),
    current: vue_types["a" /* default */].number,
    defaultCurrent: vue_types["a" /* default */].number.def(1),
    total: vue_types["a" /* default */].number.def(0),
    pageSize: vue_types["a" /* default */].number,
    defaultPageSize: vue_types["a" /* default */].number.def(10),
    change: vue_types["a" /* default */].func.def(Pagination_noop),
    hideOnSinglePage: vue_types["a" /* default */].bool.def(false),
    showSizeChanger: vue_types["a" /* default */].bool.def(false),
    showLessItems: vue_types["a" /* default */].bool.def(true),
    // showSizeChange: PropTypes.func.def(noop),
    selectComponentClass: vue_types["a" /* default */].any,
    showPrevNextJumpers: vue_types["a" /* default */].bool.def(true),
    showQuickJumper: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, vue_types["a" /* default */].object]).def(false),
    showTitle: vue_types["a" /* default */].bool.def(true),
    pageSizeOptions: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
    buildOptionText: vue_types["a" /* default */].func,
    showTotal: vue_types["a" /* default */].func,
    simple: vue_types["a" /* default */].bool,
    locale: vue_types["a" /* default */].object.def(vc_pagination_locale_zh_CN),
    itemRender: vue_types["a" /* default */].func.def(defaultItemRender),
    // 后端分页添加 add by zhouhy
    dataSource: vue_types["a" /* default */].array,
    url: vue_types["a" /* default */].string,
    params: vue_types["a" /* default */].func
  },
  model: {
    prop: 'current',
    event: 'change'
  },
  data: function data() {
    var hasOnChange = this.onChange !== Pagination_noop;
    var hasCurrent = Object(props_util["p" /* hasProp */])(this, 'current');

    if (hasCurrent && !hasOnChange) {
      console.warn('Warning: You provided a `current` prop to a Pagination component without an `onChange` handler. This will render a read-only component.'); // eslint-disable-line
    }

    var current = this.defaultCurrent;

    if (hasCurrent) {
      current = this.current;
    }

    var pageSize = this.defaultPageSize;

    if (Object(props_util["p" /* hasProp */])(this, 'pageSize')) {
      pageSize = this.pageSize;
    }

    return {
      stateCurrent: current,
      stateCurrentInputValue: current,
      statePageSize: pageSize,
      totalSize: this.total ? this.total : 0
    };
  },
  watch: {
    current: function current(val) {
      this.setState({
        stateCurrent: val,
        stateCurrentInputValue: val
      });
    },
    pageSize: function pageSize(val) {
      var newState = {};
      var current = this.stateCurrent;
      var newCurrent = this.calculatePage(val);
      current = current > newCurrent ? newCurrent : current;

      if (!Object(props_util["p" /* hasProp */])(this, 'current')) {
        newState.stateCurrent = current;
        newState.stateCurrentInputValue = current;
      }

      newState.statePageSize = val;
      this.setState(newState);
    },
    stateCurrent: function stateCurrent(val, oldValue) {
      var _this = this;

      // When current page change, fix focused style of prev item
      // A hacky solution of https://github.com/ant-design/ant-design/issues/8948
      this.$nextTick(function () {
        if (_this.$refs.paginationNode) {
          var lastCurrentNode = _this.$refs.paginationNode.querySelector(".".concat(_this.prefixCls, "-item-").concat(oldValue));

          if (lastCurrentNode && document.activeElement === lastCurrentNode) {
            lastCurrentNode.blur();
          }
        }
      });
    }
  },
  methods: {
    isValid: function isValid(page) {
      return isInteger(page) && page >= 1 && page !== this.stateCurrent;
    },
    calculatePage: function calculatePage(p) {
      var pageSize = p;

      if (typeof pageSize === 'undefined') {
        pageSize = this.statePageSize;
      }

      return Math.floor((this.totalSize - 1) / pageSize) + 1;
    },
    handleGoTO: function handleGoTO(event) {
      if (event.keyCode === vc_pagination_KeyCode.ENTER || event.type === 'click') {
        this.handleChange(this.stateCurrentInputValue);
      }
    },
    prev: function prev() {
      if (this.hasPrev()) {
        this.handleChange(this.stateCurrent - 1);
      }
    },
    next: function next() {
      if (this.hasNext()) {
        this.handleChange(this.stateCurrent + 1);
      }
    },
    hasPrev: function hasPrev() {
      return this.stateCurrent > 1;
    },
    hasNext: function hasNext() {
      return this.stateCurrent < this.calculatePage();
    },
    handleKeyDown: function handleKeyDown(event) {
      if (event.keyCode === vc_pagination_KeyCode.ARROW_UP || event.keyCode === vc_pagination_KeyCode.ARROW_DOWN) {
        event.preventDefault();
      }
    },
    handleKeyUp: function handleKeyUp(event) {
      var inputValue = event.target.value;
      var stateCurrentInputValue = this.stateCurrentInputValue;
      var value;

      if (inputValue === '') {
        value = inputValue;
      } else if (isNaN(Number(inputValue))) {
        value = stateCurrentInputValue;
      } else {
        value = Number(inputValue);
      }

      if (value !== stateCurrentInputValue) {
        this.setState({
          stateCurrentInputValue: value
        });
      }

      if (event.keyCode === vc_pagination_KeyCode.ENTER) {
        this.handleChange(value);
      } else if (event.keyCode === vc_pagination_KeyCode.ARROW_UP) {
        this.handleChange(value - 1);
      } else if (event.keyCode === vc_pagination_KeyCode.ARROW_DOWN) {
        this.handleChange(value + 1);
      }
    },
    changePageSize: function changePageSize(size) {
      var current = this.stateCurrent;
      var newCurrent = this.calculatePage(size);
      current = current > newCurrent ? newCurrent : current; // fix the issue:
      // Once 'total' is 0, 'current' in 'onShowSizeChange' is 0, which is not correct.

      if (newCurrent === 0) {
        current = this.stateCurrent;
      }

      if (typeof size === 'number') {
        if (!Object(props_util["p" /* hasProp */])(this, 'pageSize')) {
          this.setState({
            statePageSize: size
          });
        }

        if (!Object(props_util["p" /* hasProp */])(this, 'current')) {
          this.setState({
            stateCurrent: 1,
            stateCurrentInputValue: 1
          });
        }
      }

      this.$emit('update:pageSize', size);
      this.$emit('showSizeChange', 1, size);
      this.$emit('change', 1, size); // 执行后端分页

      if (this.url) {
        this.axiosForPage(1, size);
      }
    },
    handleChange: function handleChange(p) {
      var page = p;

      if (this.isValid(page)) {
        var allTotal = this.calculatePage();

        if (page > allTotal) {
          page = allTotal;
        }

        if (!Object(props_util["p" /* hasProp */])(this, 'current')) {
          this.setState({
            stateCurrent: page,
            stateCurrentInputValue: page
          });
        } // this.$emit('input', page)


        this.$emit('change', page, this.statePageSize); // 执行后端分页

        if (this.url) {
          this.axiosForPage(page, this.statePageSize);
        }

        return page;
      }

      return this.stateCurrent;
    },
    // add by zhouhy  支持后端分页
    axiosForPage: function axiosForPage(pageNumber, pageSize, callFun, isLoadData) {
      var _this2 = this;

      //如果分页条上分信息存在
      if (this.statePageSize) {
        pageSize = this.statePageSize;
      }

      var submitParameter = {
        url: this.url,
        data: Pagination_objectSpread({
          pageNumber: pageNumber,
          pageSize: pageSize
        }, this.params())
      };
      var callBack = {
        successCallback: function successCallback(data) {
          if (!data.errors) {
            if (isLoadData) {
              _this2.setState({
                stateCurrent: 1,
                stateCurrentInputValue: 1
              });
            }

            if (data.data.pageBean.total >= 0) {
              _this2.totalSize = data.data.pageBean.total;
            }

            _this2.$emit('update:dataSource', data.data.pageBean.list);
          } // 提供回调函数


          if (callFun) {
            callFun(data);
          }
        }
      };
      this.Base.submit(null, submitParameter, callBack);
    },
    runIfEnter: function runIfEnter(event, callback) {
      if (event.key === 'Enter' || event.charCode === 13) {
        for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          restParams[_key - 2] = arguments[_key];
        }

        callback.apply(void 0, restParams);
      }
    },
    runIfEnterPrev: function runIfEnterPrev(event) {
      this.runIfEnter(event, this.prev);
    },
    runIfEnterNext: function runIfEnterNext(event) {
      this.runIfEnter(event, this.next);
    },
    runIfEnterJumpPrev: function runIfEnterJumpPrev(event) {
      this.runIfEnter(event, this.jumpPrev);
    },
    runIfEnterJumpNext: function runIfEnterJumpNext(event) {
      this.runIfEnter(event, this.jumpNext);
    },
    getJumpPrevPage: function getJumpPrevPage() {
      return Math.max(1, this.stateCurrent - (this.showLessItems ? 3 : 5));
    },
    getJumpNextPage: function getJumpNextPage() {
      return Math.min(this.calculatePage(), this.stateCurrent + (this.showLessItems ? 3 : 5));
    },
    jumpPrev: function jumpPrev() {
      this.handleChange(this.getJumpPrevPage());
    },
    jumpNext: function jumpNext() {
      this.handleChange(this.getJumpNextPage());
    }
  },
  render: function render() {
    var h = arguments[0];

    // When hideOnSinglePage is true and there is only 1 page, hide the pager
    if (this.hideOnSinglePage === true && this.totalSize <= this.statePageSize) {
      return null;
    }

    var locale = this.locale;
    var prefixCls = this.prefixCls;
    var allPages = this.calculatePage();
    var pagerList = [];
    var jumpPrev = null;
    var jumpNext = null;
    var firstPager = null;
    var lastPager = null;
    var gotoButton = null;
    var goButton = this.showQuickJumper && this.showQuickJumper.goButton;
    var pageBufferSize = this.showLessItems ? 1 : 2;
    var stateCurrent = this.stateCurrent,
        statePageSize = this.statePageSize;
    var prevPage = stateCurrent - 1 > 0 ? stateCurrent - 1 : 0;
    var nextPage = stateCurrent + 1 < allPages ? stateCurrent + 1 : allPages;

    if (this.simple) {
      if (goButton) {
        if (typeof goButton === 'boolean') {
          gotoButton = h("button", {
            attrs: {
              type: 'button'
            },
            on: {
              "click": this.handleGoTO,
              "keyup": this.handleGoTO
            }
          }, [locale.jump_to_confirm]);
        } else {
          gotoButton = h("span", {
            on: {
              "click": this.handleGoTO,
              "keyup": this.handleGoTO
            }
          }, [goButton]);
        }

        gotoButton = h("li", {
          attrs: {
            title: this.showTitle ? "".concat(locale.jump_to).concat(this.stateCurrent, "/").concat(allPages) : null
          },
          "class": "".concat(prefixCls, "-simple-pager")
        }, [gotoButton]);
      }

      var hasPrev = this.hasPrev();
      var hasNext = this.hasNext();
      return h("ul", {
        "class": "".concat(prefixCls, " ").concat(prefixCls, "-simple")
      }, [h("li", {
        attrs: {
          title: this.showTitle ? locale.prev_page : null,
          tabIndex: hasPrev ? 0 : null,
          "aria-disabled": !this.hasPrev()
        },
        on: {
          "click": this.prev,
          "keypress": this.runIfEnterPrev
        },
        "class": "".concat(hasPrev ? '' : "".concat(prefixCls, "-disabled"), " ").concat(prefixCls, "-prev")
      }, [this.itemRender(prevPage, 'prev', h("a", {
        "class": "".concat(prefixCls, "-item-link")
      }))]), h("li", {
        attrs: {
          title: this.showTitle ? "".concat(stateCurrent, "/").concat(allPages) : null
        },
        "class": "".concat(prefixCls, "-simple-pager")
      }, [h("input", {
        attrs: {
          type: 'text',
          size: '3'
        },
        domProps: {
          "value": this.stateCurrentInputValue
        },
        on: {
          "keydown": this.handleKeyDown,
          "keyup": this.handleKeyUp,
          "input": this.handleKeyUp
        }
      }), h("span", {
        "class": "".concat(prefixCls, "-slash")
      }, ["\uFF0F"]), allPages]), h("li", {
        attrs: {
          title: this.showTitle ? locale.next_page : null,
          tabIndex: this.hasNext ? 0 : null,
          "aria-disabled": !this.hasNext()
        },
        on: {
          "click": this.next,
          "keypress": this.runIfEnterNext
        },
        "class": "".concat(hasNext ? '' : "".concat(prefixCls, "-disabled"), " ").concat(prefixCls, "-next")
      }, [this.itemRender(nextPage, 'next', h("a", {
        "class": "".concat(prefixCls, "-item-link")
      }))]), gotoButton]);
    }

    if (allPages <= 5 + pageBufferSize * 2) {
      for (var i = 1; i <= allPages; i++) {
        var active = stateCurrent === i;
        pagerList.push(h(Pager, {
          attrs: {
            locale: locale,
            rootPrefixCls: prefixCls,
            page: i,
            active: active,
            showTitle: this.showTitle,
            itemRender: this.itemRender
          },
          on: {
            "click": this.handleChange,
            "keypress": this.runIfEnter
          },
          key: i
        }));
      }
    } else {
      var prevItemTitle = this.showLessItems ? locale.prev_3 : locale.prev_5;
      var nextItemTitle = this.showLessItems ? locale.next_3 : locale.next_5;

      if (this.showPrevNextJumpers) {
        jumpPrev = h("li", {
          attrs: {
            title: this.showTitle ? prevItemTitle : null,
            tabIndex: '0'
          },
          key: 'prev',
          on: {
            "click": this.jumpPrev,
            "keypress": this.runIfEnterJumpPrev
          },
          "class": "".concat(prefixCls, "-jump-prev")
        }, [this.itemRender(this.getJumpPrevPage(), 'jump-prev', h("a", {
          "class": "".concat(prefixCls, "-item-link")
        }))]);
        jumpNext = h("li", {
          attrs: {
            title: this.showTitle ? nextItemTitle : null,
            tabIndex: '0'
          },
          key: 'next',
          on: {
            "click": this.jumpNext,
            "keypress": this.runIfEnterJumpNext
          },
          "class": "".concat(prefixCls, "-jump-next")
        }, [this.itemRender(this.getJumpNextPage(), 'jump-next', h("a", {
          "class": "".concat(prefixCls, "-item-link")
        }))]);
      }

      lastPager = h(Pager, {
        attrs: {
          locale: locale,
          last: true,
          rootPrefixCls: prefixCls,
          page: allPages,
          active: false,
          showTitle: this.showTitle,
          itemRender: this.itemRender
        },
        on: {
          "click": this.handleChange,
          "keypress": this.runIfEnter
        },
        key: allPages
      });
      firstPager = h(Pager, {
        attrs: {
          locale: locale,
          rootPrefixCls: prefixCls,
          page: 1,
          active: false,
          showTitle: this.showTitle,
          itemRender: this.itemRender
        },
        on: {
          "click": this.handleChange,
          "keypress": this.runIfEnter
        },
        key: 1
      });
      var left = Math.max(1, stateCurrent - pageBufferSize);
      var right = Math.min(stateCurrent + pageBufferSize, allPages);

      if (stateCurrent - 1 <= pageBufferSize) {
        right = 1 + pageBufferSize * 2;
      }

      if (allPages - stateCurrent <= pageBufferSize) {
        left = allPages - pageBufferSize * 2;
      }

      for (var _i = left; _i <= right; _i++) {
        var _active = stateCurrent === _i;

        pagerList.push(h(Pager, {
          attrs: {
            locale: locale,
            rootPrefixCls: prefixCls,
            page: _i,
            active: _active,
            showTitle: this.showTitle,
            itemRender: this.itemRender
          },
          on: {
            "click": this.handleChange,
            "keypress": this.runIfEnter
          },
          key: _i
        }));
      }

      if (stateCurrent - 1 >= pageBufferSize * 2 && stateCurrent !== 1 + 2) {
        pagerList[0] = h(Pager, {
          attrs: {
            locale: locale,
            rootPrefixCls: prefixCls,
            page: left,
            active: false,
            showTitle: this.showTitle,
            itemRender: this.itemRender
          },
          on: {
            "click": this.handleChange,
            "keypress": this.runIfEnter
          },
          key: left,
          "class": "".concat(prefixCls, "-item-after-jump-prev")
        });
        pagerList.unshift(jumpPrev);
      }

      if (allPages - stateCurrent >= pageBufferSize * 2 && stateCurrent !== allPages - 2) {
        pagerList[pagerList.length - 1] = h(Pager, {
          attrs: {
            locale: locale,
            rootPrefixCls: prefixCls,
            page: right,
            active: false,
            showTitle: this.showTitle,
            itemRender: this.itemRender
          },
          on: {
            "click": this.handleChange,
            "keypress": this.runIfEnter
          },
          key: right,
          "class": "".concat(prefixCls, "-item-before-jump-next")
        });
        pagerList.push(jumpNext);
      }

      if (left !== 1) {
        pagerList.unshift(firstPager);
      }

      if (right !== allPages) {
        pagerList.push(lastPager);
      }
    }

    var totalStr = this.url ? this.totalSize : this.total;
    var totalText = "总数：" + totalStr + "条";

    if (this.showTotal) {
      totalText = h("li", {
        "class": "".concat(prefixCls, "-total-text")
      }, [this.showTotal(this.totalSize, [(stateCurrent - 1) * statePageSize + 1, stateCurrent * statePageSize > this.totalSize ? this.totalSize : stateCurrent * statePageSize])]);
    }

    var prevDisabled = !this.hasPrev();
    var nextDisabled = !this.hasNext();
    var buildOptionText = this.buildOptionText || this.$scopedSlots.buildOptionText;
    return h("ul", {
      "class": "".concat(prefixCls),
      attrs: {
        unselectable: 'unselectable'
      },
      ref: 'paginationNode'
    }, [totalText, "\xA0\xA0", h("li", {
      attrs: {
        title: this.showTitle ? locale.prev_page : null,
        tabIndex: prevDisabled ? null : 0,
        "aria-disabled": prevDisabled
      },
      on: {
        "click": this.prev,
        "keypress": this.runIfEnterPrev
      },
      "class": "".concat(!prevDisabled ? '' : "".concat(prefixCls, "-disabled"), " ").concat(prefixCls, "-prev")
    }, [this.itemRender(prevPage, 'prev', h("a", {
      "class": "".concat(prefixCls, "-item-link")
    }))]), pagerList, h("li", {
      attrs: {
        title: this.showTitle ? locale.next_page : null,
        tabIndex: nextDisabled ? null : 0,
        "aria-disabled": nextDisabled
      },
      on: {
        "click": this.next,
        "keypress": this.runIfEnterNext
      },
      "class": "".concat(!nextDisabled ? '' : "".concat(prefixCls, "-disabled"), " ").concat(prefixCls, "-next")
    }, [this.itemRender(nextPage, 'next', h("a", {
      "class": "".concat(prefixCls, "-item-link")
    }))]), h(Options, {
      attrs: {
        locale: locale,
        rootPrefixCls: prefixCls,
        selectComponentClass: this.selectComponentClass,
        selectPrefixCls: this.selectPrefixCls,
        changeSize: this.showSizeChanger ? this.changePageSize : null,
        current: stateCurrent,
        pageSize: statePageSize,
        pageSizeOptions: this.pageSizeOptions,
        buildOptionText: buildOptionText || null,
        quickGo: this.showQuickJumper ? this.handleChange : null,
        goButton: goButton
      }
    })]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-pagination/index.js
// based on rc-pagination 1.16.5

// CONCATENATED MODULE: ./src/components/pagination/Pagination.jsx


function Pagination_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Pagination_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Pagination_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function pagination_Pagination_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { pagination_Pagination_defineProperty(target, key, source[key]); }); } return target; }

function pagination_Pagination_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var Pagination_PaginationProps = function PaginationProps() {
  return {
    total: vue_types["a" /* default */].number,
    defaultCurrent: vue_types["a" /* default */].number,
    current: vue_types["a" /* default */].number,
    defaultPageSize: vue_types["a" /* default */].number,
    pageSize: vue_types["a" /* default */].number,
    hideOnSinglePage: vue_types["a" /* default */].bool,
    showSizeChanger: vue_types["a" /* default */].bool,
    pageSizeOptions: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string])),
    buildOptionText: vue_types["a" /* default */].func,
    showSizeChange: vue_types["a" /* default */].func,
    showQuickJumper: vue_types["a" /* default */].bool,
    showTotal: vue_types["a" /* default */].any,
    size: vue_types["a" /* default */].string,
    simple: vue_types["a" /* default */].bool,
    locale: vue_types["a" /* default */].object,
    prefixCls: vue_types["a" /* default */].string,
    selectPrefixCls: vue_types["a" /* default */].string,
    itemRender: vue_types["a" /* default */].any,
    role: vue_types["a" /* default */].string,
    // 添加后端分页 add by zhouhy
    dataSource: vue_types["a" /* default */].array,
    url: vue_types["a" /* default */].string,
    params: vue_types["a" /* default */].func
  };
};
var Pagination_PaginationConfig = function PaginationConfig() {
  return pagination_Pagination_objectSpread({}, Pagination_PaginationProps(), {
    position: vue_types["a" /* default */].oneOf(['top', 'bottom', 'both'])
  });
};
/* harmony default export */ var pagination_Pagination = ({
  name: 'TaPagination',
  props: pagination_Pagination_objectSpread({}, Pagination_PaginationProps(), {
    prefixCls: vue_types["a" /* default */].string.def('ant-pagination'),
    selectPrefixCls: vue_types["a" /* default */].string.def('ant-select')
  }),
  model: {
    prop: 'current',
    event: 'change'
  },
  methods: {
    renderPagination: function renderPagination(contextLocale) {
      var h = this.$createElement;

      var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
          buildOptionText = _getOptionProps.buildOptionText,
          size = _getOptionProps.size,
          customLocale = _getOptionProps.locale,
          restProps = Pagination_objectWithoutProperties(_getOptionProps, ["buildOptionText", "size", "locale"]);

      var isSmall = size === 'small';
      var paginationProps = {
        props: pagination_Pagination_objectSpread({}, restProps, {
          selectComponentClass: isSmall ? MiniSelect : components_select,
          locale: pagination_Pagination_objectSpread({}, contextLocale, customLocale),
          buildOptionText: buildOptionText || this.$scopedSlots.buildOptionText
        }),
        "class": {
          'mini': isSmall
        },
        on: this.$listeners
      };
      return h(Pagination, babel_helper_vue_jsx_merge_props_default()([paginationProps, {
        ref: "vcPage"
      }]));
    },
    // 支持父组件调用分页条查询
    loadData: function loadData(callBack) {
      this.$refs.vcPage.axiosForPage(1, this.defaultPageSize, callBack, true);
    }
  },
  render: function render() {
    var h = arguments[0];
    return h(LocaleReceiver, {
      attrs: {
        componentName: 'Pagination',
        defaultLocale: vc_pagination_locale_zh_CN
      },
      scopedSlots: {
        "default": this.renderPagination
      }
    });
  }
});
// CONCATENATED MODULE: ./src/components/pagination/index.js


/* istanbul ignore next */

pagination_Pagination.install = function (Vue) {
  Vue.component(pagination_Pagination.name, pagination_Pagination);
};

/* harmony default export */ var components_pagination = (pagination_Pagination);
// CONCATENATED MODULE: ./src/components/list/Item.jsx




function Item_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var ListItemProps = {
  prefixCls: vue_types["a" /* default */].string,
  extra: vue_types["a" /* default */].any,
  actions: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].any),
  grid: ListGridType
};
var ListItemMetaProps = {
  avatar: vue_types["a" /* default */].any,
  description: vue_types["a" /* default */].any,
  prefixCls: vue_types["a" /* default */].string,
  title: vue_types["a" /* default */].any
};
var Item_Meta = {
  functional: true,
  name: 'TaListItemMeta',
  __ANT_LIST_ITEM_META: true,
  render: function render(h, context) {
    var props = context.props,
        slots = context.slots,
        listeners = context.listeners;
    var slotsMap = slots();
    var _props$prefixCls = props.prefixCls,
        prefixCls = _props$prefixCls === void 0 ? 'ant-list' : _props$prefixCls;
    var avatar = props.avatar || slotsMap.avatar;
    var title = props.title || slotsMap.title;
    var description = props.description || slotsMap.description;
    var content = h("div", {
      "class": "".concat(prefixCls, "-item-meta-content")
    }, [title && h("h4", {
      "class": "".concat(prefixCls, "-item-meta-title")
    }, [title]), description && h("div", {
      "class": "".concat(prefixCls, "-item-meta-description")
    }, [description])]);
    return h("div", babel_helper_vue_jsx_merge_props_default()([{
      on: listeners
    }, {
      "class": "".concat(prefixCls, "-item-meta")
    }]), [avatar && h("div", {
      "class": "".concat(prefixCls, "-item-meta-avatar")
    }, [avatar]), (title || description) && content]);
  }
};

function getGrid(grid, t) {
  return grid[t] && Math.floor(24 / grid[t]);
}

/* harmony default export */ var Item = ({
  name: 'TaListItem',
  Meta: Item_Meta,
  props: ListItemProps,
  inject: {
    listContext: {
      "default": {}
    }
  },
  render: function render() {
    var h = arguments[0];
    var grid = this.listContext.grid;
    var _this$prefixCls = this.prefixCls,
        prefixCls = _this$prefixCls === void 0 ? 'ant-list' : _this$prefixCls,
        $slots = this.$slots,
        $listeners = this.$listeners;
    var classString = "".concat(prefixCls, "-item");
    var extra = Object(props_util["g" /* getComponentFromProp */])(this, 'extra');
    var actions = Object(props_util["g" /* getComponentFromProp */])(this, 'actions');
    var metaContent = [];
    var otherContent = [];
    ($slots["default"] || []).forEach(function (element) {
      if (!Object(props_util["r" /* isEmptyElement */])(element)) {
        if (Object(props_util["l" /* getSlotOptions */])(element).__ANT_LIST_ITEM_META) {
          metaContent.push(element);
        } else {
          otherContent.push(element);
        }
      }
    });
    var contentClassString = classnames_default()("".concat(prefixCls, "-item-content"), Item_defineProperty({}, "".concat(prefixCls, "-item-content-single"), metaContent.length < 1));
    var content = otherContent.length > 0 ? h("div", {
      "class": contentClassString
    }, [otherContent]) : null;
    var actionsContent;

    if (actions && actions.length > 0) {
      var actionsContentItem = function actionsContentItem(action, i) {
        return h("li", {
          key: "".concat(prefixCls, "-item-action-").concat(i)
        }, [action, i !== actions.length - 1 && h("em", {
          "class": "".concat(prefixCls, "-item-action-split")
        })]);
      };

      actionsContent = h("ul", {
        "class": "".concat(prefixCls, "-item-action")
      }, [actions.map(function (action, i) {
        return actionsContentItem(action, i);
      })]);
    }

    var extraContent = h("div", {
      "class": "".concat(prefixCls, "-item-extra-wrap")
    }, [h("div", {
      "class": "".concat(prefixCls, "-item-main")
    }, [metaContent, content, actionsContent]), h("div", {
      "class": "".concat(prefixCls, "-item-extra")
    }, [extra])]);
    var mainContent = grid ? h(Col, {
      attrs: {
        span: getGrid(grid, 'column'),
        xs: getGrid(grid, 'xs'),
        sm: getGrid(grid, 'sm'),
        md: getGrid(grid, 'md'),
        lg: getGrid(grid, 'lg'),
        xl: getGrid(grid, 'xl'),
        xxl: getGrid(grid, 'xxl')
      }
    }, [h("div", babel_helper_vue_jsx_merge_props_default()([{
      on: $listeners
    }, {
      "class": classString
    }]), [extra && extraContent, !extra && metaContent, !extra && content, !extra && actionsContent])]) : h("div", babel_helper_vue_jsx_merge_props_default()([{
      on: $listeners
    }, {
      "class": classString
    }]), [extra && extraContent, !extra && metaContent, !extra && content, !extra && actionsContent]);
    return mainContent;
  }
});
// CONCATENATED MODULE: ./src/components/list/index.jsx


function list_toConsumableArray(arr) { return list_arrayWithoutHoles(arr) || list_iterableToArray(arr) || list_nonIterableSpread(); }

function list_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function list_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function list_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function list_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = list_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function list_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function list_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { list_defineProperty(target, key, source[key]); }); } return target; }

function list_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













var ColumnCount = ['', 1, 2, 3, 4, 6, 8, 12, 24];
var ColumnType = ['gutter', 'column', 'xs', 'sm', 'md', 'lg', 'xl', 'xxl'];
var ListGridType = {
  gutter: vue_types["a" /* default */].number,
  column: vue_types["a" /* default */].oneOf(ColumnCount),
  xs: vue_types["a" /* default */].oneOf(ColumnCount),
  sm: vue_types["a" /* default */].oneOf(ColumnCount),
  md: vue_types["a" /* default */].oneOf(ColumnCount),
  lg: vue_types["a" /* default */].oneOf(ColumnCount),
  xl: vue_types["a" /* default */].oneOf(ColumnCount),
  xxl: vue_types["a" /* default */].oneOf(ColumnCount)
};
var ListSize = ['small', 'default', 'large'];
var list_ListProps = function ListProps() {
  return {
    bordered: vue_types["a" /* default */].bool,
    dataSource: vue_types["a" /* default */].any,
    extra: vue_types["a" /* default */].any,
    grid: vue_types["a" /* default */].shape(ListGridType).loose,
    itemLayout: vue_types["a" /* default */].string,
    loading: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, vue_types["a" /* default */].object]),
    loadMore: vue_types["a" /* default */].any,
    pagination: Pagination_PaginationConfig(),
    prefixCls: vue_types["a" /* default */].string,
    rowKey: vue_types["a" /* default */].any,
    renderItem: vue_types["a" /* default */].any,
    size: vue_types["a" /* default */].oneOf(ListSize),
    split: vue_types["a" /* default */].bool,
    header: vue_types["a" /* default */].any,
    footer: vue_types["a" /* default */].any,
    locale: vue_types["a" /* default */].object
  };
};
var List = {
  Item: Item,
  name: 'TaList',
  props: Object(props_util["q" /* initDefaultProps */])(list_ListProps(), {
    dataSource: [],
    prefixCls: 'ant-list',
    bordered: false,
    split: true,
    loading: false,
    pagination: false
  }),
  provide: function provide() {
    return {
      listContext: this
    };
  },
  data: function data() {
    var _this = this;

    this.keys = [];
    this.defaultPaginationProps = {
      current: 1,
      pageSize: 10,
      onChange: function onChange(page, pageSize) {
        var pagination = _this.pagination;
        _this.paginationCurrent = page;

        if (pagination && pagination.onChange) {
          pagination.onChange(page, pageSize);
        }
      },
      total: 0
    };
    return {
      paginationCurrent: 1
    };
  },
  methods: {
    renderItem2: function renderItem2(item, index) {
      var dataSource = this.dataSource,
          $scopedSlots = this.$scopedSlots,
          rowKey = this.rowKey;
      var key;
      var renderItem = this.renderItem || $scopedSlots.renderItem;

      if (typeof rowKey === 'function') {
        key = rowKey(dataSource[index]);
      } else if (typeof rowKey === 'string') {
        key = dataSource[rowKey];
      } else {
        key = dataSource.key;
      }

      if (!key) {
        key = "list-item-".concat(index);
      }

      this.keys[index] = key;
      return renderItem(item, index);
    },
    isSomethingAfterLastItem: function isSomethingAfterLastItem() {
      var pagination = this.pagination;
      var loadMore = Object(props_util["g" /* getComponentFromProp */])(this, 'loadMore');
      var footer = Object(props_util["g" /* getComponentFromProp */])(this, 'footer');
      return !!(loadMore || pagination || footer);
    },
    renderEmpty: function renderEmpty(contextLocale) {
      var h = this.$createElement;

      var locale = list_objectSpread({}, contextLocale, this.locale);

      return h("div", {
        "class": "".concat(this.prefixCls, "-empty-text")
      }, [locale.emptyText]);
    }
  },
  render: function render() {
    var _classNames,
        _this2 = this;

    var h = arguments[0];
    var bordered = this.bordered,
        split = this.split,
        itemLayout = this.itemLayout,
        pagination = this.pagination,
        prefixCls = this.prefixCls,
        grid = this.grid,
        dataSource = this.dataSource,
        size = this.size,
        loading = this.loading,
        $listeners = this.$listeners,
        $slots = this.$slots,
        paginationCurrent = this.paginationCurrent;
    var loadMore = Object(props_util["g" /* getComponentFromProp */])(this, 'loadMore');
    var footer = Object(props_util["g" /* getComponentFromProp */])(this, 'footer');
    var header = Object(props_util["g" /* getComponentFromProp */])(this, 'header');
    var children = Object(props_util["c" /* filterEmpty */])($slots["default"] || []);
    var loadingProp = loading;

    if (typeof loadingProp === 'boolean') {
      loadingProp = {
        spinning: loadingProp
      };
    }

    var isLoading = loadingProp && loadingProp.spinning; // large => lg
    // small => sm

    var sizeCls = '';

    switch (size) {
      case 'large':
        sizeCls = 'lg';
        break;

      case 'small':
        sizeCls = 'sm';
        break;

      default:
        break;
    }

    var classString = classnames_default()(prefixCls, (_classNames = {}, list_defineProperty(_classNames, "".concat(prefixCls, "-vertical"), itemLayout === 'vertical'), list_defineProperty(_classNames, "".concat(prefixCls, "-").concat(sizeCls), sizeCls), list_defineProperty(_classNames, "".concat(prefixCls, "-split"), split), list_defineProperty(_classNames, "".concat(prefixCls, "-bordered"), bordered), list_defineProperty(_classNames, "".concat(prefixCls, "-loading"), isLoading), list_defineProperty(_classNames, "".concat(prefixCls, "-grid"), grid), list_defineProperty(_classNames, "".concat(prefixCls, "-something-after-last-item"), this.isSomethingAfterLastItem()), _classNames));

    var paginationProps = list_objectSpread({}, this.defaultPaginationProps, {
      total: dataSource.length,
      current: paginationCurrent
    }, pagination || {});

    var largestPage = Math.ceil(paginationProps.total / paginationProps.pageSize);

    if (paginationProps.current > largestPage) {
      paginationProps.current = largestPage;
    }

    var cls = paginationProps["class"],
        style = paginationProps.style,
        _paginationProps$onSh = paginationProps.onShowSizeChange,
        onShowSizeChange = _paginationProps$onSh === void 0 ? function () {} : _paginationProps$onSh,
        restProps = list_objectWithoutProperties(paginationProps, ["class", "style", "onShowSizeChange"]);

    var paginationContent = pagination ? h("div", {
      "class": "".concat(prefixCls, "-pagination")
    }, [h(components_pagination, {
      props: Object(es["a" /* default */])(restProps, ['onChange']),
      "class": cls,
      style: style,
      on: {
        change: this.defaultPaginationProps.onChange,
        showSizeChange: onShowSizeChange
      }
    })]) : null;

    var splitDataSource = list_toConsumableArray(dataSource);

    if (pagination) {
      if (dataSource.length > (paginationProps.current - 1) * paginationProps.pageSize) {
        splitDataSource = list_toConsumableArray(dataSource).splice((paginationProps.current - 1) * paginationProps.pageSize, paginationProps.pageSize);
      }
    }

    var childrenContent;
    childrenContent = isLoading && h("div", {
      style: {
        minHeight: 53
      }
    });

    if (splitDataSource.length > 0) {
      var items = splitDataSource.map(function (item, index) {
        return _this2.renderItem2(item, index);
      });
      var childrenList = items.map(function (child, index) {
        return Object(vnode["a" /* cloneElement */])(child, {
          key: _this2.keys[index]
        });
      });
      childrenContent = grid ? h(Row, {
        attrs: {
          gutter: grid.gutter
        }
      }, [childrenList]) : childrenList;
    } else if (!children.length && !isLoading) {
      childrenContent = h(LocaleReceiver, {
        attrs: {
          componentName: 'Table',
          defaultLocale: locale_provider_default.Table
        },
        scopedSlots: {
          "default": this.renderEmpty
        }
      });
    }

    var paginationPosition = paginationProps.position || 'bottom';
    return h("div", babel_helper_vue_jsx_merge_props_default()([{
      "class": classString
    }, {
      on: $listeners
    }]), [(paginationPosition === 'top' || paginationPosition === 'both') && paginationContent, header && h("div", {
      "class": "".concat(prefixCls, "-header")
    }, [header]), h(spin, {
      props: loadingProp
    }, [childrenContent, children]), footer && h("div", {
      "class": "".concat(prefixCls, "-footer")
    }, [footer]), loadMore || (paginationPosition === 'bottom' || paginationPosition === 'both') && paginationContent]);
  }
};
/* istanbul ignore next */

List.install = function (Vue) {
  Vue.component(List.name, List);
  Vue.component(List.Item.name, List.Item);
  Vue.component(List.Item.Meta.name, List.Item.Meta);
};

/* harmony default export */ var components_list = (List);
// CONCATENATED MODULE: ./src/components/modal/locale.js
function locale_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      locale_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function locale_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

 // export interface ModalLocale {
//   okText: string;
//   cancelText: string;
//   justOkText: string;
// }

var locale_runtimeLocale = locale_objectSpread({}, locale_provider_default.Modal);

function changeConfirmLocale(newLocale) {
  if (newLocale) {
    locale_runtimeLocale = locale_objectSpread({}, locale_runtimeLocale, newLocale);
  } else {
    locale_runtimeLocale = locale_objectSpread({}, locale_provider_default.Modal);
  }
}
function getConfirmLocale() {
  return locale_runtimeLocale;
}
// CONCATENATED MODULE: ./src/components/locale-provider/index.jsx
function locale_provider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { locale_provider_defineProperty(target, key, source[key]); }); } return target; }

function locale_provider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




 // export interface Locale {
//   locale: string;
//   Pagination?: Object;
//   DatePicker?: Object;
//   TimePicker?: Object;
//   Calendar?: Object;
//   Table?: Object;
//   Modal?: ModalLocale;
//   Popconfirm?: Object;
//   Transfer?: Object;
//   Select?: Object;
//   Upload?: Object;
// }

function setMomentLocale(locale) {
  if (locale && locale.locale) {
    interopDefault(external_moment_).locale(locale.locale);
  } else {
    interopDefault(external_moment_).locale('en');
  }
}

var LocaleProvider = {
  name: 'TaLocaleProvider',
  props: {
    locale: vue_types["a" /* default */].object.def({})
  },
  data: function data() {
    return {
      antLocale: locale_provider_objectSpread({}, this.locale, {
        exist: true
      })
    };
  },
  provide: function provide() {
    return {
      localeData: this.$data
    };
  },
  watch: {
    locale: function locale(val) {
      this.antLocale = locale_provider_objectSpread({}, this.locale, {
        exist: true
      });
      setMomentLocale(val);
    }
  },
  created: function created() {
    var locale = this.locale;
    setMomentLocale(locale);
    changeConfirmLocale(locale && locale.Modal);
  },
  updated: function updated() {
    var locale = this.locale;
    changeConfirmLocale(locale && locale.Modal);
  },
  beforeDestroy: function beforeDestroy() {
    changeConfirmLocale();
  },
  render: function render() {
    return this.$slots["default"] ? this.$slots["default"][0] : null;
  }
};
/* istanbul ignore next */

LocaleProvider.install = function (Vue) {
  Vue.component(LocaleProvider.name, LocaleProvider);
};

/* harmony default export */ var locale_provider = (LocaleProvider);
// CONCATENATED MODULE: ./src/components/vc-notification/Notice.jsx
function Notice_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/* harmony default export */ var Notice = ({
  mixins: [BaseMixin["a" /* default */]],
  props: {
    duration: vue_types["a" /* default */].number.def(1.5),
    closable: vue_types["a" /* default */].bool,
    prefixCls: vue_types["a" /* default */].string,
    update: vue_types["a" /* default */].bool
  },
  mounted: function mounted() {
    this.startCloseTimer();
  },
  updated: function updated() {
    if (this.update) {
      this.restartCloseTimer();
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.clearCloseTimer();
    this.willDestroy = true; // beforeDestroy调用后依然会触发onMouseleave事件
  },
  watch: {
    duration: function duration() {
      this.restartCloseTimer();
    }
  },
  methods: {
    close: function close() {
      this.clearCloseTimer();

      this.__emit('close');
    },
    startCloseTimer: function startCloseTimer() {
      var _this = this;

      this.clearCloseTimer();

      if (!this.willDestroy && this.duration) {
        this.closeTimer = setTimeout(function () {
          _this.close();
        }, this.duration * 1000);
      }
    },
    clearCloseTimer: function clearCloseTimer() {
      if (this.closeTimer) {
        clearTimeout(this.closeTimer);
        this.closeTimer = null;
      }
    },
    restartCloseTimer: function restartCloseTimer() {
      this.clearCloseTimer();
      this.startCloseTimer();
    }
  },
  render: function render() {
    var _className;

    var h = arguments[0];
    var prefixCls = this.prefixCls,
        closable = this.closable,
        clearCloseTimer = this.clearCloseTimer,
        startCloseTimer = this.startCloseTimer,
        $slots = this.$slots,
        close = this.close;
    var componentClass = "".concat(prefixCls, "-notice");
    var className = (_className = {}, Notice_defineProperty(_className, "".concat(componentClass), 1), Notice_defineProperty(_className, "".concat(componentClass, "-closable"), closable), _className);
    var style = Object(props_util["n" /* getStyle */])(this);
    return h("div", {
      "class": className,
      style: style || {
        right: '50%'
      },
      on: {
        "mouseenter": clearCloseTimer,
        "mouseleave": startCloseTimer
      }
    }, [h("div", {
      "class": "".concat(componentClass, "-content")
    }, [$slots["default"]]), closable ? h("a", {
      attrs: {
        tabIndex: '0'
      },
      on: {
        "click": close
      },
      "class": "".concat(componentClass, "-close")
    }, [h("span", {
      "class": "".concat(componentClass, "-close-x")
    })]) : null]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-notification/Notification.jsx
function Notification_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Notification_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Notification_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function Notification_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var seed = 0;
var Notification_now = Date.now();

function getUuid() {
  return "rcNotification_".concat(Notification_now, "_").concat(seed++);
}

var Notification = {
  mixins: [BaseMixin["a" /* default */]],
  props: {
    prefixCls: vue_types["a" /* default */].string.def('rc-notification'),
    transitionName: vue_types["a" /* default */].string,
    animation: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].object]).def('fade'),
    maxCount: vue_types["a" /* default */].number
  },
  data: function data() {
    return {
      notices: []
    };
  },
  methods: {
    getTransitionName: function getTransitionName() {
      var props = this.$props;
      var transitionName = props.transitionName;

      if (!transitionName && props.animation) {
        transitionName = "".concat(props.prefixCls, "-").concat(props.animation);
      }

      return transitionName;
    },
    add: function add(notice) {
      var key = notice.key = notice.key || getUuid();
      var maxCount = this.$props.maxCount;
      this.setState(function (previousState) {
        var notices = previousState.notices;
        var noticeIndex = notices.map(function (v) {
          return v.key;
        }).indexOf(key);
        var updatedNotices = notices.concat();

        if (noticeIndex !== -1) {
          updatedNotices.splice(noticeIndex, 1, notice);
        } else {
          if (maxCount && notices.length >= maxCount) {
            // XXX, use key of first item to update new added (let React to move exsiting
            // instead of remove and mount). Same key was used before for both a) external
            // manual control and b) internal react 'key' prop , which is not that good.
            notice.updateKey = updatedNotices[0].updateKey || updatedNotices[0].key;
            updatedNotices.shift();
          }

          updatedNotices.push(notice);
        }

        return {
          notices: updatedNotices
        };
      });
    },
    remove: function remove(key) {
      this.setState(function (previousState) {
        return {
          notices: previousState.notices.filter(function (notice) {
            return notice.key !== key;
          })
        };
      });
    }
  },
  render: function render(h) {
    var _this = this;

    var prefixCls = this.prefixCls,
        notices = this.notices,
        remove = this.remove,
        getTransitionName = this.getTransitionName;
    var transitionProps = Object(getTransitionProps["a" /* default */])(getTransitionName());
    var noticeNodes = notices.map(function (notice, index) {
      var update = Boolean(index === notices.length - 1 && notice.updateKey);
      var key = notice.updateKey ? notice.updateKey : notice.key;
      var content = notice.content,
          duration = notice.duration,
          closable = notice.closable,
          onClose = notice.onClose,
          style = notice.style,
          className = notice["class"];
      var close = createChainedFunction(remove.bind(_this, key), onClose);
      var noticeProps = {
        props: {
          prefixCls: prefixCls,
          duration: duration,
          closable: closable,
          update: update
        },
        on: {
          close: close
        },
        style: style,
        "class": className,
        key: key
      };
      return h(Notice, noticeProps, [typeof content === 'function' ? content(h) : content]);
    });

    var className = Notification_defineProperty({}, prefixCls, 1);

    var style = Object(props_util["n" /* getStyle */])(this);
    return h("div", {
      "class": className,
      style: style || {
        top: '65px',
        left: '50%'
      }
    }, [h("transition-group", transitionProps, [noticeNodes])]);
  }
};

Notification.newInstance = function newNotificationInstance(properties, callback) {
  var _ref = properties || {},
      getContainer = _ref.getContainer,
      style = _ref.style,
      className = _ref["class"],
      props = Notification_objectWithoutProperties(_ref, ["getContainer", "style", "class"]);

  var div = document.createElement('div');

  if (getContainer) {
    var root = getContainer();
    root.appendChild(div);
  } else {
    document.body.appendChild(div);
  }

  new external_Vue_default.a({
    el: div,
    mounted: function mounted() {
      var self = this;
      this.$nextTick(function () {
        callback({
          notice: function notice(noticeProps) {
            self.$refs.notification.add(noticeProps);
          },
          removeNotice: function removeNotice(key) {
            self.$refs.notification.remove(key);
          },
          component: self,
          destroy: function destroy() {
            self.$destroy();
            self.$el.parentNode.removeChild(self.$el);
          }
        });
      });
    },
    render: function render() {
      var h = arguments[0];
      var p = {
        props: props,
        ref: 'notification',
        style: style,
        "class": className
      };
      return h(Notification, p);
    }
  });
};

/* harmony default export */ var vc_notification_Notification = (Notification);
// CONCATENATED MODULE: ./src/components/vc-notification/index.js
// based on rc-notification 3.1.1

/* harmony default export */ var vc_notification = (vc_notification_Notification);
// CONCATENATED MODULE: ./src/components/message/index.js


var defaultDuration = 3;
var defaultTop;
var messageInstance;
var message_key = 1;
var message_prefixCls = 'ant-message';
var message_transitionName = 'move-up';

var message_getContainer = function getContainer() {
  return document.body;
};

var maxCount;

function getMessageInstance(callback) {
  if (messageInstance) {
    callback(messageInstance);
    return;
  }

  vc_notification.newInstance({
    prefixCls: message_prefixCls,
    transitionName: message_transitionName,
    style: {
      top: defaultTop
    },
    // 覆盖原来的样式
    getContainer: message_getContainer,
    maxCount: maxCount
  }, function (instance) {
    if (messageInstance) {
      callback(messageInstance);
      return;
    }

    messageInstance = instance;
    callback(instance);
  });
} // type NoticeType = 'info' | 'success' | 'error' | 'warning' | 'loading';


function message_notice(_content, duration, type, onClose) {
  var iconType = {
    info: 'info-circle',
    success: 'check-circle',
    error: 'cross-circle',
    warning: 'exclamation-circle',
    loading: 'loading'
  }[type];

  if (typeof duration === 'function') {
    onClose = duration;
    duration = defaultDuration;
  } //add by cy 不自动关闭提示时显示关闭按钮


  var close = function close() {
    if (messageInstance) {
      if (typeof onClose === 'function') {
        onClose();
      }

      messageInstance.destroy();
      messageInstance = null;
    }
  };

  var target = message_key++;
  var closePromise = new Promise(function (resolve) {
    var callback = function callback() {
      if (typeof onClose === 'function') {
        onClose();
      }

      return resolve(true);
    };

    getMessageInstance(function (instance) {
      instance.notice({
        key: target,
        duration: duration,
        style: {},
        content: function content(h) {
          return h("div", {
            "class": "".concat(message_prefixCls, "-custom-content ").concat(message_prefixCls, "-").concat(type)
          }, [h(components_icon, {
            attrs: {
              type: iconType
            }
          }), h("span", [typeof _content === 'function' ? _content(h) : _content]), duration === 0 && h("span", {
            "class": "".concat(message_prefixCls, "-custom-content-close"),
            on: {
              "click": close
            }
          }, [h("ta-icon", {
            attrs: {
              type: "close"
            }
          })])]);
        },
        onClose: callback,
        closable: true
      });
    });
  });

  var result = function result() {
    if (messageInstance) {
      messageInstance.removeNotice(target);
    }
  };

  result.then = function (filled, rejected) {
    return closePromise.then(filled, rejected);
  };

  result.promise = closePromise;
  return result;
} // type ConfigContent = React.ReactNode | string;
// type ConfigDuration = number | (() => void);
// export type ConfigOnClose = () => void;
// export interface ConfigOptions {
//   top?: number;
//   duration?: number;
//   prefixCls?: string;
//   getContainer?: () => HTMLElement;
//   transitionName?: string;
// }


/* harmony default export */ var components_message = ({
  info: function info(content, duration, onClose) {
    return message_notice(content, duration, 'info', onClose);
  },
  success: function success(content, duration, onClose) {
    return message_notice(content, duration, 'success', onClose);
  },
  error: function error(content, duration, onClose) {
    return message_notice(content, duration, 'error', onClose);
  },
  // Departed usage, please use warning()
  warn: function warn(content, duration, onClose) {
    return message_notice(content, duration, 'warning', onClose);
  },
  warning: function warning(content, duration, onClose) {
    return message_notice(content, duration, 'warning', onClose);
  },
  loading: function loading(content, duration, onClose) {
    return message_notice(content, duration, 'loading', onClose);
  },
  config: function config(options) {
    if (options.top !== undefined) {
      defaultTop = options.top;
      messageInstance = null; // delete messageInstance for new defaultTop
    }

    if (options.duration !== undefined) {
      defaultDuration = options.duration;
    }

    if (options.prefixCls !== undefined) {
      message_prefixCls = options.prefixCls;
    }

    if (options.getContainer !== undefined) {
      message_getContainer = options.getContainer;
    }

    if (options.transitionName !== undefined) {
      message_transitionName = options.transitionName;
      messageInstance = null; // delete messageInstance for new transitionName
    }

    if (options.maxCount !== undefined) {
      maxCount = options.maxCount;
      messageInstance = null;
    }
  },
  destroy: function destroy() {
    if (messageInstance) {
      messageInstance.destroy();
      messageInstance = null;
    }
  }
});
// CONCATENATED MODULE: ./src/components/vc-tooltip/placements.js
var vc_tooltip_placements_autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var vc_tooltip_placements_targetOffset = [0, 0];
var vc_tooltip_placements_placements = {
  left: {
    points: ['cr', 'cl'],
    overflow: vc_tooltip_placements_autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: vc_tooltip_placements_targetOffset
  },
  right: {
    points: ['cl', 'cr'],
    overflow: vc_tooltip_placements_autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: vc_tooltip_placements_targetOffset
  },
  top: {
    points: ['bc', 'tc'],
    overflow: vc_tooltip_placements_autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: vc_tooltip_placements_targetOffset
  },
  bottom: {
    points: ['tc', 'bc'],
    overflow: vc_tooltip_placements_autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: vc_tooltip_placements_targetOffset
  },
  topLeft: {
    points: ['bl', 'tl'],
    overflow: vc_tooltip_placements_autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: vc_tooltip_placements_targetOffset
  },
  leftTop: {
    points: ['tr', 'tl'],
    overflow: vc_tooltip_placements_autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: vc_tooltip_placements_targetOffset
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: vc_tooltip_placements_autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: vc_tooltip_placements_targetOffset
  },
  rightTop: {
    points: ['tl', 'tr'],
    overflow: vc_tooltip_placements_autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: vc_tooltip_placements_targetOffset
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: vc_tooltip_placements_autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: vc_tooltip_placements_targetOffset
  },
  rightBottom: {
    points: ['bl', 'br'],
    overflow: vc_tooltip_placements_autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: vc_tooltip_placements_targetOffset
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: vc_tooltip_placements_autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: vc_tooltip_placements_targetOffset
  },
  leftBottom: {
    points: ['br', 'bl'],
    overflow: vc_tooltip_placements_autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: vc_tooltip_placements_targetOffset
  }
};
/* harmony default export */ var vc_tooltip_placements = (vc_tooltip_placements_placements);
// CONCATENATED MODULE: ./src/components/vc-tooltip/Content.jsx

/* harmony default export */ var vc_tooltip_Content = ({
  props: {
    prefixCls: vue_types["a" /* default */].string,
    overlay: vue_types["a" /* default */].any,
    trigger: vue_types["a" /* default */].any
  },
  updated: function updated() {
    var trigger = this.trigger;

    if (trigger) {
      trigger.forcePopupAlign();
    }
  },
  render: function render() {
    var h = arguments[0];
    var overlay = this.overlay,
        prefixCls = this.prefixCls;
    return h("div", {
      "class": "".concat(prefixCls, "-inner")
    }, [typeof overlay === 'function' ? overlay() : overlay]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-tooltip/Tooltip.jsx
function Tooltip_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Tooltip_defineProperty(target, key, source[key]); }); } return target; }

function Tooltip_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Tooltip_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Tooltip_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Tooltip_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







function Tooltip_noop() {}

/* harmony default export */ var Tooltip = ({
  props: {
    trigger: vue_types["a" /* default */].any.def(['hover']),
    defaultVisible: vue_types["a" /* default */].bool,
    visible: vue_types["a" /* default */].bool,
    placement: vue_types["a" /* default */].string.def('right'),
    transitionName: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].object]),
    animation: vue_types["a" /* default */].any,
    afterVisibleChange: vue_types["a" /* default */].func.def(function () {}),
    overlay: vue_types["a" /* default */].any,
    overlayStyle: vue_types["a" /* default */].object,
    overlayClassName: vue_types["a" /* default */].string,
    prefixCls: vue_types["a" /* default */].string.def('rc-tooltip'),
    mouseEnterDelay: vue_types["a" /* default */].number.def(0),
    mouseLeaveDelay: vue_types["a" /* default */].number.def(0.1),
    getTooltipContainer: vue_types["a" /* default */].func,
    destroyTooltipOnHide: vue_types["a" /* default */].bool.def(false),
    align: vue_types["a" /* default */].object.def({}),
    arrowContent: vue_types["a" /* default */].any.def(null),
    tipId: vue_types["a" /* default */].string,
    builtinPlacements: vue_types["a" /* default */].object
  },
  methods: {
    getPopupElement: function getPopupElement(h) {
      var _this$$props = this.$props,
          prefixCls = _this$$props.prefixCls,
          tipId = _this$$props.tipId;
      return [h("div", {
        "class": "".concat(prefixCls, "-arrow"),
        key: 'arrow'
      }, [Object(props_util["g" /* getComponentFromProp */])(this, 'arrowContent')]), h(vc_tooltip_Content, {
        key: 'content',
        attrs: {
          trigger: this.$refs.trigger,
          prefixCls: prefixCls,
          id: tipId,
          overlay: Object(props_util["g" /* getComponentFromProp */])(this, 'overlay')
        }
      })];
    },
    getPopupDomNode: function getPopupDomNode() {
      return this.$refs.trigger.getPopupDomNode();
    }
  },
  render: function render(h) {
    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        overlayClassName = _getOptionProps.overlayClassName,
        trigger = _getOptionProps.trigger,
        mouseEnterDelay = _getOptionProps.mouseEnterDelay,
        mouseLeaveDelay = _getOptionProps.mouseLeaveDelay,
        overlayStyle = _getOptionProps.overlayStyle,
        prefixCls = _getOptionProps.prefixCls,
        afterVisibleChange = _getOptionProps.afterVisibleChange,
        transitionName = _getOptionProps.transitionName,
        animation = _getOptionProps.animation,
        placement = _getOptionProps.placement,
        align = _getOptionProps.align,
        destroyTooltipOnHide = _getOptionProps.destroyTooltipOnHide,
        defaultVisible = _getOptionProps.defaultVisible,
        getTooltipContainer = _getOptionProps.getTooltipContainer,
        restProps = Tooltip_objectWithoutProperties(_getOptionProps, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer"]);

    var extraProps = Tooltip_objectSpread({}, restProps);

    if (Object(props_util["p" /* hasProp */])(this, 'visible')) {
      extraProps.popupVisible = this.$props.visible;
    }

    var triggerProps = {
      props: Tooltip_objectSpread({
        popupClassName: overlayClassName,
        prefixCls: prefixCls,
        action: trigger,
        builtinPlacements: vc_tooltip_placements_placements,
        popupPlacement: placement,
        popupAlign: align,
        getPopupContainer: getTooltipContainer,
        afterPopupVisibleChange: afterVisibleChange,
        popupTransitionName: transitionName,
        popupAnimation: animation,
        defaultPopupVisible: defaultVisible,
        destroyPopupOnHide: destroyTooltipOnHide,
        mouseLeaveDelay: mouseLeaveDelay,
        popupStyle: overlayStyle,
        mouseEnterDelay: mouseEnterDelay
      }, extraProps),
      on: Tooltip_objectSpread({}, this.$listeners, {
        popupVisibleChange: this.$listeners.visibleChange || Tooltip_noop,
        popupAlign: this.$listeners.popupAlign || Tooltip_noop
      }),
      ref: 'trigger'
    };
    return h(components_trigger, triggerProps, [h("template", {
      slot: 'popup'
    }, [this.getPopupElement(h)]), this.$slots["default"]]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-tooltip/index.js
// based on rc-tooltip 3.7.2

/* harmony default export */ var vc_tooltip = (Tooltip);
// CONCATENATED MODULE: ./src/components/tooltip/placements.js
function placements_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      placements_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function placements_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


var autoAdjustOverflowEnabled = {
  adjustX: 1,
  adjustY: 1
};
var autoAdjustOverflowDisabled = {
  adjustX: 0,
  adjustY: 0
};
var tooltip_placements_targetOffset = [0, 0];
function getOverflowOptions(autoAdjustOverflow) {
  if (typeof autoAdjustOverflow === 'boolean') {
    return autoAdjustOverflow ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
  }

  return placements_objectSpread({}, autoAdjustOverflowDisabled, autoAdjustOverflow);
}
function placements_getPlacements(config) {
  var _config$arrowWidth = config.arrowWidth,
      arrowWidth = _config$arrowWidth === void 0 ? 5 : _config$arrowWidth,
      _config$horizontalArr = config.horizontalArrowShift,
      horizontalArrowShift = _config$horizontalArr === void 0 ? 16 : _config$horizontalArr,
      _config$verticalArrow = config.verticalArrowShift,
      verticalArrowShift = _config$verticalArrow === void 0 ? 12 : _config$verticalArrow,
      _config$autoAdjustOve = config.autoAdjustOverflow,
      autoAdjustOverflow = _config$autoAdjustOve === void 0 ? true : _config$autoAdjustOve;
  var placementMap = {
    left: {
      points: ['cr', 'cl'],
      offset: [-4, 0]
    },
    right: {
      points: ['cl', 'cr'],
      offset: [4, 0]
    },
    top: {
      points: ['bc', 'tc'],
      offset: [0, -4]
    },
    bottom: {
      points: ['tc', 'bc'],
      offset: [0, 4]
    },
    topLeft: {
      points: ['bl', 'tc'],
      offset: [-(horizontalArrowShift + arrowWidth), -4]
    },
    leftTop: {
      points: ['tr', 'cl'],
      offset: [-4, -(verticalArrowShift + arrowWidth)]
    },
    topRight: {
      points: ['br', 'tc'],
      offset: [horizontalArrowShift + arrowWidth, -4]
    },
    rightTop: {
      points: ['tl', 'cr'],
      offset: [4, -(verticalArrowShift + arrowWidth)]
    },
    bottomRight: {
      points: ['tr', 'bc'],
      offset: [horizontalArrowShift + arrowWidth, 4]
    },
    rightBottom: {
      points: ['bl', 'cr'],
      offset: [4, verticalArrowShift + arrowWidth]
    },
    bottomLeft: {
      points: ['tl', 'bc'],
      offset: [-(horizontalArrowShift + arrowWidth), 4]
    },
    leftBottom: {
      points: ['br', 'cl'],
      offset: [-4, verticalArrowShift + arrowWidth]
    }
  };
  Object.keys(placementMap).forEach(function (key) {
    placementMap[key] = config.arrowPointAtCenter ? placements_objectSpread({}, placementMap[key], {
      overflow: getOverflowOptions(autoAdjustOverflow),
      targetOffset: tooltip_placements_targetOffset
    }) : placements_objectSpread({}, vc_tooltip_placements_placements[key], {
      overflow: getOverflowOptions(autoAdjustOverflow)
    });
  });
  return placementMap;
}
// CONCATENATED MODULE: ./src/components/tooltip/abstractTooltipProps.js

var triggerType = vue_types["a" /* default */].oneOf(['hover', 'focus', 'click', 'contextmenu']);
/* harmony default export */ var abstractTooltipProps = (function () {
  return {
    trigger: vue_types["a" /* default */].oneOfType([triggerType, vue_types["a" /* default */].arrayOf(triggerType)]).def('hover'),
    visible: vue_types["a" /* default */].bool,
    placement: vue_types["a" /* default */].oneOf(['top', 'left', 'right', 'bottom', 'topLeft', 'topRight', 'bottomLeft', 'bottomRight', 'leftTop', 'leftBottom', 'rightTop', 'rightBottom']).def('top'),
    transitionName: vue_types["a" /* default */].string.def('zoom-big-fast'),
    // onVisibleChange: PropTypes.func,
    overlayStyle: vue_types["a" /* default */].object.def({}),
    overlayClassName: vue_types["a" /* default */].string,
    prefixCls: vue_types["a" /* default */].string.def('ant-tooltip'),
    mouseEnterDelay: vue_types["a" /* default */].number.def(0.1),
    mouseLeaveDelay: vue_types["a" /* default */].number.def(0.1),
    getTooltipContainer: vue_types["a" /* default */].func,
    getPopupContainer: vue_types["a" /* default */].func,
    arrowPointAtCenter: vue_types["a" /* default */].bool.def(false),
    autoAdjustOverflow: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, vue_types["a" /* default */].object]).def(true)
  };
});
// CONCATENATED MODULE: ./src/components/tooltip/Tooltip.jsx
function tooltip_Tooltip_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { tooltip_Tooltip_defineProperty(target, key, source[key]); }); } return target; }

function tooltip_Tooltip_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var splitObject = function splitObject(obj, keys) {
  var picked = {};

  var omitted = tooltip_Tooltip_objectSpread({}, obj);

  keys.forEach(function (key) {
    if (obj && key in obj) {
      picked[key] = obj[key];
      delete omitted[key];
    }
  });
  return {
    picked: picked,
    omitted: omitted
  };
};

var Tooltip_props = abstractTooltipProps();
/* harmony default export */ var tooltip_Tooltip = ({
  name: 'TaTooltip',
  props: tooltip_Tooltip_objectSpread({}, Tooltip_props, {
    title: vue_types["a" /* default */].any
  }),
  model: {
    prop: 'visible',
    event: 'visibleChange'
  },
  data: function data() {
    return {
      sVisible: !!this.$props.visible
    };
  },
  watch: {
    visible: function visible(val) {
      this.sVisible = val;
    }
  },
  methods: {
    onVisibleChange: function onVisibleChange(visible) {
      if (!Object(props_util["p" /* hasProp */])(this, 'visible')) {
        this.sVisible = this.isNoTitle() ? false : visible;
      }

      if (!this.isNoTitle()) {
        this.$emit('visibleChange', visible);
      }
    },
    getPopupDomNode: function getPopupDomNode() {
      return this.$refs.tooltip.getPopupDomNode();
    },
    getPlacements: function getPlacements() {
      var _this$$props = this.$props,
          builtinPlacements = _this$$props.builtinPlacements,
          arrowPointAtCenter = _this$$props.arrowPointAtCenter,
          autoAdjustOverflow = _this$$props.autoAdjustOverflow;
      return builtinPlacements || placements_getPlacements({
        arrowPointAtCenter: arrowPointAtCenter,
        verticalArrowShift: 8,
        autoAdjustOverflow: autoAdjustOverflow
      });
    },
    isHoverTrigger: function isHoverTrigger() {
      var trigger = this.$props.trigger;

      if (!trigger || trigger === 'hover') {
        return true;
      }

      if (Array.isArray(trigger)) {
        return trigger.indexOf('hover') >= 0;
      }

      return false;
    },
    // Fix Tooltip won't hide at disabled button
    // mouse events don't trigger at disabled button in Chrome
    // https://github.com/react-component/tooltip/issues/18
    getDisabledCompatibleChildren: function getDisabledCompatibleChildren(ele) {
      var h = this.$createElement;
      var isAntBtn = ele.componentOptions && ele.componentOptions.Ctor.options.__ANT_BUTTON;

      if ((isAntBtn && (ele.componentOptions.propsData.disabled || ele.componentOptions.propsData.disabled === '') || ele.tag === 'button' && ele.data && ele.data.attrs.disabled !== false) && this.isHoverTrigger()) {
        // Pick some layout related style properties up to span
        // Prevent layout bugs like https://github.com/ant-design/ant-design/issues/5254
        var _splitObject = splitObject(Object(props_util["n" /* getStyle */])(ele), ['position', 'left', 'right', 'top', 'bottom', 'float', 'display', 'zIndex']),
            picked = _splitObject.picked,
            omitted = _splitObject.omitted;

        var spanStyle = tooltip_Tooltip_objectSpread({
          display: 'inline-block'
        }, picked, {
          cursor: 'not-allowed'
        });

        var buttonStyle = tooltip_Tooltip_objectSpread({}, omitted, {
          pointerEvents: 'none'
        });

        var spanCls = Object(props_util["f" /* getClass */])(ele);
        var child = Object(vnode["a" /* cloneElement */])(ele, {
          style: buttonStyle,
          "class": null
        });
        return h("span", {
          style: spanStyle,
          "class": spanCls
        }, [child]);
      }

      return ele;
    },
    isNoTitle: function isNoTitle() {
      var $slots = this.$slots,
          title = this.title;
      return !$slots.title && !title;
    },
    // 动态设置动画点
    onPopupAlign: function onPopupAlign(domNode, align) {
      var placements = this.getPlacements(); // 当前返回的位置

      var placement = Object.keys(placements).filter(function (key) {
        return placements[key].points[0] === align.points[0] && placements[key].points[1] === align.points[1];
      })[0];

      if (!placement) {
        return;
      } // 根据当前坐标设置动画点


      var rect = domNode.getBoundingClientRect();
      var transformOrigin = {
        top: '50%',
        left: '50%'
      };

      if (placement.indexOf('top') >= 0 || placement.indexOf('Bottom') >= 0) {
        transformOrigin.top = "".concat(rect.height - align.offset[1], "px");
      } else if (placement.indexOf('Top') >= 0 || placement.indexOf('bottom') >= 0) {
        transformOrigin.top = "".concat(-align.offset[1], "px");
      }

      if (placement.indexOf('left') >= 0 || placement.indexOf('Right') >= 0) {
        transformOrigin.left = "".concat(rect.width - align.offset[0], "px");
      } else if (placement.indexOf('right') >= 0 || placement.indexOf('Left') >= 0) {
        transformOrigin.left = "".concat(-align.offset[0], "px");
      }

      domNode.style.transformOrigin = "".concat(transformOrigin.left, " ").concat(transformOrigin.top);
    }
  },
  render: function render(h) {
    var $props = this.$props,
        $data = this.$data,
        $slots = this.$slots,
        $listeners = this.$listeners;
    var prefixCls = $props.prefixCls,
        openClassName = $props.openClassName,
        getPopupContainer = $props.getPopupContainer;
    var children = ($slots["default"] || []).filter(function (c) {
      return c.tag || c.text.trim() !== '';
    });
    children = children.length === 1 ? children[0] : children;
    var sVisible = $data.sVisible; // Hide tooltip when there is no title

    if (!Object(props_util["p" /* hasProp */])(this, 'visible') && this.isNoTitle()) {
      sVisible = false;
    }

    if (!children) {
      return null;
    }

    var child = this.getDisabledCompatibleChildren(Object(props_util["s" /* isValidElement */])(children) ? children : h("span", [children]));

    var childCls = tooltip_Tooltip_defineProperty({}, openClassName || "".concat(prefixCls, "-open"), true);

    var tooltipProps = {
      props: tooltip_Tooltip_objectSpread({}, $props, {
        getTooltipContainer: getPopupContainer,
        builtinPlacements: this.getPlacements(),
        visible: sVisible
      }),
      ref: 'tooltip',
      on: tooltip_Tooltip_objectSpread({}, $listeners, {
        visibleChange: this.onVisibleChange,
        popupAlign: this.onPopupAlign
      })
    };
    return h(vc_tooltip, tooltipProps, [h("template", {
      slot: 'overlay'
    }, [Object(props_util["g" /* getComponentFromProp */])(this, 'title')]), sVisible ? Object(vnode["a" /* cloneElement */])(child, {
      "class": childCls
    }) : child]);
  }
});
// CONCATENATED MODULE: ./src/components/tooltip/index.js

/* istanbul ignore next */

tooltip_Tooltip.install = function (Vue) {
  Vue.component(tooltip_Tooltip.name, tooltip_Tooltip);
};

/* harmony default export */ var tooltip = (tooltip_Tooltip);
// CONCATENATED MODULE: ./src/components/menu/MenuItem.jsx






function MenuItem_noop() {}

/* harmony default export */ var menu_MenuItem = ({
  props: MenuItem_props,
  name: 'MenuItem',
  inject: {
    getInlineCollapsed: {
      "default": function _default() {
        return MenuItem_noop;
      }
    }
  },
  isMenuItem: 1,
  methods: {
    onKeyDown: function onKeyDown(e) {
      this.$refs.menuItem.onKeyDown(e);
    }
  },
  render: function render(h) {
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var getInlineCollapsed = this.getInlineCollapsed,
        $slots = this.$slots,
        attrs = this.$attrs,
        $listeners = this.$listeners;
    var inlineCollapsed = getInlineCollapsed();
    var itemProps = {
      props: props,
      attrs: attrs,
      on: $listeners
    };
    var toolTipProps = {
      props: {
        title: inlineCollapsed && props.level === 1 ? $slots["default"] : '',
        placement: 'right',
        overlayClassName: "".concat(props.rootPrefixCls, "-inline-collapsed-tooltip")
      }
    };
    return h(tooltip, toolTipProps, [h(vc_menu_MenuItem, babel_helper_vue_jsx_merge_props_default()([itemProps, {
      ref: 'menuItem'
    }]), [$slots["default"]])]);
  }
});
// CONCATENATED MODULE: ./src/components/menu/index.jsx


function menu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { menu_defineProperty(target, key, source[key]); }); } return target; }

function menu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










var MenuMode = vue_types["a" /* default */].oneOf(['vertical', 'vertical-left', 'vertical-right', 'horizontal', 'inline']);
var menu_menuProps = menu_objectSpread({}, commonPropsType, {
  theme: vue_types["a" /* default */].oneOf(['light', 'dark']).def('light'),
  mode: MenuMode.def('vertical'),
  selectable: vue_types["a" /* default */].bool,
  selectedKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
  defaultSelectedKeys: vue_types["a" /* default */].array,
  openKeys: vue_types["a" /* default */].array,
  defaultOpenKeys: vue_types["a" /* default */].array,
  openAnimation: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].object]),
  openTransitionName: vue_types["a" /* default */].string,
  prefixCls: vue_types["a" /* default */].string.def('ant-menu'),
  multiple: vue_types["a" /* default */].bool,
  inlineIndent: vue_types["a" /* default */].number.def(24),
  inlineCollapsed: vue_types["a" /* default */].bool,
  isRootMenu: vue_types["a" /* default */].bool.def(true),
  focusable: vue_types["a" /* default */].bool.def(false)
});
var menu_Menu = {
  name: 'TaMenu',
  props: menu_menuProps,
  Divider: menu_objectSpread({}, Divider, {
    name: 'TaMenuDivider'
  }),
  Item: menu_objectSpread({}, menu_MenuItem, {
    name: 'TaMenuItem'
  }),
  SubMenu: menu_objectSpread({}, vc_menu_SubMenu, {
    name: 'TaSubMenu'
  }),
  ItemGroup: menu_objectSpread({}, vc_menu_MenuItemGroup, {
    name: 'TaMenuItemGroup'
  }),
  provide: function provide() {
    return {
      getInlineCollapsed: this.getInlineCollapsed
    };
  },
  mixins: [BaseMixin["a" /* default */]],
  inject: {
    layoutSiderContext: {
      "default": {}
    }
  },
  model: {
    prop: 'selectedKeys',
    event: 'selectChange'
  },
  created: function created() {
    this.preProps = menu_objectSpread({}, this.$props);
  },
  watch: {
    '$props': {
      handler: function handler(nextProps) {
        var preProps = this.preProps,
            sOpenKeys = this.sOpenKeys;
        var prefixCls = preProps.prefixCls;

        if (preProps.mode === 'inline' && nextProps.mode !== 'inline') {
          this.switchModeFromInline = true;
        }

        if (Object(props_util["p" /* hasProp */])(this, 'openKeys')) {
          this.setState({
            sOpenKeys: nextProps.openKeys
          });
          this.preProps = menu_objectSpread({}, nextProps);
          return;
        }

        if (nextProps.inlineCollapsed && !preProps.inlineCollapsed) {
          this.switchModeFromInline = !!sOpenKeys.length && !!this.$el.querySelectorAll(".".concat(prefixCls, "-submenu-open")).length;
          this.inlineOpenKeys = sOpenKeys;
          this.setState({
            sOpenKeys: []
          });
        }

        if (!nextProps.inlineCollapsed && preProps.inlineCollapsed) {
          this.setState({
            sOpenKeys: this.inlineOpenKeys
          });
          this.inlineOpenKeys = [];
        }

        this.preProps = menu_objectSpread({}, nextProps);
      },
      deep: true
    },
    'layoutSiderContext.sCollapsed': function layoutSiderContextSCollapsed(val) {
      var openKeys = this.openKeys,
          _this$sOpenKeys = this.sOpenKeys,
          sOpenKeys = _this$sOpenKeys === void 0 ? [] : _this$sOpenKeys,
          prefixCls = this.prefixCls;

      if (Object(props_util["p" /* hasProp */])(this, 'openKeys')) {
        this.setState({
          sOpenKeys: openKeys
        });
        return;
      }

      if (val) {
        this.switchModeFromInline = !!sOpenKeys.length && !!this.$el.querySelectorAll(".".concat(prefixCls, "-submenu-open")).length;
        this.inlineOpenKeys = sOpenKeys;
        this.setState({
          sOpenKeys: []
        });
      } else {
        this.setState({
          sOpenKeys: this.inlineOpenKeys
        });
        this.inlineOpenKeys = [];
      }
    }
  },
  data: function data() {
    var props = this.$props;
    _util_warning(!(Object(props_util["p" /* hasProp */])(this, 'inlineCollapsed') && props.mode !== 'inline'), '`inlineCollapsed` should only be used when Menu\'s `mode` is inline.');
    this.switchModeFromInline = false;
    this.leaveAnimationExecutedWhenInlineCollapsed = false;
    this.inlineOpenKeys = [];
    var sOpenKeys;

    if (Object(props_util["p" /* hasProp */])(this, 'openKeys')) {
      sOpenKeys = props.openKeys;
    } else if (Object(props_util["p" /* hasProp */])(this, 'defaultOpenKeys')) {
      sOpenKeys = props.defaultOpenKeys;
    }

    return {
      sOpenKeys: sOpenKeys
    };
  },
  methods: {
    handleClick: function handleClick(e) {
      this.handleOpenChange([]);
      this.$emit('click', e);
    },
    handleSelect: function handleSelect(info) {
      this.$emit('select', info);
      this.$emit('selectChange', info.selectedKeys);
    },
    handleDeselect: function handleDeselect(info) {
      this.$emit('deselect', info);
      this.$emit('selectChange', info.selectedKeys);
    },
    handleOpenChange: function handleOpenChange(openKeys) {
      this.setOpenKeys(openKeys);
      this.$emit('openChange', openKeys);
      this.$emit('update:openKeys', openKeys);
    },
    setOpenKeys: function setOpenKeys(openKeys) {
      if (!Object(props_util["p" /* hasProp */])(this, 'openKeys')) {
        this.setState({
          sOpenKeys: openKeys
        });
      }
    },
    getRealMenuMode: function getRealMenuMode() {
      var inlineCollapsed = this.getInlineCollapsed();

      if (this.switchModeFromInline && inlineCollapsed) {
        return 'inline';
      }

      var mode = this.$props.mode;
      return inlineCollapsed ? 'vertical' : mode;
    },
    getInlineCollapsed: function getInlineCollapsed() {
      var inlineCollapsed = this.$props.inlineCollapsed;

      if (this.layoutSiderContext.sCollapsed !== undefined) {
        return this.layoutSiderContext.sCollapsed;
      }

      return inlineCollapsed;
    },
    getMenuOpenAnimation: function getMenuOpenAnimation(menuMode) {
      var _this = this;

      var _this$$props = this.$props,
          openAnimation = _this$$props.openAnimation,
          openTransitionName = _this$$props.openTransitionName;
      var menuOpenAnimation = openAnimation || openTransitionName;

      if (openAnimation === undefined && openTransitionName === undefined) {
        switch (menuMode) {
          case 'horizontal':
            menuOpenAnimation = 'slide-up';
            break;

          case 'vertical':
          case 'vertical-left':
          case 'vertical-right':
            // When mode switch from inline
            // submenu should hide without animation
            if (this.switchModeFromInline) {
              menuOpenAnimation = '';
              this.switchModeFromInline = false;
            } else {
              menuOpenAnimation = 'zoom-big';
            }

            break;

          case 'inline':
            menuOpenAnimation = {
              on: menu_objectSpread({}, _util_openAnimation, {
                leave: function leave(node, done) {
                  return _util_openAnimation.leave(node, function () {
                    // Make sure inline menu leave animation finished before mode is switched
                    _this.switchModeFromInline = false; // this.setState({})

                    _this.$forceUpdate(); // when inlineCollapsed change false to true, all submenu will be unmounted,
                    // so that we don't need handle animation leaving.


                    if (_this.getRealMenuMode() === 'vertical') {
                      return;
                    }

                    done();
                  });
                }
              })
            };
            break;

          default:
        }
      }

      return menuOpenAnimation;
    }
  },
  render: function render() {
    var _menuClassName,
        _this2 = this;

    var h = arguments[0];
    var layoutSiderContext = this.layoutSiderContext,
        $slots = this.$slots,
        $listeners = this.$listeners;
    var collapsedWidth = layoutSiderContext.collapsedWidth;
    var _this$$props2 = this.$props,
        prefixCls = _this$$props2.prefixCls,
        theme = _this$$props2.theme;
    var menuMode = this.getRealMenuMode();
    var menuOpenAnimation = this.getMenuOpenAnimation(menuMode);
    var menuClassName = (_menuClassName = {}, menu_defineProperty(_menuClassName, "".concat(prefixCls, "-").concat(theme), true), menu_defineProperty(_menuClassName, "".concat(prefixCls, "-inline-collapsed"), this.getInlineCollapsed()), _menuClassName);
    var menuProps = {
      props: menu_objectSpread({}, Object(es["a" /* default */])(this.$props, ['inlineCollapsed']), {
        openKeys: this.sOpenKeys,
        mode: menuMode
      }),
      on: menu_objectSpread({}, $listeners, {
        select: this.handleSelect,
        deselect: this.handleDeselect,
        openChange: this.handleOpenChange
      })
    };

    if (!Object(props_util["p" /* hasProp */])(this, 'selectedKeys')) {
      delete menuProps.props.selectedKeys;
    }

    if (menuMode !== 'inline') {
      // closing vertical popup submenu after click it
      menuProps.on.click = this.handleClick;
      menuProps.props.openTransitionName = menuOpenAnimation;
    } else {
      menuProps.on.click = function (e) {
        _this2.$emit('click', e);
      };

      menuProps.props.openAnimation = menuOpenAnimation;
    } // https://github.com/ant-design/ant-design/issues/8587


    if (this.getInlineCollapsed() && (collapsedWidth === 0 || collapsedWidth === '0' || collapsedWidth === '0px')) {
      return null;
    }

    return h(vc_menu, babel_helper_vue_jsx_merge_props_default()([menuProps, {
      "class": menuClassName
    }]), [$slots["default"]]);
  }
};
/* istanbul ignore next */

menu_Menu.install = function (Vue) {
  Vue.component(menu_Menu.name, menu_Menu);
  Vue.component(menu_Menu.Item.name, menu_Menu.Item);
  Vue.component(menu_Menu.SubMenu.name, menu_Menu.SubMenu);
  Vue.component(menu_Menu.Divider.name, menu_Menu.Divider);
  Vue.component(menu_Menu.ItemGroup.name, menu_Menu.ItemGroup);
};

/* harmony default export */ var components_menu = (menu_Menu);
// CONCATENATED MODULE: ./src/components/vc-dialog/LazyRenderBox.jsx

var ILazyRenderBoxPropTypes = {
  visible: vue_types["a" /* default */].bool,
  hiddenClassName: vue_types["a" /* default */].string
};
/* harmony default export */ var vc_dialog_LazyRenderBox = ({
  props: ILazyRenderBoxPropTypes,
  render: function render() {
    var h = arguments[0];
    return h("div", [this.$slots["default"]]);
  }
});
// CONCATENATED MODULE: ./src/components/_util/getScrollBarSize.js
var cached;
function getScrollBarSize(fresh) {
  if (fresh || cached === undefined) {
    var scrollStyle = document.createElement('style');
    document.head.appendChild(scrollStyle); //  fixme：这里的::-webkit-scrollbar会导致在IE下加载drawer时出现渲染错误  @selina

    scrollStyle.sheet.addRule('.beautifulScrollbar', 'width: 6px'); // scrollStyle.sheet.addRule('.beautifulScrollbar::-webkit-scrollbar', 'width: 6px')

    var inner = document.createElement('div');
    inner.style.width = '100%';
    inner.style.height = '200px';
    var outer = document.createElement('div');
    outer.className = 'beautifulScrollbar';
    var outerStyle = outer.style;
    outerStyle.position = 'absolute';
    outerStyle.top = 0;
    outerStyle.left = 0;
    outerStyle.pointerEvents = 'none';
    outerStyle.visibility = 'hidden';
    outerStyle.width = '200px';
    outerStyle.height = '150px';
    outerStyle.overflow = 'hidden';
    outer.appendChild(inner);
    document.body.appendChild(outer);
    var widthContained = inner.offsetWidth;
    outer.style.overflow = 'scroll';
    var widthScroll = inner.getBoundingClientRect().width;

    if (widthContained === widthScroll) {
      widthScroll = outer.clientWidth;
    }

    document.body.removeChild(outer);
    cached = widthContained - widthScroll;
  }

  return cached;
}
// CONCATENATED MODULE: ./src/components/vc-dialog/IDialogPropTypes.js


function IDialogPropTypes() {
  return {
    keyboard: vue_types["a" /* default */].bool,
    mask: vue_types["a" /* default */].bool,
    afterClose: vue_types["a" /* default */].func,
    // onClose: PropTypes. (e: SyntheticEvent<HTMLDivElement>) =>any,
    closable: vue_types["a" /* default */].bool,
    maskClosable: vue_types["a" /* default */].bool,
    visible: vue_types["a" /* default */].bool,
    destroyOnClose: vue_types["a" /* default */].bool,
    mousePosition: vue_types["a" /* default */].shape({
      x: vue_types["a" /* default */].number,
      y: vue_types["a" /* default */].number
    }).loose,
    title: vue_types["a" /* default */].any,
    footer: vue_types["a" /* default */].any,
    transitionName: vue_types["a" /* default */].string,
    maskTransitionName: vue_types["a" /* default */].string,
    animation: vue_types["a" /* default */].any,
    maskAnimation: vue_types["a" /* default */].any,
    wrapStyle: vue_types["a" /* default */].object,
    bodyStyle: vue_types["a" /* default */].object,
    maskStyle: vue_types["a" /* default */].object,
    prefixCls: vue_types["a" /* default */].string,
    wrapClassName: vue_types["a" /* default */].string,
    width: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
    height: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
    zIndex: vue_types["a" /* default */].number,
    bodyProps: vue_types["a" /* default */].any,
    maskProps: vue_types["a" /* default */].any,
    wrapProps: vue_types["a" /* default */].any,
    getContainer: vue_types["a" /* default */].func,
    dialogStyle: vue_types["a" /* default */].object.def({}),
    dialogClass: vue_types["a" /* default */].object.def({})
  };
}

/* harmony default export */ var vc_dialog_IDialogPropTypes = (IDialogPropTypes);
// CONCATENATED MODULE: ./src/components/vc-dialog/Dialog.jsx






function Dialog_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Dialog_defineProperty(target, key, source[key]); }); } return target; }

function Dialog_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var Dialog_IDialogPropTypes = vc_dialog_IDialogPropTypes();
var uuid = 0;
var openCount = 0;
/* eslint react/no-is-mounted:0 */

function Dialog_noop() {}

function Dialog_getScroll(w, top) {
  var ret = w["page".concat(top ? 'Y' : 'X', "Offset")];
  var method = "scroll".concat(top ? 'Top' : 'Left');

  if (typeof ret !== 'number') {
    var d = w.document;
    ret = d.documentElement[method];

    if (typeof ret !== 'number') {
      ret = d.body[method];
    }
  }

  return ret;
}

function setTransformOrigin(node, value) {
  var style = node.style;
  ['Webkit', 'Moz', 'Ms', 'ms'].forEach(function (prefix) {
    style["".concat(prefix, "TransformOrigin")] = value;
  });
  style["transformOrigin"] = value;
}

function Dialog_offset(el) {
  var rect = el.getBoundingClientRect();
  var pos = {
    left: rect.left,
    top: rect.top
  };
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += Dialog_getScroll(w);
  pos.top += Dialog_getScroll(w, true);
  return pos;
}

var initDefaultProps = function initDefaultProps(propTypes, defaultProps) {
  return Object.keys(defaultProps).map(function (k) {
    return propTypes[k].def(defaultProps[k]);
  });
};

/* harmony default export */ var Dialog = ({
  mixins: [BaseMixin["a" /* default */]],
  props: Dialog_objectSpread({}, Dialog_IDialogPropTypes, initDefaultProps(Dialog_IDialogPropTypes, {
    mask: true,
    visible: false,
    keyboard: true,
    closable: true,
    maskClosable: true,
    destroyOnClose: false,
    prefixCls: 'rc-dialog'
  })),
  data: function data() {
    return {
      destroyPopup: false
    };
  },
  // private inTransition: boolean;
  // private titleId: string;
  // private openTime: number;
  // private lastOutSideFocusNode: HTMLElement | null;
  // private wrap: HTMLElement;
  // private dialog: any;
  // private sentinel: HTMLElement;
  // private bodyIsOverflowing: boolean;
  // private scrollbarWidth: number;
  beforeMount: function beforeMount() {
    this.inTransition = false;
    this.titleId = "rcDialogTitle".concat(uuid++);
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.updatedCallback(false);
    });
  },
  watch: {
    visible: function visible(val) {
      var _this2 = this;

      if (val) {
        this.destroyPopup = false;
      }

      this.$nextTick(function () {
        _this2.updatedCallback(!val);
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.visible || this.inTransition) {
      this.removeScrollingEffect();
    }
  },
  methods: {
    updatedCallback: function updatedCallback(visible) {
      var mousePosition = this.mousePosition;

      if (this.visible) {
        // first show
        if (!visible) {
          this.openTime = Date.now(); // this.lastOutSideFocusNode = document.activeElement

          this.addScrollingEffect(); // this.$refs.wrap.focus()

          this.tryFocus();
          var dialogNode = this.$refs.dialog.$el;

          if (mousePosition) {
            var elOffset = Dialog_offset(dialogNode);
            setTransformOrigin(dialogNode, "".concat(mousePosition.x - elOffset.left, "px ").concat(mousePosition.y - elOffset.top, "px"));
          } else {
            setTransformOrigin(dialogNode, '');
          }
        }
      } else if (visible) {
        this.inTransition = true;

        if (this.mask && this.lastOutSideFocusNode) {
          try {
            this.lastOutSideFocusNode.focus();
          } catch (e) {
            this.lastOutSideFocusNode = null;
          }

          this.lastOutSideFocusNode = null;
        }
      }
    },
    tryFocus: function tryFocus() {
      if (!contains(this.$refs.wrap, document.activeElement)) {
        this.lastOutSideFocusNode = document.activeElement;
        this.$refs.wrap.focus();
      }
    },
    onAnimateLeave: function onAnimateLeave() {
      var afterClose = this.afterClose,
          destroyOnClose = this.destroyOnClose; // need demo?
      // https://github.com/react-component/dialog/pull/28

      if (this.$refs.wrap) {
        this.$refs.wrap.style.display = 'none';
      }

      if (destroyOnClose) {
        this.destroyPopup = true;
      }

      this.inTransition = false;
      this.removeScrollingEffect();

      if (afterClose) {
        afterClose();
      }
    },
    onMaskClick: function onMaskClick(e) {
      // android trigger click on open (fastclick??)
      if (Date.now() - this.openTime < 300) {
        return;
      }

      if (e.target === e.currentTarget) {
        this.close(e);
      }
    },
    onKeydown: function onKeydown(e) {
      var props = this.$props;

      if (props.keyboard && e.keyCode === _util_KeyCode.ESC) {
        e.stopPropagation();
        this.close(e);
        return;
      } // keep focus inside dialog


      if (props.visible) {
        if (e.keyCode === _util_KeyCode.TAB) {
          var activeElement = document.activeElement;
          var dialogRoot = this.$refs.wrap;

          if (e.shiftKey) {
            if (activeElement === dialogRoot) {
              this.$refs.sentinel.focus();
            }
          } else if (activeElement === this.$refs.sentinel) {
            dialogRoot.focus();
          }
        }
      }
    },
    getDialogElement: function getDialogElement() {
      var h = this.$createElement;
      var closable = this.closable,
          prefixCls = this.prefixCls,
          width = this.width,
          height = this.height,
          title = this.title,
          tempFooter = this.footer,
          bodyStyle = this.bodyStyle,
          visible = this.visible,
          bodyProps = this.bodyProps;
      var dest = {};

      if (width !== undefined) {
        dest.width = typeof width === 'number' ? "".concat(width, "px") : width;
      }

      if (height !== undefined) {
        dest.height = typeof height === 'number' ? "".concat(height, "px") : height;
      }

      var footer;

      if (tempFooter) {
        footer = h("div", {
          key: 'footer',
          "class": "".concat(prefixCls, "-footer"),
          ref: 'footer'
        }, [tempFooter]);
      }

      var header;

      if (title) {
        header = h("div", {
          key: 'header',
          "class": "".concat(prefixCls, "-header"),
          ref: 'header'
        }, [h("div", {
          "class": "".concat(prefixCls, "-title"),
          attrs: {
            id: this.titleId
          }
        }, [title])]);
      }

      var closer;

      if (closable) {
        closer = h("button", {
          key: 'close',
          on: {
            "click": this.close || Dialog_noop
          },
          attrs: {
            "aria-label": 'Close'
          },
          "class": "".concat(prefixCls, "-close")
        }, [h("span", {
          "class": "".concat(prefixCls, "-close-x")
        })]);
      }

      var style = Dialog_objectSpread({}, this.dialogStyle, dest);

      var cls = Dialog_objectSpread(Dialog_defineProperty({}, prefixCls, true), this.dialogClass);

      var transitionName = this.getTransitionName();
      var dialogElement = h(vc_dialog_LazyRenderBox, {
        directives: [{
          name: "show",
          value: visible
        }],
        key: 'dialog-element',
        attrs: {
          role: 'document'
        },
        ref: 'dialog',
        style: style,
        "class": cls
      }, [h("div", {
        "class": "".concat(prefixCls, "-content")
      }, [closer, header, h("div", babel_helper_vue_jsx_merge_props_default()([{
        key: 'body',
        "class": "".concat(prefixCls, "-body"),
        style: bodyStyle,
        ref: 'body'
      }, bodyProps]), [this.$slots["default"]]), footer]), h("div", {
        attrs: {
          tabIndex: 0
        },
        ref: 'sentinel',
        style: 'width: 0px; height: 0px; overflow: hidden'
      }, ["sentinel"])]);
      var dialogTransitionProps = Object(getTransitionProps["a" /* default */])(transitionName, {
        afterLeave: this.onAnimateLeave
      });
      return h("transition", babel_helper_vue_jsx_merge_props_default()([{
        key: 'dialog'
      }, dialogTransitionProps]), [visible || !this.destroyPopup ? dialogElement : null]);
    },
    getZIndexStyle: function getZIndexStyle() {
      var style = {};
      var props = this.$props;

      if (props.zIndex !== undefined) {
        style.zIndex = props.zIndex;
      }

      return style;
    },
    getWrapStyle: function getWrapStyle() {
      return Dialog_objectSpread({}, this.getZIndexStyle(), this.wrapStyle);
    },
    getMaskStyle: function getMaskStyle() {
      return Dialog_objectSpread({}, this.getZIndexStyle(), this.maskStyle);
    },
    getMaskElement: function getMaskElement() {
      var h = this.$createElement;
      var props = this.$props;
      var maskElement;

      if (props.mask) {
        var maskTransition = this.getMaskTransitionName();
        maskElement = h(vc_dialog_LazyRenderBox, babel_helper_vue_jsx_merge_props_default()([{
          directives: [{
            name: "show",
            value: props.visible
          }],
          style: this.getMaskStyle(),
          key: 'mask',
          "class": "".concat(props.prefixCls, "-mask")
        }, props.maskProps]));

        if (maskTransition) {
          var maskTransitionProps = Object(getTransitionProps["a" /* default */])(maskTransition);
          maskElement = h("transition", babel_helper_vue_jsx_merge_props_default()([{
            key: 'mask'
          }, maskTransitionProps]), [maskElement]);
        }
      }

      return maskElement;
    },
    getMaskTransitionName: function getMaskTransitionName() {
      var props = this.$props;
      var transitionName = props.maskTransitionName;
      var animation = props.maskAnimation;

      if (!transitionName && animation) {
        transitionName = "".concat(props.prefixCls, "-").concat(animation);
      }

      return transitionName;
    },
    getTransitionName: function getTransitionName() {
      var props = this.$props;
      var transitionName = props.transitionName;
      var animation = props.animation;

      if (!transitionName && animation) {
        transitionName = "".concat(props.prefixCls, "-").concat(animation);
      }

      return transitionName;
    },
    setScrollbar: function setScrollbar() {
      if (this.bodyIsOverflowing && this.scrollbarWidth !== undefined) {
        document.body.style.paddingRight = "".concat(this.scrollbarWidth, "px");
      }
    },
    addScrollingEffect: function addScrollingEffect() {
      openCount++;

      if (openCount !== 1) {
        return;
      }

      this.checkScrollbar();
      this.setScrollbar();
      document.body.style.overflow = 'hidden'; // this.adjustDialog();
    },
    removeScrollingEffect: function removeScrollingEffect() {
      openCount--;

      if (openCount !== 0) {
        return;
      }

      document.body.style.overflow = '';
      this.resetScrollbar(); // this.resetAdjustments();
    },
    close: function close(e) {
      this.__emit('close', e);
    },
    checkScrollbar: function checkScrollbar() {
      var fullWindowWidth = window.innerWidth;

      if (!fullWindowWidth) {
        // workaround for missing window.innerWidth in IE8
        var documentElementRect = document.documentElement.getBoundingClientRect();
        fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
      }

      this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;

      if (this.bodyIsOverflowing) {
        this.scrollbarWidth = getScrollBarSize();
      }
    },
    resetScrollbar: function resetScrollbar() {
      document.body.style.paddingRight = '';
    },
    adjustDialog: function adjustDialog() {
      if (this.$refs.wrap && this.scrollbarWidth !== undefined) {
        var modalIsOverflowing = this.$refs.wrap.scrollHeight > document.documentElement.clientHeight;
        this.$refs.wrap.style.paddingLeft = "".concat(!this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '', "px");
        this.$refs.wrap.style.paddingRight = "".concat(this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : '', "px");
      }
    },
    resetAdjustments: function resetAdjustments() {
      if (this.$refs.wrap) {
        this.$refs.wrap.style.paddingLeft = this.$refs.wrap.style.paddingLeft = '';
      }
    }
  },
  render: function render() {
    var h = arguments[0];
    var prefixCls = this.prefixCls,
        maskClosable = this.maskClosable,
        visible = this.visible,
        wrapClassName = this.wrapClassName,
        title = this.title,
        wrapProps = this.wrapProps;
    var style = this.getWrapStyle(); // clear hide display
    // and only set display after async anim, not here for hide

    if (visible) {
      style.display = null;
    }

    return h("div", [this.getMaskElement(), h("div", babel_helper_vue_jsx_merge_props_default()([{
      attrs: {
        tabIndex: -1,
        role: 'dialog',
        "aria-labelledby": title ? this.titleId : null
      },
      on: {
        "keydown": this.onKeydown,
        "click": maskClosable ? this.onMaskClick : Dialog_noop
      },
      "class": "".concat(prefixCls, "-wrap ").concat(wrapClassName || ''),
      ref: 'wrap',
      style: style
    }, wrapProps]), [this.getDialogElement()])]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-dialog/DialogWrap.jsx
function DialogWrap_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DialogWrap_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function DialogWrap_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function DialogWrap_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { DialogWrap_defineProperty(target, key, source[key]); }); } return target; }

function DialogWrap_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var DialogWrap_IDialogPropTypes = vc_dialog_IDialogPropTypes();
var DialogWrap = {
  props: DialogWrap_objectSpread({}, DialogWrap_IDialogPropTypes, {
    visible: DialogWrap_IDialogPropTypes.visible.def(false)
  }),
  data: function data() {
    this.renderComponent = function () {};

    this.removeContainer = function () {};

    return {};
  },
  beforeDestroy: function beforeDestroy() {
    if (this.visible) {
      this.renderComponent({
        afterClose: this.removeContainer,
        visible: false,
        on: {
          close: function close() {}
        }
      });
    } else {
      this.removeContainer();
    }
  },
  methods: {
    getComponent: function getComponent() {
      var extra = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var h = this.$createElement;
      var $attrs = this.$attrs,
          $listeners = this.$listeners,
          $props = this.$props,
          $slots = this.$slots;

      var on = extra.on,
          otherProps = DialogWrap_objectWithoutProperties(extra, ["on"]);

      var dialogProps = {
        props: DialogWrap_objectSpread({}, $props, {
          dialogClass: Object(props_util["f" /* getClass */])(this),
          dialogStyle: Object(props_util["n" /* getStyle */])(this)
        }, otherProps),
        attrs: $attrs,
        ref: '_component',
        key: 'dialog',
        on: DialogWrap_objectSpread({}, $listeners, on)
      };
      return h(Dialog, dialogProps, [$slots["default"]]);
    },
    getContainer2: function getContainer2() {
      var container = document.createElement('div');

      if (this.getContainer) {
        this.getContainer().appendChild(container);
      } else {
        document.body.appendChild(container);
      }

      return container;
    }
  },
  render: function render() {
    var _this = this;

    var h = arguments[0];
    var visible = this.visible;
    return h(ContainerRender, {
      attrs: {
        parent: this,
        visible: visible,
        autoDestroy: false,
        getComponent: this.getComponent,
        getContainer: this.getContainer2,
        children: function children(_ref) {
          var renderComponent = _ref.renderComponent,
              removeContainer = _ref.removeContainer;
          _this.renderComponent = renderComponent;
          _this.removeContainer = removeContainer;
          return null;
        }
      }
    });
  }
};
/* harmony default export */ var vc_dialog_DialogWrap = (DialogWrap);
// CONCATENATED MODULE: ./src/components/vc-dialog/index.js
// based on vc-dialog 7.1.8

/* harmony default export */ var vc_dialog = (vc_dialog_DialogWrap);
// CONCATENATED MODULE: ./src/components/modal/Modal.jsx
function Modal_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Modal_defineProperty(target, key, source[key]); }); } return target; }

function Modal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










var ButtonType = buttonTypes().type;
var mousePosition = null;
var mousePositionEventBinded = false;

function Modal_noop() {}

var Modal_modalProps = function modalProps() {
  var defaultProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var props = {
    prefixCls: vue_types["a" /* default */].string,

    /** 对话框是否可见 */
    visible: vue_types["a" /* default */].bool,

    /** 确定按钮 loading */
    confirmLoading: vue_types["a" /* default */].bool,

    /** 标题 */
    title: vue_types["a" /* default */].any,

    /** 是否显示右上角的关闭按钮 */
    closable: vue_types["a" /* default */].bool,

    /** 点击确定回调 */
    // onOk: (e: React.MouseEvent<any>) => void,

    /** 点击模态框右上角叉、取消按钮、Props.maskClosable 值为 true 时的遮罩层或键盘按下 Esc 时的回调 */
    // onCancel: (e: React.MouseEvent<any>) => void,
    afterClose: vue_types["a" /* default */].func.def(Modal_noop),

    /** 居中 */
    centered: vue_types["a" /* default */].bool,

    /** 宽度 */
    width: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),

    /** 底部内容 */
    footer: vue_types["a" /* default */].any,

    /** 确认按钮文字 */
    okText: vue_types["a" /* default */].string,

    /** 确认按钮类型 */
    okType: ButtonType,

    /** 取消按钮文字 */
    cancelText: vue_types["a" /* default */].string,

    /** 点击蒙层是否允许关闭 */
    maskClosable: vue_types["a" /* default */].bool,
    okButtonProps: vue_types["a" /* default */].object,
    cancelButtonProps: vue_types["a" /* default */].object,
    destroyOnClose: vue_types["a" /* default */].bool,
    wrapClassName: vue_types["a" /* default */].string,
    maskTransitionName: vue_types["a" /* default */].string,
    transitionName: vue_types["a" /* default */].string,
    getContainer: vue_types["a" /* default */].func,
    zIndex: vue_types["a" /* default */].number,
    bodyStyle: vue_types["a" /* default */].object,
    maskStyle: vue_types["a" /* default */].object,
    mask: vue_types["a" /* default */].bool,
    keyboard: vue_types["a" /* default */].bool,
    wrapProps: vue_types["a" /* default */].object
  };
  return Object(props_util["q" /* initDefaultProps */])(props, defaultProps);
};

/* harmony default export */ var Modal = ({
  name: 'TaModal',
  props: Modal_modalProps({
    prefixCls: 'ant-modal',
    width: 520,
    transitionName: 'zoom',
    maskTransitionName: 'fade',
    confirmLoading: false,
    visible: false,
    okType: 'primary' // okButtonDisabled: false,
    // cancelButtonDisabled: false,

  }),
  model: {
    prop: 'visible',
    event: 'change'
  },
  // static info: ModalFunc;
  // static success: ModalFunc;
  // static error: ModalFunc;
  // static warn: ModalFunc;
  // static warning: ModalFunc;
  // static confirm: ModalFunc;
  methods: {
    handleCancel: function handleCancel(e) {
      this.$emit('cancel', e);
      this.$emit('change', false);
    },
    handleOk: function handleOk(e) {
      this.$emit('ok', e);
    },
    renderFooter: function renderFooter(locale) {
      var h = this.$createElement;
      var okType = this.okType,
          confirmLoading = this.confirmLoading;
      var cancelBtnProps = Object(props_util["t" /* mergeProps */])({
        on: {
          click: this.handleCancel
        }
      }, this.cancelButtonProps || {});
      var okBtnProps = Object(props_util["t" /* mergeProps */])({
        on: {
          click: this.handleOk
        },
        props: {
          type: okType,
          loading: confirmLoading
        }
      }, this.okButtonProps || {});
      return h("div", [h(components_button, cancelBtnProps, [Object(props_util["g" /* getComponentFromProp */])(this, 'cancelText') || locale.cancelText]), h(components_button, okBtnProps, [Object(props_util["g" /* getComponentFromProp */])(this, 'okText') || locale.okText])]);
    }
  },
  mounted: function mounted() {
    if (mousePositionEventBinded) {
      return;
    } // 只有点击事件支持从鼠标位置动画展开


    addEventListenerWrap(document.documentElement, 'click', function (e) {
      mousePosition = {
        x: e.pageX,
        y: e.pageY // 100ms 内发生过点击事件，则从点击位置动画展示
        // 否则直接 zoom 展示
        // 这样可以兼容非点击方式展开

      };
      setTimeout(function () {
        mousePosition = null;
      }, 100);
    });
    mousePositionEventBinded = true;
  },
  render: function render() {
    var h = arguments[0];
    var visible = this.visible,
        wrapClassName = this.wrapClassName,
        centered = this.centered,
        prefixCls = this.prefixCls,
        $listeners = this.$listeners,
        $slots = this.$slots;
    var defaultFooter = h(LocaleReceiver, {
      attrs: {
        componentName: 'Modal',
        defaultLocale: getConfirmLocale()
      },
      scopedSlots: {
        "default": this.renderFooter
      }
    });
    var footer = Object(props_util["g" /* getComponentFromProp */])(this, 'footer');
    var title = Object(props_util["g" /* getComponentFromProp */])(this, 'title');
    var dialogProps = {
      props: Modal_objectSpread({}, this.$props, {
        prefixCls: prefixCls,
        wrapClassName: classnames_default()(Modal_defineProperty({}, "".concat(prefixCls, "-centered"), !!centered), wrapClassName),
        title: title,
        footer: footer === undefined ? defaultFooter : footer,
        visible: visible,
        mousePosition: mousePosition
      }),
      on: Modal_objectSpread({}, $listeners, {
        close: this.handleCancel
      }),
      "class": Object(props_util["f" /* getClass */])(this),
      style: Object(props_util["n" /* getStyle */])(this)
    };
    return h(vc_dialog, dialogProps, [$slots["default"]]);
  }
});
// CONCATENATED MODULE: ./src/components/modal/ActionButton.jsx




var ActionButton_ButtonType = buttonTypes().type;
var ActionButtonProps = {
  type: ActionButton_ButtonType,
  actionFn: vue_types["a" /* default */].func,
  closeModal: vue_types["a" /* default */].func,
  autoFocus: vue_types["a" /* default */].bool
};
/* harmony default export */ var ActionButton = ({
  mixins: [BaseMixin["a" /* default */]],
  props: ActionButtonProps,
  data: function data() {
    return {
      loading: false
    };
  },
  mounted: function mounted() {
    var _this = this;

    if (this.autoFocus) {
      this.timeoutId = setTimeout(function () {
        return _this.$el.focus();
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    clearTimeout(this.timeoutId);
  },
  methods: {
    onClick: function onClick() {
      var _this2 = this;

      var actionFn = this.actionFn,
          closeModal = this.closeModal;

      if (actionFn) {
        var ret;

        if (actionFn.length) {
          ret = actionFn(closeModal);
        } else {
          ret = actionFn();

          if (!ret) {
            closeModal();
          }
        }

        if (ret && ret.then) {
          this.setState({
            loading: true
          });
          ret.then(function () {
            // It's unnecessary to set loading=false, for the Modal will be unmounted after close.
            // this.setState({ loading: false });
            closeModal.apply(void 0, arguments);
          }, function () {
            // See: https://github.com/ant-design/ant-design/issues/6183
            _this2.setState({
              loading: false
            });
          });
        }
      } else {
        closeModal();
      }
    }
  },
  render: function render() {
    var h = arguments[0];
    var type = this.type,
        $slots = this.$slots,
        loading = this.loading;
    return h(components_button, {
      attrs: {
        type: type,
        loading: loading
      },
      on: {
        "click": this.onClick
      }
    }, [$slots["default"]]);
  }
});
// CONCATENATED MODULE: ./src/components/modal/ConfirmDialog.jsx
function ConfirmDialog_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






/* harmony default export */ var ConfirmDialog = ({
  functional: true,
  render: function render(h, context) {
    var props = context.props;
    var onCancel = props.onCancel,
        onOk = props.onOk,
        close = props.close,
        zIndex = props.zIndex,
        afterClose = props.afterClose,
        visible = props.visible,
        keyboard = props.keyboard,
        centered = props.centered;
    var iconType = props.iconType || 'question-circle';
    var okType = props.okType || 'primary';
    var prefixCls = props.prefixCls || 'ant-confirm'; // 默认为 true，保持向下兼容

    var okCancel = 'okCancel' in props ? props.okCancel : true;
    var width = props.width || 416;
    var style = props.style || {}; // 默认为 false，保持旧版默认行为

    var maskClosable = props.maskClosable === undefined ? false : props.maskClosable;
    var runtimeLocale = getConfirmLocale();
    var okText = props.okText || (okCancel ? runtimeLocale.okText : runtimeLocale.justOkText);
    var cancelText = props.cancelText || runtimeLocale.cancelText;
    var classString = classnames_default()(prefixCls, "".concat(prefixCls, "-").concat(props.type));
    var cancelButton = okCancel && h(ActionButton, {
      attrs: {
        actionFn: onCancel,
        closeModal: close
      }
    }, [cancelText]);
    return h(Modal, {
      "class": classString,
      attrs: {
        wrapClassName: classnames_default()(ConfirmDialog_defineProperty({}, "".concat(prefixCls, "-centered"), !!centered)),
        visible: visible,
        title: '',
        transitionName: 'zoom',
        footer: '',
        maskTransitionName: 'fade',
        maskClosable: maskClosable,
        width: width,
        zIndex: zIndex,
        afterClose: afterClose,
        keyboard: keyboard
      },
      on: {
        "cancel": function cancel(e) {
          return close({
            triggerCancel: true
          }, e);
        }
      },
      style: style
    }, [h("div", {
      "class": "".concat(prefixCls, "-body-wrapper")
    }, [h("div", {
      "class": "".concat(prefixCls, "-body")
    }, [h(components_icon, {
      attrs: {
        type: iconType
      }
    }), h("span", {
      "class": "".concat(prefixCls, "-title")
    }, [props.title]), h("div", {
      "class": "".concat(prefixCls, "-content")
    }, [props.content])]), h("div", {
      "class": "".concat(prefixCls, "-btns")
    }, [cancelButton, h(ActionButton, {
      attrs: {
        type: okType,
        actionFn: onOk,
        closeModal: close,
        autoFocus: true
      }
    }, [okText])])])]);
  }
});
// CONCATENATED MODULE: ./src/components/modal/confirm.js
function confirm_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      confirm_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function confirm_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



function confirm_confirm(config) {
  var div = document.createElement('div');
  var el = document.createElement('div');
  div.appendChild(el);
  document.body.appendChild(div);
  var confirmDialogInstance = null;

  function close() {
    destroy.apply(void 0, arguments);
  }

  function destroy() {
    if (confirmDialogInstance && div.parentNode) {
      confirmDialogInstance.$destroy();
      confirmDialogInstance = null;
      div.parentNode.removeChild(div);
    }

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var triggerCancel = args && args.length && args.some(function (param) {
      return param && param.triggerCancel;
    });

    if (config.onCancel && triggerCancel) {
      config.onCancel.apply(config, args);
    }
  }

  function render(props) {
    var confirmDialogProps = {
      props: props
    };
    return new external_Vue_default.a({
      el: el,
      render: function render() {
        var h = arguments[0];
        return h(ConfirmDialog, confirmDialogProps);
      }
    });
  }

  confirmDialogInstance = render(confirm_objectSpread({}, config, {
    visible: true,
    close: close
  }));
  return {
    destroy: close
  };
}
// CONCATENATED MODULE: ./src/components/modal/index.js
function modal_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      modal_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function modal_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


 // export { ActionButtonProps } from './ActionButton'
// export { ModalProps, ModalFuncProps } from './Modal'

var modal_info = function info(props) {
  var config = modal_objectSpread({
    type: 'info',
    iconType: 'info-circle',
    okCancel: false
  }, props);

  return confirm_confirm(config);
};

var modal_success = function success(props) {
  var config = modal_objectSpread({
    type: 'success',
    iconType: 'check-circle',
    okCancel: false
  }, props);

  return confirm_confirm(config);
};

var modal_error = function error(props) {
  var config = modal_objectSpread({
    type: 'error',
    iconType: 'cross-circle',
    okCancel: false
  }, props);

  return confirm_confirm(config);
};

var modal_warning = function warning(props) {
  var config = modal_objectSpread({
    type: 'warning',
    iconType: 'exclamation-circle',
    okCancel: false
  }, props);

  return confirm_confirm(config);
};

var warn = modal_warning;

var modal_confirm = function confirm(props) {
  var config = modal_objectSpread({
    type: 'confirm',
    okCancel: true
  }, props);

  return confirm_confirm(config);
};

Modal.info = modal_info;
Modal.success = modal_success;
Modal.error = modal_error;
Modal.warning = modal_warning;
Modal.warn = warn;
Modal.confirm = modal_confirm;
/* istanbul ignore next */

Modal.install = function (Vue) {
  Vue.component(Modal.name, Modal);
};

/* harmony default export */ var modal = (Modal);
// CONCATENATED MODULE: ./src/components/notification/index.js
function notification_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      notification_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function notification_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


 // export type NotificationPlacement = 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';
// export type IconType = 'success' | 'info' | 'error' | 'warning';

var notificationInstance = {};
var notification_defaultDuration = 4.5;
var notification_defaultTop = '24px';
var defaultBottom = '24px';
var defaultPlacement = 'topRight';

var defaultGetContainer = function defaultGetContainer() {
  return document.body;
}; // export interface ConfigProps {
//   top?: number;
//   bottom?: number;
//   duration?: number;
//   placement?: NotificationPlacement;
//   getContainer?: () => HTMLElement;
// }


function setNotificationConfig(options) {
  var duration = options.duration,
      placement = options.placement,
      bottom = options.bottom,
      top = options.top,
      getContainer = options.getContainer;

  if (duration !== undefined) {
    notification_defaultDuration = duration;
  }

  if (placement !== undefined) {
    defaultPlacement = placement;
  }

  if (bottom !== undefined) {
    defaultBottom = typeof bottom === 'number' ? "".concat(bottom, "px") : bottom;
  }

  if (top !== undefined) {
    notification_defaultTop = typeof top === 'number' ? "".concat(top, "px") : top;
  }

  if (getContainer !== undefined) {
    defaultGetContainer = getContainer;
  }
}

function getPlacementStyle(placement) {
  var style;

  switch (placement) {
    case 'topLeft':
      style = {
        left: 0,
        top: notification_defaultTop,
        bottom: 'auto'
      };
      break;

    case 'topRight':
      style = {
        right: 0,
        top: notification_defaultTop,
        bottom: 'auto'
      };
      break;

    case 'bottomLeft':
      style = {
        left: 0,
        top: 'auto',
        bottom: defaultBottom
      };
      break;

    default:
      style = {
        right: 0,
        top: 'auto',
        bottom: defaultBottom
      };
      break;
  }

  return style;
}

function getNotificationInstance(prefixCls, placement, callback) {
  var cacheKey = "".concat(prefixCls, "-").concat(placement);

  if (notificationInstance[cacheKey]) {
    callback(notificationInstance[cacheKey]);
    return;
  }

  vc_notification.newInstance({
    prefixCls: prefixCls,
    "class": "".concat(prefixCls, "-").concat(placement),
    style: getPlacementStyle(placement),
    getContainer: defaultGetContainer
  }, function (notification) {
    notificationInstance[cacheKey] = notification;
    callback(notification);
  });
}

var typeToIcon = {
  success: 'check-circle-o',
  info: 'info-circle-o',
  error: 'cross-circle-o',
  warning: 'exclamation-circle-o' // export interface ArgsProps {
  //   message: React.ReactNode;
  //   description: React.ReactNode;
  //   btn?: React.ReactNode;
  //   key?: string;
  //   onClose?: () => void;
  //   duration?: number | null;
  //   icon?: React.ReactNode;
  //   placement?: NotificationPlacement;
  //   style?: React.CSSProperties;
  //   prefixCls?: string;
  //   className?: string;
  //   readonly type?: IconType;
  // }

};

function notification_notice(args) {
  var icon = args.icon,
      type = args.type,
      description = args.description,
      placement = args.placement,
      message = args.message,
      btn = args.btn;
  var outerPrefixCls = args.prefixCls || 'ant-notification';
  var prefixCls = "".concat(outerPrefixCls, "-notice");
  var duration = args.duration === undefined ? notification_defaultDuration : args.duration;
  var iconNode = null;

  if (icon) {
    iconNode = function iconNode(h) {
      return h("span", {
        "class": "".concat(prefixCls, "-icon")
      }, [typeof icon === 'function' ? icon(h) : icon]);
    };
  } else if (type) {
    var iconType = typeToIcon[type];

    iconNode = function iconNode(h) {
      return h(components_icon, {
        "class": "".concat(prefixCls, "-icon ").concat(prefixCls, "-icon-").concat(type),
        attrs: {
          type: iconType
        }
      });
    };
  }

  getNotificationInstance(outerPrefixCls, placement || defaultPlacement, function (notification) {
    notification.notice({
      content: function content(h) {
        return h("div", {
          "class": iconNode ? "".concat(prefixCls, "-with-icon") : ''
        }, [iconNode && iconNode(h), h("div", {
          "class": "".concat(prefixCls, "-message")
        }, [!description && iconNode ? h("span", {
          "class": "".concat(prefixCls, "-message-single-line-auto-margin")
        }) : null, typeof message === 'function' ? message(h) : message]), h("div", {
          "class": "".concat(prefixCls, "-description")
        }, [typeof description === 'function' ? description(h) : description]), btn ? h("span", {
          "class": "".concat(prefixCls, "-btn")
        }, [typeof btn === 'function' ? btn(h) : btn]) : null]);
      },
      duration: duration,
      closable: true,
      onClose: args.onClose,
      key: args.key,
      style: args.style || {},
      "class": args["class"]
    });
  });
}

var api = {
  open: notification_notice,
  close: function close(key) {
    Object.keys(notificationInstance).forEach(function (cacheKey) {
      return notificationInstance[cacheKey].removeNotice(key);
    });
  },
  config: setNotificationConfig,
  destroy: function destroy() {
    Object.keys(notificationInstance).forEach(function (cacheKey) {
      notificationInstance[cacheKey].destroy();
      delete notificationInstance[cacheKey];
    });
  }
};
['success', 'info', 'warning', 'error'].forEach(function (type) {
  api[type] = function (args) {
    return api.open(notification_objectSpread({}, args, {
      type: type
    }));
  };
});
api.warn = api.warning; // export interface NotificationApi {
//   success(args: ArgsProps): void;
//   error(args: ArgsProps): void;
//   info(args: ArgsProps): void;
//   warn(args: ArgsProps): void;
//   warning(args: ArgsProps): void;
//   open(args: ArgsProps): void;
//   close(key: string): void;
//   config(options: ConfigProps): void;
//   destroy(): void;
// }

/* harmony default export */ var notification = (api);
// CONCATENATED MODULE: ./src/components/popconfirm/index.jsx
function popconfirm_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { popconfirm_defineProperty(target, key, source[key]); }); } return target; }

function popconfirm_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












var popconfirm_tooltipProps = abstractTooltipProps();
var popconfirm_btnProps = buttonTypes();
var Popconfirm = {
  name: 'TaPopconfirm',
  props: popconfirm_objectSpread({}, popconfirm_tooltipProps, {
    prefixCls: vue_types["a" /* default */].string.def('ant-popover'),
    transitionName: vue_types["a" /* default */].string.def('zoom-big'),
    content: vue_types["a" /* default */].any,
    title: vue_types["a" /* default */].any,
    trigger: popconfirm_tooltipProps.trigger.def('click'),
    okType: popconfirm_btnProps.type.def('primary'),
    okText: vue_types["a" /* default */].any,
    cancelText: vue_types["a" /* default */].any,
    icon: vue_types["a" /* default */].any
  }),
  mixins: [BaseMixin["a" /* default */]],
  model: {
    prop: 'visible',
    event: 'visibleChange'
  },
  watch: {
    visible: function visible(val) {
      this.sVisible = val;
    }
  },
  data: function data() {
    return {
      sVisible: this.$props.visible
    };
  },
  methods: {
    onConfirm: function onConfirm(e) {
      this.setVisible(false);
      this.$emit('confirm', e);
    },
    onCancel: function onCancel(e) {
      this.setVisible(false);
      this.$emit('cancel', e);
    },
    onVisibleChange: function onVisibleChange(sVisible) {
      this.setVisible(sVisible);
    },
    setVisible: function setVisible(sVisible) {
      if (!Object(props_util["p" /* hasProp */])(this, 'visible')) {
        this.setState({
          sVisible: sVisible
        });
      }

      this.$emit('visibleChange', sVisible);
    },
    getPopupDomNode: function getPopupDomNode() {
      return this.$refs.tooltip.getPopupDomNode();
    },
    renderOverlay: function renderOverlay(popconfirmLocale) {
      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          okType = this.okType;
      var icon = Object(props_util["g" /* getComponentFromProp */])(this, 'icon') || h(components_icon, {
        attrs: {
          type: 'exclamation-circle'
        }
      });
      return h("div", {
        "class": "".concat(prefixCls, "-inner-content")
      }, [h("div", {
        "class": "".concat(prefixCls, "-message")
      }, [icon, h("div", {
        "class": "".concat(prefixCls, "-message-title")
      }, [Object(props_util["g" /* getComponentFromProp */])(this, 'title')])]), h("div", {
        "class": "".concat(prefixCls, "-buttons")
      }, [h(components_button, {
        on: {
          "click": this.onCancel
        },
        attrs: {
          size: 'small'
        }
      }, [Object(props_util["g" /* getComponentFromProp */])(this, 'cancelText') || popconfirmLocale.cancelText]), h(components_button, {
        on: {
          "click": this.onConfirm
        },
        attrs: {
          type: okType,
          size: 'small'
        }
      }, [Object(props_util["g" /* getComponentFromProp */])(this, 'okText') || popconfirmLocale.okText])])]);
    }
  },
  render: function render(h) {
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var otherProps = Object(es["a" /* default */])(props, ['title', 'content', 'cancelText', 'okText']);
    var tooltipProps = {
      props: popconfirm_objectSpread({}, otherProps, {
        visible: this.sVisible
      }),
      ref: 'tooltip',
      on: {
        visibleChange: this.onVisibleChange
      }
    };
    var overlay = h(LocaleReceiver, {
      attrs: {
        componentName: 'Popconfirm',
        defaultLocale: locale_provider_default.Popconfirm
      },
      scopedSlots: {
        "default": this.renderOverlay
      }
    });
    return h(tooltip, tooltipProps, [h("template", {
      slot: 'title'
    }, [overlay]), this.$slots["default"]]);
  }
};
/* istanbul ignore next */

Popconfirm.install = function (Vue) {
  Vue.component(Popconfirm.name, Popconfirm);
};

/* harmony default export */ var popconfirm = (Popconfirm);
// CONCATENATED MODULE: ./src/components/vc-progress/src/enhancer.js
function enhancer(Component) {
  return {
    mixins: [Component],
    updated: function updated() {
      var _this = this;

      this.$nextTick(function () {
        if (!_this.$refs.svgPathRef) {
          return;
        }

        var pathStyle = _this.$refs.svgPathRef.style;
        pathStyle.transitionDuration = '.3s, .3s, .3s, .06s';
        var now = Date.now();

        if (_this.prevTimeStamp && now - _this.prevTimeStamp < 100) {
          pathStyle.transitionDuration = '0s, 0s';
        }

        _this.prevTimeStamp = Date.now();
      });
    }
  };
}

/* harmony default export */ var src_enhancer = (enhancer);
// CONCATENATED MODULE: ./src/components/vc-progress/src/types.js

var types_defaultProps = {
  // className: '',
  percent: 0,
  prefixCls: 'rc-progress',
  strokeColor: '#2db7f5',
  strokeLinecap: 'round',
  strokeWidth: 1,
  // style: {},
  trailColor: '#D9D9D9',
  trailWidth: 1
};
var types_propTypes = {
  // className: PropTypes.string,
  percent: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string]),
  prefixCls: vue_types["a" /* default */].string,
  strokeColor: vue_types["a" /* default */].string,
  strokeLinecap: vue_types["a" /* default */].oneOf(['butt', 'round', 'square']),
  strokeWidth: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string]),
  // style: PropTypes.object,
  trailColor: vue_types["a" /* default */].string,
  trailWidth: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string])
};
// CONCATENATED MODULE: ./src/components/vc-progress/src/Line.js


function Line_objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = Line_objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function Line_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}




var Line = {
  props: Object(props_util["q" /* initDefaultProps */])(types_propTypes, types_defaultProps),
  render: function render() {
    var h = arguments[0];

    var _this$$props = this.$props,
        percent = _this$$props.percent,
        prefixCls = _this$$props.prefixCls,
        strokeColor = _this$$props.strokeColor,
        strokeLinecap = _this$$props.strokeLinecap,
        strokeWidth = _this$$props.strokeWidth,
        trailColor = _this$$props.trailColor,
        trailWidth = _this$$props.trailWidth,
        restProps = Line_objectWithoutProperties(_this$$props, ["percent", "prefixCls", "strokeColor", "strokeLinecap", "strokeWidth", "trailColor", "trailWidth"]);

    delete restProps.gapPosition;
    var pathStyle = {
      strokeDasharray: '100px, 100px',
      strokeDashoffset: "".concat(100 - percent, "px"),
      transition: 'stroke-dashoffset 0.3s ease 0s, stroke 0.3s linear'
    };
    var center = strokeWidth / 2;
    var right = 100 - strokeWidth / 2;
    var pathString = "M ".concat(strokeLinecap === 'round' ? center : 0, ",").concat(center, "\n           L ").concat(strokeLinecap === 'round' ? right : 100, ",").concat(center);
    var viewBoxString = "0 0 100 ".concat(strokeWidth);
    var pathFirst = {
      attrs: {
        'd': pathString,
        'stroke-linecap': strokeLinecap,
        'stroke': trailColor,
        'stroke-width': trailWidth || strokeWidth,
        'fill-opacity': '0'
      },
      "class": "".concat(prefixCls, "-line-trail")
    };
    var pathSecond = {
      attrs: {
        'd': pathString,
        'stroke-linecap': strokeLinecap,
        'stroke': strokeColor,
        'stroke-width': strokeWidth,
        'fill-opacity': '0'
      },
      "class": "".concat(prefixCls, "-line-path"),
      style: pathStyle,
      ref: 'svgPathRef'
    };
    return h("svg", babel_helper_vue_jsx_merge_props_default()([{
      "class": "".concat(prefixCls, "-line"),
      attrs: {
        viewBox: viewBoxString,
        preserveAspectRatio: 'none'
      }
    }, restProps]), [h("path", pathFirst), h("path", pathSecond)]);
  }
};
/* harmony default export */ var src_Line = (src_enhancer(Line));
// CONCATENATED MODULE: ./src/components/vc-progress/src/Circle.js


function Circle_objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = Circle_objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function Circle_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function Circle_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      Circle_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function Circle_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}






var circlePropTypes = Circle_objectSpread({}, types_propTypes, {
  gapPosition: vue_types["a" /* default */].oneOf(['top', 'bottom', 'left', 'right']),
  gapDegree: vue_types["a" /* default */].number
});

var circleDefaultProps = Circle_objectSpread({}, types_defaultProps, {
  gapPosition: 'top'
});

var Circle = {
  props: Object(props_util["q" /* initDefaultProps */])(circlePropTypes, circleDefaultProps),
  methods: {
    getPathStyles: function getPathStyles() {
      var _this$$props = this.$props,
          percent = _this$$props.percent,
          strokeWidth = _this$$props.strokeWidth,
          _this$$props$gapDegre = _this$$props.gapDegree,
          gapDegree = _this$$props$gapDegre === void 0 ? 0 : _this$$props$gapDegre,
          gapPosition = _this$$props.gapPosition;
      var radius = 50 - strokeWidth / 2;
      var beginPositionX = 0;
      var beginPositionY = -radius;
      var endPositionX = 0;
      var endPositionY = -2 * radius;

      switch (gapPosition) {
        case 'left':
          beginPositionX = -radius;
          beginPositionY = 0;
          endPositionX = 2 * radius;
          endPositionY = 0;
          break;

        case 'right':
          beginPositionX = radius;
          beginPositionY = 0;
          endPositionX = -2 * radius;
          endPositionY = 0;
          break;

        case 'bottom':
          beginPositionY = radius;
          endPositionY = 2 * radius;
          break;

        default:
      }

      var pathString = "M 50,50 m ".concat(beginPositionX, ",").concat(beginPositionY, "\n       a ").concat(radius, ",").concat(radius, " 0 1 1 ").concat(endPositionX, ",").concat(-endPositionY, "\n       a ").concat(radius, ",").concat(radius, " 0 1 1 ").concat(-endPositionX, ",").concat(endPositionY);
      var len = Math.PI * 2 * radius;
      var trailPathStyle = {
        strokeDasharray: "".concat(len - gapDegree, "px ").concat(len, "px"),
        strokeDashoffset: "-".concat(gapDegree / 2, "px"),
        transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s'
      };
      var strokePathStyle = {
        strokeDasharray: "".concat(percent / 100 * (len - gapDegree), "px ").concat(len, "px"),
        strokeDashoffset: "-".concat(gapDegree / 2, "px"),
        transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s' // eslint-disable-line

      };
      return {
        pathString: pathString,
        trailPathStyle: trailPathStyle,
        strokePathStyle: strokePathStyle
      };
    }
  },
  render: function render() {
    var h = arguments[0];

    var _this$$props2 = this.$props,
        prefixCls = _this$$props2.prefixCls,
        strokeWidth = _this$$props2.strokeWidth,
        trailWidth = _this$$props2.trailWidth,
        strokeColor = _this$$props2.strokeColor,
        trailColor = _this$$props2.trailColor,
        strokeLinecap = _this$$props2.strokeLinecap,
        percent = _this$$props2.percent,
        restProps = Circle_objectWithoutProperties(_this$$props2, ["prefixCls", "strokeWidth", "trailWidth", "strokeColor", "trailColor", "strokeLinecap", "percent"]);

    var _this$getPathStyles = this.getPathStyles(),
        pathString = _this$getPathStyles.pathString,
        trailPathStyle = _this$getPathStyles.trailPathStyle,
        strokePathStyle = _this$getPathStyles.strokePathStyle;

    delete restProps.percent;
    delete restProps.gapDegree;
    delete restProps.gapPosition;
    var pathFirst = {
      attrs: {
        'd': pathString,
        'stroke': trailColor,
        'stroke-width': trailWidth || strokeWidth,
        'fill-opacity': '0'
      },
      "class": "".concat(prefixCls, "-circle-trail"),
      style: trailPathStyle
    };
    var pathSecond = {
      attrs: {
        'd': pathString,
        'stroke-linecap': strokeLinecap,
        'stroke': strokeColor,
        'stroke-width': percent === 0 ? 0 : strokeWidth,
        'fill-opacity': '0'
      },
      "class": "".concat(prefixCls, "-circle-path"),
      style: strokePathStyle,
      ref: 'svgPathRef'
    };
    return h("svg", babel_helper_vue_jsx_merge_props_default()([{
      "class": "".concat(prefixCls, "-circle"),
      attrs: {
        viewBox: '0 0 100 100'
      }
    }, restProps]), [h("path", pathFirst), percent > 0 ? h("path", pathSecond) : null]);
  }
};
/* harmony default export */ var src_Circle = (src_enhancer(Circle));
// CONCATENATED MODULE: ./src/components/vc-progress/src/index.js



/* harmony default export */ var vc_progress_src = ({
  Line: src_Line,
  Circle: src_Circle
});
// CONCATENATED MODULE: ./src/components/vc-progress/index.js
// based on rc-progress 2.2.5


/* harmony default export */ var vc_progress = (vc_progress_src);
// CONCATENATED MODULE: ./src/components/progress/progress.jsx
function progress_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { progress_defineProperty(target, key, source[key]); }); } return target; }

function progress_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function progress_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = progress_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function progress_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







function addUnit(num, unit) {
  var unitType = unit || 'px';
  return num ? num + unitType : null;
}

var statusColorMap = {
  normal: '#108ee9',
  exception: '#ff5500',
  success: '#87d068'
};
var ProgressType = vue_types["a" /* default */].oneOf(['line', 'circle', 'dashboard']);
var ProgressSize = vue_types["a" /* default */].oneOf(['default', 'small']);
var ProgressProps = {
  prefixCls: vue_types["a" /* default */].string,
  type: ProgressType,
  percent: vue_types["a" /* default */].number,
  successPercent: vue_types["a" /* default */].number,
  format: vue_types["a" /* default */].func,
  status: vue_types["a" /* default */].oneOf(['success', 'active', 'exception']),
  showInfo: vue_types["a" /* default */].bool,
  strokeWidth: vue_types["a" /* default */].number,
  strokeLinecap: vue_types["a" /* default */].oneOf(['round', 'square']),
  strokeColor: vue_types["a" /* default */].string,
  trailColor: vue_types["a" /* default */].string,
  width: vue_types["a" /* default */].number,
  gapDegree: vue_types["a" /* default */].number,
  gapPosition: vue_types["a" /* default */].oneOf(['top', 'bottom', 'left', 'right']),
  size: ProgressSize
};

var validProgress = function validProgress(progress) {
  if (!progress || progress < 0) {
    return 0;
  } else if (progress > 100) {
    return 100;
  }

  return progress;
};

/* harmony default export */ var progress_progress = ({
  name: 'TaProgress',
  props: Object(props_util["q" /* initDefaultProps */])(ProgressProps, {
    type: 'line',
    percent: 0,
    showInfo: true,
    trailColor: '#f3f3f3',
    prefixCls: 'ant-progress',
    size: 'default'
  }),
  render: function render() {
    var _classNames;

    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);

    var prefixCls = props.prefixCls,
        _props$percent = props.percent,
        percent = _props$percent === void 0 ? 0 : _props$percent,
        status = props.status,
        format = props.format,
        trailColor = props.trailColor,
        size = props.size,
        successPercent = props.successPercent,
        type = props.type,
        strokeWidth = props.strokeWidth,
        width = props.width,
        showInfo = props.showInfo,
        _props$gapDegree = props.gapDegree,
        gapDegree = _props$gapDegree === void 0 ? 0 : _props$gapDegree,
        gapPosition = props.gapPosition,
        strokeColor = props.strokeColor,
        _props$strokeLinecap = props.strokeLinecap,
        strokeLinecap = _props$strokeLinecap === void 0 ? 'round' : _props$strokeLinecap,
        restProps = progress_objectWithoutProperties(props, ["prefixCls", "percent", "status", "format", "trailColor", "size", "successPercent", "type", "strokeWidth", "width", "showInfo", "gapDegree", "gapPosition", "strokeColor", "strokeLinecap"]);

    var progressStatus = parseInt(successPercent ? successPercent.toString() : percent.toString(), 10) >= 100 && !('status' in props) ? 'success' : status || 'normal';
    var progressInfo;
    var progress;

    var textFormatter = format || function (percentNumber) {
      return "".concat(percentNumber, "%");
    };

    if (showInfo) {
      var text;
      var iconType = type === 'circle' || type === 'dashboard' ? '' : '-circle';

      if (format || progressStatus !== 'exception' && progressStatus !== 'success') {
        text = textFormatter(validProgress(percent), validProgress(successPercent));
      } else if (progressStatus === 'exception') {
        text = h(components_icon, {
          attrs: {
            type: "cross".concat(iconType)
          }
        });
      } else if (progressStatus === 'success') {
        text = h(components_icon, {
          attrs: {
            type: "check".concat(iconType)
          }
        });
      }

      progressInfo = h("span", {
        "class": "".concat(prefixCls, "-text")
      }, [text]);
    }

    if (type === 'line') {
      var percentStyle = {
        width: "".concat(validProgress(percent), "%"),
        height: "".concat(strokeWidth || (size === 'small' ? 6 : 8), "px"),
        background: strokeColor,
        borderRadius: strokeLinecap === 'square' ? 0 : '100px'
      };
      var successPercentStyle = {
        width: "".concat(validProgress(successPercent), "%"),
        height: "".concat(strokeWidth || (size === 'small' ? 6 : 8), "px"),
        borderRadius: strokeLinecap === 'square' ? 0 : '100px'
      };
      var successSegment = successPercent !== undefined ? h("div", {
        "class": "".concat(prefixCls, "-success-bg"),
        style: successPercentStyle
      }) : null;
      progress = h("div", [h("div", {
        "class": "".concat(prefixCls, "-outer")
      }, [h("div", {
        "class": "".concat(prefixCls, "-inner")
      }, [h("div", {
        "class": "".concat(prefixCls, "-bg"),
        style: percentStyle
      }), successSegment])]), progressInfo]);
    } else if (type === 'circle' || type === 'dashboard') {
      var circleSize = width || 120;
      var circleStyle = {
        width: addUnit(circleSize),
        height: addUnit(circleSize),
        fontSize: addUnit(circleSize * 0.15 + 6)
      };
      var circleWidth = strokeWidth || 6;
      var gapPos = gapPosition || type === 'dashboard' && 'bottom' || 'top';
      var gapDeg = gapDegree || type === 'dashboard' && 75;
      progress = h("div", {
        "class": "".concat(prefixCls, "-inner"),
        style: circleStyle
      }, [h(src_Circle, {
        attrs: {
          percent: validProgress(percent),
          strokeWidth: circleWidth,
          trailWidth: circleWidth,
          strokeColor: statusColorMap[progressStatus],
          strokeLinecap: strokeLinecap,
          trailColor: trailColor,
          prefixCls: prefixCls,
          gapDegree: gapDeg || 0,
          gapPosition: gapPos
        }
      }), progressInfo]);
    }

    var classString = classnames_default()(prefixCls, (_classNames = {}, progress_defineProperty(_classNames, "".concat(prefixCls, "-").concat(type === 'dashboard' && 'circle' || type), true), progress_defineProperty(_classNames, "".concat(prefixCls, "-status-").concat(progressStatus), true), progress_defineProperty(_classNames, "".concat(prefixCls, "-show-info"), showInfo), progress_defineProperty(_classNames, "".concat(prefixCls, "-").concat(size), size), _classNames));
    var progressProps = {
      props: progress_objectSpread({}, restProps),
      on: this.$listeners,
      "class": classString
    };
    return h("div", progressProps, [progress]);
  }
});
// CONCATENATED MODULE: ./src/components/progress/index.jsx


/* istanbul ignore next */

progress_progress.install = function (Vue) {
  Vue.component(progress_progress.name, progress_progress);
};

/* harmony default export */ var components_progress = (progress_progress);
// CONCATENATED MODULE: ./src/components/vc-rate/src/util.js
function util_getScroll(w, top) {
  var ret = top ? w.pageYOffset : w.pageXOffset;
  var method = top ? 'scrollTop' : 'scrollLeft';

  if (typeof ret !== 'number') {
    var d = w.document; // ie6,7,8 standard mode

    ret = d.documentElement[method];

    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }

  return ret;
}

function util_getClientPosition(elem) {
  var x;
  var y;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  var box = elem.getBoundingClientRect();
  x = box.left;
  y = box.top;
  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x,
    top: y
  };
}

function getOffsetLeft(el) {
  var pos = util_getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += util_getScroll(w);
  return pos.left;
}
// CONCATENATED MODULE: ./src/components/vc-rate/src/Star.jsx


function Star_noop() {}

/* harmony default export */ var Star = ({
  name: 'Star',
  props: {
    value: vue_types["a" /* default */].number,
    index: vue_types["a" /* default */].number,
    prefixCls: vue_types["a" /* default */].string,
    allowHalf: vue_types["a" /* default */].bool,
    disabled: vue_types["a" /* default */].bool,
    character: vue_types["a" /* default */].any,
    focused: vue_types["a" /* default */].bool
  },
  methods: {
    onHover: function onHover(e) {
      var index = this.index;
      this.$emit('hover', e, index);
    },
    onClick: function onClick(e) {
      var index = this.index;
      this.$emit('click', e, index);
    },
    getClassName: function getClassName() {
      var prefixCls = this.prefixCls,
          index = this.index,
          value = this.value,
          allowHalf = this.allowHalf,
          focused = this.focused;
      var starValue = index + 1;
      var className = prefixCls;

      if (value === 0 && index === 0 && focused) {
        className += " ".concat(prefixCls, "-focused");
      } else if (allowHalf && value + 0.5 === starValue) {
        className += " ".concat(prefixCls, "-half ").concat(prefixCls, "-active");

        if (focused) {
          className += " ".concat(prefixCls, "-focused");
        }
      } else {
        className += starValue <= value ? " ".concat(prefixCls, "-full") : " ".concat(prefixCls, "-zero");

        if (starValue === value && focused) {
          className += " ".concat(prefixCls, "-focused");
        }
      }

      return className;
    }
  },
  render: function render() {
    var h = arguments[0];
    var onHover = this.onHover,
        onClick = this.onClick,
        disabled = this.disabled,
        prefixCls = this.prefixCls;
    var character = this.character;

    if (character === undefined) {
      character = this.$slots.character;
    }

    return h("li", {
      "class": this.getClassName(),
      on: {
        "click": disabled ? Star_noop : onClick,
        "mousemove": disabled ? Star_noop : onHover
      }
    }, [h("div", {
      "class": "".concat(prefixCls, "-first")
    }, [character]), h("div", {
      "class": "".concat(prefixCls, "-second")
    }, [character])]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-rate/src/Rate.jsx







var Rate_rateProps = {
  disabled: vue_types["a" /* default */].bool,
  value: vue_types["a" /* default */].number,
  defaultValue: vue_types["a" /* default */].number,
  count: vue_types["a" /* default */].number,
  allowHalf: vue_types["a" /* default */].bool,
  allowClear: vue_types["a" /* default */].bool,
  prefixCls: vue_types["a" /* default */].string,
  character: vue_types["a" /* default */].any,
  tabIndex: vue_types["a" /* default */].number,
  autoFocus: vue_types["a" /* default */].bool
};

function Rate_noop() {}

/* harmony default export */ var Rate = ({
  name: 'Rate',
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(Rate_rateProps, {
    defaultValue: 0,
    count: 5,
    allowHalf: false,
    allowClear: true,
    prefixCls: 'rc-rate',
    tabIndex: 0,
    character: '★'
  }),
  model: {
    prop: 'value',
    event: 'change'
  },
  data: function data() {
    var value = this.value;

    if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
      value = this.defaultValue;
    }

    return {
      sValue: value,
      focused: false,
      cleanedValue: null,
      hoverValue: undefined
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      if (_this.autoFocus && !_this.disabled) {
        _this.focus();
      }
    });
  },
  watch: {
    value: function value(val) {
      this.setState({
        sValue: val
      });
    }
  },
  methods: {
    onHover: function onHover(event, index) {
      var hoverValue = this.getStarValue(index, event.pageX);
      var cleanedValue = this.cleanedValue;

      if (hoverValue !== cleanedValue) {
        this.setState({
          hoverValue: hoverValue,
          cleanedValue: null
        });
      }

      this.$emit('hoverChange', hoverValue);
    },
    onMouseLeave: function onMouseLeave() {
      this.setState({
        hoverValue: undefined,
        cleanedValue: null
      });
      this.$emit('hoverChange', undefined);
    },
    onClick: function onClick(event, index) {
      var value = this.getStarValue(index, event.pageX);
      var isReset = false;

      if (this.allowClear) {
        isReset = value === this.sValue;
      }

      this.onMouseLeave(true);
      this.changeValue(isReset ? 0 : value);
      this.setState({
        cleanedValue: isReset ? value : null
      });
    },
    onFocus: function onFocus() {
      this.setState({
        focused: true
      });
      this.$emit('focus');
    },
    onBlur: function onBlur() {
      this.setState({
        focused: false
      });
      this.$emit('blur');
    },
    onKeyDown: function onKeyDown(event) {
      var keyCode = event.keyCode;
      var count = this.count,
          allowHalf = this.allowHalf;
      var sValue = this.sValue;

      if (keyCode === _util_KeyCode.RIGHT && sValue < count) {
        if (allowHalf) {
          sValue += 0.5;
        } else {
          sValue += 1;
        }

        this.changeValue(sValue);
        event.preventDefault();
      } else if (keyCode === _util_KeyCode.LEFT && sValue > 0) {
        if (allowHalf) {
          sValue -= 0.5;
        } else {
          sValue -= 1;
        }

        this.changeValue(sValue);
        event.preventDefault();
      }

      this.$emit('keydown', event);
    },
    getStarDOM: function getStarDOM(index) {
      return this.$refs['stars' + index].$el;
    },
    getStarValue: function getStarValue(index, x) {
      var value = index + 1;

      if (this.allowHalf) {
        var starEle = this.getStarDOM(index);
        var leftDis = getOffsetLeft(starEle);
        var width = starEle.clientWidth;

        if (x - leftDis < width / 2) {
          value -= 0.5;
        }
      }

      return value;
    },
    focus: function focus() {
      if (!this.disabled) {
        this.$refs.rateRef.focus();
      }
    },
    blur: function blur() {
      if (!this.disabled) {
        this.$refs.rateRef.blur();
      }
    },
    changeValue: function changeValue(value) {
      if (!Object(props_util["p" /* hasProp */])(this, 'value')) {
        this.setState({
          sValue: value
        });
      }

      this.$emit('change', value);
    }
  },
  render: function render() {
    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        count = _getOptionProps.count,
        allowHalf = _getOptionProps.allowHalf,
        prefixCls = _getOptionProps.prefixCls,
        disabled = _getOptionProps.disabled,
        character = _getOptionProps.character,
        tabIndex = _getOptionProps.tabIndex;

    var sValue = this.sValue,
        hoverValue = this.hoverValue,
        focused = this.focused;
    var stars = [];
    var disabledClass = disabled ? "".concat(prefixCls, "-disabled") : '';
    var slotCharacter = this.$slots.character;

    for (var index = 0; index < count; index++) {
      var starProps = {
        props: {
          index: index,
          disabled: disabled,
          prefixCls: "".concat(prefixCls, "-star"),
          allowHalf: allowHalf,
          value: hoverValue === undefined ? sValue : hoverValue,
          character: slotCharacter === undefined ? character : undefined,
          focused: focused
        },
        on: {
          click: this.onClick,
          hover: this.onHover
        },
        key: index,
        ref: "stars".concat(index)
      };
      stars.push(h(Star, starProps, [slotCharacter !== undefined ? h("template", {
        slot: 'character'
      }, [slotCharacter]) : null]));
    }

    return h("ul", {
      "class": classnames_default()(prefixCls, disabledClass),
      on: {
        "mouseleave": disabled ? Rate_noop : this.onMouseLeave,
        "focus": disabled ? Rate_noop : this.onFocus,
        "blur": disabled ? Rate_noop : this.onBlur,
        "keydown": disabled ? Rate_noop : this.onKeyDown
      },
      attrs: {
        tabIndex: disabled ? -1 : tabIndex
      },
      ref: 'rateRef'
    }, [stars]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-rate/src/index.js

/* harmony default export */ var vc_rate_src = (Rate);
// CONCATENATED MODULE: ./src/components/vc-rate/index.js
// based on rc-rate 2.4.0

/* harmony default export */ var vc_rate = (vc_rate_src);
// CONCATENATED MODULE: ./src/components/rate/index.jsx
function rate_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { rate_defineProperty(target, key, source[key]); }); } return target; }

function rate_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function rate_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = rate_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function rate_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





var RateProps = {
  prefixCls: vue_types["a" /* default */].string,
  count: vue_types["a" /* default */].number,
  value: vue_types["a" /* default */].value,
  defaultValue: vue_types["a" /* default */].value,
  allowHalf: vue_types["a" /* default */].bool,
  allowClear: vue_types["a" /* default */].bool,
  disabled: vue_types["a" /* default */].bool,
  character: vue_types["a" /* default */].any,
  autoFocus: vue_types["a" /* default */].bool
};
var rate_Rate = {
  name: 'TaRate',
  model: {
    prop: 'value',
    event: 'change'
  },
  props: Object(props_util["q" /* initDefaultProps */])(RateProps, {
    prefixCls: 'ant-rate'
  }),
  methods: {
    focus: function focus() {
      this.$refs.refRate.focus();
    },
    blur: function blur() {
      this.$refs.refRate.blur();
    }
  },
  render: function render() {
    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        character = _getOptionProps.character,
        restProps = rate_objectWithoutProperties(_getOptionProps, ["character"]);

    var slotCharacter = this.$slots.character;
    var rateProps = {
      props: rate_objectSpread({
        character: character
      }, restProps),
      on: this.$listeners,
      ref: 'refRate'
    };
    var slotCharacterHtml = slotCharacter !== undefined ? h("template", {
      slot: 'character'
    }, [slotCharacter]) : h(components_icon, {
      slot: 'character',
      attrs: {
        type: 'star'
      }
    });
    return h(vc_rate, rateProps, [character === undefined ? slotCharacterHtml : null]);
  }
};
/* istanbul ignore next */

rate_Rate.install = function (Vue) {
  Vue.component(rate_Rate.name, rate_Rate);
};

/* harmony default export */ var rate = (rate_Rate);
// CONCATENATED MODULE: ./src/components/vc-slider/src/common/Track.jsx
function Track_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Track_defineProperty(target, key, source[key]); }); } return target; }

function Track_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable */
var Track = {
  functional: true,
  render: function render(createElement, context) {
    var h = arguments[0];
    var _context$props = context.props,
        included = _context$props.included,
        vertical = _context$props.vertical,
        offset = _context$props.offset,
        length = _context$props.length;
    var _context$data = context.data,
        style = _context$data.style,
        className = _context$data["class"];
    var positonStyle = vertical ? {
      bottom: "".concat(offset, "%"),
      height: "".concat(length, "%")
    } : {
      left: "".concat(offset, "%"),
      width: "".concat(length, "%")
    };

    var elStyle = Track_objectSpread({}, style, positonStyle);

    return included ? h("div", {
      "class": className,
      style: elStyle
    }) : null;
  }
};
/* harmony default export */ var common_Track = (Track);
// CONCATENATED MODULE: ./src/components/vc-slider/src/common/Steps.jsx
function Steps_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Steps_defineProperty(target, key, source[key]); }); } return target; }

function Steps_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var Steps_calcPoints = function calcPoints(vertical, marks, dots, step, min, max) {
  _util_warning(dots ? step > 0 : true, '`Slider[step]` should be a positive number in order to make Slider[dots] work.');
  var points = Object.keys(marks).map(parseFloat);

  if (dots) {
    for (var i = min; i <= max; i = i + step) {
      if (points.indexOf(i) >= 0) continue;
      points.push(i);
    }
  }

  return points;
};

var Steps = {
  functional: true,
  render: function render(createElement, context) {
    var h = arguments[0];
    var _context$props = context.props,
        prefixCls = _context$props.prefixCls,
        vertical = _context$props.vertical,
        marks = _context$props.marks,
        dots = _context$props.dots,
        step = _context$props.step,
        included = _context$props.included,
        lowerBound = _context$props.lowerBound,
        upperBound = _context$props.upperBound,
        max = _context$props.max,
        min = _context$props.min,
        dotStyle = _context$props.dotStyle,
        activeDotStyle = _context$props.activeDotStyle;
    var range = max - min;
    var elements = Steps_calcPoints(vertical, marks, dots, step, min, max).map(function (point) {
      var _classNames;

      var offset = "".concat(Math.abs(point - min) / range * 100, "%");
      var isActived = !included && point === upperBound || included && point <= upperBound && point >= lowerBound;
      var style = vertical ? Steps_objectSpread({
        bottom: offset
      }, dotStyle) : Steps_objectSpread({
        left: offset
      }, dotStyle);

      if (isActived) {
        style = Steps_objectSpread({}, style, activeDotStyle);
      }

      var pointClassName = classnames_default()((_classNames = {}, Steps_defineProperty(_classNames, "".concat(prefixCls, "-dot"), true), Steps_defineProperty(_classNames, "".concat(prefixCls, "-dot-active"), isActived), _classNames));
      return h("span", {
        "class": pointClassName,
        style: style,
        key: point
      });
    });
    return h("div", {
      "class": "".concat(prefixCls, "-step")
    }, [elements]);
  }
};
/* harmony default export */ var common_Steps = (Steps);
// CONCATENATED MODULE: ./src/components/vc-slider/src/common/Marks.jsx
function Marks_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Marks_defineProperty(target, key, source[key]); }); } return target; }

function Marks_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Marks_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Marks_typeof = function _typeof(obj) { return typeof obj; }; } else { Marks_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Marks_typeof(obj); }



var Marks = {
  functional: true,
  render: function render(h, context) {
    var _context$props = context.props,
        className = _context$props.className,
        vertical = _context$props.vertical,
        marks = _context$props.marks,
        included = _context$props.included,
        upperBound = _context$props.upperBound,
        lowerBound = _context$props.lowerBound,
        max = _context$props.max,
        min = _context$props.min; // antd未开发完成
    // const { clickLabel } = context.listeners

    var marksKeys = Object.keys(marks);
    var marksCount = marksKeys.length;
    var unit = marksCount > 1 ? 100 / (marksCount - 1) : 100;
    var markWidth = unit * 0.9;
    var range = max - min;
    var elements = marksKeys.map(parseFloat).sort(function (a, b) {
      return a - b;
    }).map(function (point) {
      var _classNames;

      var markPoint = typeof marks[point] === 'function' ? marks[point](h) : marks[point];
      var markPointIsObject = Marks_typeof(markPoint) === 'object' && !Object(props_util["s" /* isValidElement */])(markPoint);
      var markLabel = markPointIsObject ? markPoint.label : markPoint;

      if (!markLabel && markLabel !== 0) {
        return null;
      }

      var isActive = !included && point === upperBound || included && point <= upperBound && point >= lowerBound;
      var markClassName = classnames_default()((_classNames = {}, Marks_defineProperty(_classNames, "".concat(className, "-text"), true), Marks_defineProperty(_classNames, "".concat(className, "-text-active"), isActive), _classNames));
      var bottomStyle = {
        marginBottom: '-50%',
        bottom: "".concat((point - min) / range * 100, "%")
      };
      var leftStyle = {
        width: "".concat(markWidth, "%"),
        marginLeft: "".concat(-markWidth / 2, "%"),
        left: "".concat((point - min) / range * 100, "%")
      };
      var style = vertical ? bottomStyle : leftStyle;
      var markStyle = markPointIsObject ? Marks_objectSpread({}, style, markPoint.style) : style;
      return h("span", {
        "class": markClassName,
        style: markStyle,
        key: point
      }, [markLabel]);
    });
    return h("div", {
      "class": className
    }, [elements]);
  }
};
/* harmony default export */ var common_Marks = (Marks);
// CONCATENATED MODULE: ./src/components/vc-slider/src/Handle.jsx
function Handle_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Handle_defineProperty(target, key, source[key]); }); } return target; }

function Handle_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/* harmony default export */ var Handle = ({
  name: 'Handle',
  mixins: [BaseMixin["a" /* default */]],
  props: {
    prefixCls: vue_types["a" /* default */].string,
    vertical: vue_types["a" /* default */].bool,
    offset: vue_types["a" /* default */].number,
    disabled: vue_types["a" /* default */].bool,
    min: vue_types["a" /* default */].number,
    max: vue_types["a" /* default */].number,
    value: vue_types["a" /* default */].number,
    tabIndex: vue_types["a" /* default */].number,
    className: vue_types["a" /* default */].string // handleFocus: PropTypes.func.def(noop),
    // handleBlur: PropTypes.func.def(noop),

  },
  methods: {
    focus: function focus() {
      this.$refs.handle.focus();
    },
    blur: function blur() {
      this.$refs.handle.blur();
    }
  },
  render: function render() {
    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        className = _getOptionProps.className,
        vertical = _getOptionProps.vertical,
        offset = _getOptionProps.offset,
        disabled = _getOptionProps.disabled,
        min = _getOptionProps.min,
        max = _getOptionProps.max,
        value = _getOptionProps.value,
        tabIndex = _getOptionProps.tabIndex;

    var postionStyle = vertical ? {
      bottom: "".concat(offset, "%")
    } : {
      left: "".concat(offset, "%")
    };

    var elStyle = Handle_objectSpread({}, postionStyle);

    var ariaProps = {};

    if (value !== undefined) {
      ariaProps = Handle_objectSpread({}, ariaProps, {
        'aria-valuemin': min,
        'aria-valuemax': max,
        'aria-valuenow': value,
        'aria-disabled': !!disabled
      });
    }

    var handleProps = {
      attrs: Handle_objectSpread({
        role: 'slider',
        tabIndex: disabled ? null : tabIndex || 0
      }, ariaProps),
      "class": className,
      on: this.$listeners,
      ref: 'handle',
      style: elStyle
    };
    return h("div", handleProps);
  }
});
// CONCATENATED MODULE: ./src/components/vc-slider/src/utils.js
function utils_toConsumableArray(arr) {
  return utils_arrayWithoutHoles(arr) || utils_iterableToArray(arr) || utils_nonIterableSpread();
}

function utils_nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function utils_iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function utils_arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}


function isEventFromHandle(e, handles) {
  return Object.keys(handles).some(function (key) {
    return e.target === handles[key].$el;
  });
}
function isValueOutOfRange(value, _ref) {
  var min = _ref.min,
      max = _ref.max;
  return value < min || value > max;
}
function isNotTouchEvent(e) {
  return e.touches.length > 1 || e.type.toLowerCase() === 'touchend' && e.touches.length > 0;
}
function getClosestPoint(val, _ref2) {
  var marks = _ref2.marks,
      step = _ref2.step,
      min = _ref2.min;
  var points = Object.keys(marks).map(parseFloat);

  if (step !== null) {
    var closestStep = Math.round((val - min) / step) * step + min;
    points.push(closestStep);
  }

  var diffs = points.map(function (point) {
    return Math.abs(val - point);
  });
  return points[diffs.indexOf(Math.min.apply(Math, utils_toConsumableArray(diffs)))];
}
function utils_getPrecision(step) {
  var stepString = step.toString();
  var precision = 0;

  if (stepString.indexOf('.') >= 0) {
    precision = stepString.length - stepString.indexOf('.') - 1;
  }

  return precision;
}
function getMousePosition(vertical, e) {
  return vertical ? e.clientY : e.pageX;
}
function getTouchPosition(vertical, e) {
  return vertical ? e.touches[0].clientY : e.touches[0].pageX;
}
function getHandleCenterPosition(vertical, handle) {
  var coords = handle.getBoundingClientRect();
  return vertical ? coords.top + coords.height * 0.5 : coords.left + coords.width * 0.5;
}
function ensureValueInRange(val, _ref3) {
  var max = _ref3.max,
      min = _ref3.min;

  if (val <= min) {
    return min;
  }

  if (val >= max) {
    return max;
  }

  return val;
}
function ensureValuePrecision(val, props) {
  var step = props.step;
  var closestPoint = getClosestPoint(val, props);
  return step === null ? closestPoint : parseFloat(closestPoint.toFixed(utils_getPrecision(step)));
}
function pauseEvent(e) {
  e.stopPropagation();
  e.preventDefault();
}
function getKeyboardValueMutator(e) {
  switch (e.keyCode) {
    case _util_KeyCode.UP:
    case _util_KeyCode.RIGHT:
      return function (value, props) {
        return value + props.step;
      };

    case _util_KeyCode.DOWN:
    case _util_KeyCode.LEFT:
      return function (value, props) {
        return value - props.step;
      };

    case _util_KeyCode.END:
      return function (value, props) {
        return props.max;
      };

    case _util_KeyCode.HOME:
      return function (value, props) {
        return props.min;
      };

    case _util_KeyCode.PAGE_UP:
      return function (value, props) {
        return value + props.step * 2;
      };

    case _util_KeyCode.PAGE_DOWN:
      return function (value, props) {
        return value - props.step * 2;
      };

    default:
      return undefined;
  }
}
function getComponentProps(obj, prop) {
  if (obj[prop]) {
    return obj;
  } else if (obj.$children.length) {
    var len = obj.$children.length;

    for (var i = 0; i < len; i++) {
      if (obj.$children[i][prop]) {
        return obj.$children[i];
      } else if (obj.$children[i].$children.length) {
        return getComponentProps(obj.$children[i], prop);
      }
    }
  }
}
// CONCATENATED MODULE: ./src/components/vc-slider/src/common/createSlider.jsx
function createSlider_slicedToArray(arr, i) { return createSlider_arrayWithHoles(arr) || createSlider_iterableToArrayLimit(arr, i) || createSlider_nonIterableRest(); }

function createSlider_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function createSlider_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function createSlider_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function createSlider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { createSlider_defineProperty(target, key, source[key]); }); } return target; }

function createSlider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function createSlider_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = createSlider_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function createSlider_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }











function createSlider_noop() {}

function createSlider(Component) {
  // const displayName = `ComponentEnhancer(${Component.displayName})`
  var propTypes = {
    min: vue_types["a" /* default */].number,
    max: vue_types["a" /* default */].number,
    step: vue_types["a" /* default */].number,
    marks: vue_types["a" /* default */].object,
    included: vue_types["a" /* default */].bool,
    prefixCls: vue_types["a" /* default */].string,
    disabled: vue_types["a" /* default */].bool,
    handle: vue_types["a" /* default */].func,
    dots: vue_types["a" /* default */].bool,
    vertical: vue_types["a" /* default */].bool,
    minimumTrackStyle: vue_types["a" /* default */].object,
    // just for compatibility, will be deperecate
    maximumTrackStyle: vue_types["a" /* default */].object,
    // just for compatibility, will be deperecate
    handleStyle: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].object, vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].object)]),
    trackStyle: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].object, vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].object)]),
    railStyle: vue_types["a" /* default */].object,
    dotStyle: vue_types["a" /* default */].object,
    activeDotStyle: vue_types["a" /* default */].object,
    autoFocus: vue_types["a" /* default */].bool
  };
  return {
    name: 'createSlider',
    mixins: [Component],
    model: {
      prop: 'value',
      event: 'change'
    },
    props: Object(props_util["q" /* initDefaultProps */])(propTypes, {
      prefixCls: 'rc-slider',
      min: 0,
      max: 100,
      step: 1,
      marks: {},
      handle: function handle(h, _ref) {
        var index = _ref.index,
            ref = _ref.ref,
            className = _ref.className,
            style = _ref.style,
            restProps = createSlider_objectWithoutProperties(_ref, ["index", "ref", "className", "style"]);

        delete restProps.dragging;
        var handleProps = {
          props: createSlider_objectSpread({}, restProps),
          "class": className,
          style: style,
          key: index,
          ref: ref
        };
        return h(Handle, handleProps);
      },
      included: true,
      disabled: false,
      dots: false,
      vertical: false,
      trackStyle: [{}],
      handleStyle: [{}],
      railStyle: {},
      dotStyle: {},
      activeDotStyle: {}
    }),
    data: function data() {
      if (false) { var step, max, min; }

      return {};
    },
    beforeDestroy: function beforeDestroy() {
      var _this = this;

      this.$nextTick(function () {
        // if (super.componentWillUnmount) super.componentWillUnmount()
        _this.removeDocumentEvents();
      });
    },
    mounted: function mounted() {
      var _this2 = this;

      this.$nextTick(function () {
        // Snapshot testing cannot handle refs, so be sure to null-check this.
        _this2.document = _this2.$refs.sliderRef && _this2.$refs.sliderRef.ownerDocument; // this.setHandleRefs()
      });
    },
    computed: {
      handlesRefs: function handlesRefs() {
        var handlesRefs = [];

        for (var _i = 0, _Object$entries = Object.entries(this.$refs); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = createSlider_slicedToArray(_Object$entries[_i], 2),
              k = _Object$entries$_i[0],
              v = _Object$entries$_i[1];

          var matchs = k.match(/handleRefs_(\d+$)/);

          if (matchs) {
            handlesRefs[+matchs[1]] = v;
          }
        }

        return handlesRefs;
      }
    },
    methods: {
      onMouseDown: function onMouseDown(e) {
        if (e.button !== 0) {
          return;
        }

        var isVertical = this.vertical;
        var position = getMousePosition(isVertical, e);

        if (!isEventFromHandle(e, this.handlesRefs)) {
          this.dragOffset = 0;
        } else {
          var handlePosition = getHandleCenterPosition(isVertical, e.target);
          this.dragOffset = position - handlePosition;
          position = handlePosition;
        }

        this.removeDocumentEvents();
        this.onStart(position);
        this.addDocumentMouseEvents();
        pauseEvent(e);
      },
      onTouchStart: function onTouchStart(e) {
        if (isNotTouchEvent(e)) return;
        var isVertical = this.vertical;
        var position = getTouchPosition(isVertical, e);

        if (!isEventFromHandle(e, this.handlesRefs)) {
          this.dragOffset = 0;
        } else {
          var handlePosition = getHandleCenterPosition(isVertical, e.target);
          this.dragOffset = position - handlePosition;
          position = handlePosition;
        }

        this.onStart(position);
        this.addDocumentTouchEvents();
        pauseEvent(e);
      },
      onFocus: function onFocus(e) {
        var vertical = this.vertical;

        if (isEventFromHandle(e, this.handlesRefs)) {
          var handlePosition = getHandleCenterPosition(vertical, e.target);
          this.dragOffset = 0;
          this.onStart(handlePosition);
          pauseEvent(e);
          this.$emit('focus', e);
        }
      },
      onBlur: function onBlur(e) {
        this.onEnd(e);
        this.$emit('blur', e);
      },
      addDocumentTouchEvents: function addDocumentTouchEvents() {
        // just work for Chrome iOS Safari and Android Browser
        this.onTouchMoveListener = addEventListenerWrap(this.document, 'touchmove', this.onTouchMove);
        this.onTouchUpListener = addEventListenerWrap(this.document, 'touchend', this.onEnd);
      },
      addDocumentMouseEvents: function addDocumentMouseEvents() {
        this.onMouseMoveListener = addEventListenerWrap(this.document, 'mousemove', this.onMouseMove);
        this.onMouseUpListener = addEventListenerWrap(this.document, 'mouseup', this.onEnd);
      },
      removeDocumentEvents: function removeDocumentEvents() {
        /* eslint-disable no-unused-expressions */
        this.onTouchMoveListener && this.onTouchMoveListener.remove();
        this.onTouchUpListener && this.onTouchUpListener.remove();
        this.onMouseMoveListener && this.onMouseMoveListener.remove();
        this.onMouseUpListener && this.onMouseUpListener.remove();
        /* eslint-enable no-unused-expressions */
      },
      onMouseMove: function onMouseMove(e) {
        if (!this.$refs.sliderRef) {
          this.onEnd();
          return;
        }

        var position = getMousePosition(this.vertical, e);
        this.onMove(e, position - this.dragOffset);
      },
      onTouchMove: function onTouchMove(e) {
        if (isNotTouchEvent(e) || !this.$refs.sliderRef) {
          this.onEnd();
          return;
        }

        var position = getTouchPosition(this.vertical, e);
        this.onMove(e, position - this.dragOffset);
      },
      onKeyDown: function onKeyDown(e) {
        if (this.$refs.sliderRef && isEventFromHandle(e, this.handlesRefs)) {
          this.onKeyboard(e);
        }
      },
      focus: function focus() {
        if (!this.disabled) {
          this.handlesRefs[0].focus();
        }
      },
      blur: function blur() {
        if (!this.disabled) {
          this.handlesRefs[0].blur();
        }
      },
      getSliderStart: function getSliderStart() {
        var slider = this.$refs.sliderRef;
        var rect = slider.getBoundingClientRect();
        return this.vertical ? rect.top : rect.left;
      },
      getSliderLength: function getSliderLength() {
        var slider = this.$refs.sliderRef;

        if (!slider) {
          return 0;
        }

        var coords = slider.getBoundingClientRect();
        return this.vertical ? coords.height : coords.width;
      },
      calcValue: function calcValue(offset) {
        var vertical = this.vertical,
            min = this.min,
            max = this.max;
        var ratio = Math.abs(Math.max(offset, 0) / this.getSliderLength());
        var value = vertical ? (1 - ratio) * (max - min) + min : ratio * (max - min) + min;
        return value;
      },
      calcValueByPos: function calcValueByPos(position) {
        var pixelOffset = position - this.getSliderStart();
        var nextValue = this.trimAlignValue(this.calcValue(pixelOffset));
        return nextValue;
      },
      calcOffset: function calcOffset(value) {
        var min = this.min,
            max = this.max;
        var ratio = (value - min) / (max - min);
        return ratio * 100;
      }
    },
    render: function render(h) {
      var _classNames;

      var prefixCls = this.prefixCls,
          marks = this.marks,
          dots = this.dots,
          step = this.step,
          included = this.included,
          disabled = this.disabled,
          vertical = this.vertical,
          min = this.min,
          max = this.max,
          maximumTrackStyle = this.maximumTrackStyle,
          railStyle = this.railStyle,
          dotStyle = this.dotStyle,
          activeDotStyle = this.activeDotStyle;

      var _this$renderSlider = this.renderSlider(h),
          tracks = _this$renderSlider.tracks,
          handles = _this$renderSlider.handles;

      var sliderClassName = classnames_default()(prefixCls, (_classNames = {}, createSlider_defineProperty(_classNames, "".concat(prefixCls, "-with-marks"), Object.keys(marks).length), createSlider_defineProperty(_classNames, "".concat(prefixCls, "-disabled"), disabled), createSlider_defineProperty(_classNames, "".concat(prefixCls, "-vertical"), vertical), _classNames));
      var markProps = {
        props: {
          vertical: vertical,
          marks: marks,
          included: included,
          lowerBound: this.getLowerBound(),
          upperBound: this.getUpperBound(),
          max: max,
          min: min,
          className: "".concat(prefixCls, "-mark")
        }
      };
      return h("div", {
        ref: 'sliderRef',
        "class": sliderClassName,
        on: {
          "touchstart": disabled ? createSlider_noop : this.onTouchStart,
          "mousedown": disabled ? createSlider_noop : this.onMouseDown,
          "keydown": disabled ? createSlider_noop : this.onKeyDown,
          "focus": disabled ? createSlider_noop : this.onFocus,
          "blur": disabled ? createSlider_noop : this.onBlur
        }
      }, [h("div", {
        "class": "".concat(prefixCls, "-rail"),
        style: createSlider_objectSpread({}, maximumTrackStyle, railStyle)
      }), tracks, h(common_Steps, {
        attrs: {
          prefixCls: prefixCls,
          vertical: vertical,
          marks: marks,
          dots: dots,
          step: step,
          included: included,
          lowerBound: this.getLowerBound(),
          upperBound: this.getUpperBound(),
          max: max,
          min: min,
          dotStyle: dotStyle,
          activeDotStyle: activeDotStyle
        }
      }), handles, h(common_Marks, markProps), this.$slots["default"]]);
    }
  };
}
// CONCATENATED MODULE: ./src/components/vc-slider/src/Slider.jsx
function Slider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Slider_defineProperty(target, key, source[key]); }); } return target; }

function Slider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var Slider = {
  name: 'Slider',
  mixins: [BaseMixin["a" /* default */]],
  props: {
    defaultValue: vue_types["a" /* default */].number,
    value: vue_types["a" /* default */].number,
    disabled: vue_types["a" /* default */].bool,
    autoFocus: vue_types["a" /* default */].bool,
    tabIndex: vue_types["a" /* default */].number
  },
  data: function data() {
    var defaultValue = this.defaultValue !== undefined ? this.defaultValue : this.min;
    var value = this.value !== undefined ? this.value : defaultValue;

    if (false) {}

    return {
      sValue: this.trimAlignValue(value),
      dragging: false
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      var autoFocus = _this.autoFocus,
          disabled = _this.disabled;

      if (autoFocus && !disabled) {
        _this.focus();
      }
    });
  },
  watch: {
    value: {
      handler: function handler(val) {
        var min = this.min,
            max = this.max;
        this.setChangeValue(val, min, max);
      },
      deep: true
    },
    min: function min(val) {
      var sValue = this.sValue,
          max = this.max;
      this.setChangeValue(sValue, val, max);
    },
    max: function max(val) {
      var sValue = this.sValue,
          min = this.min;
      this.setChangeValue(sValue, min, val);
    }
  },
  methods: {
    setChangeValue: function setChangeValue(value, min, max) {
      var minAmaxProps = {
        min: min,
        max: max
      };
      var newValue = value !== undefined ? value : this.sValue;
      var nextValue = this.trimAlignValue(newValue, minAmaxProps);
      if (nextValue === this.sValue) return;
      this.setState({
        sValue: nextValue
      });

      if (isValueOutOfRange(newValue, minAmaxProps)) {
        this.$emit('change', nextValue);
      }
    },
    onChange: function onChange(state) {
      var isNotControlled = !Object(props_util["p" /* hasProp */])(this, 'value');

      if (isNotControlled) {
        this.setState(state);
      }

      var changedValue = state.sValue;
      this.$emit('change', changedValue);
    },
    onStart: function onStart(position) {
      this.setState({
        dragging: true
      });
      var sValue = this.sValue;
      this.$emit('beforeChange', sValue);
      var value = this.calcValueByPos(position);
      this.startValue = value;
      this.startPosition = position;
      if (value === sValue) return;
      this.onChange({
        sValue: value
      });
    },
    onEnd: function onEnd() {
      this.setState({
        dragging: false
      });
      this.removeDocumentEvents();
      this.$emit('afterChange', this.sValue);
    },
    onMove: function onMove(e, position) {
      pauseEvent(e);
      var sValue = this.sValue;
      var value = this.calcValueByPos(position);
      if (value === sValue) return;
      this.onChange({
        sValue: value
      });
    },
    onKeyboard: function onKeyboard(e) {
      var valueMutator = getKeyboardValueMutator(e);

      if (valueMutator) {
        pauseEvent(e);
        var sValue = this.sValue;
        var mutatedValue = valueMutator(sValue, this.$props);
        var value = this.trimAlignValue(mutatedValue);
        if (value === sValue) return;
        this.onChange({
          sValue: value
        });
      }
    },
    getLowerBound: function getLowerBound() {
      return this.min;
    },
    getUpperBound: function getUpperBound() {
      return this.sValue;
    },
    trimAlignValue: function trimAlignValue(v) {
      var nextProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var mergedProps = Slider_objectSpread({}, this.$props, nextProps);

      var val = ensureValueInRange(v, mergedProps);
      return ensureValuePrecision(val, mergedProps);
    },
    getTrack: function getTrack(_ref) {
      var prefixCls = _ref.prefixCls,
          vertical = _ref.vertical,
          included = _ref.included,
          offset = _ref.offset,
          minimumTrackStyle = _ref.minimumTrackStyle,
          _trackStyle = _ref._trackStyle;
      var h = this.$createElement;
      return h(common_Track, {
        "class": "".concat(prefixCls, "-track"),
        attrs: {
          vertical: vertical,
          included: included,
          offset: 0,
          length: offset
        },
        style: Slider_objectSpread({}, minimumTrackStyle, _trackStyle)
      });
    },
    renderSlider: function renderSlider() {
      var prefixCls = this.prefixCls,
          vertical = this.vertical,
          included = this.included,
          disabled = this.disabled,
          minimumTrackStyle = this.minimumTrackStyle,
          trackStyle = this.trackStyle,
          handleStyle = this.handleStyle,
          tabIndex = this.tabIndex,
          min = this.min,
          max = this.max,
          handleGenerator = this.handle;
      var sValue = this.sValue,
          dragging = this.dragging;
      var offset = this.calcOffset(sValue);
      var handle = handleGenerator(this.$createElement, {
        className: "".concat(prefixCls, "-handle"),
        vertical: vertical,
        offset: offset,
        value: sValue,
        dragging: dragging,
        disabled: disabled,
        min: min,
        max: max,
        index: 0,
        tabIndex: tabIndex,
        style: handleStyle[0] || handleStyle,
        ref: 'handleRefs_0',
        handleFocus: this.onFocus,
        handleBlur: this.onBlur
      });

      var _trackStyle = trackStyle[0] || trackStyle;

      return {
        tracks: this.getTrack({
          prefixCls: prefixCls,
          vertical: vertical,
          included: included,
          offset: offset,
          minimumTrackStyle: minimumTrackStyle,
          _trackStyle: _trackStyle
        }),
        handles: handle
      };
    }
  }
};
/* harmony default export */ var src_Slider = (createSlider(Slider));
// CONCATENATED MODULE: ./src/components/vc-slider/src/Range.jsx
function Range_toConsumableArray(arr) { return Range_arrayWithoutHoles(arr) || Range_iterableToArray(arr) || Range_nonIterableSpread(); }

function Range_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function Range_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function Range_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function Range_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Range_defineProperty(target, key, source[key]); }); } return target; }

function Range_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var rangeProps = {
  defaultValue: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].number),
  value: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].number),
  count: vue_types["a" /* default */].number,
  pushable: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, vue_types["a" /* default */].number]),
  allowCross: vue_types["a" /* default */].bool,
  disabled: vue_types["a" /* default */].bool,
  tabIndex: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].number),
  prefixCls: vue_types["a" /* default */].string
};
var Range = {
  name: 'Range',
  displayName: 'Range',
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(rangeProps, {
    count: 1,
    allowCross: true,
    pushable: false,
    tabIndex: []
  }),
  data: function data() {
    var _this = this;

    var count = this.count,
        min = this.min,
        max = this.max;
    var initialValue = Array.apply(null, Array(count + 1)).map(function () {
      return min;
    });
    var defaultValue = Object(props_util["p" /* hasProp */])(this, 'defaultValue') ? this.defaultValue : initialValue;
    var value = this.value;

    if (value === undefined) {
      value = defaultValue;
    }

    var bounds = value.map(function (v, i) {
      return _this.trimAlignValue(v, i);
    });
    var recent = bounds[0] === max ? 0 : bounds.length - 1;
    return {
      sHandle: null,
      recent: recent,
      bounds: bounds
    };
  },
  watch: {
    value: {
      handler: function handler(val) {
        var min = this.min,
            max = this.max;
        this.setChangeValue(val, min, max);
      },
      deep: true
    },
    min: function min(val) {
      var bounds = this.bounds,
          max = this.max;
      this.setChangeValue(bounds, val, max);
    },
    max: function max(val) {
      var bounds = this.bounds,
          min = this.min;
      this.setChangeValue(bounds, min, val);
    }
  },
  methods: {
    setChangeValue: function setChangeValue(value, min, max) {
      var _this2 = this;

      var bounds = this.bounds;
      var newValue = value || bounds;
      var minAmaxProps = {
        min: min,
        max: max
      };
      var nextBounds = newValue.map(function (v, i) {
        return _this2.trimAlignValue(v, i, minAmaxProps);
      });
      if (nextBounds.length === bounds.length && nextBounds.every(function (v, i) {
        return v === bounds[i];
      })) return;
      this.setState({
        bounds: nextBounds
      });

      if (bounds.some(function (v) {
        return isValueOutOfRange(v, minAmaxProps);
      })) {
        this.$emit('change', nextBounds);
      }
    },
    onChange: function onChange(state) {
      var isNotControlled = !Object(props_util["p" /* hasProp */])(this, 'value');

      if (isNotControlled) {
        this.setState(state);
      } else if (state.sHandle !== undefined) {
        this.setState({
          sHandle: state.sHandle
        });
      }

      var data = Range_objectSpread({}, this.$data, state);

      var changedValue = data.bounds;
      this.$emit('change', changedValue);
    },
    onStart: function onStart(position) {
      var bounds = this.bounds;
      this.$emit('beforeChange', bounds);
      var value = this.calcValueByPos(position);
      this.startValue = value;
      this.startPosition = position;
      var closestBound = this.getClosestBound(value);
      var boundNeedMoving = this.getBoundNeedMoving(value, closestBound);
      this.setState({
        sHandle: boundNeedMoving,
        recent: boundNeedMoving
      });
      var prevValue = bounds[boundNeedMoving];
      if (value === prevValue) return;

      var nextBounds = Range_toConsumableArray(bounds);

      nextBounds[boundNeedMoving] = value;
      this.onChange({
        bounds: nextBounds
      });
    },
    onEnd: function onEnd() {
      this.setState({
        sHandle: null
      });
      this.removeDocumentEvents();
      this.$emit('afterChange', this.bounds);
    },
    onMove: function onMove(e, position) {
      pauseEvent(e);
      var props = this.$props;
      var bounds = this.bounds,
          sHandle = this.sHandle;
      var value = this.calcValueByPos(position);
      var oldValue = bounds[sHandle];
      if (value === oldValue) return;

      var nextBounds = Range_toConsumableArray(bounds);

      nextBounds[sHandle] = value;
      var nextHandle = sHandle;

      if (props.pushable !== false) {
        this.pushSurroundingHandles(nextBounds, nextHandle);
      } else if (props.allowCross) {
        nextBounds.sort(function (a, b) {
          return a - b;
        });
        nextHandle = nextBounds.indexOf(value);
      }

      this.onChange({
        sHandle: nextHandle,
        bounds: nextBounds
      });
    },
    onKeyboard: function onKeyboard() {
      browser_default()(true, 'Keyboard support is not yet supported for ranges.');
    },
    getClosestBound: function getClosestBound(value) {
      var bounds = this.bounds;
      var closestBound = 0;

      for (var i = 1; i < bounds.length - 1; ++i) {
        if (value > bounds[i]) {
          closestBound = i;
        }
      }

      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {
        closestBound = closestBound + 1;
      }

      return closestBound;
    },
    getBoundNeedMoving: function getBoundNeedMoving(value, closestBound) {
      var bounds = this.bounds,
          recent = this.recent;
      var boundNeedMoving = closestBound;
      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];

      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {
        boundNeedMoving = recent;
      }

      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {
        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;
      }

      return boundNeedMoving;
    },
    getLowerBound: function getLowerBound() {
      return this.bounds[0];
    },
    getUpperBound: function getUpperBound() {
      var bounds = this.bounds;
      return bounds[bounds.length - 1];
    },

    /**
     * Returns an array of possible slider points, taking into account both
     * `marks` and `step`. The result is cached.
     */
    getPoints: function getPoints() {
      var marks = this.marks,
          step = this.step,
          min = this.min,
          max = this.max;
      var cache = this._getPointsCache;

      if (!cache || cache.marks !== marks || cache.step !== step) {
        var pointsObject = Range_objectSpread({}, marks);

        if (step !== null) {
          for (var point = min; point <= max; point += step) {
            pointsObject[point] = point;
          }
        }

        var points = Object.keys(pointsObject).map(parseFloat);
        points.sort(function (a, b) {
          return a - b;
        });
        this._getPointsCache = {
          marks: marks,
          step: step,
          points: points
        };
      }

      return this._getPointsCache.points;
    },
    pushSurroundingHandles: function pushSurroundingHandles(bounds, handle) {
      var value = bounds[handle];
      var threshold = this.pushable;
      threshold = Number(threshold);
      var direction = 0;

      if (bounds[handle + 1] - value < threshold) {
        direction = +1; // push to right
      }

      if (value - bounds[handle - 1] < threshold) {
        direction = -1; // push to left
      }

      if (direction === 0) {
        return;
      }

      var nextHandle = handle + direction;
      var diffToNext = direction * (bounds[nextHandle] - value);

      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {
        // revert to original value if pushing is impossible
        bounds[handle] = bounds[nextHandle] - direction * threshold;
      }
    },
    pushHandle: function pushHandle(bounds, handle, direction, amount) {
      var originalValue = bounds[handle];
      var currentValue = bounds[handle];

      while (direction * (currentValue - originalValue) < amount) {
        if (!this.pushHandleOnePoint(bounds, handle, direction)) {
          // can't push handle enough to create the needed `amount` gap, so we
          // revert its position to the original value
          bounds[handle] = originalValue;
          return false;
        }

        currentValue = bounds[handle];
      } // the handle was pushed enough to create the needed `amount` gap


      return true;
    },
    pushHandleOnePoint: function pushHandleOnePoint(bounds, handle, direction) {
      var points = this.getPoints();
      var pointIndex = points.indexOf(bounds[handle]);
      var nextPointIndex = pointIndex + direction;

      if (nextPointIndex >= points.length || nextPointIndex < 0) {
        // reached the minimum or maximum available point, can't push anymore
        return false;
      }

      var nextHandle = handle + direction;
      var nextValue = points[nextPointIndex];
      var threshold = this.pushable;
      var diffToNext = direction * (bounds[nextHandle] - nextValue);

      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {
        // couldn't push next handle, so we won't push this one either
        return false;
      } // push the handle


      bounds[handle] = nextValue;
      return true;
    },
    trimAlignValue: function trimAlignValue(v, handle) {
      var nextProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var mergedProps = Range_objectSpread({}, this.$props, nextProps);

      var valInRange = ensureValueInRange(v, mergedProps);
      var valNotConflict = this.ensureValueNotConflict(handle, valInRange, mergedProps);
      return ensureValuePrecision(valNotConflict, mergedProps);
    },
    ensureValueNotConflict: function ensureValueNotConflict(handle, val, _ref) {
      var allowCross = _ref.allowCross,
          thershold = _ref.pushable;
      var state = this.$data || {};
      var bounds = state.bounds;
      handle = handle === undefined ? state.sHandle : handle;
      thershold = Number(thershold);
      /* eslint-disable eqeqeq */

      if (!allowCross && handle != null && bounds !== undefined) {
        if (handle > 0 && val <= bounds[handle - 1] + thershold) {
          return bounds[handle - 1] + thershold;
        }

        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {
          return bounds[handle + 1] - thershold;
        }
      }
      /* eslint-enable eqeqeq */


      return val;
    },
    getTrack: function getTrack(_ref2) {
      var bounds = _ref2.bounds,
          prefixCls = _ref2.prefixCls,
          vertical = _ref2.vertical,
          included = _ref2.included,
          offsets = _ref2.offsets,
          trackStyle = _ref2.trackStyle;
      var h = this.$createElement;
      return bounds.slice(0, -1).map(function (_, index) {
        var _classNames;

        var i = index + 1;
        var trackClassName = classnames_default()((_classNames = {}, Range_defineProperty(_classNames, "".concat(prefixCls, "-track"), true), Range_defineProperty(_classNames, "".concat(prefixCls, "-track-").concat(i), true), _classNames));
        return h(common_Track, {
          "class": trackClassName,
          attrs: {
            vertical: vertical,
            included: included,
            offset: offsets[i - 1],
            length: offsets[i] - offsets[i - 1]
          },
          style: trackStyle[index],
          key: i
        });
      });
    },
    renderSlider: function renderSlider() {
      var _this3 = this;

      var sHandle = this.sHandle,
          bounds = this.bounds,
          prefixCls = this.prefixCls,
          vertical = this.vertical,
          included = this.included,
          disabled = this.disabled,
          min = this.min,
          max = this.max,
          handleGenerator = this.handle,
          trackStyle = this.trackStyle,
          handleStyle = this.handleStyle,
          tabIndex = this.tabIndex,
          $createElement = this.$createElement;
      var offsets = bounds.map(function (v) {
        return _this3.calcOffset(v);
      });
      var handleClassName = "".concat(prefixCls, "-handle");
      var handles = bounds.map(function (v, i) {
        var _classNames2;

        return handleGenerator($createElement, {
          className: classnames_default()((_classNames2 = {}, Range_defineProperty(_classNames2, handleClassName, true), Range_defineProperty(_classNames2, "".concat(handleClassName, "-").concat(i + 1), true), _classNames2)),
          vertical: vertical,
          offset: offsets[i],
          value: v,
          dragging: sHandle === i,
          index: i,
          tabIndex: tabIndex[i] || 0,
          min: min,
          max: max,
          disabled: disabled,
          style: handleStyle[i],
          ref: 'handleRefs_' + i,
          handleFocus: _this3.onFocus,
          handleBlur: _this3.onBlur
        });
      });
      return {
        tracks: this.getTrack({
          bounds: bounds,
          prefixCls: prefixCls,
          vertical: vertical,
          included: included,
          offsets: offsets,
          trackStyle: trackStyle
        }),
        handles: handles
      };
    }
  }
};
/* harmony default export */ var src_Range = (createSlider(Range));
// CONCATENATED MODULE: ./src/components/slider/index.jsx
function slider_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = slider_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function slider_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function slider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { slider_defineProperty(target, key, source[key]); }); } return target; }

function slider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







 // export interface SliderMarks {
//   [key]: React.ReactNode | {
//     style: React.CSSProperties,
//     label: React.ReactNode,
//   };
// }
// const SliderMarks = PropTypes.shape({
//   style: PropTypes.object,
//   label: PropTypes.any,
// }).loose

var slider_SliderProps = function SliderProps() {
  return {
    prefixCls: vue_types["a" /* default */].string,
    tooltipPrefixCls: vue_types["a" /* default */].string,
    range: vue_types["a" /* default */].bool,
    min: vue_types["a" /* default */].number,
    max: vue_types["a" /* default */].number,
    step: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].any]),
    marks: vue_types["a" /* default */].object,
    dots: vue_types["a" /* default */].bool,
    value: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].number)]),
    defaultValue: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].number)]),
    included: vue_types["a" /* default */].bool,
    disabled: vue_types["a" /* default */].bool,
    vertical: vue_types["a" /* default */].bool,
    tipFormatter: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].func, vue_types["a" /* default */].object]),
    id: vue_types["a" /* default */].string
  };
};
var slider_Slider = {
  name: 'TaSlider',
  model: {
    prop: 'value',
    event: 'change'
  },
  mixins: [BaseMixin["a" /* default */]],
  props: slider_objectSpread({}, slider_SliderProps(), {
    prefixCls: vue_types["a" /* default */].string.def('ant-slider'),
    tooltipPrefixCls: vue_types["a" /* default */].string.def('ant-tooltip'),
    tipFormatter: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].func, vue_types["a" /* default */].object]).def(function (value) {
      return value.toString();
    })
  }),
  data: function data() {
    return {
      visibles: {}
    };
  },
  methods: {
    toggleTooltipVisible: function toggleTooltipVisible(index, visible) {
      this.setState(function (_ref) {
        var visibles = _ref.visibles;
        return {
          visibles: slider_objectSpread({}, visibles, slider_defineProperty({}, index, visible))
        };
      });
    },
    handleWithTooltip: function handleWithTooltip(h, _ref2) {
      var _this = this;

      var value = _ref2.value,
          dragging = _ref2.dragging,
          index = _ref2.index,
          ref = _ref2.ref,
          restProps = slider_objectWithoutProperties(_ref2, ["value", "dragging", "index", "ref"]);

      var _this$$props = this.$props,
          tooltipPrefixCls = _this$$props.tooltipPrefixCls,
          tipFormatter = _this$$props.tipFormatter;
      var visibles = this.visibles;
      var visible = tipFormatter ? visibles[index] || dragging : false;
      var tooltipProps = {
        props: {
          prefixCls: tooltipPrefixCls,
          title: tipFormatter ? tipFormatter(value) : '',
          visible: visible,
          placement: 'top',
          transitionName: 'fade'
        },
        key: index
      };
      var handleProps = {
        props: slider_objectSpread({
          value: value
        }, restProps),
        ref: ref,
        on: {
          mouseenter: function mouseenter() {
            return _this.toggleTooltipVisible(index, true);
          },
          mouseleave: function mouseleave() {
            return _this.toggleTooltipVisible(index, false);
          }
        }
      };
      return h(tooltip, tooltipProps, [h(Handle, handleProps)]);
    },
    focus: function focus() {
      this.$refs.sliderRef.focus();
    },
    blur: function blur() {
      this.$refs.sliderRef.focus();
    }
  },
  render: function render() {
    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        range = _getOptionProps.range,
        restProps = slider_objectWithoutProperties(_getOptionProps, ["range"]);

    if (range) {
      var vcRangeProps = {
        props: slider_objectSpread({}, restProps, {
          handle: this.handleWithTooltip
        }),
        ref: 'sliderRef',
        on: this.$listeners
      };
      return h(src_Range, vcRangeProps);
    }

    var vcSliderProps = {
      props: slider_objectSpread({}, restProps, {
        handle: this.handleWithTooltip
      }),
      ref: 'sliderRef',
      on: this.$listeners
    };
    return h(src_Slider, vcSliderProps);
  }
};
/* istanbul ignore next */

slider_Slider.install = function (Vue) {
  Vue.component(slider_Slider.name, slider_Slider);
};

/* harmony default export */ var slider = (slider_Slider);
// CONCATENATED MODULE: ./src/components/vc-steps/Steps.jsx
function vc_steps_Steps_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { vc_steps_Steps_defineProperty(target, key, source[key]); }); } return target; }

function vc_steps_Steps_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







/* harmony default export */ var vc_steps_Steps = ({
  name: 'Steps',
  mixins: [BaseMixin["a" /* default */]],
  props: {
    prefixCls: vue_types["a" /* default */].string.def('rc-steps'),
    iconPrefix: vue_types["a" /* default */].string.def('rc'),
    direction: vue_types["a" /* default */].string.def('horizontal'),
    labelPlacement: vue_types["a" /* default */].string.def('horizontal'),
    status: vue_types["a" /* default */].string.def('process'),
    size: vue_types["a" /* default */].string.def(''),
    progressDot: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, vue_types["a" /* default */].func]),
    current: vue_types["a" /* default */].number.def(0)
  },
  data: function data() {
    this.calcStepOffsetWidth = debounce_default()(this.calcStepOffsetWidth, 150);
    return {
      flexSupported: true,
      lastStepOffsetWidth: 0
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.calcStepOffsetWidth();

      if (!isFlexSupported()) {
        _this.setState({
          flexSupported: false
        });
      }
    });
  },
  updated: function updated() {
    var _this2 = this;

    this.$nextTick(function () {
      _this2.calcStepOffsetWidth();
    });
  },
  beforeDestroy: function beforeDestroy() {
    if (this.calcTimeout) {
      clearTimeout(this.calcTimeout);
    }

    if (this.calcStepOffsetWidth && this.calcStepOffsetWidth.cancel) {
      this.calcStepOffsetWidth.cancel();
    }
  },
  methods: {
    calcStepOffsetWidth: function calcStepOffsetWidth() {
      var _this3 = this;

      if (isFlexSupported()) {
        return;
      } // Just for IE9


      var domNode = this.$refs.vcStepsRef;

      if (domNode.children.length > 0) {
        if (this.calcTimeout) {
          clearTimeout(this.calcTimeout);
        }

        this.calcTimeout = setTimeout(function () {
          // +1 for fit edge bug of digit width, like 35.4px
          var lastStepOffsetWidth = (domNode.lastChild.offsetWidth || 0) + 1; // Reduce shake bug

          if (_this3.lastStepOffsetWidth === lastStepOffsetWidth || Math.abs(_this3.lastStepOffsetWidth - lastStepOffsetWidth) <= 3) {
            return;
          }

          _this3.setState({
            lastStepOffsetWidth: lastStepOffsetWidth
          });
        });
      }
    }
  },
  render: function render() {
    var _classString,
        _this4 = this;

    var h = arguments[0];
    var prefixCls = this.prefixCls,
        direction = this.direction,
        labelPlacement = this.labelPlacement,
        iconPrefix = this.iconPrefix,
        status = this.status,
        size = this.size,
        current = this.current,
        $scopedSlots = this.$scopedSlots;
    var progressDot = this.progressDot;

    if (progressDot === undefined) {
      progressDot = $scopedSlots.progressDot;
    }

    var lastStepOffsetWidth = this.lastStepOffsetWidth,
        flexSupported = this.flexSupported;
    var filteredChildren = Object(props_util["c" /* filterEmpty */])(this.$slots["default"]);
    var lastIndex = filteredChildren.length - 1;
    var adjustedlabelPlacement = progressDot ? 'vertical' : labelPlacement;
    var classString = (_classString = {}, vc_steps_Steps_defineProperty(_classString, prefixCls, true), vc_steps_Steps_defineProperty(_classString, "".concat(prefixCls, "-").concat(direction), true), vc_steps_Steps_defineProperty(_classString, "".concat(prefixCls, "-").concat(size), size), vc_steps_Steps_defineProperty(_classString, "".concat(prefixCls, "-label-").concat(adjustedlabelPlacement), direction === 'horizontal'), vc_steps_Steps_defineProperty(_classString, "".concat(prefixCls, "-dot"), !!progressDot), _classString);
    var stepsProps = {
      "class": classString,
      ref: 'vcStepsRef',
      on: this.$listeners
    };
    return h("div", stepsProps, [filteredChildren.map(function (child, index) {
      var childProps = Object(props_util["k" /* getPropsData */])(child);
      var stepProps = {
        props: vc_steps_Steps_objectSpread({
          stepNumber: "".concat(index + 1),
          prefixCls: prefixCls,
          iconPrefix: iconPrefix,
          progressDot: _this4.progressDot
        }, childProps),
        on: Object(props_util["h" /* getEvents */])(child),
        scopedSlots: $scopedSlots
      };

      if (!flexSupported && direction !== 'vertical' && index !== lastIndex) {
        stepProps.props.itemWidth = "".concat(100 / lastIndex, "%");
        stepProps.props.adjustMarginRight = "".concat(-Math.round(lastStepOffsetWidth / lastIndex + 1), "px");
      } // fix tail color


      if (status === 'error' && index === current - 1) {
        stepProps["class"] = "".concat(prefixCls, "-next-error");
      }

      if (!childProps.status) {
        if (index === current) {
          stepProps.props.status = status;
        } else if (index < current) {
          stepProps.props.status = 'finish';
        } else {
          stepProps.props.status = 'wait';
        }
      }

      return Object(vnode["a" /* cloneElement */])(child, stepProps);
    })]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-steps/Step.jsx


function Step_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




function isString(str) {
  return typeof str === 'string';
}

/* harmony default export */ var Step = ({
  name: 'Step',
  props: {
    prefixCls: vue_types["a" /* default */].string,
    wrapperStyle: vue_types["a" /* default */].object,
    itemWidth: vue_types["a" /* default */].string,
    status: vue_types["a" /* default */].string,
    iconPrefix: vue_types["a" /* default */].string,
    icon: vue_types["a" /* default */].node,
    adjustMarginRight: vue_types["a" /* default */].string,
    stepNumber: vue_types["a" /* default */].string,
    description: vue_types["a" /* default */].any,
    title: vue_types["a" /* default */].any,
    progressDot: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, vue_types["a" /* default */].func]),
    tailContent: vue_types["a" /* default */].any
  },
  methods: {
    renderIconNode: function renderIconNode() {
      var _iconClassName;

      var h = this.$createElement;

      var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
          prefixCls = _getOptionProps.prefixCls,
          stepNumber = _getOptionProps.stepNumber,
          status = _getOptionProps.status,
          iconPrefix = _getOptionProps.iconPrefix;

      var progressDot = this.progressDot;

      if (progressDot === undefined) {
        progressDot = this.$scopedSlots.progressDot;
      }

      var icon = Object(props_util["g" /* getComponentFromProp */])(this, 'icon');
      var title = Object(props_util["g" /* getComponentFromProp */])(this, 'title');
      var description = Object(props_util["g" /* getComponentFromProp */])(this, 'description');
      var iconNode;
      var iconClassName = (_iconClassName = {}, Step_defineProperty(_iconClassName, "".concat(prefixCls, "-icon"), true), Step_defineProperty(_iconClassName, "".concat(iconPrefix, "icon"), true), Step_defineProperty(_iconClassName, "".concat(iconPrefix, "icon-").concat(icon), icon && isString(icon)), Step_defineProperty(_iconClassName, "".concat(iconPrefix, "icon-check"), !icon && status === 'finish'), Step_defineProperty(_iconClassName, "".concat(iconPrefix, "icon-cross"), !icon && status === 'error'), _iconClassName);
      var iconDot = h("span", {
        "class": "".concat(prefixCls, "-icon-dot")
      }); // `progressDot` enjoy the highest priority

      if (progressDot) {
        if (typeof progressDot === 'function') {
          iconNode = h("span", {
            "class": "".concat(prefixCls, "-icon")
          }, [progressDot({
            index: stepNumber - 1,
            status: status,
            title: title,
            description: description,
            prefixCls: prefixCls
          })]);
        } else {
          iconNode = h("span", {
            "class": "".concat(prefixCls, "-icon")
          }, [iconDot]);
        }
      } else if (icon && !isString(icon)) {
        iconNode = h("span", {
          "class": "".concat(prefixCls, "-icon")
        }, [icon]);
      } else if (icon || status === 'finish' || status === 'error') {
        iconNode = h("span", {
          "class": iconClassName
        });
      } else {
        iconNode = h("span", {
          "class": "".concat(prefixCls, "-icon")
        }, [stepNumber]);
      }

      return iconNode;
    }
  },
  render: function render() {
    var _classString;

    var h = arguments[0];

    var _getOptionProps2 = Object(props_util["j" /* getOptionProps */])(this),
        prefixCls = _getOptionProps2.prefixCls,
        itemWidth = _getOptionProps2.itemWidth,
        _getOptionProps2$stat = _getOptionProps2.status,
        status = _getOptionProps2$stat === void 0 ? 'wait' : _getOptionProps2$stat,
        icon = _getOptionProps2.icon,
        tailContent = _getOptionProps2.tailContent,
        adjustMarginRight = _getOptionProps2.adjustMarginRight;

    var title = Object(props_util["g" /* getComponentFromProp */])(this, 'title');
    var description = Object(props_util["g" /* getComponentFromProp */])(this, 'description');
    var classString = (_classString = {}, Step_defineProperty(_classString, "".concat(prefixCls, "-item"), true), Step_defineProperty(_classString, "".concat(prefixCls, "-item-").concat(status), true), Step_defineProperty(_classString, "".concat(prefixCls, "-item-custom"), icon), _classString);
    var stepProps = {
      "class": classString,
      on: this.$listeners
    };
    var stepItemStyle = {};

    if (itemWidth) {
      stepItemStyle.width = itemWidth;
    }

    if (adjustMarginRight) {
      stepItemStyle.marginRight = adjustMarginRight;
    }

    return h("div", babel_helper_vue_jsx_merge_props_default()([stepProps, {
      style: stepItemStyle
    }]), [h("div", {
      "class": "".concat(prefixCls, "-item-tail")
    }, [tailContent]), h("div", {
      "class": "".concat(prefixCls, "-item-icon")
    }, [this.renderIconNode()]), h("div", {
      "class": "".concat(prefixCls, "-item-content")
    }, [h("div", {
      "class": "".concat(prefixCls, "-item-title")
    }, [title]), description && h("div", {
      "class": "".concat(prefixCls, "-item-description")
    }, [description])])]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-steps/index.js
// base rc-steps 3.1.1


vc_steps_Steps.Step = Step;

/* harmony default export */ var vc_steps = (vc_steps_Steps);
// CONCATENATED MODULE: ./src/components/steps/index.jsx
function steps_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { steps_defineProperty(target, key, source[key]); }); } return target; }

function steps_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var steps_getStepsProps = function getStepsProps() {
  var defaultProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var props = {
    prefixCls: vue_types["a" /* default */].string,
    iconPrefix: vue_types["a" /* default */].string,
    current: vue_types["a" /* default */].number,
    status: vue_types["a" /* default */].oneOf(['wait', 'process', 'finish', 'error']),
    size: vue_types["a" /* default */].oneOf(['default', 'small']),
    direction: vue_types["a" /* default */].oneOf(['horizontal', 'vertical']),
    labelPlacement: vue_types["a" /* default */].oneOf(['horizontal', 'vertical']),
    progressDot: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, vue_types["a" /* default */].func])
  };
  return Object(props_util["q" /* initDefaultProps */])(props, defaultProps);
};

var steps_Steps = {
  name: 'TaSteps',
  props: steps_getStepsProps({
    prefixCls: 'ant-steps',
    iconPrefix: 'ant',
    current: 0
  }),
  Step: steps_objectSpread({}, vc_steps.Step, {
    name: 'TaStep'
  }),
  render: function render() {
    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var stepsProps = {
      props: props,
      on: this.$listeners,
      scopedSlots: this.$scopedSlots
    };
    return h(vc_steps, stepsProps, [this.$slots["default"]]);
  }
};
/* istanbul ignore next */

steps_Steps.install = function (Vue) {
  Vue.component(steps_Steps.name, steps_Steps);
  Vue.component(steps_Steps.Step.name, steps_Steps.Step);
};

/* harmony default export */ var steps = (steps_Steps);
// CONCATENATED MODULE: ./src/components/vc-switch/PropTypes.js

var switchPropTypes = {
  prefixCls: vue_types["a" /* default */].string,
  disabled: vue_types["a" /* default */].bool.def(false),
  checkedChildren: vue_types["a" /* default */].any,
  unCheckedChildren: vue_types["a" /* default */].any,
  // onChange: PropTypes.func,
  // onMouseUp: PropTypes.func,
  // onClick: PropTypes.func,
  tabIndex: vue_types["a" /* default */].number,
  checked: vue_types["a" /* default */].bool.def(false),
  defaultChecked: vue_types["a" /* default */].bool.def(false),
  autoFocus: vue_types["a" /* default */].bool.def(false)
};
// CONCATENATED MODULE: ./src/components/vc-switch/Switch.jsx
function Switch_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Switch_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Switch_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function Switch_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Switch_defineProperty(target, key, source[key]); }); } return target; }

function Switch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



 // function noop () {
// }

/* harmony default export */ var Switch = ({
  name: 'vc-switch',
  mixins: [BaseMixin["a" /* default */]],
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: Switch_objectSpread({}, switchPropTypes, {
    prefixCls: switchPropTypes.prefixCls.def('rc-switch') // onChange: switchPropTypes.onChange.def(noop),
    // onClick: switchPropTypes.onClick.def(noop),

  }),
  data: function data() {
    var checked = false;

    if (Object(props_util["p" /* hasProp */])(this, 'checked')) {
      checked = !!this.checked;
    } else {
      checked = !!this.defaultChecked;
    }

    return {
      stateChecked: checked
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      var autoFocus = _this.autoFocus,
          disabled = _this.disabled;

      if (autoFocus && !disabled) {
        _this.focus();
      }
    });
  },
  watch: {
    checked: function checked(val) {
      this.stateChecked = val;
    }
  },
  methods: {
    setChecked: function setChecked(checked) {
      if (this.disabled) {
        return;
      }

      if (!Object(props_util["p" /* hasProp */])(this, 'checked')) {
        this.stateChecked = checked;
      }

      this.$emit('change', checked);
    },
    toggle: function toggle() {
      var checked = !this.stateChecked;
      this.setChecked(checked);
      this.$emit('click', checked);
    },
    handleKeyDown: function handleKeyDown(e) {
      if (e.keyCode === 37) {
        // Left
        this.setChecked(false);
      } else if (e.keyCode === 39) {
        // Right
        this.setChecked(true);
      } else if (e.keyCode === 32 || e.keyCode === 13) {
        // Space, Enter
        this.toggle();
      }
    },
    handleMouseUp: function handleMouseUp(e) {
      if (this.$refs.refSwitchNode) {
        this.$refs.refSwitchNode.blur();
      }

      this.$emit('mouseup', e);
    },
    focus: function focus() {
      this.$refs.refSwitchNode.focus();
    },
    blur: function blur() {
      this.$refs.refSwitchNode.blur();
    }
  },
  render: function render() {
    var _switchClassName;

    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        prefixCls = _getOptionProps.prefixCls,
        disabled = _getOptionProps.disabled,
        tabIndex = _getOptionProps.tabIndex,
        restProps = Switch_objectWithoutProperties(_getOptionProps, ["prefixCls", "disabled", "tabIndex"]);

    var checked = this.stateChecked;
    var switchTabIndex = disabled ? -1 : tabIndex || 0;
    var switchClassName = (_switchClassName = {}, Switch_defineProperty(_switchClassName, prefixCls, true), Switch_defineProperty(_switchClassName, "".concat(prefixCls, "-checked"), checked), Switch_defineProperty(_switchClassName, "".concat(prefixCls, "-disabled"), disabled), _switchClassName);
    var spanProps = {
      props: Switch_objectSpread({}, restProps),
      on: Switch_objectSpread({}, this.$listeners, {
        keydown: this.handleKeyDown,
        click: this.toggle,
        mouseup: this.handleMouseUp
      }),
      attrs: {
        tabIndex: switchTabIndex
      },
      "class": switchClassName,
      ref: 'refSwitchNode'
    };
    return h("span", spanProps, [h("span", {
      "class": "".concat(prefixCls, "-inner")
    }, [checked ? Object(props_util["g" /* getComponentFromProp */])(this, 'checkedChildren') : Object(props_util["g" /* getComponentFromProp */])(this, 'unCheckedChildren')])]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-switch/index.js
// base rc-switch 1.6.0

/* harmony default export */ var vc_switch = (Switch);
// CONCATENATED MODULE: ./src/components/switch/index.jsx
function switch_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { switch_defineProperty(target, key, source[key]); }); } return target; }

function switch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function switch_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = switch_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function switch_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





var switch_Switch = {
  name: 'TaSwitch',
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    prefixCls: vue_types["a" /* default */].string.def('ant-switch'),
    // size=default and size=large are the same
    size: vue_types["a" /* default */].oneOf(['small', 'default', 'large']),
    disabled: vue_types["a" /* default */].bool,
    checkedChildren: vue_types["a" /* default */].any,
    unCheckedChildren: vue_types["a" /* default */].any,
    tabIndex: vue_types["a" /* default */].number,
    checked: vue_types["a" /* default */].bool,
    defaultChecked: vue_types["a" /* default */].bool,
    autoFocus: vue_types["a" /* default */].bool,
    loading: vue_types["a" /* default */].bool
  },
  methods: {
    focus: function focus() {
      this.$refs.refSwitchNode.focus();
    },
    blur: function blur() {
      this.$refs.refSwitchNode.blur();
    }
  },
  render: function render() {
    var _classes;

    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        prefixCls = _getOptionProps.prefixCls,
        size = _getOptionProps.size,
        loading = _getOptionProps.loading,
        restProps = switch_objectWithoutProperties(_getOptionProps, ["prefixCls", "size", "loading"]);

    var classes = (_classes = {}, switch_defineProperty(_classes, "".concat(prefixCls, "-small"), size === 'small'), switch_defineProperty(_classes, "".concat(prefixCls, "-loading"), loading), _classes);
    var switchProps = {
      props: switch_objectSpread({}, restProps, {
        prefixCls: prefixCls
      }),
      on: this.$listeners,
      "class": classes,
      ref: 'refSwitchNode'
    };
    return h(wave, {
      attrs: {
        insertExtraNode: true
      }
    }, [h(vc_switch, switchProps, [h("template", {
      slot: 'checkedChildren'
    }, [Object(props_util["g" /* getComponentFromProp */])(this, 'checkedChildren')]), h("template", {
      slot: 'unCheckedChildren'
    }, [Object(props_util["g" /* getComponentFromProp */])(this, 'unCheckedChildren')])])]);
  }
};
/* istanbul ignore next */

switch_Switch.install = function (Vue) {
  Vue.component(switch_Switch.name, switch_Switch);
};

/* harmony default export */ var components_switch = (switch_Switch);
// EXTERNAL MODULE: ./node_modules/lodash/merge.js
var merge = __webpack_require__(260);
var merge_default = /*#__PURE__*/__webpack_require__.n(merge);

// CONCATENATED MODULE: ./src/components/vc-table/src/utils.js

var scrollbarSize; // Measure scrollbar width for padding body during modal show/hide

var scrollbarMeasure = {
  position: 'absolute',
  top: '-9999px',
  width: '50px',
  height: '50px',
  overflow: 'scroll'
};
function measureScrollbar() {
  var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'vertical';

  if (typeof document === 'undefined' || typeof window === 'undefined') {
    return 0;
  }

  if (scrollbarSize) {
    return scrollbarSize;
  }

  var scrollDiv = document.createElement('div');
  Object.keys(scrollbarMeasure).forEach(function (scrollProp) {
    scrollDiv.style[scrollProp] = scrollbarMeasure[scrollProp];
  });
  document.body.appendChild(scrollDiv);
  var size = 0;

  if (direction === 'vertical') {
    size = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  } else if (direction === 'horizontal') {
    size = scrollDiv.offsetHeight - scrollDiv.clientHeight;
  }

  document.body.removeChild(scrollDiv);
  scrollbarSize = size;
  return scrollbarSize;
}
function utils_debounce(func, wait, immediate) {
  var timeout;

  function debounceFunc() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var context = this; // https://fb.me/react-event-pooling

    if (args[0] && args[0].persist) {
      args[0].persist();
    }

    var later = function later() {
      timeout = null;

      if (!immediate) {
        func.apply(context, args);
      }
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);

    if (callNow) {
      func.apply(context, args);
    }
  }

  debounceFunc.cancel = function cancel() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };

  return debounceFunc;
}
var utils_warned = {};
function warningOnce(condition, format, args) {
  if (!utils_warned[format]) {
    browser_default()(condition, format, args);
    utils_warned[format] = !condition;
  }
}
function utils_remove(array, item) {
  var index = array.indexOf(item);
  var front = array.slice(0, index);
  var last = array.slice(index + 1, array.length);
  return front.concat(last);
}
// CONCATENATED MODULE: ./src/components/vc-table/src/ColumnManager.jsx
function ColumnManager_toConsumableArray(arr) { return ColumnManager_arrayWithoutHoles(arr) || ColumnManager_iterableToArray(arr) || ColumnManager_nonIterableSpread(); }

function ColumnManager_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function ColumnManager_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function ColumnManager_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ColumnManager_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { ColumnManager_defineProperty(target, key, source[key]); }); } return target; }

function ColumnManager_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function ColumnManager_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ColumnManager_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function ColumnManager_createClass(Constructor, protoProps, staticProps) { if (protoProps) ColumnManager_defineProperties(Constructor.prototype, protoProps); if (staticProps) ColumnManager_defineProperties(Constructor, staticProps); return Constructor; }

var ColumnManager =
/*#__PURE__*/
function () {
  function ColumnManager(columns) {
    ColumnManager_classCallCheck(this, ColumnManager);

    this.columns = columns;
    this._cached = {};
  }

  ColumnManager_createClass(ColumnManager, [{
    key: "isAnyColumnsFixed",
    value: function isAnyColumnsFixed() {
      var _this = this;

      return this._cache('isAnyColumnsFixed', function () {
        return _this.columns.some(function (column) {
          return !!column.fixed;
        });
      });
    }
  }, {
    key: "isAnyColumnsLeftFixed",
    value: function isAnyColumnsLeftFixed() {
      var _this2 = this;

      return this._cache('isAnyColumnsLeftFixed', function () {
        return _this2.columns.some(function (column) {
          return column.fixed === 'left' || column.fixed === true;
        });
      });
    }
  }, {
    key: "isAnyColumnsRightFixed",
    value: function isAnyColumnsRightFixed() {
      var _this3 = this;

      return this._cache('isAnyColumnsRightFixed', function () {
        return _this3.columns.some(function (column) {
          return column.fixed === 'right';
        });
      });
    }
  }, {
    key: "leftColumns",
    value: function leftColumns() {
      var _this4 = this;

      return this._cache('leftColumns', function () {
        return _this4.groupedColumns().filter(function (column) {
          return column.fixed === 'left' || column.fixed === true;
        });
      });
    }
  }, {
    key: "rightColumns",
    value: function rightColumns() {
      var _this5 = this;

      return this._cache('rightColumns', function () {
        return _this5.groupedColumns().filter(function (column) {
          return column.fixed === 'right';
        });
      });
    }
  }, {
    key: "leafColumns",
    value: function leafColumns() {
      var _this6 = this;

      return this._cache('leafColumns', function () {
        return _this6._leafColumns(_this6.columns);
      });
    }
  }, {
    key: "leftLeafColumns",
    value: function leftLeafColumns() {
      var _this7 = this;

      return this._cache('leftLeafColumns', function () {
        return _this7._leafColumns(_this7.leftColumns());
      });
    }
  }, {
    key: "rightLeafColumns",
    value: function rightLeafColumns() {
      var _this8 = this;

      return this._cache('rightLeafColumns', function () {
        return _this8._leafColumns(_this8.rightColumns());
      });
    } // add appropriate rowspan and colspan to column

  }, {
    key: "groupedColumns",
    value: function groupedColumns() {
      var _this9 = this;

      return this._cache('groupedColumns', function () {
        var _groupColumns = function _groupColumns(columns) {
          var currentRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var parentColumn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var rows = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
          // track how many rows we got
          rows[currentRow] = rows[currentRow] || [];
          var grouped = [];

          var setRowSpan = function setRowSpan(column) {
            var rowSpan = rows.length - currentRow;

            if (column && !column.children && // parent columns are supposed to be one row
            rowSpan > 1 && (!column.rowSpan || column.rowSpan < rowSpan)) {
              column.rowSpan = rowSpan;
            }
          };

          columns.forEach(function (column, index) {
            var newColumn = ColumnManager_objectSpread({}, column);

            rows[currentRow].push(newColumn);
            parentColumn.colSpan = parentColumn.colSpan || 0;

            if (newColumn.children && newColumn.children.length > 0) {
              newColumn.children = _groupColumns(newColumn.children, currentRow + 1, newColumn, rows);
              parentColumn.colSpan += newColumn.colSpan;
            } else {
              parentColumn.colSpan++;
            } // update rowspan to all same row columns


            for (var i = 0; i < rows[currentRow].length - 1; ++i) {
              setRowSpan(rows[currentRow][i]);
            } // last column, update rowspan immediately


            if (index + 1 === columns.length) {
              setRowSpan(newColumn);
            }

            grouped.push(newColumn);
          });
          return grouped;
        };

        return _groupColumns(_this9.columns);
      });
    }
  }, {
    key: "reset",
    value: function reset(columns) {
      this.columns = columns;
      this._cached = {};
    }
  }, {
    key: "_cache",
    value: function _cache(name, fn) {
      if (name in this._cached) {
        return this._cached[name];
      }

      this._cached[name] = fn();
      return this._cached[name];
    }
  }, {
    key: "_leafColumns",
    value: function _leafColumns(columns) {
      var _this10 = this;

      var leafColumns = [];
      columns.forEach(function (column) {
        if (!column.children) {
          leafColumns.push(column);
        } else {
          leafColumns.push.apply(leafColumns, ColumnManager_toConsumableArray(_this10._leafColumns(column.children)));
        }
      });
      return leafColumns;
    }
  }]);

  return ColumnManager;
}();


// CONCATENATED MODULE: ./src/components/vc-table/src/ColGroup.jsx

/* harmony default export */ var ColGroup = ({
  name: 'ColGroup',
  props: {
    fixed: vue_types["a" /* default */].string,
    columns: vue_types["a" /* default */].array
  },
  inject: {
    table: {
      "default": {}
    }
  },
  render: function render() {
    var h = arguments[0];
    var fixed = this.fixed,
        table = this.table;
    var prefixCls = table.prefixCls,
        expandIconAsCell = table.expandIconAsCell,
        columnManager = table.columnManager;
    var cols = [];

    if (expandIconAsCell && fixed !== 'right') {
      cols.push(h("col", {
        "class": "".concat(prefixCls, "-expand-icon-col"),
        key: 'rc-table-expand-icon-col'
      }));
    }

    var leafColumns;

    if (fixed === 'left') {
      leafColumns = columnManager.leftLeafColumns();
    } else if (fixed === 'right') {
      leafColumns = columnManager.rightLeafColumns();
    } else {
      leafColumns = columnManager.leafColumns();
    }

    cols = cols.concat(leafColumns.map(function (c) {
      var width = typeof c.width === 'number' ? "".concat(c.width, "px") : c.width;
      return h("col", {
        key: c.key || c.dataIndex,
        style: {
          width: width,
          minWidth: width
        }
      });
    }));
    return h("colgroup", [cols]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-table/src/TableHeaderRow.jsx


function TableHeaderRow_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TableHeaderRow_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function TableHeaderRow_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function TableHeaderRow_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { TableHeaderRow_defineProperty(target, key, source[key]); }); } return target; }

function TableHeaderRow_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var TableHeaderRow = {
  props: {
    index: vue_types["a" /* default */].number,
    fixed: vue_types["a" /* default */].string,
    columns: vue_types["a" /* default */].array,
    rows: vue_types["a" /* default */].array,
    row: vue_types["a" /* default */].array,
    components: vue_types["a" /* default */].object,
    height: vue_types["a" /* default */].any,
    customHeaderRow: vue_types["a" /* default */].func
  },
  name: 'TableHeaderRow',
  render: function render(h) {
    var row = this.row,
        index = this.index,
        height = this.height,
        components = this.components,
        customHeaderRow = this.customHeaderRow;
    var HeaderRow = components.header.row;
    var HeaderCell = components.header.cell;
    var rowProps = customHeaderRow(row.map(function (cell) {
      return cell.column;
    }), index);
    var customStyle = rowProps ? rowProps.style : {};

    var style = TableHeaderRow_objectSpread({
      height: height
    }, customStyle);

    return h(HeaderRow, babel_helper_vue_jsx_merge_props_default()([rowProps, {
      style: style
    }]), [row.map(function (cell, i) {
      var column = cell.column,
          children = cell.children,
          className = cell.className,
          cellProps = TableHeaderRow_objectWithoutProperties(cell, ["column", "children", "className"]);

      var cls = cell["class"] || className;
      var customProps = column.customHeaderCell ? column.customHeaderCell(column) : {};
      var headerCellProps = Object(props_util["t" /* mergeProps */])({
        attrs: TableHeaderRow_objectSpread({}, cellProps),
        "class": cls
      }, TableHeaderRow_objectSpread({}, customProps, {
        key: column.key || column.dataIndex || i
      }));

      if (column.align) {
        headerCellProps.style = TableHeaderRow_objectSpread({}, customProps.style, {
          textAlign: column.align
        });
      }

      if (typeof HeaderCell === 'function') {
        return HeaderCell(h, headerCellProps, children);
      }

      return h(HeaderCell, headerCellProps, [children]);
    })]);
  }
};

function getRowHeight(state, props) {
  var fixedColumnsHeadRowsHeight = state.fixedColumnsHeadRowsHeight;
  var columns = props.columns,
      rows = props.rows,
      fixed = props.fixed;
  var headerHeight = fixedColumnsHeadRowsHeight[0];

  if (!fixed) {
    return null;
  }

  if (headerHeight && columns) {
    if (headerHeight === 'auto') {
      return 'auto';
    }

    return "".concat(headerHeight / rows.length, "px");
  }

  return null;
}

/* harmony default export */ var src_TableHeaderRow = (connect(function (state, props) {
  return {
    height: getRowHeight(state, props)
  };
})(TableHeaderRow));
// CONCATENATED MODULE: ./src/components/vc-table/src/TableHeader.jsx



function getHeaderRows(columns) {
  var currentRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var rows = arguments.length > 2 ? arguments[2] : undefined;
  rows = rows || [];
  rows[currentRow] = rows[currentRow] || [];
  columns.forEach(function (column) {
    if (column.rowSpan && rows.length < column.rowSpan) {
      while (rows.length < column.rowSpan) {
        rows.push([]);
      }
    }

    var cell = {
      key: column.key,
      className: column.className || column["class"] || '',
      children: column.title,
      column: column
    };

    if (column.children) {
      getHeaderRows(column.children, currentRow + 1, rows);
    }

    if ('colSpan' in column) {
      cell.colSpan = column.colSpan;
    }

    if ('rowSpan' in column) {
      cell.rowSpan = column.rowSpan;
    }

    if (cell.colSpan !== 0) {
      rows[currentRow].push(cell);
    }
  });
  return rows.filter(function (row) {
    return row.length > 0;
  });
}

/* harmony default export */ var TableHeader = ({
  name: 'TableHeader',
  props: {
    fixed: vue_types["a" /* default */].string,
    columns: vue_types["a" /* default */].array.isRequired,
    expander: vue_types["a" /* default */].object.isRequired
  },
  inject: {
    table: {
      "default": {}
    }
  },
  render: function render() {
    var h = arguments[0];
    var _this$table = this.table,
        components = _this$table.sComponents,
        prefixCls = _this$table.prefixCls,
        showHeader = _this$table.showHeader,
        customHeaderRow = _this$table.customHeaderRow;
    var expander = this.expander,
        columns = this.columns,
        fixed = this.fixed;

    if (!showHeader) {
      return null;
    }

    var rows = getHeaderRows(columns);
    expander.renderExpandIndentCell(rows, fixed);
    var HeaderWrapper = components.header.wrapper;
    return h(HeaderWrapper, {
      "class": "".concat(prefixCls, "-thead")
    }, [rows.map(function (row, index) {
      return h(src_TableHeaderRow, {
        key: index,
        attrs: {
          index: index,
          fixed: fixed,
          columns: columns,
          rows: rows,
          row: row,
          components: components,
          customHeaderRow: customHeaderRow
        }
      });
    })]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-table/src/TableCell.jsx
function TableCell_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { TableCell_typeof = function _typeof(obj) { return typeof obj; }; } else { TableCell_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return TableCell_typeof(obj); }

function TableCell_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { TableCell_defineProperty(target, key, source[key]); }); } return target; }

function TableCell_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





function isInvalidRenderCellText(text) {
  return text && !Object(props_util["s" /* isValidElement */])(text) && Object.prototype.toString.call(text) === '[object Object]';
}

/* harmony default export */ var TableCell = ({
  name: 'TableCell',
  props: {
    record: vue_types["a" /* default */].object,
    prefixCls: vue_types["a" /* default */].string,
    index: vue_types["a" /* default */].number,
    indent: vue_types["a" /* default */].number,
    indentSize: vue_types["a" /* default */].number,
    column: vue_types["a" /* default */].object,
    expandIcon: vue_types["a" /* default */].any,
    component: vue_types["a" /* default */].any
  },
  methods: {
    handleClick: function handleClick(e) {
      var record = this.record,
          onCellClick = this.column.onCellClick;

      if (onCellClick) {
        onCellClick(record, e);
      }
    },
    getTooltip: function getTooltip(key, record) {
      var result;

      if (key.indexOf('.') != -1) {
        var arr = key.split('.');
        result = TableCell_objectSpread({}, record);

        for (var i = 0; i < arr.length; i++) {
          if (result[arr[i]]) {
            result = result[arr[i]];
          } else {
            return '';
          }
        }
      } else {
        result = record[key];
      }

      return result;
    },
    getTooltipValue: function getTooltipValue(list) {
      var _this = this;

      var result = [];
      list.forEach(function (item) {
        if (item.children) {
          var temp = _this.getTooltipValue(item.children);

          result = result.concat(temp);
        } else {
          if (item.text && item.text != ' ') {
            result.push(item.text);
          }
        }
      });
      return result;
    }
  },
  render: function render(h) {
    var record = this.record,
        indentSize = this.indentSize,
        prefixCls = this.prefixCls,
        indent = this.indent,
        index = this.index,
        expandIcon = this.expandIcon,
        column = this.column,
        BodyCell = this.component;
    var dataIndex = column.dataIndex,
        customRender = column.customRender,
        _column$className = column.className,
        className = _column$className === void 0 ? '' : _column$className;
    var cls = className || column["class"]; // We should return undefined if no dataIndex is specified, but in order to
    // be compatible with object-path's behavior, we return the record object instead.

    var text;

    if (typeof dataIndex === 'number') {
      text = get_default()(record, dataIndex);
    } else if (!dataIndex || dataIndex.length === 0) {
      text = record;
    } else {
      text = get_default()(record, dataIndex);
    }

    var tdProps = {
      props: {},
      attrs: {},
      "class": cls,
      on: {
        click: this.handleClick
      }
    };
    var colSpan;
    var rowSpan;

    if (customRender) {
      text = customRender(text, record, index);

      if (isInvalidRenderCellText(text)) {
        tdProps.attrs = text.attrs || {};
        tdProps.props = text.props || {};
        colSpan = tdProps.attrs.colSpan;
        rowSpan = tdProps.attrs.rowSpan;
        text = text.children;
      }
    }

    if (column.customCell) {
      tdProps = Object(props_util["t" /* mergeProps */])(tdProps, column.customCell(record));
    } // Fix https://github.com/ant-design/ant-design/issues/1202


    if (isInvalidRenderCellText(text)) {
      text = null;
    }

    var indentText = expandIcon ? h("span", {
      style: {
        paddingLeft: "".concat(indentSize * indent, "px")
      },
      "class": "".concat(prefixCls, "-indent indent-level-").concat(indent)
    }) : null;

    if (rowSpan === 0 || colSpan === 0) {
      return null;
    }

    if (column.align) {
      tdProps.style = {
        textAlign: column.align
      };
    } // add by Selina 表格文字溢出


    if (this.record && !this.record.editable && column.key != 'selection-column' && text && (column.title.context.showOverflowTooltip || column.overflowTooltip != undefined) && column.width) {
      if (column.title.context.showOverflowTooltip || column.overflowTooltip != undefined) {
        var tooltipText,
            tempText = text,
            expandWidth = expandIcon ? indentSize * indent + 25 : 0;
        var width = column.width.toString().indexOf('%') == -1 ? "".concat(parseInt(column.width) - 32 - expandWidth, "px") : "calc(100% - ".concat(expandWidth, "px )");
        var overflowDiv = h("div", {
          style: {
            width: width,
            overflow: 'hidden',
            textOverflow: 'ellipsis',
            whiteSpace: 'nowrap',
            display: expandIcon ? 'inline-block' : '',
            verticalAlign: expandIcon ? 'bottom' : ''
          }
        }, [tempText]);
      }

      if (column.title.context.showOverflowTooltip && column.overflowTooltip == undefined) {
        if (TableCell_typeof(tempText) === 'object') {
          var tooltipVNode = tempText[0] ? tempText[0].children : tempText.children;

          if (tooltipVNode) {
            tooltipText = this.getTooltipValue(tooltipVNode).join('');
          }
        } else {
          tooltipText = tempText;
        }

        text = h("ta-tooltip", {
          attrs: {
            placement: "topLeft"
          }
        }, [h("template", {
          slot: "title"
        }, [tooltipText]), overflowDiv]);
      }

      if (column.overflowTooltip != undefined) {
        if (column.overflowTooltip === false) {
          text = overflowDiv;
        } else {
          if (column.overflowTooltip === true) {
            if (TableCell_typeof(tempText) === 'object') {
              var _tooltipVNode = tempText[0] ? tempText[0].children : tempText.children;

              if (_tooltipVNode) {
                tooltipText = this.getTooltipValue(_tooltipVNode).join('');
              }
            } else {
              tooltipText = tempText;
            }
          } else {
            tooltipText = this.getTooltip(column.overflowTooltip, record);
          }

          text = h("ta-tooltip", {
            attrs: {
              placement: "topLeft"
            }
          }, [h("template", {
            slot: "title"
          }, [tooltipText]), overflowDiv]);
        }
      }
    }

    return h(BodyCell, tdProps, [indentText, expandIcon, text]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-table/src/TableRow.jsx
function TableRow_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { TableRow_defineProperty(target, key, source[key]); }); } return target; }

function TableRow_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








function TableRow_noop() {}

var TableRow = {
  name: 'TableRow',
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])({
    customRow: vue_types["a" /* default */].func,
    // onRowClick: PropTypes.func,
    // onRowDoubleClick: PropTypes.func,
    // onRowContextMenu: PropTypes.func,
    // onRowMouseEnter: PropTypes.func,
    // onRowMouseLeave: PropTypes.func,
    record: vue_types["a" /* default */].object,
    prefixCls: vue_types["a" /* default */].string,
    // onHover: PropTypes.func,
    columns: vue_types["a" /* default */].array,
    height: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
    index: vue_types["a" /* default */].number,
    rowKey: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]).isRequired,
    className: vue_types["a" /* default */].string,
    indent: vue_types["a" /* default */].number,
    indentSize: vue_types["a" /* default */].number,
    hasExpandIcon: vue_types["a" /* default */].func,
    hovered: vue_types["a" /* default */].bool.isRequired,
    visible: vue_types["a" /* default */].bool.isRequired,
    store: vue_types["a" /* default */].object.isRequired,
    fixed: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].bool]),
    renderExpandIcon: vue_types["a" /* default */].func,
    renderExpandIconCell: vue_types["a" /* default */].func,
    components: vue_types["a" /* default */].any,
    expandedRow: vue_types["a" /* default */].bool,
    isAnyColumnsFixed: vue_types["a" /* default */].bool,
    ancestorKeys: vue_types["a" /* default */].array.isRequired,
    expandIconColumnIndex: vue_types["a" /* default */].number,
    expandRowByClick: vue_types["a" /* default */].bool // visible: PropTypes.bool,
    // hovered: PropTypes.bool,
    // height: PropTypes.any,

  }, {
    // expandIconColumnIndex: 0,
    // expandRowByClick: false,
    hasExpandIcon: function hasExpandIcon() {},
    renderExpandIcon: function renderExpandIcon() {},
    renderExpandIconCell: function renderExpandIconCell() {}
  }),
  data: function data() {
    // this.shouldRender = this.visible
    return {
      shouldRender: this.visible
    };
  },
  mounted: function mounted() {
    var _this = this;

    if (this.shouldRender) {
      this.$nextTick(function () {
        _this.saveRowRef();
      });
    }
  },
  watch: {
    visible: function visible(val) {
      if (val) {
        this.shouldRender = true;
      }
    }
  },
  updated: function updated() {
    var _this2 = this;

    if (this.shouldRender && !this.rowRef) {
      this.$nextTick(function () {
        _this2.saveRowRef();
      });
    }
  },
  methods: {
    onRowClick: function onRowClick(event) {
      var record = this.record,
          index = this.index;

      this.__emit('rowClick', record, index, event);
    },
    onRowDoubleClick: function onRowDoubleClick(event) {
      var record = this.record,
          index = this.index;

      this.__emit('rowDoubleClick', record, index, event);
    },
    onContextMenu: function onContextMenu(event) {
      var record = this.record,
          index = this.index;

      this.__emit('rowContextmenu', record, index, event);
    },
    onMouseEnter: function onMouseEnter(event) {
      var record = this.record,
          index = this.index,
          rowKey = this.rowKey;

      this.__emit('hover', true, rowKey);

      this.__emit('rowMouseenter', record, index, event);
    },
    onMouseLeave: function onMouseLeave(event) {
      var record = this.record,
          index = this.index,
          rowKey = this.rowKey;

      this.__emit('hover', false, rowKey);

      this.__emit('rowMouseleave', record, index, event);
    },
    setExpanedRowHeight: function setExpanedRowHeight() {
      var store = this.store,
          rowKey = this.rowKey;

      var _store$getState = store.getState(),
          expandedRowsHeight = _store$getState.expandedRowsHeight;

      var height = this.rowRef.getBoundingClientRect().height;
      expandedRowsHeight = TableRow_objectSpread({}, expandedRowsHeight, TableRow_defineProperty({}, rowKey, height));
      store.setState({
        expandedRowsHeight: expandedRowsHeight
      });
    },
    setRowHeight: function setRowHeight() {
      var store = this.store,
          rowKey = this.rowKey;

      var _store$getState2 = store.getState(),
          fixedColumnsBodyRowsHeight = _store$getState2.fixedColumnsBodyRowsHeight;

      var height = this.rowRef.getBoundingClientRect().height;
      store.setState({
        fixedColumnsBodyRowsHeight: TableRow_objectSpread({}, fixedColumnsBodyRowsHeight, TableRow_defineProperty({}, rowKey, height))
      });
    },
    getStyle: function getStyle() {
      var height = this.height,
          visible = this.visible;

      var style = Object(props_util["n" /* getStyle */])(this);

      if (height) {
        style = TableRow_objectSpread({}, style, {
          height: height
        });
      }

      if (!visible && !style.display) {
        style = TableRow_objectSpread({}, style, {
          display: 'none'
        });
      }

      return style;
    },
    saveRowRef: function saveRowRef() {
      this.rowRef = this.$el;
      var isAnyColumnsFixed = this.isAnyColumnsFixed,
          fixed = this.fixed,
          expandedRow = this.expandedRow,
          ancestorKeys = this.ancestorKeys;

      if (!isAnyColumnsFixed) {
        return;
      }

      if (!fixed && expandedRow) {
        this.setExpanedRowHeight();
      }

      if (!fixed && ancestorKeys.length >= 0) {
        this.setRowHeight();
      }
    },
    onDragDrop: function onDragDrop(ev) {
      ev.preventDefault();
      var dataRowKey = ev.dataTransfer.getData('text');
      var target = ev.target.parentNode;
      var parent = target.parentNode;
      var src;

      try {
        // FIXME:这里可能存在一定的性能问题，时间复杂度o(n):n表示元素当前的位置
        parent.childNodes.forEach(function (node, i) {
          if (node.getAttribute('data-row-key') === dataRowKey) {
            src = node;
            throw DOMException();
          }
        });
      } catch (e) {// do nothing
      }

      src.parentNode.removeChild(src); // FIXME: 这个条件要修改

      if (ev.offsetY < target.offsetHeight / 2) {
        parent.insertBefore(src, target);
      } else {
        var next = parent.nextSibling;

        if (next) {
          next.insertBefore(src, target);
        } else {
          parent.appendChild(src);
        }
      }
    },
    onDragStart: function onDragStart(e) {
      e.dataTransfer.setData('text/plain', e.target.getAttribute('data-row-key'));
    },
    onDragOver: function onDragOver(e) {
      e.preventDefault();
    }
  },
  render: function render() {
    var h = arguments[0];

    if (!this.shouldRender) {
      return null;
    }

    var prefixCls = this.prefixCls,
        columns = this.columns,
        record = this.record,
        rowKey = this.rowKey,
        index = this.index,
        _this$customRow = this.customRow,
        customRow = _this$customRow === void 0 ? TableRow_noop : _this$customRow,
        indent = this.indent,
        indentSize = this.indentSize,
        hovered = this.hovered,
        height = this.height,
        visible = this.visible,
        components = this.components,
        hasExpandIcon = this.hasExpandIcon,
        renderExpandIcon = this.renderExpandIcon,
        renderExpandIconCell = this.renderExpandIconCell;
    var BodyRow = components.body.row;
    var BodyCell = components.body.cell;
    var className = '';

    if (hovered) {
      className += " ".concat(prefixCls, "-hover");
    }

    var cells = [];
    renderExpandIconCell(cells);

    for (var i = 0; i < columns.length; i++) {
      var column = columns[i];
      warningOnce(column.onCellClick === undefined, 'column[onCellClick] is deprecated, please use column[customCell] instead.');
      cells.push(h(TableCell, {
        attrs: {
          prefixCls: prefixCls,
          record: record,
          indentSize: indentSize,
          indent: indent,
          index: index,
          column: column,
          expandIcon: hasExpandIcon(i) && renderExpandIcon(),
          component: BodyCell
        },
        key: column.key || column.dataIndex
      }));
    }

    var rowClassName = "".concat(prefixCls, " ").concat(className, " ").concat(prefixCls, "-level-").concat(indent).trim();
    var rowProps = customRow(record, index);
    var customStyle = rowProps ? rowProps.style : {};
    var style = {
      height: typeof height === 'number' ? "".concat(height, "px") : height
    };

    if (!visible) {
      style.display = 'none';
    }

    style = TableRow_objectSpread({}, style, customStyle);
    var dragable = false;

    if (rowProps && rowProps.props.draggable) {
      dragable = rowProps.props.draggable;
    }

    var bodyRowProps = Object(props_util["t" /* mergeProps */])({
      on: {
        click: this.onRowClick,
        dblclick: this.onRowDoubleClick,
        mouseenter: this.onMouseEnter,
        mouseleave: this.onMouseLeave,
        contextmenu: this.onContextMenu,
        dragstart: this.onDragStart,
        dragover: this.onDragOver,
        drop: this.onDragDrop
      },
      "class": rowClassName
    }, TableRow_objectSpread({}, rowProps, {
      style: style
    }), {
      attrs: {
        'data-row-key': rowKey,
        'draggable': dragable
      }
    });
    return h(BodyRow, bodyRowProps, [cells]);
  }
};

function TableRow_getRowHeight(state, props) {
  var expandedRowsHeight = state.expandedRowsHeight,
      fixedColumnsBodyRowsHeight = state.fixedColumnsBodyRowsHeight;
  var fixed = props.fixed,
      rowKey = props.rowKey;

  if (!fixed) {
    return null;
  }

  if (expandedRowsHeight[rowKey]) {
    return expandedRowsHeight[rowKey];
  }

  if (fixedColumnsBodyRowsHeight[rowKey]) {
    return fixedColumnsBodyRowsHeight[rowKey];
  }

  return null;
}

/* harmony default export */ var src_TableRow = (connect(function (state, props) {
  var currentHoverKey = state.currentHoverKey,
      expandedRowKeys = state.expandedRowKeys;
  var rowKey = props.rowKey,
      ancestorKeys = props.ancestorKeys;
  var visible = ancestorKeys.length === 0 || ancestorKeys.every(function (k) {
    return ~expandedRowKeys.indexOf(k);
  });
  return {
    visible: visible,
    hovered: currentHoverKey === rowKey,
    height: TableRow_getRowHeight(state, props)
  };
})(TableRow));
// CONCATENATED MODULE: ./src/components/vc-table/src/ExpandIcon.jsx


/* harmony default export */ var ExpandIcon = ({
  mixins: [BaseMixin["a" /* default */]],
  name: 'ExpandIcon',
  props: {
    record: vue_types["a" /* default */].object,
    prefixCls: vue_types["a" /* default */].string,
    expandable: vue_types["a" /* default */].any,
    expanded: vue_types["a" /* default */].bool,
    needIndentSpaced: vue_types["a" /* default */].bool
  },
  methods: {
    onExpand: function onExpand(e) {
      this.__emit('expand', this.record, e);
    }
  },
  render: function render() {
    var h = arguments[0];
    var expandable = this.expandable,
        prefixCls = this.prefixCls,
        onExpand = this.onExpand,
        needIndentSpaced = this.needIndentSpaced,
        expanded = this.expanded;

    if (expandable) {
      var expandClassName = expanded ? 'expanded' : 'collapsed';
      return h("span", {
        "class": "".concat(prefixCls, "-expand-icon ").concat(prefixCls, "-").concat(expandClassName),
        on: {
          "click": onExpand
        }
      });
    } else if (needIndentSpaced) {
      return h("span", {
        "class": "".concat(prefixCls, "-expand-icon ").concat(prefixCls, "-spaced")
      });
    }

    return null;
  }
});
// CONCATENATED MODULE: ./src/components/vc-table/src/ExpandableRow.jsx




var ExpandableRow = {
  mixins: [BaseMixin["a" /* default */]],
  name: 'ExpandableRow',
  props: {
    prefixCls: vue_types["a" /* default */].string.isRequired,
    rowKey: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]).isRequired,
    fixed: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].bool]),
    record: vue_types["a" /* default */].object.isRequired,
    indentSize: vue_types["a" /* default */].number,
    needIndentSpaced: vue_types["a" /* default */].bool.isRequired,
    expandRowByClick: vue_types["a" /* default */].bool,
    expanded: vue_types["a" /* default */].bool.isRequired,
    expandIconAsCell: vue_types["a" /* default */].bool,
    expandIconColumnIndex: vue_types["a" /* default */].number,
    childrenColumnName: vue_types["a" /* default */].string,
    expandedRowRender: vue_types["a" /* default */].func // onExpandedChange: PropTypes.func.isRequired,
    // onRowClick: PropTypes.func,
    // children: PropTypes.func.isRequired,

  },
  beforeDestroy: function beforeDestroy() {
    this.handleDestroy();
  },
  methods: {
    hasExpandIcon: function hasExpandIcon(columnIndex) {
      var expandRowByClick = this.expandRowByClick;
      return !this.tempExpandIconAsCell && !expandRowByClick && columnIndex === this.tempExpandIconColumnIndex;
    },
    handleExpandChange: function handleExpandChange(record, event) {
      var expanded = this.expanded,
          rowKey = this.rowKey;

      this.__emit('expandedChange', !expanded, record, event, rowKey);
    },
    handleDestroy: function handleDestroy() {
      var rowKey = this.rowKey,
          record = this.record;

      this.__emit('expandedChange', false, record, null, rowKey, true);
    },
    handleRowClick: function handleRowClick(record, index, event) {
      var expandRowByClick = this.expandRowByClick;

      if (expandRowByClick) {
        this.handleExpandChange(record, event);
      }

      this.__emit('rowClick', record, index, event);
    },
    renderExpandIcon: function renderExpandIcon() {
      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          expanded = this.expanded,
          record = this.record,
          needIndentSpaced = this.needIndentSpaced;
      return h(ExpandIcon, {
        attrs: {
          expandable: this.expandable,
          prefixCls: prefixCls,
          needIndentSpaced: needIndentSpaced,
          expanded: expanded,
          record: record
        },
        on: {
          "expand": this.handleExpandChange
        }
      });
    },
    renderExpandIconCell: function renderExpandIconCell(cells) {
      var h = this.$createElement;

      if (!this.tempExpandIconAsCell) {
        return;
      }

      var prefixCls = this.prefixCls;
      cells.push(h("td", {
        "class": "".concat(prefixCls, "-expand-icon-cell"),
        key: 'rc-table-expand-icon-cell'
      }, [this.renderExpandIcon()]));
    }
  },
  render: function render() {
    var childrenColumnName = this.childrenColumnName,
        expandedRowRender = this.expandedRowRender,
        indentSize = this.indentSize,
        record = this.record,
        fixed = this.fixed,
        $scopedSlots = this.$scopedSlots;
    this.tempExpandIconAsCell = fixed !== 'right' ? this.expandIconAsCell : false;
    this.tempExpandIconColumnIndex = fixed !== 'right' ? this.expandIconColumnIndex : -1;
    var childrenData = record[childrenColumnName];
    this.expandable = !!(childrenData || expandedRowRender);
    var expandableRowProps = {
      props: {
        indentSize: indentSize,
        hasExpandIcon: this.hasExpandIcon,
        renderExpandIcon: this.renderExpandIcon,
        renderExpandIconCell: this.renderExpandIconCell
      },
      on: {
        rowClick: this.handleRowClick
      }
    };
    return $scopedSlots["default"] && $scopedSlots["default"](expandableRowProps);
  }
};
/* harmony default export */ var src_ExpandableRow = (connect(function (_ref, _ref2) {
  var expandedRowKeys = _ref.expandedRowKeys;
  var rowKey = _ref2.rowKey;
  return {
    expanded: !!~expandedRowKeys.indexOf(rowKey)
  };
})(ExpandableRow));
// CONCATENATED MODULE: ./src/components/vc-table/src/BaseTable.jsx
function BaseTable_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { BaseTable_defineProperty(target, key, source[key]); }); } return target; }

function BaseTable_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










function BaseTable_noop() {}

var BaseTable = {
  name: 'BaseTable',
  props: {
    fixed: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].bool]),
    columns: vue_types["a" /* default */].array.isRequired,
    tableClassName: vue_types["a" /* default */].string.isRequired,
    hasHead: vue_types["a" /* default */].bool.isRequired,
    hasBody: vue_types["a" /* default */].bool.isRequired,
    store: vue_types["a" /* default */].object.isRequired,
    expander: vue_types["a" /* default */].object.isRequired,
    getRowKey: vue_types["a" /* default */].func,
    isAnyColumnsFixed: vue_types["a" /* default */].bool
  },
  inject: {
    table: {
      "default": {}
    }
  },
  methods: {
    getColumns: function getColumns(cols) {
      var _this$$props = this.$props,
          _this$$props$columns = _this$$props.columns,
          columns = _this$$props$columns === void 0 ? [] : _this$$props$columns,
          fixed = _this$$props.fixed;
      var table = this.table;
      var prefixCls = table.$props.prefixCls;
      return (cols || columns).map(function (column) {
        return BaseTable_objectSpread({}, column, {
          className: !!column.fixed && !fixed ? classnames_default()("".concat(prefixCls, "-fixed-columns-in-body"), column.className || column["class"]) : column.className || column["class"]
        });
      });
    },
    handleRowHover: function handleRowHover(isHover, key) {
      this.store.setState({
        currentHoverKey: isHover ? key : null
      });
    },
    renderRows: function renderRows(renderData, indent) {
      var _this = this;

      var ancestorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var h = this.$createElement;
      var _this$table = this.table,
          columnManager = _this$table.columnManager,
          components = _this$table.sComponents,
          prefixCls = _this$table.prefixCls,
          childrenColumnName = _this$table.childrenColumnName,
          rowClassName = _this$table.rowClassName,
          _this$table$$listener = _this$table.$listeners,
          _this$table$$listener2 = _this$table$$listener.rowClick,
          onRowClick = _this$table$$listener2 === void 0 ? BaseTable_noop : _this$table$$listener2,
          _this$table$$listener3 = _this$table$$listener.rowDoubleclick,
          onRowDoubleClick = _this$table$$listener3 === void 0 ? BaseTable_noop : _this$table$$listener3,
          _this$table$$listener4 = _this$table$$listener.rowContextmenu,
          onRowContextMenu = _this$table$$listener4 === void 0 ? BaseTable_noop : _this$table$$listener4,
          _this$table$$listener5 = _this$table$$listener.rowMouseenter,
          onRowMouseEnter = _this$table$$listener5 === void 0 ? BaseTable_noop : _this$table$$listener5,
          _this$table$$listener6 = _this$table$$listener.rowMouseleave,
          onRowMouseLeave = _this$table$$listener6 === void 0 ? BaseTable_noop : _this$table$$listener6,
          _this$table$customRow = _this$table.customRow,
          customRow = _this$table$customRow === void 0 ? BaseTable_noop : _this$table$customRow;
      var getRowKey = this.getRowKey,
          fixed = this.fixed,
          expander = this.expander,
          isAnyColumnsFixed = this.isAnyColumnsFixed;
      var rows = [];

      var _loop = function _loop(i) {
        var record = renderData[i];
        var key = getRowKey(record, i);
        var className = typeof rowClassName === 'string' ? rowClassName : rowClassName(record, i, indent);
        var onHoverProps = {};

        if (columnManager.isAnyColumnsFixed()) {
          onHoverProps.hover = _this.handleRowHover;
        }

        var leafColumns = void 0;

        if (fixed === 'left') {
          leafColumns = columnManager.leftLeafColumns();
        } else if (fixed === 'right') {
          leafColumns = columnManager.rightLeafColumns();
        } else {
          leafColumns = _this.getColumns(columnManager.leafColumns());
        }

        var rowPrefixCls = "".concat(prefixCls, "-row");
        var expandableRowProps = {
          props: BaseTable_objectSpread({}, expander.props, {
            fixed: fixed,
            index: i,
            prefixCls: rowPrefixCls,
            record: record,
            rowKey: key,
            needIndentSpaced: expander.needIndentSpaced
          }),
          key: key,
          on: {
            // ...expander.on,
            rowClick: onRowClick,
            expandedChange: expander.handleExpandChange
          },
          scopedSlots: {
            "default": function _default(expandableRow) {
              var tableRowProps = Object(props_util["t" /* mergeProps */])({
                props: {
                  fixed: fixed,
                  indent: indent,
                  record: record,
                  index: i,
                  prefixCls: rowPrefixCls,
                  childrenColumnName: childrenColumnName,
                  columns: leafColumns,
                  rowKey: key,
                  ancestorKeys: ancestorKeys,
                  components: components,
                  isAnyColumnsFixed: isAnyColumnsFixed,
                  customRow: customRow
                },
                on: BaseTable_objectSpread({
                  rowDoubleclick: onRowDoubleClick,
                  rowContextmenu: onRowContextMenu,
                  rowMouseenter: onRowMouseEnter,
                  rowMouseleave: onRowMouseLeave
                }, onHoverProps),
                "class": className,
                ref: "row_".concat(i, "_").concat(indent)
              }, expandableRow);
              return h(src_TableRow, tableRowProps);
            }
          }
        };
        var row = h(src_ExpandableRow, expandableRowProps);
        rows.push(row);
        expander.renderRows(_this.renderRows, rows, record, i, indent, fixed, key, ancestorKeys);
      };

      for (var i = 0; i < renderData.length; i++) {
        _loop(i);
      }

      return rows;
    }
  },
  render: function render() {
    var h = arguments[0];
    var _this$table2 = this.table,
        components = _this$table2.sComponents,
        prefixCls = _this$table2.prefixCls,
        scroll = _this$table2.scroll,
        data = _this$table2.data,
        getBodyWrapper = _this$table2.getBodyWrapper;
    var _this$$props2 = this.$props,
        expander = _this$$props2.expander,
        tableClassName = _this$$props2.tableClassName,
        hasHead = _this$$props2.hasHead,
        hasBody = _this$$props2.hasBody,
        fixed = _this$$props2.fixed;
    var tableStyle = {};

    if (!fixed && scroll.x) {
      // not set width, then use content fixed width
      if (scroll.x === true) {
        tableStyle.tableLayout = 'fixed';
      } else {
        tableStyle.width = typeof scroll.x === 'number' ? "".concat(scroll.x, "px") : scroll.x;
      }
    }

    var Table = hasBody ? components.table : 'table';
    var BodyWrapper = components.body.wrapper;
    var body;

    if (hasBody) {
      body = h(BodyWrapper, {
        "class": "".concat(prefixCls, "-tbody")
      }, [this.renderRows(data, 0)]);

      if (getBodyWrapper) {
        body = getBodyWrapper(body);
      }
    }

    var columns = this.getColumns();

    for (var i = 0; i < columns.length; i++) {
      if (columns[i].overflowTooltip || columns[i].title.context.showOverflowTooltip) {
        tableStyle.tableLayout = 'fixed';
        break;
      }
    }

    return h(Table, {
      "class": tableClassName,
      style: tableStyle,
      key: 'table'
    }, [h(ColGroup, {
      attrs: {
        columns: columns,
        fixed: fixed
      }
    }), hasHead && h(TableHeader, {
      attrs: {
        expander: expander,
        columns: columns,
        fixed: fixed
      }
    }), body]);
  }
};
/* harmony default export */ var src_BaseTable = (connect()(BaseTable));
// CONCATENATED MODULE: ./src/components/vc-table/src/HeadTable.jsx



/* harmony default export */ var HeadTable = ({
  name: 'HeadTable',
  props: {
    fixed: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].bool]),
    columns: vue_types["a" /* default */].array.isRequired,
    tableClassName: vue_types["a" /* default */].string.isRequired,
    handleBodyScrollLeft: vue_types["a" /* default */].func.isRequired,
    expander: vue_types["a" /* default */].object.isRequired
  },
  inject: {
    table: {
      "default": {}
    }
  },
  mounted: function mounted() {
    this.updateTableRef();
  },
  updated: function updated() {
    this.updateTableRef();
  },
  methods: {
    updateTableRef: function updateTableRef() {
      var _this = this;

      this.$nextTick(function () {
        _this.$refs.headTable && _this.table.saveChildrenRef('headTable', _this.$refs.headTable);
      });
    }
  },
  render: function render() {
    var h = arguments[0];
    var columns = this.columns,
        fixed = this.fixed,
        tableClassName = this.tableClassName,
        handleBodyScrollLeft = this.handleBodyScrollLeft,
        expander = this.expander,
        table = this.table;
    var prefixCls = table.prefixCls,
        scroll = table.scroll,
        showHeader = table.showHeader;
    var useFixedHeader = table.useFixedHeader;
    var headStyle = {};

    if (scroll.y) {
      useFixedHeader = true; // Add negative margin bottom for scroll bar overflow bug

      var scrollbarWidth = measureScrollbar('horizontal');
      /* if (scrollbarWidth > 0 && !fixed) {
        headStyle.marginBottom = `-${scrollbarWidth}px`
        headStyle.paddingBottom = '0px'
      } */
    }

    if (!useFixedHeader || !showHeader) {
      return null;
    }

    return h("div", {
      key: 'headTable',
      ref: fixed ? null : 'headTable',
      "class": "".concat(prefixCls, "-header"),
      style: headStyle,
      on: {
        "scroll": handleBodyScrollLeft
      }
    }, [h(src_BaseTable, {
      attrs: {
        tableClassName: tableClassName,
        hasHead: true,
        hasBody: false,
        fixed: fixed,
        columns: columns,
        expander: expander
      }
    })]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-table/src/BodyTable.jsx
function BodyTable_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { BodyTable_defineProperty(target, key, source[key]); }); } return target; }

function BodyTable_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/* harmony default export */ var BodyTable = ({
  name: 'BodyTable',
  props: {
    fixed: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].bool]),
    columns: vue_types["a" /* default */].array.isRequired,
    tableClassName: vue_types["a" /* default */].string.isRequired,
    handleBodyScroll: vue_types["a" /* default */].func.isRequired,
    handleWheel: vue_types["a" /* default */].func.isRequired,
    getRowKey: vue_types["a" /* default */].func.isRequired,
    expander: vue_types["a" /* default */].object.isRequired,
    isAnyColumnsFixed: vue_types["a" /* default */].bool
  },
  inject: {
    table: {
      "default": {}
    }
  },
  mounted: function mounted() {
    this.updateTableRef();
  },
  updated: function updated() {
    this.updateTableRef();
  },
  methods: {
    updateTableRef: function updateTableRef() {
      this.$refs.fixedColumnsBodyLeft && this.table.saveChildrenRef('fixedColumnsBodyLeft', this.$refs.fixedColumnsBodyLeft);
      this.$refs.fixedColumnsBodyRight && this.table.saveChildrenRef('fixedColumnsBodyRight', this.$refs.fixedColumnsBodyRight);
      this.$refs.bodyTable && this.table.saveChildrenRef('bodyTable', this.$refs.bodyTable);
    }
  },
  render: function render() {
    var h = arguments[0];
    var _this$table = this.table,
        prefixCls = _this$table.prefixCls,
        scroll = _this$table.scroll;
    var columns = this.columns,
        fixed = this.fixed,
        tableClassName = this.tableClassName,
        getRowKey = this.getRowKey,
        handleBodyScroll = this.handleBodyScroll,
        handleWheel = this.handleWheel,
        expander = this.expander,
        isAnyColumnsFixed = this.isAnyColumnsFixed;
    var useFixedHeader = this.table.useFixedHeader;

    var bodyStyle = BodyTable_objectSpread({}, this.table.bodyStyle);

    var innerBodyStyle = {};

    if (scroll.x || fixed) {
      bodyStyle.overflowX = bodyStyle.overflowX || 'scroll'; // Fix weired webkit render bug
      // https://github.com/ant-design/ant-design/issues/7783

      bodyStyle.WebkitTransform = 'translate3d (0, 0, 0)';
    }

    if (scroll.y) {
      // maxHeight will make fixed-Table scrolling not working
      // so we only set maxHeight to body-Table here
      var maxHeight = bodyStyle.maxHeight || scroll.y;
      maxHeight = typeof maxHeight === 'number' ? "".concat(maxHeight, "px") : maxHeight;

      if (fixed) {
        innerBodyStyle.maxHeight = maxHeight;
        innerBodyStyle.overflowY = bodyStyle.overflowY || 'scroll';
      } else {
        bodyStyle.maxHeight = maxHeight;
      }

      bodyStyle.overflowY = bodyStyle.overflowY || 'scroll';
      useFixedHeader = true; // Add negative margin bottom for scroll bar overflow bug

      var scrollbarWidth = measureScrollbar();
      /* if (scrollbarWidth > 0 && fixed) {
        bodyStyle.marginBottom = `-${scrollbarWidth}px`
        bodyStyle.paddingBottom = '0px'
      } */
    }

    var baseTable = h(src_BaseTable, {
      attrs: {
        tableClassName: tableClassName,
        hasHead: !useFixedHeader,
        hasBody: true,
        fixed: fixed,
        columns: columns,
        expander: expander,
        getRowKey: getRowKey,
        isAnyColumnsFixed: isAnyColumnsFixed
      }
    });

    if (fixed && columns.length) {
      var refName;

      if (columns[0].fixed === 'left' || columns[0].fixed === true) {
        refName = 'fixedColumnsBodyLeft';
      } else if (columns[0].fixed === 'right') {
        refName = 'fixedColumnsBodyRight';
      }

      delete bodyStyle.overflowX;
      delete bodyStyle.overflowY;
      return h("div", {
        key: 'bodyTable',
        "class": "".concat(prefixCls, "-body-outer"),
        style: BodyTable_objectSpread({}, bodyStyle)
      }, [h("div", {
        "class": "".concat(prefixCls, "-body-inner"),
        style: innerBodyStyle,
        ref: refName,
        on: {
          "wheel": handleWheel,
          "scroll": handleBodyScroll
        }
      }, [baseTable])]);
    }

    return h("div", {
      key: 'bodyTable',
      "class": "".concat(prefixCls, "-body"),
      style: bodyStyle,
      ref: 'bodyTable',
      on: {
        "wheel": handleWheel,
        "scroll": handleBodyScroll
      }
    }, [baseTable]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-table/src/ExpandableTable.jsx
function ExpandableTable_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { ExpandableTable_defineProperty(target, key, source[key]); }); } return target; }

function ExpandableTable_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function ExpandableTable_toConsumableArray(arr) { return ExpandableTable_arrayWithoutHoles(arr) || ExpandableTable_iterableToArray(arr) || ExpandableTable_nonIterableSpread(); }

function ExpandableTable_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function ExpandableTable_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function ExpandableTable_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }







var ExpandableTable_ExpandableTableProps = function ExpandableTableProps() {
  return {
    expandIconAsCell: vue_types["a" /* default */].bool,
    expandRowByClick: vue_types["a" /* default */].bool,
    expandedRowKeys: vue_types["a" /* default */].array,
    expandedRowClassName: vue_types["a" /* default */].func,
    defaultExpandAllRows: vue_types["a" /* default */].bool,
    defaultExpandedRowKeys: vue_types["a" /* default */].array,
    expandIconColumnIndex: vue_types["a" /* default */].number,
    expandedRowRender: vue_types["a" /* default */].func,
    childrenColumnName: vue_types["a" /* default */].string,
    indentSize: vue_types["a" /* default */].number,
    // onExpand: PropTypes.func,
    // onExpandedRowsChange: PropTypes.func,
    columnManager: vue_types["a" /* default */].object.isRequired,
    store: vue_types["a" /* default */].object.isRequired,
    prefixCls: vue_types["a" /* default */].string.isRequired,
    data: vue_types["a" /* default */].array,
    getRowKey: vue_types["a" /* default */].func
  };
};
var ExpandableTable = {
  name: 'ExpandableTable',
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(ExpandableTable_ExpandableTableProps(), {
    expandIconAsCell: false,
    expandedRowClassName: function expandedRowClassName() {
      return '';
    },
    expandIconColumnIndex: 0,
    defaultExpandAllRows: false,
    defaultExpandedRowKeys: [],
    childrenColumnName: 'children',
    indentSize: 15
  }),
  data: function data() {
    var data = this.data,
        childrenColumnName = this.childrenColumnName,
        defaultExpandAllRows = this.defaultExpandAllRows,
        expandedRowKeys = this.expandedRowKeys,
        defaultExpandedRowKeys = this.defaultExpandedRowKeys,
        getRowKey = this.getRowKey;
    var finnalExpandedRowKeys = [];

    var rows = ExpandableTable_toConsumableArray(data);

    if (defaultExpandAllRows) {
      for (var i = 0; i < rows.length; i++) {
        var row = rows[i];

        if (!row.children || row.children.length === 0) {
          continue;
        }

        finnalExpandedRowKeys.push(getRowKey(row, i));
        rows = rows.concat(row[childrenColumnName] || []);
      }
    } else {
      finnalExpandedRowKeys = expandedRowKeys || defaultExpandedRowKeys;
    } // this.columnManager = props.columnManager
    // this.store = props.store


    this.store.setState({
      expandedRowsHeight: {},
      expandedRowKeys: finnalExpandedRowKeys
    });
    return {};
  },
  watch: {
    expandedRowKeys: function expandedRowKeys(val) {
      var _this = this;

      this.$nextTick(function () {
        _this.store.setState({
          expandedRowKeys: val
        });
      });
    },
    data: function data(val) {
      var _this2 = this;

      var childrenColumnName = this.childrenColumnName,
          defaultExpandAllRows = this.defaultExpandAllRows,
          expandedRowKeys = this.expandedRowKeys,
          defaultExpandedRowKeys = this.defaultExpandedRowKeys,
          getRowKey = this.getRowKey;
      var finnalExpandedRowKeys = [];

      var rows = ExpandableTable_toConsumableArray(val);

      var storeExpanded = this.store.getState().expandedRowKeys;

      for (var i = 0; i < rows.length; i++) {
        var row = rows[i];

        if (!row.children || row.children.length === 0) {
          continue;
        }

        if (defaultExpandAllRows) {
          finnalExpandedRowKeys.push(getRowKey(row, i));
          rows = rows.concat(row[childrenColumnName] || []);
        } // 若其子节点是异步加载的，那么第二次点击开的时候应该将其从expandedRowKeys中移除


        row.children.forEach(function (item, index) {
          if (!item.children || item.children.length === 0) {
            var searchIndex = storeExpanded.indexOf(getRowKey(item, index));

            if (searchIndex != -1) {
              storeExpanded.splice(searchIndex, 1);
            }
          }
        });
      }

      this.$nextTick(function () {
        _this2.store.setState({
          data: val
        });
      });

      if (defaultExpandAllRows) {
        this.$nextTick(function () {
          _this2.store.setState({
            expandedRowKeys: finnalExpandedRowKeys
          });
        });
      }
    }
  },
  methods: {
    handleExpandChange: function handleExpandChange(expanded, record, event, rowKey) {
      var destroy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }

      var getRowKey = this.getRowKey;

      var _this$store$getState = this.store.getState(),
          expandedRowKeys = _this$store$getState.expandedRowKeys;

      if (expanded) {
        // row was expaned
        expandedRowKeys = [].concat(ExpandableTable_toConsumableArray(expandedRowKeys), [rowKey]);
      } else {
        // row was collapse
        var expandedRowIndex = expandedRowKeys.indexOf(rowKey);

        if (expandedRowIndex !== -1) {
          expandedRowKeys = utils_remove(expandedRowKeys, rowKey);
        } // 从已展开数组中移除当前节点


        var storeExpanded = this.store.getState().expandedRowKeys;

        var childrenIter = function childrenIter(sub, index) {
          var subKey = getRowKey(sub, index);
          var subKeyIndex = storeExpanded.indexOf(subKey);

          if (subKeyIndex != -1) {
            expandedRowKeys = utils_remove(expandedRowKeys, subKey);
          }
        };

        if (record.children && record.children.length >= 0) {
          record.children.forEach(childrenIter);
        }
      }

      if (!this.expandedRowKeys) {
        this.store.setState({
          expandedRowKeys: expandedRowKeys
        });
      }

      this.__emit('expandedRowsChange', expandedRowKeys);

      if (!destroy) {
        this.__emit('expand', expanded, record);
      }
    },
    renderExpandIndentCell: function renderExpandIndentCell(rows, fixed) {
      var prefixCls = this.prefixCls,
          expandIconAsCell = this.expandIconAsCell;

      if (!expandIconAsCell || fixed === 'right' || !rows.length) {
        return;
      }

      var iconColumn = {
        key: 'rc-table-expand-icon-cell',
        className: "".concat(prefixCls, "-expand-icon-th"),
        title: '',
        rowSpan: rows.length
      };
      rows[0].unshift(ExpandableTable_objectSpread({}, iconColumn, {
        column: iconColumn
      }));
    },
    renderExpandedRow: function renderExpandedRow(record, index, expandedRowRender, className, ancestorKeys, indent, fixed) {
      var _this3 = this;

      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          expandIconAsCell = this.expandIconAsCell,
          indentSize = this.indentSize;
      var parentKey = ancestorKeys[ancestorKeys.length - 1];
      var rowKey = "".concat(parentKey, "-extra-row");
      var components = {
        body: {
          row: 'tr',
          cell: 'td'
        }
      };
      var colCount;

      if (fixed === 'left') {
        colCount = this.columnManager.leftLeafColumns().length;
      } else if (fixed === 'right') {
        colCount = this.columnManager.rightLeafColumns().length;
      } else {
        colCount = this.columnManager.leafColumns().length;
      }

      var columns = [{
        key: 'extra-row',
        customRender: function customRender() {
          var _this3$store$getState = _this3.store.getState(),
              expandedRowKeys = _this3$store$getState.expandedRowKeys;

          var expanded = !!~expandedRowKeys.indexOf(parentKey);
          return {
            attrs: {
              colSpan: colCount
            },
            children: fixed !== 'right' ? expandedRowRender(record, index, indent, expanded) : '&nbsp;'
          };
        }
      }];

      if (expandIconAsCell && fixed !== 'right') {
        columns.unshift({
          key: 'expand-icon-placeholder',
          customRender: function customRender() {
            return null;
          }
        });
      }

      return h(src_TableRow, {
        key: rowKey,
        attrs: {
          columns: columns,
          rowKey: rowKey,
          ancestorKeys: ancestorKeys,
          prefixCls: "".concat(prefixCls, "-expanded-row"),
          indentSize: indentSize,
          indent: indent,
          fixed: fixed,
          components: components,
          expandedRow: true,
          hasExpandIcon: function hasExpandIcon() {}
        },
        "class": className
      });
    },
    renderRows: function renderRows(_renderRows, rows, record, index, indent, fixed, parentKey, ancestorKeys) {
      var expandedRowClassName = this.expandedRowClassName,
          expandedRowRender = this.expandedRowRender,
          childrenColumnName = this.childrenColumnName;
      var childrenData = record[childrenColumnName];
      var nextAncestorKeys = [].concat(ExpandableTable_toConsumableArray(ancestorKeys), [parentKey]);
      var nextIndent = indent + 1;

      if (expandedRowRender) {
        rows.push(this.renderExpandedRow(record, index, expandedRowRender, expandedRowClassName(record, index, indent), nextAncestorKeys, nextIndent, fixed));
      }

      if (childrenData) {
        rows.push.apply(rows, ExpandableTable_toConsumableArray(_renderRows(childrenData, nextIndent, nextAncestorKeys)));
      }
    }
  },
  render: function render() {
    var data = this.data,
        childrenColumnName = this.childrenColumnName,
        $scopedSlots = this.$scopedSlots,
        $listeners = this.$listeners;
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var needIndentSpaced = data.some(function (record) {
      return record[childrenColumnName];
    });
    return $scopedSlots["default"] && $scopedSlots["default"]({
      props: props,
      on: $listeners,
      needIndentSpaced: needIndentSpaced,
      renderRows: this.renderRows,
      handleExpandChange: this.handleExpandChange,
      renderExpandIndentCell: this.renderExpandIndentCell
    });
  }
};
/* harmony default export */ var src_ExpandableTable = (connect()(ExpandableTable));
// CONCATENATED MODULE: ./src/components/vc-table/src/Table.jsx
function Table_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Table_defineProperty(target, key, source[key]); }); } return target; }

function Table_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Table_toConsumableArray(arr) { return Table_arrayWithoutHoles(arr) || Table_iterableToArray(arr) || Table_nonIterableSpread(); }

function Table_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function Table_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function Table_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

/* eslint-disable camelcase */













/* harmony default export */ var src_Table = ({
  name: 'Table',
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])({
    data: vue_types["a" /* default */].array,
    useFixedHeader: vue_types["a" /* default */].bool,
    columns: vue_types["a" /* default */].array,
    prefixCls: vue_types["a" /* default */].string,
    bodyStyle: vue_types["a" /* default */].object,
    rowKey: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].func]),
    rowClassName: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].func]),
    customRow: vue_types["a" /* default */].func,
    customHeaderRow: vue_types["a" /* default */].func,
    // onRowClick: PropTypes.func,
    // onRowDoubleClick: PropTypes.func,
    // onRowContextMenu: PropTypes.func,
    // onRowMouseEnter: PropTypes.func,
    // onRowMouseLeave: PropTypes.func,
    showHeader: vue_types["a" /* default */].bool,
    title: vue_types["a" /* default */].func,
    id: vue_types["a" /* default */].string,
    footer: vue_types["a" /* default */].func,
    emptyText: vue_types["a" /* default */].any,
    scroll: vue_types["a" /* default */].object,
    rowRef: vue_types["a" /* default */].func,
    getBodyWrapper: vue_types["a" /* default */].func,
    components: vue_types["a" /* default */].shape({
      table: vue_types["a" /* default */].any,
      header: vue_types["a" /* default */].shape({
        wrapper: vue_types["a" /* default */].any,
        row: vue_types["a" /* default */].any,
        cell: vue_types["a" /* default */].any
      }),
      body: vue_types["a" /* default */].shape({
        wrapper: vue_types["a" /* default */].any,
        row: vue_types["a" /* default */].any,
        cell: vue_types["a" /* default */].any
      })
    }),
    expandIconAsCell: vue_types["a" /* default */].bool,
    expandedRowKeys: vue_types["a" /* default */].array,
    expandedRowClassName: vue_types["a" /* default */].func,
    defaultExpandAllRows: vue_types["a" /* default */].bool,
    defaultExpandedRowKeys: vue_types["a" /* default */].array,
    expandIconColumnIndex: vue_types["a" /* default */].number,
    expandedRowRender: vue_types["a" /* default */].func,
    childrenColumnName: vue_types["a" /* default */].string,
    indentSize: vue_types["a" /* default */].number,
    expandRowByClick: vue_types["a" /* default */].bool,
    __propsSymbol__: vue_types["a" /* default */].any
  }, {
    data: [],
    useFixedHeader: false,
    rowKey: 'key',
    rowClassName: function rowClassName() {
      return '';
    },
    prefixCls: 'rc-table',
    bodyStyle: {},
    showHeader: true,
    scroll: {},
    rowRef: function rowRef() {
      return null;
    },
    emptyText: function emptyText() {
      return 'No Data';
    },
    customHeaderRow: function customHeaderRow() {}
  }),
  // static childContextTypes = {
  //   table: PropTypes.any,
  //   components: PropTypes.any,
  // },
  created: function created() {
    var _this = this;

    ['rowClick', 'rowDoubleclick', 'rowContextmenu', 'rowMouseenter', 'rowMouseleave'].forEach(function (name) {
      warningOnce(_this.$listeners[name] === undefined, "".concat(name, " is deprecated, please use customRow instead."));
    });
    warningOnce(this.getBodyWrapper === undefined, 'getBodyWrapper is deprecated, please use custom components instead.'); // this.columnManager = new ColumnManager(this.columns, this.$slots.default)

    this.store = create_create({
      currentHoverKey: null,
      fixedColumnsHeadRowsHeight: [],
      fixedColumnsBodyRowsHeight: {}
    });
    this.setScrollPosition('left');
    this.debouncedWindowResize = utils_debounce(this.handleWindowResize, 150);
  },
  data: function data() {
    this.preData = Table_toConsumableArray(this.data);
    return {
      columnManager: new ColumnManager(this.columns),
      sComponents: merge_default()({
        table: 'table',
        header: {
          wrapper: 'thead',
          row: 'tr',
          cell: 'th'
        },
        body: {
          wrapper: 'tbody',
          row: 'tr',
          cell: 'td'
        }
      }, this.components)
    };
  },
  provide: function provide() {
    return {
      table: this
    };
  },
  watch: {
    components: function components(val) {
      this._components = merge_default()({
        table: 'table',
        header: {
          wrapper: 'thead',
          row: 'tr',
          cell: 'th'
        },
        body: {
          wrapper: 'tbody',
          row: 'tr',
          cell: 'td'
        }
      }, this.components);
    },
    columns: function columns(val) {
      if (val) {
        this.columnManager.reset(val);
      }
    },
    data: function data(val) {
      var _this2 = this;

      if (val.length === 0 && this.hasScrollX()) {
        this.$nextTick(function () {
          _this2.resetScrollX();
        });
      }
    },
    __propsSymbol__: {
      handler: function handler(val) {
        this.$emit('storeCheckStatus');
      },
      immediate: true
    }
  },
  mounted: function mounted() {
    var _this3 = this;

    this.$nextTick(function () {
      if (_this3.columnManager.isAnyColumnsFixed()) {
        _this3.handleWindowResize();

        _this3.resizeEvent = addEventListenerWrap(window, 'resize', _this3.debouncedWindowResize);
      }
    });
  },
  updated: function updated(prevProps) {
    var _this4 = this;

    this.$nextTick(function () {
      if (_this4.columnManager.isAnyColumnsFixed()) {
        _this4.handleWindowResize();

        if (!_this4.resizeEvent) {
          _this4.resizeEvent = addEventListenerWrap(window, 'resize', _this4.debouncedWindowResize);
        }
      }
    });
  },
  beforeDestroy: function beforeDestroy() {
    if (this.resizeEvent) {
      this.resizeEvent.remove();
    }

    if (this.debouncedWindowResize) {
      this.debouncedWindowResize.cancel();
    }
  },
  methods: {
    getRowKey: function getRowKey(record, index) {
      var rowKey = this.rowKey;
      var key = typeof rowKey === 'function' ? rowKey(record, index) : record[rowKey];
      warningOnce(key !== undefined, 'Each record in table should have a unique `key` prop,' + 'or set `rowKey` to an unique primary key.');
      return key === undefined ? index : key;
    },
    setScrollPosition: function setScrollPosition(position) {
      this.scrollPosition = position;

      if (this.$refs.tableNode) {
        var prefixCls = this.prefixCls;

        if (position === 'both') {
          component_classes_default()(this.$refs.tableNode).remove(new RegExp("^".concat(prefixCls, "-scroll-position-.+$"))).add("".concat(prefixCls, "-scroll-position-left")).add("".concat(prefixCls, "-scroll-position-right"));
        } else {
          component_classes_default()(this.$refs.tableNode).remove(new RegExp("^".concat(prefixCls, "-scroll-position-.+$"))).add("".concat(prefixCls, "-scroll-position-").concat(position));
        }
      }
    },
    setScrollPositionClassName: function setScrollPositionClassName() {
      var node = this.ref_bodyTable;
      var scrollToLeft = node.scrollLeft === 0;
      var scrollToRight = node.scrollLeft + 1 >= node.children[0].getBoundingClientRect().width - node.getBoundingClientRect().width;

      if (scrollToLeft && scrollToRight) {
        this.setScrollPosition('both');
      } else if (scrollToLeft) {
        this.setScrollPosition('left');
      } else if (scrollToRight) {
        this.setScrollPosition('right');
      } else if (this.scrollPosition !== 'middle') {
        this.setScrollPosition('middle');
      }
    },
    handleWindowResize: function handleWindowResize() {
      this.syncFixedTableRowHeight();
      this.setScrollPositionClassName();
    },
    syncFixedTableRowHeight: function syncFixedTableRowHeight() {
      var tableRect = this.$refs.tableNode.getBoundingClientRect(); // If tableNode's height less than 0, suppose it is hidden and don't recalculate rowHeight.
      // see: https://github.com/ant-design/ant-design/issues/4836

      if (tableRect.height !== undefined && tableRect.height <= 0) {
        return;
      }

      var prefixCls = this.prefixCls;
      var headRows = this.ref_headTable ? this.ref_headTable.querySelectorAll('thead') : this.ref_bodyTable.querySelectorAll('thead');
      var bodyRows = this.ref_bodyTable.querySelectorAll(".".concat(prefixCls, "-row")) || [];
      var fixedColumnsHeadRowsHeight = [].map.call(headRows, function (row) {
        return row.getBoundingClientRect().height || 'auto';
      });
      var state = this.store.getState();
      var fixedColumnsBodyRowsHeight = [].reduce.call(bodyRows, function (acc, row) {
        var rowKey = row.getAttribute('data-row-key');
        var height = row.getBoundingClientRect().height || state.fixedColumnsBodyRowsHeight[rowKey] || 'auto';
        acc[rowKey] = height;
        return acc;
      }, {});

      if (shallowequal_default()(state.fixedColumnsHeadRowsHeight, fixedColumnsHeadRowsHeight) && shallowequal_default()(state.fixedColumnsBodyRowsHeight, fixedColumnsBodyRowsHeight)) {
        return;
      }

      this.store.setState({
        fixedColumnsHeadRowsHeight: fixedColumnsHeadRowsHeight,
        fixedColumnsBodyRowsHeight: fixedColumnsBodyRowsHeight
      });
    },
    resetScrollX: function resetScrollX() {
      if (this.ref_headTable) {
        this.ref_headTable.scrollLeft = 0;
      }

      if (this.ref_bodyTable) {
        this.ref_bodyTable.scrollLeft = 0;
      }
    },
    hasScrollX: function hasScrollX() {
      var _this$scroll = this.scroll,
          scroll = _this$scroll === void 0 ? {} : _this$scroll;
      return 'x' in scroll;
    },
    handleBodyScrollLeft: function handleBodyScrollLeft(e) {
      // Fix https://github.com/ant-design/ant-design/issues/7635
      if (e.currentTarget !== e.target) {
        return;
      }

      var target = e.target;
      var _this$scroll2 = this.scroll,
          scroll = _this$scroll2 === void 0 ? {} : _this$scroll2;
      var ref_headTable = this.ref_headTable,
          ref_bodyTable = this.ref_bodyTable;

      if (target.scrollLeft !== this.lastScrollLeft && scroll.x) {
        if (target === ref_bodyTable && ref_headTable) {
          ref_headTable.scrollLeft = target.scrollLeft;
        } else if (target === ref_headTable && ref_bodyTable) {
          ref_bodyTable.scrollLeft = target.scrollLeft;
        }

        this.setScrollPositionClassName();
      } // Remember last scrollLeft for scroll direction detecting.


      this.lastScrollLeft = target.scrollLeft;
    },
    handleBodyScrollTop: function handleBodyScrollTop(e) {
      var target = e.target; // Fix https://github.com/ant-design/ant-design/issues/9033

      if (e.currentTarget !== target) {
        return;
      }

      var _this$scroll3 = this.scroll,
          scroll = _this$scroll3 === void 0 ? {} : _this$scroll3;
      var ref_headTable = this.ref_headTable,
          ref_bodyTable = this.ref_bodyTable,
          ref_fixedColumnsBodyLeft = this.ref_fixedColumnsBodyLeft,
          ref_fixedColumnsBodyRight = this.ref_fixedColumnsBodyRight;

      if (target.scrollTop !== this.lastScrollTop && scroll.y && target !== ref_headTable) {
        var scrollTop = target.scrollTop;

        if (ref_fixedColumnsBodyLeft && target !== ref_fixedColumnsBodyLeft) {
          ref_fixedColumnsBodyLeft.scrollTop = scrollTop;
        }

        if (ref_fixedColumnsBodyRight && target !== ref_fixedColumnsBodyRight) {
          ref_fixedColumnsBodyRight.scrollTop = scrollTop;
        }

        if (ref_bodyTable && target !== ref_bodyTable) {
          ref_bodyTable.scrollTop = scrollTop;
        }
      } // Remember last scrollTop for scroll direction detecting.


      this.lastScrollTop = target.scrollTop;
    },
    handleBodyScroll: function handleBodyScroll(e) {
      this.handleBodyScrollLeft(e);
      this.handleBodyScrollTop(e);
    },
    handleWheel: function handleWheel(event) {
      var _this$$props$scroll = this.$props.scroll,
          scroll = _this$$props$scroll === void 0 ? {} : _this$$props$scroll;

      if (window.navigator.userAgent.match(/Trident\/7\./) && scroll.y) {
        event.preventDefault();
        var wd = event.deltaY;
        var target = event.target;
        var bodyTable = this.bodyTable,
            fixedColumnsBodyLeft = this.fixedColumnsBodyLeft,
            fixedColumnsBodyRight = this.fixedColumnsBodyRight;
        var scrollTop = 0;

        if (this.lastScrollTop) {
          scrollTop = this.lastScrollTop + wd;
        } else {
          scrollTop = wd;
        }

        if (fixedColumnsBodyLeft && target !== fixedColumnsBodyLeft) {
          fixedColumnsBodyLeft.scrollTop = scrollTop;
        }

        if (fixedColumnsBodyRight && target !== fixedColumnsBodyRight) {
          fixedColumnsBodyRight.scrollTop = scrollTop;
        }

        if (bodyTable && target !== bodyTable) {
          bodyTable.scrollTop = scrollTop;
        }
      }
    },
    saveChildrenRef: function saveChildrenRef(name, node) {
      this["ref_".concat(name)] = node;
    },
    renderMainTable: function renderMainTable() {
      var h = this.$createElement;
      var scroll = this.scroll,
          prefixCls = this.prefixCls;
      var isAnyColumnsFixed = this.columnManager.isAnyColumnsFixed();
      var scrollable = isAnyColumnsFixed || scroll.x || scroll.y;
      var table = [this.renderTable({
        columns: this.columnManager.groupedColumns(),
        isAnyColumnsFixed: isAnyColumnsFixed
      }), this.renderEmptyText(), this.renderFooter()];
      return scrollable ? h("div", {
        "class": "".concat(prefixCls, "-scroll")
      }, [table]) : table;
    },
    renderLeftFixedTable: function renderLeftFixedTable() {
      var h = this.$createElement;
      var prefixCls = this.prefixCls;
      return h("div", {
        "class": "".concat(prefixCls, "-fixed-left")
      }, [this.renderTable({
        columns: this.columnManager.leftColumns(),
        fixed: 'left'
      })]);
    },
    renderRightFixedTable: function renderRightFixedTable() {
      var h = this.$createElement;
      var prefixCls = this.prefixCls;
      return h("div", {
        "class": "".concat(prefixCls, "-fixed-right")
      }, [this.renderTable({
        columns: this.columnManager.rightColumns(),
        fixed: 'right'
      })]);
    },
    renderTable: function renderTable(options) {
      var h = this.$createElement;
      var columns = options.columns,
          fixed = options.fixed,
          isAnyColumnsFixed = options.isAnyColumnsFixed;
      var prefixCls = this.prefixCls,
          _this$scroll4 = this.scroll,
          scroll = _this$scroll4 === void 0 ? {} : _this$scroll4;
      var tableClassName = scroll.x || fixed ? "".concat(prefixCls, "-fixed") : '';
      var headTable = h(HeadTable, {
        key: 'head',
        attrs: {
          columns: columns,
          fixed: fixed,
          tableClassName: tableClassName,
          handleBodyScrollLeft: this.handleBodyScrollLeft,
          expander: this.expander
        }
      });
      var bodyTable = h(BodyTable, {
        key: 'body',
        attrs: {
          columns: columns,
          fixed: fixed,
          tableClassName: tableClassName,
          getRowKey: this.getRowKey,
          handleWheel: this.handleWheel,
          handleBodyScroll: this.handleBodyScroll,
          expander: this.expander,
          isAnyColumnsFixed: isAnyColumnsFixed
        }
      });
      return [headTable, bodyTable];
    },
    renderTitle: function renderTitle() {
      var h = this.$createElement;
      var title = this.title,
          prefixCls = this.prefixCls,
          data = this.data;
      return title ? h("div", {
        "class": "".concat(prefixCls, "-title"),
        key: 'title'
      }, [title(data)]) : null;
    },
    renderFooter: function renderFooter() {
      var h = this.$createElement;
      var footer = this.footer,
          prefixCls = this.prefixCls,
          data = this.data;
      return footer ? h("div", {
        "class": "".concat(prefixCls, "-footer"),
        key: 'footer'
      }, [footer(data)]) : null;
    },
    renderEmptyText: function renderEmptyText() {
      var h = this.$createElement;
      var emptyText = this.emptyText,
          prefixCls = this.prefixCls,
          data = this.data;

      if (data.length) {
        return null;
      }

      var emptyClassName = "".concat(prefixCls, "-placeholder");
      return h("div", {
        "class": emptyClassName,
        key: 'emptyText'
      }, [typeof emptyText === 'function' ? emptyText() : emptyText]);
    }
  },
  render: function render() {
    var _this5 = this;

    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var $listeners = this.$listeners,
        columnManager = this.columnManager,
        getRowKey = this.getRowKey;
    var prefixCls = props.prefixCls;
    var className = props.prefixCls;

    if (props.useFixedHeader || props.scroll && props.scroll.y) {
      className += " ".concat(prefixCls, "-fixed-header");
    }

    if (this.scrollPosition === 'both') {
      className += " ".concat(prefixCls, "-scroll-position-left ").concat(prefixCls, "-scroll-position-right");
    } else {
      className += " ".concat(prefixCls, "-scroll-position-").concat(this.scrollPosition);
    }

    var hasLeftFixed = columnManager.isAnyColumnsLeftFixed();
    var hasRightFixed = columnManager.isAnyColumnsRightFixed();
    var expandableTableProps = {
      props: Table_objectSpread({}, props, {
        columnManager: columnManager,
        getRowKey: getRowKey
      }),
      on: Table_objectSpread({}, $listeners),
      scopedSlots: {
        "default": function _default(expander) {
          _this5.expander = expander;
          return h("div", {
            ref: 'tableNode',
            "class": className // style={props.style}
            // id={props.id}

          }, [_this5.renderTitle(), h("div", {
            "class": "".concat(prefixCls, "-content")
          }, [_this5.renderMainTable(), hasLeftFixed && _this5.renderLeftFixedTable(), hasRightFixed && _this5.renderRightFixedTable()])]);
        }
      }
    };
    return h(Provider, {
      attrs: {
        store: this.store
      }
    }, [h(src_ExpandableTable, expandableTableProps)]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-table/src/Column.jsx

/* harmony default export */ var Column = ({
  name: 'Column',
  props: {
    colSpan: vue_types["a" /* default */].number,
    title: vue_types["a" /* default */].any,
    dataIndex: vue_types["a" /* default */].string,
    width: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].string]),
    fixed: vue_types["a" /* default */].oneOf([true, 'left', 'right']),
    customRender: vue_types["a" /* default */].func,
    className: vue_types["a" /* default */].string,
    // onCellClick: PropTypes.func,
    customCell: vue_types["a" /* default */].func,
    customHeaderCell: vue_types["a" /* default */].func
  }
});
// CONCATENATED MODULE: ./src/components/vc-table/src/ColumnGroup.jsx

/* harmony default export */ var ColumnGroup = ({
  name: 'ColumnGroup',
  props: {
    title: vue_types["a" /* default */].any
  },
  isTableColumnGroup: true
});
// CONCATENATED MODULE: ./src/components/vc-table/index.js
function vc_table_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      vc_table_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function vc_table_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
} // base rc-table 6.2.9






var vc_table_Table = {
  name: 'Table',
  Column: Column,
  ColumnGroup: ColumnGroup,
  props: src_Table.props,
  methods: {
    normalize: function normalize() {
      var _this = this;

      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var columns = [];
      elements.forEach(function (element) {
        if (!element.tag) {
          return;
        }

        var key = Object(props_util["i" /* getKey */])(element);
        var style = Object(props_util["n" /* getStyle */])(element);
        var cls = Object(props_util["f" /* getClass */])(element);
        var props = Object(props_util["j" /* getOptionProps */])(element);
        var events = Object(props_util["h" /* getEvents */])(element);
        var listeners = {};
        Object.keys(events).forEach(function (e) {
          var k = "on-".concat(e);
          listeners[Object(props_util["a" /* camelize */])(k)] = events[e];
        });

        var _getSlots = Object(props_util["m" /* getSlots */])(element),
            children = _getSlots["default"],
            title = _getSlots.title;

        var column = vc_table_objectSpread({
          title: title
        }, props, {
          style: style,
          "class": cls
        }, listeners);

        if (key) {
          column.key = key;
        }

        if (Object(props_util["l" /* getSlotOptions */])(element).isTableColumnGroup) {
          column.children = _this.normalize(children);
        } else {
          var customRender = element.data && element.data.scopedSlots && element.data.scopedSlots["default"];
          column.customRender = column.customRender || customRender;
        }

        columns.push(column);
      });
      return columns;
    }
  },
  render: function render() {
    var h = arguments[0];
    var $listeners = this.$listeners,
        $slots = this.$slots,
        normalize = this.normalize;
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var columns = props.columns || normalize($slots["default"]);
    var tProps = {
      props: vc_table_objectSpread({}, props, {
        columns: columns
      }),
      on: $listeners
    };
    return h(src_Table, tProps);
  }
};
/* harmony default export */ var vc_table = (vc_table_Table);

// EXTERNAL MODULE: ./node_modules/dom-closest/index.js
var dom_closest = __webpack_require__(414);
var dom_closest_default = /*#__PURE__*/__webpack_require__.n(dom_closest);

// CONCATENATED MODULE: ./src/components/table/FilterDropdownMenuWrapper.jsx
/* harmony default export */ var FilterDropdownMenuWrapper = ({
  methods: {
    handelClick: function handelClick(e) {
      this.$emit('click', e);
    }
  },
  render: function render() {
    var h = arguments[0];
    var $slots = this.$slots,
        handelClick = this.handelClick;
    return h("div", {
      on: {
        "click": handelClick
      }
    }, [$slots["default"]]);
  }
});
// CONCATENATED MODULE: ./src/components/table/createStore.jsx


var Store = vue_types["a" /* default */].shape({
  setState: vue_types["a" /* default */].func,
  getState: vue_types["a" /* default */].func,
  subscribe: vue_types["a" /* default */].func
}).loose;
var createStore = create_create;
/* harmony default export */ var table_createStore = (createStore);
// CONCATENATED MODULE: ./src/components/table/interface.js
function table_interface_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      table_interface_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function table_interface_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}





var interface_PaginationProps = Pagination_PaginationProps();
var interface_SpinProps = Spin_SpinProps(); // export type CompareFn<T> = ((a: T, b: T) => number);

var ColumnFilterItem = vue_types["a" /* default */].shape({
  text: vue_types["a" /* default */].string,
  value: vue_types["a" /* default */].string,
  children: vue_types["a" /* default */].array
}).loose;
var ColumnProps = {
  title: vue_types["a" /* default */].any,
  // key?: React.Key;
  dataIndex: vue_types["a" /* default */].string,
  customRender: vue_types["a" /* default */].func,
  customCell: vue_types["a" /* default */].func,
  customHeaderCell: vue_types["a" /* default */].func,
  align: vue_types["a" /* default */].oneOf(['left', 'right', 'center']),
  filters: vue_types["a" /* default */].arrayOf(ColumnFilterItem),
  // onFilter: (value: any, record: T) => PropTypes.bool,
  filterMultiple: vue_types["a" /* default */].bool,
  filterDropdown: vue_types["a" /* default */].any,
  filterDropdownVisible: vue_types["a" /* default */].bool,
  // onFilterDropdownVisibleChange?: (visible: boolean) => void;
  sorter: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */]["boolean"], vue_types["a" /* default */].func]),
  defaultSortOrder: vue_types["a" /* default */].oneOf(['ascend', 'descend']),
  colSpan: vue_types["a" /* default */].number,
  width: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
  className: vue_types["a" /* default */].string,
  fixed: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, vue_types["a" /* default */].oneOf(['left', 'right'])]),
  filterIcon: vue_types["a" /* default */].any,
  filteredValue: vue_types["a" /* default */].array,
  sortOrder: vue_types["a" /* default */].oneOf(['ascend', 'descend']),
  overflowTooltip: vue_types["a" /* default */].bool // children?: ColumnProps<T>[];
  // onCellClick?: (record: T, event: any) => void;
  // onCell?: (record: T) => any;
  // onHeaderCell?: (props: ColumnProps<T>) => any;
  // export interface TableComponents {
  //   table?: any;
  //   header?: {
  //     wrapper?: any;
  //     row?: any;
  //     cell?: any;
  //   };
  //   body?: {
  //     wrapper?: any;
  //     row?: any;
  //     cell?: any;
  //   };
  // }

};
var TableLocale = vue_types["a" /* default */].shape({
  filterTitle: vue_types["a" /* default */].string,
  filterConfirm: vue_types["a" /* default */].any,
  filterReset: vue_types["a" /* default */].any,
  emptyText: vue_types["a" /* default */].any,
  selectAll: vue_types["a" /* default */].any,
  selectInvert: vue_types["a" /* default */].any
}).loose;
var RowSelectionType = vue_types["a" /* default */].oneOf(['checkbox', 'radio']); // export type SelectionSelectFn<T> = (record: T, selected: boolean, selectedRows: Object[]) => any;

var TableRowSelection = {
  type: RowSelectionType,
  selectedRowKeys: vue_types["a" /* default */].array,
  // onChange?: (selectedRowKeys: string[] | number[], selectedRows: Object[]) => any;
  getCheckboxProps: vue_types["a" /* default */].func,
  // onSelect?: SelectionSelectFn<T>;
  // onSelectAll?: (selected: boolean, selectedRows: Object[], changeRows: Object[]) => any;
  // onSelectInvert?: (selectedRows: Object[]) => any;
  selections: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].array, vue_types["a" /* default */].bool]),
  hideDefaultSelections: vue_types["a" /* default */].bool,
  fixed: vue_types["a" /* default */].bool,
  columnWidth: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
  selectWay: vue_types["a" /* default */].oneOf(['onSelect', 'onSelectMultiple', 'onSelectAll', 'onSelectInvert']),
  columnTitle: vue_types["a" /* default */].any,
  isTreeSelectMode: vue_types["a" /* default */].bool
};
var TableProps = {
  prefixCls: vue_types["a" /* default */].string,
  dropdownPrefixCls: vue_types["a" /* default */].string,
  rowSelection: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].shape(TableRowSelection).loose, null]),
  pagination: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].shape(table_interface_objectSpread({}, interface_PaginationProps, {
    position: vue_types["a" /* default */].oneOf(['top', 'bottom', 'both'])
  })).loose, vue_types["a" /* default */].bool]),
  size: vue_types["a" /* default */].oneOf(['default', 'middle', 'small', 'large']),
  dataSource: vue_types["a" /* default */].array,
  components: vue_types["a" /* default */].object,
  columns: vue_types["a" /* default */].array,
  rowKey: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].func]),
  rowClassName: vue_types["a" /* default */].func,
  expandedRowRender: vue_types["a" /* default */].any,
  defaultExpandAllRows: vue_types["a" /* default */].bool,
  defaultExpandedRowKeys: vue_types["a" /* default */].array,
  expandedRowKeys: vue_types["a" /* default */].array,
  expandIconAsCell: vue_types["a" /* default */].bool,
  expandIconColumnIndex: vue_types["a" /* default */].number,
  expandRowByClick: vue_types["a" /* default */].bool,
  // onExpandedRowsChange?: (expandedRowKeys: string[] | number[]) => void;
  //  onExpand?: (expanded: boolean, record: T) => void;
  // onChange?: (pagination: PaginationProps | boolean, filters: string[], sorter: Object) => any;
  loading: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].shape(interface_SpinProps).loose, vue_types["a" /* default */].bool]),
  locale: vue_types["a" /* default */].object,
  indentSize: vue_types["a" /* default */].number,
  // onRowClick?: (record: T, index: number, event: Event) => any;
  customRow: vue_types["a" /* default */].func,
  customHeaderRow: vue_types["a" /* default */].func,
  useFixedHeader: vue_types["a" /* default */].bool,
  bordered: vue_types["a" /* default */].bool,
  showOverflowTooltip: vue_types["a" /* default */].bool,
  showHeader: vue_types["a" /* default */].bool,
  footer: vue_types["a" /* default */].func,
  title: vue_types["a" /* default */].func,
  scroll: vue_types["a" /* default */].object,
  childrenColumnName: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].array, vue_types["a" /* default */].string]),
  bodyStyle: vue_types["a" /* default */].any // className?: PropTypes.string,
  // style?: React.CSSProperties;
  // children?: React.ReactNode;
  // export interface TableStateFilters {
  //   [key: string]: string[];
  // }
  // export interface TableState<T> {
  //   pagination: PaginationProps;
  //   filters: TableStateFilters;
  //   sortColumn: ColumnProps<T> | null;
  //   sortOrder: PropTypes.string,
  // }
  // export type SelectionItemSelectFn = (key: string[]) => any;
  // export interface SelectionItem {
  //   key: PropTypes.string,
  //   text: PropTypes.any,
  //   onSelect: SelectionItemSelectFn;
  // }

};
var SelectionCheckboxAllProps = {
  store: Store,
  locale: vue_types["a" /* default */].any,
  disabled: vue_types["a" /* default */].bool,
  getCheckboxPropsByItem: vue_types["a" /* default */].func,
  getRecordKey: vue_types["a" /* default */].func,
  data: vue_types["a" /* default */].array,
  prefixCls: vue_types["a" /* default */].string,
  // onSelect: (key: string, index: number, selectFunc: any) => void;
  hideDefaultSelections: vue_types["a" /* default */].bool,
  selections: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].array, vue_types["a" /* default */].bool]),
  getPopupContainer: vue_types["a" /* default */].func // export interface SelectionCheckboxAllState {
  //   checked: PropTypes.bool,
  //   indeterminate: PropTypes.bool,
  // }

};
var SelectionBoxProps = {
  store: Store,
  type: RowSelectionType,
  defaultSelection: vue_types["a" /* default */].arrayOf([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
  rowIndex: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
  name: vue_types["a" /* default */].string,
  disabled: vue_types["a" /* default */].bool,
  id: vue_types["a" /* default */].string // onChange: React.ChangeEventHandler<HTMLInputElement>;
  // export interface SelectionBoxState {
  //   checked?: PropTypes.bool,
  // }

};
var FilterMenuProps = {
  _propsSymbol: vue_types["a" /* default */].any,
  locale: TableLocale,
  selectedKeys: vue_types["a" /* default */].arrayOf([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
  column: vue_types["a" /* default */].object,
  confirmFilter: vue_types["a" /* default */].func,
  prefixCls: vue_types["a" /* default */].string,
  dropdownPrefixCls: vue_types["a" /* default */].string,
  getPopupContainer: vue_types["a" /* default */].func,
  handleFilter: vue_types["a" /* default */].func // export interface FilterMenuState {
  //   selectedKeys: string[];
  //   keyPathOfSelectedItem: { [key: string]: string };
  //   visible?: PropTypes.bool,
  // }

};
// CONCATENATED MODULE: ./src/components/table/filterDropdown.jsx
function filterDropdown_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { filterDropdown_defineProperty(target, key, source[key]); }); } return target; }

function filterDropdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }














/* harmony default export */ var table_filterDropdown = ({
  mixins: [BaseMixin["a" /* default */]],
  name: 'FilterMenu',
  props: Object(props_util["q" /* initDefaultProps */])(FilterMenuProps, {
    handleFilter: function handleFilter() {},
    column: {}
  }),
  data: function data() {
    var visible = 'filterDropdownVisible' in this.column ? this.column.filterDropdownVisible : false;
    this.preProps = filterDropdown_objectSpread({}, Object(props_util["j" /* getOptionProps */])(this));
    return {
      sSelectedKeys: this.selectedKeys,
      sKeyPathOfSelectedItem: {},
      // 记录所有有选中子菜单的祖先菜单
      sVisible: visible
    };
  },
  mounted: function mounted() {
    var _this = this;

    var column = this.column;
    this.$nextTick(function () {
      _this.setNeverShown(column);
    });
  },
  watch: {
    _propsSymbol: function _propsSymbol() {
      var nextProps = Object(props_util["j" /* getOptionProps */])(this);
      var column = nextProps.column;
      this.setNeverShown(column);
      var newState = {};
      /**
      * if the state is visible the component should ignore updates on selectedKeys prop to avoid
      * that the user selection is lost
      * this happens frequently when a table is connected on some sort of realtime data
      * Fixes https://github.com/ant-design/ant-design/issues/10289 and
      * https://github.com/ant-design/ant-design/issues/10209
      */

      if ('selectedKeys' in nextProps && !shallowequal_default()(this.preProps.selectedKeys, nextProps.selectedKeys)) {
        newState.sSelectedKeys = nextProps.selectedKeys;
      }

      if ('filterDropdownVisible' in column) {
        newState.sVisible = column.filterDropdownVisible;
      }

      if (Object.keys(newState).length > 0) {
        this.setState(newState);
      }

      this.preProps = filterDropdown_objectSpread({}, nextProps);
    } // 'column.fixed': function (val) {
    //   this.setNeverShown(this.column)
    // },
    // column (val) {
    //   if ('filterDropdownVisible' in val) {
    //     this.sVisible = val.filterDropdownVisible
    //   }
    // },
    // selectedKeys (val) {
    //   this.sSelectedKeys = val
    // },

  },
  methods: {
    setNeverShown: function setNeverShown(column) {
      var rootNode = this.$el;
      var filterBelongToScrollBody = !!dom_closest_default()(rootNode, ".ant-table-scroll");

      if (filterBelongToScrollBody) {
        // When fixed column have filters, there will be two dropdown menus
        // Filter dropdown menu inside scroll body should never be shown
        // To fix https://github.com/ant-design/ant-design/issues/5010 and
        // https://github.com/ant-design/ant-design/issues/7909
        this.neverShown = !!column.fixed;
      }
    },
    setSelectedKeys: function setSelectedKeys(_ref) {
      var selectedKeys = _ref.selectedKeys;
      this.setState({
        sSelectedKeys: selectedKeys
      });
    },
    setVisible: function setVisible(visible) {
      var column = this.column;

      if (!('filterDropdownVisible' in column)) {
        this.setState({
          sVisible: visible
        });
      }

      if (column.onFilterDropdownVisibleChange) {
        column.onFilterDropdownVisibleChange(visible);
      }
    },
    handleClearFilters: function handleClearFilters() {
      this.setState({
        sSelectedKeys: []
      }, this.handleConfirm);
    },
    handleConfirm: function handleConfirm() {
      this.setVisible(false);
      this.confirmFilter2();
    },
    onVisibleChange: function onVisibleChange(visible) {
      this.setVisible(visible);

      if (!visible) {
        this.confirmFilter2();
      }
    },
    confirmFilter2: function confirmFilter2() {
      if (!shallowequal_default()(this.sSelectedKeys, this.selectedKeys)) {
        this.confirmFilter(this.column, this.sSelectedKeys);
      }
    },
    renderMenuItem: function renderMenuItem(item) {
      var h = this.$createElement;
      var column = this.column;
      var multiple = 'filterMultiple' in column ? column.filterMultiple : true;
      var input = multiple ? h(components_checkbox, {
        attrs: {
          checked: this.sSelectedKeys.indexOf(item.value.toString()) >= 0
        }
      }) : h(components_radio, {
        attrs: {
          checked: this.sSelectedKeys.indexOf(item.value.toString()) >= 0
        }
      });
      return h(vc_menu_MenuItem, {
        key: item.value
      }, [input, h("span", [item.text])]);
    },
    hasSubMenu: function hasSubMenu() {
      var _this$column$filters = this.column.filters,
          filters = _this$column$filters === void 0 ? [] : _this$column$filters;
      return filters.some(function (item) {
        return !!(item.children && item.children.length > 0);
      });
    },
    renderMenus: function renderMenus(items) {
      var _this2 = this;

      var h = this.$createElement;
      return items.map(function (item) {
        if (item.children && item.children.length > 0) {
          var sKeyPathOfSelectedItem = _this2.sKeyPathOfSelectedItem;
          var containSelected = Object.keys(sKeyPathOfSelectedItem).some(function (key) {
            return sKeyPathOfSelectedItem[key].indexOf(item.value) >= 0;
          });
          var subMenuCls = containSelected ? "".concat(_this2.dropdownPrefixCls, "-submenu-contain-selected") : '';
          return h(vc_menu_SubMenu, {
            attrs: {
              title: item.text
            },
            "class": subMenuCls,
            key: item.value.toString()
          }, [_this2.renderMenus(item.children)]);
        }

        return _this2.renderMenuItem(item);
      });
    },
    handleMenuItemClick: function handleMenuItemClick(info) {
      if (!info.keyPath || info.keyPath.length <= 1) {
        return;
      }

      var keyPathOfSelectedItem = this.sKeyPathOfSelectedItem;

      if (this.sSelectedKeys.indexOf(info.key) >= 0) {
        // deselect SubMenu child
        delete keyPathOfSelectedItem[info.key];
      } else {
        // select SubMenu child
        keyPathOfSelectedItem[info.key] = info.keyPath;
      }

      this.setState({
        keyPathOfSelectedItem: keyPathOfSelectedItem
      });
    },
    renderFilterIcon: function renderFilterIcon() {
      var h = this.$createElement;
      var column = this.column,
          locale = this.locale,
          prefixCls = this.prefixCls,
          selectedKeys = this.selectedKeys;
      var filterd = selectedKeys.length > 0;
      var filterIcon = column.filterIcon;

      if (typeof filterIcon === 'function') {
        filterIcon = filterIcon(filterd);
      }

      var dropdownSelectedClass = filterd ? "".concat(prefixCls, "-selected") : '';
      return filterIcon ? Object(vnode["a" /* cloneElement */])(filterIcon, {
        attrs: {
          title: locale.filterTitle
        },
        "class": classnames_default()("".concat(prefixCls, "-icon"), filterIcon.className)
      }) : h(components_icon, {
        attrs: {
          title: locale.filterTitle,
          type: 'filter'
        },
        "class": dropdownSelectedClass
      });
    }
  },
  render: function render() {
    var _this3 = this;

    var h = arguments[0];
    var column = this.column,
        locale = this.locale,
        prefixCls = this.prefixCls,
        dropdownPrefixCls = this.dropdownPrefixCls,
        getPopupContainer = this.getPopupContainer; // default multiple selection in filter dropdown

    var multiple = 'filterMultiple' in column ? column.filterMultiple : true;
    var dropdownMenuClass = classnames_default()(filterDropdown_defineProperty({}, "".concat(dropdownPrefixCls, "-menu-without-submenu"), !this.hasSubMenu()));
    var filterDropdown = column.filterDropdown;

    if (filterDropdown && typeof filterDropdown === 'function') {
      filterDropdown = filterDropdown({
        prefixCls: "".concat(dropdownPrefixCls, "-custom"),
        setSelectedKeys: function setSelectedKeys(selectedKeys) {
          return _this3.setSelectedKeys({
            selectedKeys: selectedKeys
          });
        },
        selectedKeys: this.sSelectedKeys,
        confirm: this.handleConfirm,
        clearFilters: this.handleClearFilters,
        filters: column.filters,
        getPopupContainer: function getPopupContainer(triggerNode) {
          return triggerNode.parentNode;
        }
      });
    }

    var menus = filterDropdown ? h(FilterDropdownMenuWrapper, [filterDropdown]) : h(FilterDropdownMenuWrapper, {
      "class": "".concat(prefixCls, "-dropdown")
    }, [h(vc_menu, {
      attrs: {
        multiple: multiple,
        prefixCls: "".concat(dropdownPrefixCls, "-menu"),
        selectedKeys: this.sSelectedKeys,
        getPopupContainer: function getPopupContainer(triggerNode) {
          return triggerNode.parentNode;
        }
      },
      on: {
        "click": this.handleMenuItemClick,
        "select": this.setSelectedKeys,
        "deselect": this.setSelectedKeys
      },
      "class": dropdownMenuClass
    }, [this.renderMenus(column.filters)]), h("div", {
      "class": "".concat(prefixCls, "-dropdown-btns")
    }, [h("a", {
      "class": "".concat(prefixCls, "-dropdown-link confirm"),
      on: {
        "click": this.handleConfirm
      }
    }, [locale.filterConfirm]), h("a", {
      "class": "".concat(prefixCls, "-dropdown-link clear"),
      on: {
        "click": this.handleClearFilters
      }
    }, [locale.filterReset])])]);
    return h(components_dropdown, {
      attrs: {
        trigger: ['click'],
        visible: this.neverShown ? false : this.sVisible,
        getPopupContainer: getPopupContainer,
        forceRender: true
      },
      on: {
        "visibleChange": this.onVisibleChange
      }
    }, [h("template", {
      slot: 'overlay'
    }, [menus]), this.renderFilterIcon()]);
  }
});
// CONCATENATED MODULE: ./src/components/table/SelectionBox.jsx
function SelectionBox_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { SelectionBox_defineProperty(target, key, source[key]); }); } return target; }

function SelectionBox_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function SelectionBox_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = SelectionBox_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function SelectionBox_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






/* harmony default export */ var SelectionBox = ({
  mixins: [BaseMixin["a" /* default */]],
  name: 'SelectionBox',
  props: SelectionBoxProps,
  data: function data() {
    return {
      checked: this.getCheckState(this.$props),
      indeterminate: this.getCheckIndeterminateState(this.$props)
    };
  },
  mounted: function mounted() {
    this.subscribe();
  },
  beforeDestroy: function beforeDestroy() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  },
  methods: {
    subscribe: function subscribe() {
      var _this = this;

      var store = this.store;
      this.unsubscribe = store.subscribe(function () {
        var checked = _this.getCheckState(_this.$props);

        var indeterminate = _this.getCheckIndeterminateState(_this.$props);

        _this.setState({
          indeterminate: indeterminate
        });

        if (checked && indeterminate) checked = false;

        _this.setState({
          checked: checked
        });
      });
    },
    getCheckState: function getCheckState(props) {
      var store = props.store,
          defaultSelection = props.defaultSelection,
          rowIndex = props.rowIndex;
      var checked = false;

      if (store.getState().selectionDirty) {
        checked = store.getState().selectedRowKeys.indexOf(rowIndex) >= 0;
      } else {
        checked = store.getState().selectedRowKeys.indexOf(rowIndex) >= 0 || defaultSelection.indexOf(rowIndex) >= 0;
      }

      return checked;
    },
    getCheckIndeterminateState: function getCheckIndeterminateState(props) {
      var store = props.store,
          defaultSelection = props.defaultSelection,
          rowIndex = props.rowIndex;
      return (store.getState().halfCheckedKeys || []).indexOf(rowIndex) >= 0;
    }
  },
  render: function render() {
    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        type = _getOptionProps.type,
        rowIndex = _getOptionProps.rowIndex,
        rest = SelectionBox_objectWithoutProperties(_getOptionProps, ["type", "rowIndex"]);

    var checked = this.checked,
        indeterminate = this.indeterminate,
        $attrs = this.$attrs,
        $listeners = this.$listeners;
    var checkboxProps = {
      props: SelectionBox_objectSpread({
        checked: checked,
        indeterminate: indeterminate
      }, rest),
      attrs: $attrs,
      on: $listeners
    };

    if (type === 'radio') {
      checkboxProps.props.value = rowIndex;
      return h(components_radio, checkboxProps);
    } else {
      return h(components_checkbox, checkboxProps);
    }
  }
});
// CONCATENATED MODULE: ./src/components/table/SelectionCheckboxAll.jsx
function SelectionCheckboxAll_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








/* harmony default export */ var SelectionCheckboxAll = ({
  props: SelectionCheckboxAllProps,
  name: 'SelectionCheckboxAll',
  mixins: [BaseMixin["a" /* default */]],
  data: function data() {
    var props = this.$props;
    this.defaultSelections = props.hideDefaultSelections ? [] : [{
      key: 'all',
      text: props.locale.selectAll,
      onSelect: function onSelect() {}
    }, {
      key: 'invert',
      text: props.locale.selectInvert,
      onSelect: function onSelect() {}
    }];
    return {
      checked: this.getCheckState(props),
      indeterminate: this.getIndeterminateState(props)
    };
  },
  mounted: function mounted() {
    this.subscribe();
  },
  watch: {
    '$props': {
      handler: function handler() {
        this.setCheckState();
      },
      deep: true
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  },
  methods: {
    subscribe: function subscribe() {
      var _this = this;

      var store = this.store;
      this.unsubscribe = store.subscribe(function () {
        _this.setCheckState();
      });
    },
    checkSelection: function checkSelection(data, type, byDefaultChecked) {
      var store = this.store,
          getCheckboxPropsByItem = this.getCheckboxPropsByItem,
          getRecordKey = this.getRecordKey; // type should be 'every' | 'some'

      if (type === 'every' || type === 'some') {
        return byDefaultChecked ? data[type](function (item, i) {
          return getCheckboxPropsByItem(item, i).props.defaultChecked;
        }) : data[type](function (item, i) {
          return store.getState().selectedRowKeys.indexOf(getRecordKey(item, i)) >= 0;
        });
      }

      return false;
    },
    setCheckState: function setCheckState() {
      var checked = this.getCheckState();
      var indeterminate = this.getIndeterminateState();
      this.setState(function (prevState) {
        var newState = {};

        if (indeterminate !== prevState.indeterminate) {
          newState.indeterminate = indeterminate;
        }

        if (checked !== prevState.checked) {
          newState.checked = checked;
        }

        return newState;
      });
    },
    getCheckState: function getCheckState() {
      var store = this.store,
          data = this.data;
      var checked;

      if (!data.length) {
        checked = false;
      } else {
        checked = store.getState().selectionDirty ? this.checkSelection(data, 'every', false) : this.checkSelection(data, 'every', false) || this.checkSelection(data, 'every', true);
      }

      return checked;
    },
    getIndeterminateState: function getIndeterminateState() {
      var store = this.store,
          data = this.data;
      var indeterminate;

      if (!data.length) {
        indeterminate = false;
      } else {
        indeterminate = store.getState().selectionDirty ? this.checkSelection(data, 'some', false) && !this.checkSelection(data, 'every', false) : this.checkSelection(data, 'some', false) && !this.checkSelection(data, 'every', false) || this.checkSelection(data, 'some', true) && !this.checkSelection(data, 'every', true);
      }

      return indeterminate;
    },
    handleSelectAllChagne: function handleSelectAllChagne(e) {
      var checked = e.target.checked;
      this.$emit('select', checked ? 'all' : 'removeAll', 0, null);
    },
    renderMenus: function renderMenus(selections) {
      var _this2 = this;

      var h = this.$createElement;
      return selections.map(function (selection, index) {
        return h(components_menu.Item, {
          key: selection.key || index
        }, [h("div", {
          on: {
            "click": function click() {
              _this2.$emit('select', selection.key, index, selection.onSelect);
            }
          }
        }, [selection.text])]);
      });
    }
  },
  render: function render() {
    var h = arguments[0];
    var disabled = this.disabled,
        prefixCls = this.prefixCls,
        selections = this.selections,
        getPopupContainer = this.getPopupContainer,
        checked = this.checked,
        indeterminate = this.indeterminate;
    var selectionPrefixCls = "".concat(prefixCls, "-selection");
    var customSelections = null;

    if (selections) {
      var newSelections = Array.isArray(selections) ? this.defaultSelections.concat(selections) : this.defaultSelections;
      var menu = h(components_menu, {
        "class": "".concat(selectionPrefixCls, "-menu"),
        attrs: {
          selectedKeys: []
        }
      }, [this.renderMenus(newSelections)]);
      customSelections = newSelections.length > 0 ? h(components_dropdown, {
        attrs: {
          getPopupContainer: getPopupContainer
        }
      }, [h("template", {
        slot: 'overlay'
      }, [menu]), h("div", {
        "class": "".concat(selectionPrefixCls, "-down")
      }, [h(components_icon, {
        attrs: {
          type: 'down'
        }
      })])]) : null;
    }

    return h("div", {
      "class": selectionPrefixCls
    }, [h(components_checkbox, {
      "class": classnames_default()(SelectionCheckboxAll_defineProperty({}, "".concat(selectionPrefixCls, "-select-all-custom"), customSelections)),
      attrs: {
        checked: checked,
        indeterminate: indeterminate,
        disabled: disabled
      },
      on: {
        "change": this.handleSelectAllChagne
      }
    }), customSelections]);
  }
});
// CONCATENATED MODULE: ./src/components/table/Column.jsx

/* harmony default export */ var table_Column = ({
  name: 'TaTableColumn',
  props: ColumnProps
});
// CONCATENATED MODULE: ./src/components/table/ColumnGroup.jsx

/* harmony default export */ var table_ColumnGroup = ({
  name: 'TaTableColumnGroup',
  props: {
    title: vue_types["a" /* default */].any
  },
  __ANT_TABLE_COLUMN_GROUP: true
});
// CONCATENATED MODULE: ./src/components/table/createBodyRow.jsx


function createBodyRow_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var BodyRowProps = {
  store: Store,
  rowKey: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
  prefixCls: vue_types["a" /* default */].string
};
function createTableRow() {
  var Component = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'tr';
  var BodyRow = {
    name: 'BodyRow',
    props: BodyRowProps,
    data: function data() {
      var _this$store$getState = this.store.getState(),
          selectedRowKeys = _this$store$getState.selectedRowKeys;

      return {
        selected: selectedRowKeys.indexOf(this.rowKey) >= 0
      };
    },
    mounted: function mounted() {
      this.subscribe();
    },
    beforeDestroy: function beforeDestroy() {
      if (this.unsubscribe) {
        this.unsubscribe();
      }
    },
    methods: {
      subscribe: function subscribe() {
        var _this = this;

        var store = this.store,
            rowKey = this.rowKey;
        this.unsubscribe = store.subscribe(function () {
          var _this$store$getState2 = _this.store.getState(),
              selectedRowKeys = _this$store$getState2.selectedRowKeys;

          var selected = selectedRowKeys.indexOf(rowKey) >= 0;

          if (selected !== _this.selected) {
            _this.selected = selected;
          }
        });
      }
    },
    render: function render() {
      var h = arguments[0];

      var className = createBodyRow_defineProperty({}, "".concat(this.prefixCls, "-row-selected"), this.selected);

      return h(Component, babel_helper_vue_jsx_merge_props_default()([{
        "class": className
      }, {
        on: this.$listeners
      }]), [this.$slots["default"]]);
    }
  };
  return BodyRow;
}
// CONCATENATED MODULE: ./src/components/table/util.js
function util_toConsumableArray(arr) {
  return util_arrayWithoutHoles(arr) || util_iterableToArray(arr) || util_nonIterableSpread();
}

function util_nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function util_iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function util_arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function table_util_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      table_util_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function table_util_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function flatArray() {
  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var childrenName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'children';
  var result = [];

  var loop = function loop(array) {
    array.forEach(function (item) {
      if (item[childrenName]) {
        var newItem = table_util_objectSpread({}, item);

        delete newItem[childrenName];
        result.push(newItem);

        if (item[childrenName].length > 0) {
          loop(item[childrenName]);
        }
      } else {
        result.push(item);
      }
    });
  };

  loop(data);
  return result;
}
function treeMap(tree, mapper) {
  var childrenName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'children';
  return tree.map(function (node, index) {
    var extra = {};

    if (node[childrenName]) {
      extra[childrenName] = treeMap(node[childrenName], mapper, childrenName);
    }

    return table_util_objectSpread({}, mapper(node, index), extra);
  });
}
function flatFilter(tree, callback) {
  return tree.reduce(function (acc, node) {
    if (callback(node)) {
      acc.push(node);
    }

    if (node.children) {
      var children = flatFilter(node.children, callback);
      acc.push.apply(acc, util_toConsumableArray(children));
    }

    return acc;
  }, []);
}
function convertTreeToKeyEntities(tree, getRecordKey, callback) {
  if (!callback) callback = function callback() {
    return true;
  };

  function deepFlat(tree) {
    var parentNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return tree.reduce(function (acc, node) {
      if (callback(node)) {
        acc[getRecordKey(node)] = {
          node: node,
          parent: parentNode
        };
      }

      if (node.children) {
        var children = deepFlat(node.children, node);
        Object.assign(acc, children);
      }

      return acc;
    }, {});
  }

  return deepFlat(tree);
}
function conductCheck(keyEntities, keyList, isCheck, checkStatus, getNodeKey, isCheckDisabled) {
  // 全选列表
  var checkedKeys = {}; // 半选列表

  var halfCheckedKeys = {};
  (checkStatus.checkedKeys || []).forEach(function (key) {
    checkedKeys[key] = true;
  });
  (checkStatus.halfCheckedKeys || []).forEach(function (key) {
    halfCheckedKeys[key] = true;
  });

  function checkNodeStatus(key) {
    return checkedKeys[key] == isCheck;
  } // Conduct up


  function conductUp(key) {
    // 校验节点是否状态一致
    if (checkNodeStatus(key)) return;
    var entity = keyEntities[key];
    if (!entity) return;
    var parent = entity.parent,
        node = entity.node;
    var children = node.children; // 校验是否是可选节点

    if (isCheckDisabled(node)) return; // 判断记入半选列表还是 全选列表

    var everyChildChecked = true;
    var someChildChecked = false; // Child checked or half checked

    (children || []).filter(function (child) {
      return !isCheckDisabled(child);
    }).forEach(function (child) {
      var childKey = getNodeKey(child);
      var childChecked = checkedKeys[childKey];
      var childHalfChecked = halfCheckedKeys[childKey];
      if (childChecked || childHalfChecked) someChildChecked = true;
      if (!childChecked) everyChildChecked = false;
    }); // Update checked status

    if (isCheck) {
      checkedKeys[key] = everyChildChecked;
    } else {
      checkedKeys[key] = false;
    }

    halfCheckedKeys[key] = someChildChecked; // 递归处理父节点

    if (parent) {
      conductUp(getNodeKey(parent));
    }
  } // Conduct down


  function conductDown(key) {
    // 校验节点是否状态一致
    if (checkNodeStatus(key)) return;
    var entity = keyEntities[key];
    if (!entity) return;
    var parent = entity.parent,
        node = entity.node;
    var children = node.children; // 校验是否是可选节点

    if (isCheckDisabled(node)) return; // 记入全选列表

    checkedKeys[key] = isCheck; // 递归处理子节点

    (children || []).filter(function (child) {
      return !isCheckDisabled(child);
    }).forEach(function (child) {
      conductDown(getNodeKey(child));
    });
  }

  function conduct(key) {
    var entity = keyEntities[key];

    if (!entity) {
      return;
    }

    var parent = entity.parent,
        node = entity.node;
    var children = node.children;
    if (isCheckDisabled(node)) return;
    checkedKeys[key] = isCheck; // Conduct down

    (children || []).filter(function (child) {
      return !isCheckDisabled(child);
    }).forEach(function (child) {
      conductDown(getNodeKey(child));
    }); // Conduct up

    if (parent) {
      conductUp(getNodeKey(parent));
    }
  }

  (keyList || []).forEach(function (key) {
    conduct(key);
  });
  var checkedKeyList = [];
  var halfCheckedKeyList = []; // Fill checked list

  Object.keys(checkedKeys).forEach(function (key) {
    if (checkedKeys[key]) {
      checkedKeyList.push(key);
    }
  }); // Fill half checked list

  Object.keys(halfCheckedKeys).forEach(function (key) {
    if (!checkedKeys[key] && halfCheckedKeys[key]) {
      halfCheckedKeyList.push(key);
    }
  });
  return {
    checkedKeys: checkedKeyList,
    halfCheckedKeys: halfCheckedKeyList
  };
} // export function normalizeColumns (elements) {
//   const columns = []
//   React.Children.forEach(elements, (element) => {
//     if (!React.isValidElement(element)) {
//       return
//     }
//     const column = {
//       ...element.props,
//     }
//     if (element.key) {
//       column.key = element.key
//     }
//     if (element.type && element.type.__ANT_TABLE_COLUMN_GROUP) {
//       column.children = normalizeColumns(column.children)
//     }
//     columns.push(column)
//   })
//   return columns
// }
// CONCATENATED MODULE: ./src/components/table/Table.jsx
function Table_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Table_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Table_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function Table_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Table_typeof = function _typeof(obj) { return typeof obj; }; } else { Table_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Table_typeof(obj); }

function table_Table_toConsumableArray(arr) { return table_Table_arrayWithoutHoles(arr) || table_Table_iterableToArray(arr) || table_Table_nonIterableSpread(); }

function table_Table_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function table_Table_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function table_Table_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function table_Table_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { table_Table_defineProperty(target, key, source[key]); }); } return target; }

function table_Table_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





















function Table_noop() {}

function stopPropagation(e) {
  e.stopPropagation();

  if (e.nativeEvent && e.nativeEvent.stopImmediatePropagation) {
    e.nativeEvent.stopImmediatePropagation();
  }
}

function getRowSelection(props) {
  return props.rowSelection || {};
}

var defaultPagination = {
  onChange: Table_noop,
  onShowSizeChange: Table_noop
  /**
   * Avoid creating new object, so that parent component's shouldComponentUpdate
   * can works appropriately。
   */

};
var emptyObject = {};
/* harmony default export */ var table_Table = ({
  name: 'Table',
  Column: table_Column,
  ColumnGroup: table_ColumnGroup,
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(TableProps, {
    dataSource: [],
    prefixCls: 'ant-table',
    useFixedHeader: false,
    // rowSelection: null,
    size: 'default',
    loading: false,
    bordered: false,
    showOverflowTooltip: false,
    indentSize: 20,
    locale: {},
    rowKey: 'key',
    showHeader: true
  }),
  // CheckboxPropsCache: {
  //   [key: string]: any;
  // };
  // store: Store;
  // columns: ColumnProps<T>[];
  // components: TableComponents;
  data: function data() {
    // this.columns = props.columns || normalizeColumns(props.children)
    this.createComponents(this.components);
    this.CheckboxPropsCache = {};
    this.store = table_createStore({
      selectedRowKeys: getRowSelection(this.$props).selectedRowKeys || [],
      selectionDirty: false
    });
    return table_Table_objectSpread({}, this.getDefaultSortOrder(this.columns), {
      // 减少状态
      sFilters: this.getFiltersFromColumns(),
      sPagination: this.getDefaultPagination(this.$props),
      pivot: undefined,
      //add by cy用于保存columns状态
      columnsCache: table_Table_toConsumableArray(this.columns)
    });
  },
  watch: {
    pagination: {
      handler: function handler(val) {
        this.setState(function (previousState) {
          var newPagination = table_Table_objectSpread({}, defaultPagination, previousState.sPagination, val);

          newPagination.current = newPagination.current || 1;
          newPagination.pageSize = newPagination.pageSize || 10;
          return {
            sPagination: val !== false ? newPagination : emptyObject
          };
        });
      },
      deep: true
    },
    rowSelection: {
      handler: function handler(val) {
        if (val && 'selectedRowKeys' in val) {
          this.store.setState({
            selectedRowKeys: val.selectedRowKeys || []
          });
          var rowSelection = this.rowSelection;

          if (rowSelection && val.getCheckboxProps !== rowSelection.getCheckboxProps) {
            this.CheckboxPropsCache = {};
          }
        }
      },
      deep: true
    },
    dataSource: function dataSource(val) {
      this.store.setState({
        selectionDirty: false
      });
      var rowSelection = getRowSelection(this.$props);

      if (rowSelection.onChange) {
        rowSelection.onChange([], []);
      }

      ;
      this.CheckboxPropsCache = {};
    },
    columns: function columns(val) {
      if (this.getSortOrderColumns(val).length > 0) {
        var sortState = this.getSortStateFromColumns(val);

        if (sortState.sSortColumn !== this.sSortColumn || sortState.sSortOrder !== this.sSortOrder) {
          this.setState(sortState);
        }
      }

      var filteredValueColumns = this.getFilteredValueColumns(val);

      if (filteredValueColumns.length > 0) {
        var filtersFromColumns = this.getFiltersFromColumns(val);

        var newFilters = table_Table_objectSpread({}, this.sFilters);

        Object.keys(filtersFromColumns).forEach(function (key) {
          newFilters[key] = filtersFromColumns[key];
        });

        if (this.isFiltersChanged(newFilters)) {
          this.setState({
            sFilters: newFilters
          });
        }
      }
    },
    components: function components(val, preVal) {
      this.createComponents(val, preVal);
    }
  },
  methods: {
    storeCheckStatus: function storeCheckStatus() {
      var rowSelection = getRowSelection(this.$props);

      if (rowSelection && !('selectedRowKeys' in rowSelection) && rowSelection.isTreeSelectMode) {
        this.keyEntities = convertTreeToKeyEntities(this.dataSource, this.getRecordKey);
        this.store.setState({
          selectionDirty: true
        });
        var checkStatus = this.getTreeCheckStatus();
        this.store.setState({
          selectedRowKeys: checkStatus.checkedKeys,
          halfCheckedKeys: checkStatus.halfCheckedKeys
        });
      }
    },
    getTreeCheckStatus: function getTreeCheckStatus() {
      var _this = this;

      var newState = {};
      var defaultSelection = this.store.getState().selectionDirty ? [] : this.getDefaultSelection();
      var selectedRowKeys = this.store.getState().selectedRowKeys.concat(defaultSelection);
      var halfCheckedKeys = this.store.getState().halfCheckedKeys || [];
      var checkStatus = conductCheck(this.keyEntities, selectedRowKeys, true, {
        checkedKeys: selectedRowKeys,
        halfCheckedKeys: halfCheckedKeys
      }, this.getRecordKey, function (item, index) {
        if (_this.rowSelection.getCheckboxProps) {
          return _this.getCheckboxPropsByItem(item, index).props.disabled;
        }

        return false;
      });
      newState.checkedKeys = checkStatus.checkedKeys;
      newState.halfCheckedKeys = checkStatus.halfCheckedKeys;
      return newState;
    },
    getCheckboxPropsByItem: function getCheckboxPropsByItem(item, index) {
      var rowSelection = getRowSelection(this.$props);

      if (!rowSelection.getCheckboxProps) {
        return {
          props: {}
        };
      }

      var key = this.getRecordKey(item, index); // Cache checkboxProps

      if (!this.CheckboxPropsCache[key]) {
        this.CheckboxPropsCache[key] = rowSelection.getCheckboxProps(item);
      }

      this.CheckboxPropsCache[key].props = this.CheckboxPropsCache[key].props || {};
      return this.CheckboxPropsCache[key];
    },
    getDefaultSelection: function getDefaultSelection() {
      var _this2 = this;

      var rowSelection = getRowSelection(this.$props);

      if (!rowSelection.getCheckboxProps) {
        return [];
      }

      return this.getFlatData().filter(function (item, rowIndex) {
        return _this2.getCheckboxPropsByItem(item, rowIndex).props.defaultChecked;
      }).map(function (record, rowIndex) {
        return _this2.getRecordKey(record, rowIndex);
      });
    },
    getDefaultPagination: function getDefaultPagination(props) {
      var pagination = props.pagination || {};
      return this.hasPagination(props) ? table_Table_objectSpread({}, defaultPagination, pagination, {
        current: pagination.defaultCurrent || pagination.current || 1,
        pageSize: pagination.defaultPageSize || pagination.pageSize || 10
      }) : {};
    },
    onRow: function onRow(record, index) {
      var prefixCls = this.prefixCls,
          customRow = this.customRow;
      var custom = customRow ? customRow(record, index) : {};
      return Object(props_util["t" /* mergeProps */])(custom, {
        props: {
          prefixCls: prefixCls,
          store: this.store,
          rowKey: this.getRecordKey(record, index)
        }
      });
    },
    setTreeSelectedRowKeys: function setTreeSelectedRowKeys(checkedKeys, halfCheckedKeys, selectionInfo) {
      var rowSelection = getRowSelection(this.$props);

      if (rowSelection && !('selectedRowKeys' in rowSelection)) {
        this.store.setState({
          halfCheckedKeys: halfCheckedKeys
        });
      }

      this.setSelectedRowKeys(table_Table_toConsumableArray(checkedKeys), selectionInfo);
    },
    setSelectedRowKeys: function setSelectedRowKeys(selectedRowKeys, selectionInfo) {
      var _this3 = this;

      var selectWay = selectionInfo.selectWay,
          record = selectionInfo.record,
          checked = selectionInfo.checked,
          changeRowKeys = selectionInfo.changeRowKeys,
          nativeEvent = selectionInfo.nativeEvent;
      var rowSelection = getRowSelection(this.$props);

      if (rowSelection && !('selectedRowKeys' in rowSelection)) {
        this.store.setState({
          selectedRowKeys: selectedRowKeys
        });
      }

      var data = this.getFlatData();

      if (!rowSelection.onChange && !rowSelection[selectWay]) {
        return;
      }

      var selectedRows = data.filter(function (row, i) {
        return selectedRowKeys.indexOf(_this3.getRecordKey(row, i)) >= 0;
      });

      if (rowSelection.onChange) {
        rowSelection.onChange(selectedRowKeys, selectedRows);
      }

      if (selectWay === 'onSelect' && rowSelection.onSelect) {
        rowSelection.onSelect(record, checked, selectedRows, nativeEvent);
      } else if (selectWay === 'onSelectMultiple' && rowSelection.onSelectMultiple) {
        var changeRows = data.filter(function (row, i) {
          return changeRowKeys.indexOf(_this3.getRecordKey(row, i)) >= 0;
        });
        rowSelection.onSelectMultiple(checked, selectedRows, changeRows);
      } else if (selectWay === 'onSelectAll' && rowSelection.onSelectAll) {
        var _changeRows = data.filter(function (row, i) {
          return changeRowKeys.indexOf(_this3.getRecordKey(row, i)) >= 0;
        });

        rowSelection.onSelectAll(checked, selectedRows, _changeRows);
      } else if (selectWay === 'onSelectInvert' && rowSelection.onSelectInvert) {
        rowSelection.onSelectInvert(selectedRowKeys);
      }
    },
    hasPagination: function hasPagination() {
      return this.pagination !== false;
    },
    isFiltersChanged: function isFiltersChanged(filters) {
      var _this4 = this;

      var filtersChanged = false;

      if (Object.keys(filters).length !== Object.keys(this.sFilters).length) {
        filtersChanged = true;
      } else {
        Object.keys(filters).forEach(function (columnKey) {
          if (filters[columnKey] !== _this4.sFilters[columnKey]) {
            filtersChanged = true;
          }
        });
      }

      return filtersChanged;
    },
    getSortOrderColumns: function getSortOrderColumns(columns) {
      return flatFilter(columns || this.columns || [], function (column) {
        return 'sortOrder' in column;
      });
    },
    getFilteredValueColumns: function getFilteredValueColumns(columns) {
      return flatFilter(columns || this.columns || [], function (column) {
        return typeof column.filteredValue !== 'undefined';
      });
    },
    getFiltersFromColumns: function getFiltersFromColumns(columns) {
      var _this5 = this;

      var filters = {};
      this.getFilteredValueColumns(columns).forEach(function (col) {
        var colKey = _this5.getColumnKey(col);

        filters[colKey] = col.filteredValue;
      });
      return filters;
    },
    getDefaultSortOrder: function getDefaultSortOrder(columns) {
      var definedSortState = this.getSortStateFromColumns(columns);
      var defaultSortedColumn = flatFilter(columns || [], function (column) {
        return column.defaultSortOrder != null;
      })[0];

      if (defaultSortedColumn && !definedSortState.sortColumn) {
        return {
          sSortColumn: defaultSortedColumn,
          sSortOrder: defaultSortedColumn.defaultSortOrder
        };
      }

      return definedSortState;
    },
    getSortStateFromColumns: function getSortStateFromColumns(columns) {
      // return first column which sortOrder is not falsy
      var sortedColumn = this.getSortOrderColumns(columns).filter(function (col) {
        return col.sortOrder;
      })[0];

      if (sortedColumn) {
        return {
          sSortColumn: sortedColumn,
          sSortOrder: sortedColumn.sortOrder
        };
      }

      return {
        sSortColumn: null,
        sSortOrder: null
      };
    },
    getSorterFn: function getSorterFn() {
      var sortOrder = this.sSortOrder,
          sortColumn = this.sSortColumn;

      if (!sortOrder || !sortColumn || typeof sortColumn.sorter !== 'function') {
        return;
      }

      return function (a, b) {
        var result = sortColumn.sorter(a, b, sortOrder);

        if (result !== 0) {
          return sortOrder === 'descend' ? -result : result;
        }

        return 0;
      };
    },
    toggleSortOrder: function toggleSortOrder(order, column) {
      var sortOrder = this.sSortOrder,
          sortColumn = this.sSortColumn; // 只同时允许一列进行排序，否则会导致排序顺序的逻辑问题

      var isSortColumn = this.isSortColumn(column);

      if (!isSortColumn) {
        // 当前列未排序
        sortOrder = order;
        sortColumn = column;
      } else {
        // 当前列已排序
        if (sortOrder === order) {
          // 切换为未排序状态
          sortOrder = undefined;
          sortColumn = null;
        } else {
          // 切换为排序状态
          sortOrder = order;
        }
      }

      var newState = {
        sSortOrder: sortOrder,
        sSortColumn: sortColumn // Controlled

      };

      if (this.getSortOrderColumns().length === 0) {
        this.setState(newState);
      }

      this.$emit.apply(this, ['change'].concat(table_Table_toConsumableArray(this.prepareParamsArguments(table_Table_objectSpread({}, this.$data, newState)))));
    },
    handleFilter: function handleFilter(column, nextFilters) {
      var _this6 = this;

      var props = this.$props;

      var pagination = table_Table_objectSpread({}, this.sPagination);

      var filters = table_Table_objectSpread({}, this.sFilters, table_Table_defineProperty({}, this.getColumnKey(column), nextFilters)); // Remove filters not in current columns


      var currentColumnKeys = [];
      treeMap(this.columns, function (c) {
        if (!c.children) {
          currentColumnKeys.push(_this6.getColumnKey(c));
        }
      });
      Object.keys(filters).forEach(function (columnKey) {
        if (currentColumnKeys.indexOf(columnKey) < 0) {
          delete filters[columnKey];
        }
      });

      if (props.pagination) {
        // Reset current prop
        pagination.current = 1;
        pagination.onChange(pagination.current);
      }

      var newState = {
        sPagination: pagination,
        sFilters: {}
      };

      var filtersToSetState = table_Table_objectSpread({}, filters); // Remove filters which is controlled


      this.getFilteredValueColumns().forEach(function (col) {
        var columnKey = _this6.getColumnKey(col);

        if (columnKey) {
          delete filtersToSetState[columnKey];
        }
      });

      if (Object.keys(filtersToSetState).length > 0) {
        newState.sFilters = filtersToSetState;
      } // Controlled current prop will not respond user interaction


      if (Table_typeof(props.pagination) === 'object' && 'current' in props.pagination) {
        newState.sPagination = table_Table_objectSpread({}, pagination, {
          current: this.sPagination.current
        });
      }

      this.setState(newState, function () {
        _this6.store.setState({
          selectionDirty: false
        });

        _this6.$emit.apply(_this6, ['change'].concat(table_Table_toConsumableArray(_this6.prepareParamsArguments(table_Table_objectSpread({}, _this6.$data, {
          sSelectionDirty: false,
          sFilters: filters,
          sPagination: pagination
        })))));
      });
    },
    handleSelect: function handleSelect(record, rowIndex, e) {
      var _this7 = this;

      var checked = e.target.checked;
      var nativeEvent = e.nativeEvent;
      var defaultSelection = this.store.getState().selectionDirty ? [] : this.getDefaultSelection();
      var selectedRowKeys = this.store.getState().selectedRowKeys.concat(defaultSelection);
      var key = this.getRecordKey(record, rowIndex);
      var pivot = this.$data.pivot;
      var rows = this.getFlatCurrentPageData();
      var realIndex = rowIndex;

      if (this.$props.expandedRowRender) {
        realIndex = rows.findIndex(function (row) {
          return _this7.getRecordKey(row, rowIndex) === key;
        });
      }

      if (nativeEvent.shiftKey && pivot !== undefined && realIndex !== pivot) {
        var changeRowKeys = [];
        var direction = Math.sign(pivot - realIndex);
        var dist = Math.abs(pivot - realIndex);
        var step = 0;

        var _loop = function _loop() {
          var i = realIndex + step * direction;
          step += 1;
          var row = rows[i];

          var rowKey = _this7.getRecordKey(row, i);

          var checkboxProps = _this7.getCheckboxPropsByItem(row, i);

          if (!checkboxProps.disabled) {
            if (selectedRowKeys.includes(rowKey)) {
              if (!checked) {
                selectedRowKeys = selectedRowKeys.filter(function (j) {
                  return rowKey !== j;
                });
                changeRowKeys.push(rowKey);
              }
            } else if (checked) {
              selectedRowKeys.push(rowKey);
              changeRowKeys.push(rowKey);
            }
          }
        };

        while (step <= dist) {
          _loop();
        }

        this.setState({
          pivot: realIndex
        });
        this.store.setState({
          selectionDirty: true
        });
        this.setSelectedRowKeys(selectedRowKeys, {
          selectWay: 'onSelectMultiple',
          record: record,
          checked: checked,
          changeRowKeys: changeRowKeys,
          nativeEvent: nativeEvent
        });
      } else {
        var rowSelection = getRowSelection(this.$props);

        if (rowSelection.isTreeSelectMode) {
          var halfCheckedKeys = this.store.getState().halfCheckedKeys || [];
          var checkStatus = conductCheck(this.keyEntities, [this.getRecordKey(record, realIndex)], checked, {
            checkedKeys: selectedRowKeys,
            halfCheckedKeys: halfCheckedKeys
          }, this.getRecordKey, function (item, index) {
            if (_this7.rowSelection.getCheckboxProps) {
              return _this7.getCheckboxPropsByItem(item, index).props.disabled;
            }

            return false;
          });
          this.setState({
            pivot: realIndex
          });
          this.store.setState({
            selectionDirty: true
          });
          this.setTreeSelectedRowKeys(checkStatus.checkedKeys, checkStatus.halfCheckedKeys, {
            selectWay: 'onSelect',
            record: record,
            checked: checked,
            changeRowKeys: void 0,
            nativeEvent: nativeEvent
          });
        } else {
          if (checked) {
            selectedRowKeys.push(this.getRecordKey(record, realIndex));
          } else {
            selectedRowKeys = selectedRowKeys.filter(function (i) {
              return key !== i;
            });
          }

          this.setState({
            pivot: realIndex
          });
          this.store.setState({
            selectionDirty: true
          });
          this.setSelectedRowKeys(selectedRowKeys, {
            selectWay: 'onSelect',
            record: record,
            checked: checked,
            changeRowKeys: void 0,
            nativeEvent: nativeEvent
          });
        }
      }
    },
    handleRadioSelect: function handleRadioSelect(record, rowIndex, e) {
      var checked = e.target.checked;
      var nativeEvent = e.nativeEvent;
      var defaultSelection = this.store.getState().selectionDirty ? [] : this.getDefaultSelection();
      var selectedRowKeys = this.store.getState().selectedRowKeys.concat(defaultSelection);
      var key = this.getRecordKey(record, rowIndex);
      selectedRowKeys = [key];
      this.store.setState({
        selectionDirty: true
      });
      this.setSelectedRowKeys(selectedRowKeys, {
        selectWay: 'onSelect',
        record: record,
        checked: checked,
        changeRowKeys: void 0,
        nativeEvent: nativeEvent
      });
    },
    handleSelectRow: function handleSelectRow(selectionKey, index, onSelectFunc) {
      var _this8 = this;

      var data = this.getFlatCurrentPageData();
      var defaultSelection = this.store.getState().selectionDirty ? [] : this.getDefaultSelection();
      var selectedRowKeys = this.store.getState().selectedRowKeys.concat(defaultSelection);
      var changeableRowKeys = data.filter(function (item, i) {
        return !_this8.getCheckboxPropsByItem(item, i).props.disabled;
      }).map(function (item, i) {
        return _this8.getRecordKey(item, i);
      });
      var changeRowKeys = [];
      var selectWay = 'onSelectAll';
      var checked; // handle default selection

      switch (selectionKey) {
        case 'all':
          changeableRowKeys.forEach(function (key) {
            if (selectedRowKeys.indexOf(key) < 0) {
              selectedRowKeys.push(key);
              changeRowKeys.push(key);
            }
          });
          selectWay = 'onSelectAll';
          checked = true;
          break;

        case 'removeAll':
          changeableRowKeys.forEach(function (key) {
            if (selectedRowKeys.indexOf(key) >= 0) {
              selectedRowKeys.splice(selectedRowKeys.indexOf(key), 1);
              changeRowKeys.push(key);
            }
          });
          selectWay = 'onSelectAll';
          checked = false;
          break;

        case 'invert':
          changeableRowKeys.forEach(function (key) {
            if (selectedRowKeys.indexOf(key) < 0) {
              selectedRowKeys.push(key);
            } else {
              selectedRowKeys.splice(selectedRowKeys.indexOf(key), 1);
            }

            changeRowKeys.push(key);
            selectWay = 'onSelectInvert';
          });
          break;

        default:
          break;
      }

      this.store.setState({
        selectionDirty: true
      }); // when select custom selection, callback selections[n].onSelect

      var rowSelection = this.rowSelection;
      var customSelectionStartIndex = 2;

      if (rowSelection && rowSelection.hideDefaultSelections) {
        customSelectionStartIndex = 0;
      }

      if (index >= customSelectionStartIndex && typeof onSelectFunc === 'function') {
        return onSelectFunc(changeableRowKeys);
      }

      this.setSelectedRowKeys(selectedRowKeys, {
        selectWay: selectWay,
        checked: checked,
        changeRowKeys: changeRowKeys
      });
    },
    handlePageChange: function handlePageChange(current) {
      var props = this.$props;

      var pagination = table_Table_objectSpread({}, this.sPagination);

      if (current) {
        pagination.current = current;
      } else {
        pagination.current = pagination.current || 1;
      }

      for (var _len = arguments.length, otherArguments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        otherArguments[_key - 1] = arguments[_key];
      }

      pagination.onChange.apply(pagination, [pagination.current].concat(otherArguments));
      var newState = {
        sPagination: pagination // Controlled current prop will not respond user interaction

      };

      if (props.pagination && Table_typeof(props.pagination) === 'object' && 'current' in props.pagination) {
        newState.sPagination = table_Table_objectSpread({}, pagination, {
          current: this.sPagination.current
        });
      }

      this.setState(newState);
      this.store.setState({
        selectionDirty: false
      });
      this.$emit.apply(this, ['change'].concat(table_Table_toConsumableArray(this.prepareParamsArguments(table_Table_objectSpread({}, this.$data, {
        sSelectionDirty: false,
        sPagination: pagination
      })))));
    },
    renderSelectionBox: function renderSelectionBox(type) {
      var _this9 = this;

      var h = this.$createElement;
      return function (_, record, index) {
        var rowKey = _this9.getRecordKey(record, index); // 从 1 开始


        var props = _this9.getCheckboxPropsByItem(record, index);

        var handleChange = function handleChange(e) {
          type === 'radio' ? _this9.handleRadioSelect(record, index, e) : _this9.handleSelect(record, index, e);
        };

        var selectionBoxProps = Object(props_util["t" /* mergeProps */])({
          props: {
            type: type,
            store: _this9.store,
            rowIndex: rowKey,
            defaultSelection: _this9.getDefaultSelection()
          },
          on: {
            change: handleChange
          }
        }, props);
        return h("span", {
          on: {
            "click": stopPropagation
          }
        }, [h(SelectionBox, selectionBoxProps)]);
      };
    },
    getRecordKey: function getRecordKey(record, index) {
      var rowKey = this.rowKey;
      var recordKey = typeof rowKey === 'function' ? rowKey(record, index) : record[rowKey];
      _util_warning(recordKey !== undefined, 'Each record in dataSource of table should have a unique `key` prop, or set `rowKey` of Table to an unique primary key,');
      return recordKey === undefined ? index : recordKey;
    },
    getPopupContainer: function getPopupContainer() {
      return this.$el;
    },
    renderRowSelection: function renderRowSelection(locale) {
      var _this10 = this;

      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          rowSelection = this.rowSelection;
      var columns = this.columns.concat();

      if (rowSelection) {
        var data = this.getFlatCurrentPageData().filter(function (item, index) {
          if (rowSelection.getCheckboxProps) {
            return !_this10.getCheckboxPropsByItem(item, index).props.disabled;
          }

          return true;
        });
        var selectionColumnClass = classnames_default()("".concat(prefixCls, "-selection-column"), table_Table_defineProperty({}, "".concat(prefixCls, "-selection-column-custom"), rowSelection.selections));
        var selectionColumn = {
          key: 'selection-column',
          customRender: this.renderSelectionBox(rowSelection.type),
          className: selectionColumnClass,
          fixed: rowSelection.fixed,
          width: rowSelection.columnWidth,
          title: rowSelection.columnTitle
        };

        if (rowSelection.type !== 'radio') {
          var checkboxAllDisabled = data.every(function (item, index) {
            return _this10.getCheckboxPropsByItem(item, index).props.disabled;
          });
          selectionColumn.title = selectionColumn.title || h(SelectionCheckboxAll, {
            attrs: {
              store: this.store,
              locale: locale,
              data: data,
              getCheckboxPropsByItem: this.getCheckboxPropsByItem,
              getRecordKey: this.getRecordKey,
              disabled: checkboxAllDisabled,
              prefixCls: prefixCls,
              selections: rowSelection.selections,
              hideDefaultSelections: rowSelection.hideDefaultSelections,
              getPopupContainer: this.getPopupContainer
            },
            on: {
              "select": this.handleSelectRow
            }
          });
        }

        if ('fixed' in rowSelection) {
          selectionColumn.fixed = rowSelection.fixed;
        } else if (columns.some(function (column) {
          return column.fixed === 'left' || column.fixed === true;
        })) {
          selectionColumn.fixed = 'left';
        }

        if (columns[0] && columns[0].key === 'selection-column') {
          columns[0] = selectionColumn;
        } else {
          columns.unshift(selectionColumn);
        }
      }

      return columns;
    },
    getColumnKey: function getColumnKey(column, index) {
      return column.key || column.dataIndex || index;
    },
    getMaxCurrent: function getMaxCurrent(total) {
      var _this$sPagination = this.sPagination,
          current = _this$sPagination.current,
          pageSize = _this$sPagination.pageSize;

      if ((current - 1) * pageSize >= total) {
        return Math.floor((total - 1) / pageSize) + 1;
      }

      return current;
    },
    isSortColumn: function isSortColumn(column) {
      var sortColumn = this.sSortColumn;

      if (!column || !sortColumn) {
        return false;
      }

      return this.getColumnKey(sortColumn) === this.getColumnKey(column);
    },
    renderColumnsDropdown: function renderColumnsDropdown(columns, locale) {
      var _this11 = this;

      var h = this.$createElement;
      var prefixCls = this.prefixCls,
          dropdownPrefixCls = this.dropdownPrefixCls;
      var sortOrder = this.sSortOrder;
      return treeMap(columns, function (originColumn, i) {
        var column = table_Table_objectSpread({}, originColumn);

        var key = _this11.getColumnKey(column, i);

        var filterDropdown;
        var sortButton;

        if (column.filters && column.filters.length > 0 || column.filterDropdown) {
          var colFilters = _this11.sFilters[key] || [];
          filterDropdown = h(table_filterDropdown, {
            attrs: {
              _propsSymbol: Symbol(),
              locale: locale,
              column: column,
              selectedKeys: colFilters,
              confirmFilter: _this11.handleFilter,
              prefixCls: "".concat(prefixCls, "-filter"),
              dropdownPrefixCls: dropdownPrefixCls || 'ant-dropdown',
              getPopupContainer: _this11.getPopupContainer
            }
          });
        }

        if (column.sorter) {
          var isSortColumn = _this11.isSortColumn(column);

          if (isSortColumn) {
            column.className = classnames_default()(column.className, table_Table_defineProperty({}, "".concat(prefixCls, "-column-sort"), sortOrder));
          }

          var isAscend = isSortColumn && sortOrder === 'ascend';
          var isDescend = isSortColumn && sortOrder === 'descend';
          sortButton = h("div", {
            "class": "".concat(prefixCls, "-column-sorter")
          }, [h("span", {
            "class": "".concat(prefixCls, "-column-sorter-up ").concat(isAscend ? 'on' : 'off'),
            attrs: {
              title: '↑'
            },
            on: {
              "click": function click() {
                return _this11.toggleSortOrder('ascend', column);
              }
            }
          }, [h(components_icon, {
            attrs: {
              type: 'caret-up'
            }
          })]), h("span", {
            "class": "".concat(prefixCls, "-column-sorter-down ").concat(isDescend ? 'on' : 'off'),
            attrs: {
              title: '↓'
            },
            on: {
              "click": function click() {
                return _this11.toggleSortOrder('descend', column);
              }
            }
          }, [h(components_icon, {
            attrs: {
              type: 'caret-down'
            }
          })])]);
        }

        column.title = h("span", {
          key: key
        }, [column.title, sortButton, filterDropdown]);

        if (sortButton || filterDropdown) {
          column.className = classnames_default()("".concat(prefixCls, "-column-has-filters"), column.className);
        }

        return column;
      });
    },
    handleShowSizeChange: function handleShowSizeChange(current, pageSize) {
      var pagination = this.sPagination;
      pagination.onShowSizeChange(current, pageSize);

      var nextPagination = table_Table_objectSpread({}, pagination, {
        pageSize: pageSize,
        current: current
      });

      this.setState({
        sPagination: nextPagination
      });
      this.$emit.apply(this, ['change'].concat(table_Table_toConsumableArray(this.prepareParamsArguments(table_Table_objectSpread({}, this.$data, {
        sPagination: nextPagination
      })))));
    },
    renderPagination: function renderPagination(paginationPosition) {
      var h = this.$createElement;

      // 强制不需要分页
      if (!this.hasPagination()) {
        return null;
      }

      var size = 'default';
      var pagination = this.sPagination;

      if (pagination.size) {
        size = pagination.size;
      } else if (this.size === 'middle' || this.size === 'small') {
        size = 'small';
      }

      var position = pagination.position || 'bottom';
      var total = pagination.total || this.getLocalData().length;

      var cls = pagination["class"],
          style = pagination.style,
          onChange = pagination.onChange,
          onShowSizeChange = pagination.onShowSizeChange,
          restProps = Table_objectWithoutProperties(pagination, ["class", "style", "onChange", "onShowSizeChange"]); // eslint-disable-line


      var paginationProps = Object(props_util["t" /* mergeProps */])({
        key: "pagination-".concat(paginationPosition),
        "class": classnames_default()(cls, "".concat(this.prefixCls, "-pagination")),
        props: table_Table_objectSpread({}, restProps, {
          total: total,
          size: size,
          current: this.getMaxCurrent(total)
        }),
        style: style,
        on: {
          change: this.handlePageChange,
          showSizeChange: this.handleShowSizeChange
        }
      });
      return total > 0 && (position === paginationPosition || position === 'both') ? h(components_pagination, paginationProps) : null;
    },
    // Get pagination, filters, sorter
    prepareParamsArguments: function prepareParamsArguments(state) {
      var pagination = table_Table_objectSpread({}, state.sPagination); // remove useless handle function in Table.onChange


      delete pagination.onChange;
      delete pagination.onShowSizeChange;
      var filters = state.sFilters;
      var sorter = {};

      if (state.sSortColumn && state.sSortOrder) {
        sorter.column = state.sSortColumn;
        sorter.order = state.sSortOrder;
        sorter.field = state.sSortColumn.dataIndex;
        sorter.columnKey = this.getColumnKey(state.sSortColumn);
      }

      return [pagination, filters, sorter];
    },
    findColumn: function findColumn(myKey) {
      var _this12 = this;

      var column;
      treeMap(this.columns, function (c) {
        if (_this12.getColumnKey(c) === myKey) {
          column = c;
        }
      });
      return column;
    },
    getCurrentPageData: function getCurrentPageData() {
      var data = this.getLocalData();
      var current;
      var pageSize;
      var sPagination = this.sPagination; // 如果没有分页的话，默认全部展示

      if (!this.hasPagination()) {
        pageSize = Number.MAX_VALUE;
        current = 1;
      } else {
        pageSize = sPagination.pageSize;
        current = this.getMaxCurrent(sPagination.total || data.length);
      } // 分页
      // ---
      // 当数据量少于等于每页数量时，直接设置数据
      // 否则进行读取分页数据


      if (data.length > pageSize || pageSize === Number.MAX_VALUE) {
        data = data.filter(function (_, i) {
          return i >= (current - 1) * pageSize && i < current * pageSize;
        });
      }

      return data;
    },
    getFlatData: function getFlatData() {
      return flatArray(this.getLocalData());
    },
    getFlatCurrentPageData: function getFlatCurrentPageData() {
      return flatArray(this.getCurrentPageData());
    },
    recursiveSort: function recursiveSort(data, sorterFn) {
      var _this13 = this;

      var _this$childrenColumnN = this.childrenColumnName,
          childrenColumnName = _this$childrenColumnN === void 0 ? 'children' : _this$childrenColumnN;
      return data.sort(sorterFn).map(function (item) {
        return item[childrenColumnName] ? table_Table_objectSpread({}, item, table_Table_defineProperty({}, childrenColumnName, _this13.recursiveSort(item[childrenColumnName], sorterFn))) : item;
      });
    },
    getLocalData: function getLocalData() {
      var _this14 = this;

      var dataSource = this.dataSource,
          filters = this.sFilters;
      var data = dataSource || []; // 优化本地排序

      data = data.slice(0);
      var sorterFn = this.getSorterFn();

      if (sorterFn) {
        data = this.recursiveSort(data, sorterFn);
      } // 筛选


      if (filters) {
        Object.keys(filters).forEach(function (columnKey) {
          var col = _this14.findColumn(columnKey);

          if (!col) {
            return;
          }

          var values = filters[columnKey] || [];

          if (values.length === 0) {
            return;
          }

          var onFilter = col.onFilter;
          data = onFilter ? data.filter(function (record) {
            return values.some(function (v) {
              return onFilter(v, record);
            });
          }) : data;
        });
      }

      return data;
    },
    createComponents: function createComponents() {
      var components = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var prevComponents = arguments.length > 1 ? arguments[1] : undefined;
      var bodyRow = components && components.body && components.body.row;
      var preBodyRow = prevComponents && prevComponents.body && prevComponents.body.row;

      if (!this.row || bodyRow !== preBodyRow) {
        this.row = createTableRow(bodyRow);
      }

      this.customComponents = table_Table_objectSpread({}, components, {
        body: table_Table_objectSpread({}, components.body, {
          row: this.row
        })
      });
    },
    renderTable: function renderTable(contextLocale, loading) {
      var _classNames3,
          _this15 = this;

      var h = this.$createElement;

      var locale = table_Table_objectSpread({}, contextLocale, this.locale);

      var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
          prefixCls = _getOptionProps.prefixCls,
          showHeader = _getOptionProps.showHeader,
          restProps = Table_objectWithoutProperties(_getOptionProps, ["prefixCls", "showHeader"]);

      var data = this.getCurrentPageData();
      var expandIconAsCell = this.expandedRowRender && this.expandIconAsCell !== false;
      var classString = classnames_default()((_classNames3 = {}, table_Table_defineProperty(_classNames3, "".concat(prefixCls, "-").concat(this.size), true), table_Table_defineProperty(_classNames3, "".concat(prefixCls, "-bordered"), this.bordered), table_Table_defineProperty(_classNames3, "".concat(prefixCls, "-empty"), !data.length), table_Table_defineProperty(_classNames3, "".concat(prefixCls, "-without-column-header"), !showHeader), _classNames3));
      var columns = this.renderRowSelection(locale);
      columns = this.renderColumnsDropdown(columns, locale);
      columns = columns.map(function (column, i) {
        var newColumn = table_Table_objectSpread({}, column);

        newColumn.key = _this15.getColumnKey(newColumn, i);
        return newColumn;
      });
      var expandIconColumnIndex = columns[0] && columns[0].key === 'selection-column' ? 1 : 0;

      if ('expandIconColumnIndex' in restProps) {
        expandIconColumnIndex = restProps.expandIconColumnIndex;
      }

      var vcTableProps = {
        key: 'table',
        props: table_Table_objectSpread({}, restProps, {
          __propsSymbol__: Symbol(),
          customRow: this.onRow,
          components: this.customComponents,
          prefixCls: prefixCls,
          data: data,
          columns: columns,
          showHeader: showHeader,
          expandIconColumnIndex: expandIconColumnIndex,
          expandIconAsCell: expandIconAsCell,
          emptyText: !(loading.props && loading.props.spinning) && locale.emptyText
        }),
        on: table_Table_objectSpread({}, this.$listeners, {
          storeCheckStatus: this.storeCheckStatus
        }),
        "class": classString
      };
      return h(vc_table, vcTableProps);
    }
  },
  render: function render() {
    var _this16 = this;

    var h = arguments[0];
    var prefixCls = this.prefixCls;
    var data = this.getCurrentPageData();
    var loading = this.loading;

    if (typeof loading === 'boolean') {
      loading = {
        props: {
          spinning: loading
        }
      };
    } else {
      loading = {
        props: table_Table_objectSpread({}, loading)
      };
    }

    var table = h(LocaleReceiver, {
      attrs: {
        componentName: 'Table',
        defaultLocale: locale_provider_default.Table,
        children: function children(locale) {
          return _this16.renderTable(locale, loading);
        }
      }
    }); // if there is no pagination or no data,
    // the height of spin should decrease by half of pagination

    var paginationPatchClass = this.hasPagination() && data && data.length !== 0 ? "".concat(prefixCls, "-with-pagination") : "".concat(prefixCls, "-without-pagination");

    var spinProps = table_Table_objectSpread({}, loading, {
      "class": loading.props && loading.props.spinning ? "".concat(paginationPatchClass, " ").concat(prefixCls, "-spin-holder") : ''
    });

    return h("div", {
      "class": classnames_default()("".concat(prefixCls, "-wrapper"))
    }, [h(spin, spinProps, [this.renderPagination('top'), table, this.renderPagination('bottom')])]);
  }
});
// CONCATENATED MODULE: ./src/components/table/index.jsx
function table_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { table_defineProperty(target, key, source[key]); }); } return target; }

function table_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function table_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = table_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function table_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function table_toConsumableArray(arr) { return table_arrayWithoutHoles(arr) || table_iterableToArray(arr) || table_nonIterableSpread(); }

function table_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function table_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function table_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }



var components_table_Table = {
  name: 'TaTable',
  Column: table_Table.Column,
  ColumnGroup: table_Table.ColumnGroup,
  props: table_Table.props,
  data: function data() {
    return {
      columnsCache: table_toConsumableArray(this.columns)
    };
  },
  methods: {
    //隐藏列
    hideColumns: function hideColumns(array) {
      if (!array) return;
      var a = this.columns.filter(function (item) {
        return !array.includes(item.dataIndex);
      });
      this.$emit('update:columns', table_toConsumableArray(a));
    },
    //显示列
    showColumns: function showColumns(array) {
      var _this = this;

      if (!array) return;
      var a = this.columnsCache.filter(function (item) {
        if (array.includes(item.dataIndex) || _this.columns.includes(item)) {
          return true;
        }

        return false;
      });
      this.$emit('update:columns', table_toConsumableArray(a));
    },
    normalize: function normalize() {
      var _this2 = this;

      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var columns = [];
      elements.forEach(function (element) {
        if (!element.tag) {
          return;
        }

        var key = Object(props_util["i" /* getKey */])(element);
        var style = Object(props_util["n" /* getStyle */])(element);
        var cls = Object(props_util["f" /* getClass */])(element);
        var props = Object(props_util["j" /* getOptionProps */])(element);
        var events = Object(props_util["h" /* getEvents */])(element);
        var listeners = {};
        Object.keys(events).forEach(function (e) {
          var k = "on-".concat(e);
          listeners[Object(props_util["a" /* camelize */])(k)] = events[e];
        });

        var _getSlots = Object(props_util["m" /* getSlots */])(element),
            children = _getSlots["default"],
            restSlots = table_objectWithoutProperties(_getSlots, ["default"]);

        var column = table_objectSpread({}, restSlots, props, {
          style: style,
          "class": cls
        }, listeners);

        if (key) {
          column.key = key;
        }

        if (Object(props_util["l" /* getSlotOptions */])(element).__ANT_TABLE_COLUMN_GROUP) {
          column.children = _this2.normalize(children);
        } else {
          var customRender = element.data && element.data.scopedSlots && element.data.scopedSlots["default"];
          column.customRender = column.customRender || customRender;
        }

        columns.push(column);
      });
      return columns;
    },
    updateColumns: function updateColumns() {
      var _this3 = this;

      var cols = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var columns = [];
      var $slots = this.$slots,
          $scopedSlots = this.$scopedSlots;
      cols.forEach(function (col) {
        var _col$slots = col.slots,
            slots = _col$slots === void 0 ? {} : _col$slots,
            _col$scopedSlots = col.scopedSlots,
            scopedSlots = _col$scopedSlots === void 0 ? {} : _col$scopedSlots,
            restProps = table_objectWithoutProperties(col, ["slots", "scopedSlots"]);

        var column = table_objectSpread({}, restProps);

        Object.keys(slots).forEach(function (key) {
          var name = slots[key];

          if (column[key] === undefined && $slots[name]) {
            column[key] = $slots[name];
          }
        });
        Object.keys(scopedSlots).forEach(function (key) {
          var name = scopedSlots[key];

          if (column[key] === undefined && $scopedSlots[name]) {
            column[key] = $scopedSlots[name];
          }
        }); // if (slotScopeName && $scopedSlots[slotScopeName]) {
        //   column.customRender = column.customRender || $scopedSlots[slotScopeName]
        // }

        if (col.children) {
          column.children = _this3.updateColumns(column.children);
        }

        columns.push(column);
      });
      return columns;
    }
  },
  render: function render() {
    var h = arguments[0];
    var $listeners = this.$listeners,
        $slots = this.$slots,
        normalize = this.normalize,
        $scopedSlots = this.$scopedSlots;
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var columns = props.columns ? this.updateColumns(props.columns) : normalize($slots["default"]);
    var title = props.title,
        footer = props.footer;
    var slotTitle = $scopedSlots.title,
        slotFooter = $scopedSlots.footer,
        _$scopedSlots$expande = $scopedSlots.expandedRowRender,
        expandedRowRender = _$scopedSlots$expande === void 0 ? props.expandedRowRender : _$scopedSlots$expande;
    title = title || slotTitle;
    footer = footer || slotFooter;
    var tProps = {
      props: table_objectSpread({}, props, {
        columns: columns,
        title: title,
        footer: footer,
        expandedRowRender: expandedRowRender
      }),
      on: $listeners
    };
    return h(table_Table, tProps);
  }
};
/* istanbul ignore next */

components_table_Table.install = function (Vue) {
  Vue.component(components_table_Table.name, components_table_Table);
  Vue.component(components_table_Table.Column.name, components_table_Table.Column);
  Vue.component(components_table_Table.ColumnGroup.name, components_table_Table.ColumnGroup);
};

/* harmony default export */ var components_table = (components_table_Table);
// CONCATENATED MODULE: ./src/components/transfer/search.jsx




var TransferSearchProps = {
  prefixCls: vue_types["a" /* default */].string,
  placeholder: vue_types["a" /* default */].string,
  value: vue_types["a" /* default */].any,
  handleClear: vue_types["a" /* default */].func
};
/* harmony default export */ var transfer_search = ({
  name: 'Search',
  props: Object(props_util["q" /* initDefaultProps */])(TransferSearchProps, {
    placeholder: ''
  }),
  methods: {
    handleChange: function handleChange(e) {
      this.$emit('change', e);
    },
    handleClear2: function handleClear2(e) {
      e.preventDefault();

      if (this.handleClear) {
        this.handleClear(e);
      }
    }
  },
  render: function render() {
    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        placeholder = _getOptionProps.placeholder,
        value = _getOptionProps.value,
        prefixCls = _getOptionProps.prefixCls;

    var icon = value && value.length > 0 ? h("a", {
      attrs: {
        href: '#'
      },
      "class": "".concat(prefixCls, "-action"),
      on: {
        "click": this.handleClear2
      }
    }, [h(components_icon, {
      attrs: {
        type: 'cross-circle'
      }
    })]) : h("span", {
      "class": "".concat(prefixCls, "-action")
    }, [h(components_icon, {
      attrs: {
        type: 'search'
      }
    })]);
    return h("div", [h(components_input, {
      attrs: {
        placeholder: placeholder,
        value: value
      },
      "class": prefixCls,
      ref: 'input',
      on: {
        "change": this.handleChange
      }
    }), icon]);
  }
});
// EXTERNAL MODULE: ./node_modules/lodash/throttle.js
var throttle = __webpack_require__(415);
var throttle_default = /*#__PURE__*/__webpack_require__.n(throttle);

// CONCATENATED MODULE: ./src/components/vc-lazy-load/src/utils/parentScroll.js
var parentScroll_style = function style(element, prop) {
  var styleVal = '';

  if (typeof getComputedStyle !== 'undefined') {
    styleVal = window.getComputedStyle(element, null).getPropertyValue(prop);
  } else {
    styleVal = element.style[prop];
  }

  return styleVal;
};

var parentScroll_overflow = function overflow(element) {
  return parentScroll_style(element, 'overflow') + parentScroll_style(element, 'overflow-y') + parentScroll_style(element, 'overflow-x');
};

var scrollParent = function scrollParent(element) {
  if (!(element instanceof window.HTMLElement)) {
    return window;
  }

  var parent = element;

  while (parent) {
    if (parent === document.body || parent === document.documentElement) {
      break;
    }

    if (!parent.parentNode) {
      break;
    }

    if (/(scroll|auto)/.test(parentScroll_overflow(parent))) {
      return parent;
    }

    parent = parent.parentNode;
  }

  return window;
};

/* harmony default export */ var parentScroll = (scrollParent);
// CONCATENATED MODULE: ./src/components/vc-lazy-load/src/utils/getElementPosition.js
/*
* Finds element's position relative to the whole document,
* rather than to the viewport as it is the case with .getBoundingClientRect().
*/
function getElementPosition(element) {
  var rect = element.getBoundingClientRect();
  return {
    top: rect.top + window.pageYOffset,
    left: rect.left + window.pageXOffset
  };
}
// CONCATENATED MODULE: ./src/components/vc-lazy-load/src/utils/inViewport.js


var isHidden = function isHidden(element) {
  return element.offsetParent === null;
};

function inViewport(element, container, customOffset) {
  if (isHidden(element)) {
    return false;
  }

  var top;
  var bottom;
  var left;
  var right;

  if (typeof container === 'undefined' || container === window) {
    top = window.pageYOffset;
    left = window.pageXOffset;
    bottom = top + window.innerHeight;
    right = left + window.innerWidth;
  } else {
    var containerPosition = getElementPosition(container);
    top = containerPosition.top;
    left = containerPosition.left;
    bottom = top + container.offsetHeight;
    right = left + container.offsetWidth;
  }

  var elementPosition = getElementPosition(element);
  return top <= elementPosition.top + element.offsetHeight + customOffset.top && bottom >= elementPosition.top - customOffset.bottom && left <= elementPosition.left + element.offsetWidth + customOffset.left && right >= elementPosition.left - customOffset.right;
}
// CONCATENATED MODULE: ./src/components/vc-lazy-load/src/LazyLoad.jsx









var lazyLoadProps = {
  debounce: vue_types["a" /* default */].bool,
  elementType: vue_types["a" /* default */].string,
  height: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
  offset: vue_types["a" /* default */].number,
  offsetBottom: vue_types["a" /* default */].number,
  offsetHorizontal: vue_types["a" /* default */].number,
  offsetLeft: vue_types["a" /* default */].number,
  offsetRight: vue_types["a" /* default */].number,
  offsetTop: vue_types["a" /* default */].number,
  offsetVertical: vue_types["a" /* default */].number,
  threshold: vue_types["a" /* default */].number,
  throttle: vue_types["a" /* default */].number,
  width: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
  _propsSymbol: vue_types["a" /* default */].any
};
/* harmony default export */ var LazyLoad = ({
  name: 'LazyLoad',
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(lazyLoadProps, {
    elementType: 'div',
    debounce: true,
    offset: 0,
    offsetBottom: 0,
    offsetHorizontal: 0,
    offsetLeft: 0,
    offsetRight: 0,
    offsetTop: 0,
    offsetVertical: 0,
    throttle: 250
  }),
  data: function data() {
    if (this.throttle > 0) {
      if (this.debounce) {
        this.lazyLoadHandler = debounce_default()(this.lazyLoadHandler, this.throttle);
      } else {
        this.lazyLoadHandler = throttle_default()(this.lazyLoadHandler, this.throttle);
      }
    }

    return {
      visible: false
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this._mounted = true;

      var eventNode = _this.getEventNode();

      _this.lazyLoadHandler();

      if (_this.lazyLoadHandler.flush) {
        _this.lazyLoadHandler.flush();
      }

      _this.resizeHander = addEventListenerWrap(window, 'resize', _this.lazyLoadHandler);
      _this.scrollHander = addEventListenerWrap(eventNode, 'scroll', _this.lazyLoadHandler);
    });
  },
  watch: {
    _propsSymbol: function _propsSymbol(val) {
      if (!this.visible) {
        this.lazyLoadHandler();
      }
    }
  },
  beforeDestroy: function beforeDestroy() {
    this._mounted = false;

    if (this.lazyLoadHandler.cancel) {
      this.lazyLoadHandler.cancel();
    }

    this.detachListeners();
  },
  methods: {
    getEventNode: function getEventNode() {
      return parentScroll(this.$el);
    },
    getOffset: function getOffset() {
      var _this$$props = this.$props,
          offset = _this$$props.offset,
          offsetVertical = _this$$props.offsetVertical,
          offsetHorizontal = _this$$props.offsetHorizontal,
          offsetTop = _this$$props.offsetTop,
          offsetBottom = _this$$props.offsetBottom,
          offsetLeft = _this$$props.offsetLeft,
          offsetRight = _this$$props.offsetRight,
          threshold = _this$$props.threshold;

      var _offsetAll = threshold || offset;

      var _offsetVertical = offsetVertical || _offsetAll;

      var _offsetHorizontal = offsetHorizontal || _offsetAll;

      return {
        top: offsetTop || _offsetVertical,
        bottom: offsetBottom || _offsetVertical,
        left: offsetLeft || _offsetHorizontal,
        right: offsetRight || _offsetHorizontal
      };
    },
    lazyLoadHandler: function lazyLoadHandler() {
      var _this2 = this;

      if (!this._mounted) {
        return;
      }

      var offset = this.getOffset();
      var node = this.$el;
      var eventNode = this.getEventNode();

      if (inViewport(node, eventNode, offset)) {
        this.setState({
          visible: true
        }, function () {
          _this2.__emit('contentVisible');
        });
        this.detachListeners();
      }
    },
    detachListeners: function detachListeners() {
      this.resizeHander && this.resizeHander.remove();
      this.scrollHander && this.scrollHander.remove();
    }
  },
  render: function render(createElement) {
    var children = this.$slots["default"];

    if (children.length !== 1) {
      _util_warning(false, 'lazyLoad组件只能包含一个子元素');
      return null;
    }

    var _this$$props2 = this.$props,
        height = _this$$props2.height,
        width = _this$$props2.width,
        elementType = _this$$props2.elementType;
    var visible = this.visible;
    var elStyles = {
      height: typeof height === 'number' ? height + 'px' : height,
      width: typeof width === 'number' ? width + 'px' : width
    };
    var elClasses = {
      'LazyLoad': true,
      'is-visible': visible
    };
    return createElement(elementType, {
      "class": elClasses,
      style: elStyles
    }, [visible ? children[0] : null]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-lazy-load/index.js

/* harmony default export */ var vc_lazy_load = (LazyLoad);
// CONCATENATED MODULE: ./src/components/transfer/item.jsx
function item_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { item_defineProperty(target, key, source[key]); }); } return target; }

function item_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






function item_noop() {}

/* harmony default export */ var transfer_item = ({
  props: {
    renderedText: vue_types["a" /* default */].any,
    renderedEl: vue_types["a" /* default */].any,
    item: vue_types["a" /* default */].any,
    lazy: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, vue_types["a" /* default */].object]),
    checked: vue_types["a" /* default */].bool,
    prefixCls: vue_types["a" /* default */].string
  },
  name: 'Item',
  render: function render() {
    var _classNames,
        _this = this;

    var h = arguments[0];
    var _this$$props = this.$props,
        renderedText = _this$$props.renderedText,
        renderedEl = _this$$props.renderedEl,
        item = _this$$props.item,
        lazy = _this$$props.lazy,
        checked = _this$$props.checked,
        prefixCls = _this$$props.prefixCls;
    var className = classnames_default()((_classNames = {}, item_defineProperty(_classNames, "".concat(prefixCls, "-content-item"), true), item_defineProperty(_classNames, "".concat(prefixCls, "-content-item-disabled"), item.disabled), _classNames));
    var listItem = h("li", {
      "class": className,
      attrs: {
        title: renderedText
      },
      on: {
        "click": item.disabled ? item_noop : function () {
          _this.$emit('click', item);
        }
      }
    }, [h(components_checkbox, {
      attrs: {
        checked: checked,
        disabled: item.disabled
      }
    }), h("span", [renderedEl])]);
    var children = null;

    if (lazy) {
      var lazyProps = {
        props: item_objectSpread({
          height: 32,
          offset: 500,
          throttle: 0,
          debounce: false
        }, lazy, {
          _propsSymbol: Symbol()
        })
      };
      children = h(vc_lazy_load, lazyProps, [listItem]);
    } else {
      children = listItem;
    }

    return children;
  }
});
// CONCATENATED MODULE: ./src/components/_util/triggerEvent.js
function triggerEvent(el, type) {
  if ('createEvent' in document) {
    // modern browsers, IE9+
    var e = document.createEvent('HTMLEvents');
    e.initEvent(type, false, true);
    el.dispatchEvent(e);
  }
}
// CONCATENATED MODULE: ./src/components/transfer/list.jsx


function transfer_list_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { transfer_list_defineProperty(target, key, source[key]); }); } return target; }

function transfer_list_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












function isIEorEDGE() {
  return document.documentMode || /Edge/.test(navigator.userAgent);
}

function list_noop() {}

var TransferItem = {
  key: vue_types["a" /* default */].string.isRequired,
  title: vue_types["a" /* default */].string.isRequired,
  description: vue_types["a" /* default */].string,
  disabled: vue_types["a" /* default */].bool
};

function isRenderResultPlainObject(result) {
  return result && !Object(props_util["s" /* isValidElement */])(result) && Object.prototype.toString.call(result) === '[object Object]';
}

var TransferListProps = {
  prefixCls: vue_types["a" /* default */].string,
  titleText: vue_types["a" /* default */].string,
  dataSource: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].shape(TransferItem).loose),
  filter: vue_types["a" /* default */].string,
  filterOption: vue_types["a" /* default */].func,
  checkedKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
  handleFilter: vue_types["a" /* default */].func,
  handleSelect: vue_types["a" /* default */].func,
  handleSelectAll: vue_types["a" /* default */].func,
  handleClear: vue_types["a" /* default */].func,
  renderItem: vue_types["a" /* default */].func,
  showSearch: vue_types["a" /* default */].bool,
  searchPlaceholder: vue_types["a" /* default */].string,
  notFoundContent: vue_types["a" /* default */].any,
  itemUnit: vue_types["a" /* default */].string,
  itemsUnit: vue_types["a" /* default */].string,
  body: vue_types["a" /* default */].any,
  footer: vue_types["a" /* default */].any,
  lazy: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, vue_types["a" /* default */].object])
};
/* harmony default export */ var transfer_list = ({
  name: 'TransferList',
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(TransferListProps, {
    dataSource: [],
    titleText: '',
    showSearch: false,
    renderItem: list_noop,
    lazy: {}
  }),
  data: function data() {
    this.timer = null;
    this.triggerScrollTimer = null;
    return {
      mounted: false
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.timer = setTimeout(function () {
      _this.setState({
        mounted: true
      });
    }, 0);
    this.$nextTick(function () {
      if (_this.$refs.listContentWrapper) {
        var listContentWrapperDom = _this.$refs.listContentWrapper.$el;
        _this.scrollEvent = addEventListenerWrap(listContentWrapperDom, 'scroll', _this.handleScroll);
      }
    });
  },
  beforeDestroy: function beforeDestroy() {
    clearTimeout(this.timer);
    clearTimeout(this.triggerScrollTimer);
    clearTimeout(this.fixIERepaintTimer);

    if (this.scrollEvent) {
      this.scrollEvent.remove();
    }
  },
  updated: function updated() {
    var _this2 = this;

    this.$nextTick(function () {
      if (_this2.scrollEvent) {
        _this2.scrollEvent.remove();
      }

      if (_this2.$refs.listContentWrapper) {
        var listContentWrapperDom = _this2.$refs.listContentWrapper.$el;
        _this2.scrollEvent = addEventListenerWrap(listContentWrapperDom, 'scroll', _this2.handleScroll);
      }
    });
  },
  methods: {
    handleScroll: function handleScroll(e) {
      this.$emit('scroll', e);
    },
    getCheckStatus: function getCheckStatus(filteredDataSource) {
      var checkedKeys = this.$props.checkedKeys;

      if (checkedKeys.length === 0) {
        return 'none';
      } else if (filteredDataSource.every(function (item) {
        return checkedKeys.indexOf(item.key) >= 0;
      })) {
        return 'all';
      }

      return 'part';
    },
    _handleSelect: function _handleSelect(selectedItem) {
      var checkedKeys = this.$props.checkedKeys;
      var result = checkedKeys.some(function (key) {
        return key === selectedItem.key;
      });
      this.handleSelect(selectedItem, !result);
    },
    _handleFilter: function _handleFilter(e) {
      var _this3 = this;

      this.handleFilter(e);

      if (!e.target.value) {
        return;
      } // Manually trigger scroll event for lazy search bug
      // https://github.com/ant-design/ant-design/issues/5631


      this.triggerScrollTimer = setTimeout(function () {
        var transferNode = _this3.$el;
        var listNode = transferNode.querySelectorAll('.ant-transfer-list-content')[0];

        if (listNode) {
          triggerEvent(listNode, 'scroll');
        }
      }, 0);
      this.fixIERepaint();
    },
    _handleClear: function _handleClear(e) {
      this.handleClear(e);
      this.fixIERepaint();
    },
    matchFilter: function matchFilter(text, item) {
      var _this$$props = this.$props,
          filter = _this$$props.filter,
          filterOption = _this$$props.filterOption;

      if (filterOption) {
        return filterOption(filter, item);
      }

      return text.indexOf(filter) >= 0;
    },
    renderItemHtml: function renderItemHtml(item) {
      var _this$$props$renderIt = this.$props.renderItem,
          renderItem = _this$$props$renderIt === void 0 ? list_noop : _this$$props$renderIt;
      var renderResult = renderItem(item);
      var isRenderResultPlain = isRenderResultPlainObject(renderResult);
      return {
        renderedText: isRenderResultPlain ? renderResult.value : renderResult,
        renderedEl: isRenderResultPlain ? renderResult.label : renderResult
      };
    },
    // Fix IE/Edge repaint
    // https://github.com/ant-design/ant-design/issues/9697
    // https://stackoverflow.com/q/27947912/3040605
    fixIERepaint: function fixIERepaint() {
      var _this4 = this;

      if (!isIEorEDGE()) {
        return;
      }

      this.fixIERepaintTimer = window.setTimeout(function () {
        if (_this4.$refs.notFoundNode) {
          _this4.$refs.notFoundNode.className = _this4.$refs.notFoundNode.className;
        }
      }, 0);
    },
    filterNull: function filterNull(arr) {
      return arr.filter(function (item) {
        return item !== null;
      });
    }
  },
  render: function render() {
    var _this5 = this;

    var h = arguments[0];
    var _this$$props2 = this.$props,
        prefixCls = _this$$props2.prefixCls,
        dataSource = _this$$props2.dataSource,
        titleText = _this$$props2.titleText,
        checkedKeys = _this$$props2.checkedKeys,
        lazy = _this$$props2.lazy,
        _this$$props2$body = _this$$props2.body,
        body = _this$$props2$body === void 0 ? list_noop : _this$$props2$body,
        _this$$props2$footer = _this$$props2.footer,
        footer = _this$$props2$footer === void 0 ? list_noop : _this$$props2$footer,
        showSearch = _this$$props2.showSearch,
        filter = _this$$props2.filter,
        searchPlaceholder = _this$$props2.searchPlaceholder,
        notFoundContent = _this$$props2.notFoundContent,
        itemUnit = _this$$props2.itemUnit,
        itemsUnit = _this$$props2.itemsUnit; // Custom Layout

    var footerDom = footer(transfer_list_objectSpread({}, this.$props));
    var bodyDom = body(transfer_list_objectSpread({}, this.$props));
    var listCls = classnames_default()(prefixCls, transfer_list_defineProperty({}, "".concat(prefixCls, "-with-footer"), !!footerDom));
    var filteredDataSource = [];
    var totalDataSource = [];
    var showItems = dataSource.map(function (item) {
      var _this5$renderItemHtml = _this5.renderItemHtml(item),
          renderedText = _this5$renderItemHtml.renderedText,
          renderedEl = _this5$renderItemHtml.renderedEl;

      if (filter && filter.trim() && !_this5.matchFilter(renderedText, item)) {
        return null;
      } // all show items


      totalDataSource.push(item);

      if (!item.disabled) {
        // response to checkAll items
        filteredDataSource.push(item);
      }

      var checked = checkedKeys.indexOf(item.key) >= 0;
      return h(transfer_item, {
        key: item.key,
        attrs: {
          item: item,
          lazy: lazy,
          renderedText: renderedText,
          renderedEl: renderedEl,
          checked: checked,
          prefixCls: prefixCls
        },
        on: {
          "click": _this5._handleSelect
        }
      });
    });
    var unit = dataSource.length > 1 ? itemsUnit : itemUnit;
    var search = showSearch ? h("div", {
      "class": "".concat(prefixCls, "-body-search-wrapper")
    }, [h(transfer_search, {
      attrs: {
        prefixCls: "".concat(prefixCls, "-search"),
        handleClear: this.handleClear,
        placeholder: searchPlaceholder,
        value: filter
      },
      on: {
        "change": this._handleFilter
      }
    })]) : null;
    var transitionName = this.mounted ? "".concat(prefixCls, "-content-item-highlight") : '';
    var transitionProps = Object(getTransitionProps["a" /* default */])(transitionName, {
      leave: list_noop
    });
    var listBody = bodyDom || h("div", {
      "class": showSearch ? "".concat(prefixCls, "-body ").concat(prefixCls, "-body-with-search") : "".concat(prefixCls, "-body")
    }, [search, h("transition-group", babel_helper_vue_jsx_merge_props_default()([transitionProps, {
      attrs: {
        tag: 'ul'
      },
      "class": "".concat(prefixCls, "-content"),
      ref: 'listContentWrapper'
    }]), [showItems]), h("div", {
      "class": "".concat(prefixCls, "-body-not-found"),
      ref: 'notFoundNode'
    }, [notFoundContent])]);
    var listFooter = footerDom ? h("div", {
      "class": "".concat(prefixCls, "-footer")
    }, [footerDom]) : null;
    var checkStatus = this.getCheckStatus(filteredDataSource);
    var checkedAll = checkStatus === 'all';
    var checkAllCheckbox = h(components_checkbox, {
      ref: 'checkbox',
      attrs: {
        checked: checkedAll,
        indeterminate: checkStatus === 'part'
      },
      on: {
        "change": function change() {
          _this5.handleSelectAll(filteredDataSource, checkedAll);
        }
      }
    });
    return h("div", {
      "class": listCls
    }, [h("div", {
      "class": "".concat(prefixCls, "-header")
    }, [checkAllCheckbox, h("span", {
      "class": "".concat(prefixCls, "-header-selected")
    }, [h("span", [(checkedKeys.length > 0 ? "".concat(checkedKeys.length, "/") : '') + totalDataSource.length, " ", unit]), h("span", {
      "class": "".concat(prefixCls, "-header-title")
    }, [titleText])])]), listBody, listFooter]);
  }
});
// CONCATENATED MODULE: ./src/components/transfer/operation.jsx
function operation_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { operation_defineProperty(target, key, source[key]); }); } return target; }

function operation_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





function operation_noop() {}

var TransferOperationProps = {
  className: vue_types["a" /* default */].string,
  leftArrowText: vue_types["a" /* default */].string,
  rightArrowText: vue_types["a" /* default */].string,
  moveToLeft: vue_types["a" /* default */].any,
  moveToRight: vue_types["a" /* default */].any,
  leftActive: vue_types["a" /* default */].bool,
  rightActive: vue_types["a" /* default */].bool
};
/* harmony default export */ var operation = ({
  name: 'Operation',
  props: operation_objectSpread({}, TransferOperationProps),
  render: function render() {
    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        _getOptionProps$moveT = _getOptionProps.moveToLeft,
        moveToLeft = _getOptionProps$moveT === void 0 ? operation_noop : _getOptionProps$moveT,
        _getOptionProps$moveT2 = _getOptionProps.moveToRight,
        moveToRight = _getOptionProps$moveT2 === void 0 ? operation_noop : _getOptionProps$moveT2,
        _getOptionProps$leftA = _getOptionProps.leftArrowText,
        leftArrowText = _getOptionProps$leftA === void 0 ? '' : _getOptionProps$leftA,
        _getOptionProps$right = _getOptionProps.rightArrowText,
        rightArrowText = _getOptionProps$right === void 0 ? '' : _getOptionProps$right,
        leftActive = _getOptionProps.leftActive,
        rightActive = _getOptionProps.rightActive;

    return h("div", [h(components_button, {
      attrs: {
        type: 'primary',
        size: 'small',
        disabled: !rightActive,
        icon: 'right'
      },
      on: {
        "click": moveToRight
      }
    }, [rightArrowText]), h(components_button, {
      attrs: {
        type: 'primary',
        size: 'small',
        disabled: !leftActive,
        icon: 'left'
      },
      on: {
        "click": moveToLeft
      }
    }, [leftArrowText])]);
  }
});
// CONCATENATED MODULE: ./src/components/transfer/index.jsx
function transfer_toConsumableArray(arr) { return transfer_arrayWithoutHoles(arr) || transfer_iterableToArray(arr) || transfer_nonIterableSpread(); }

function transfer_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function transfer_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function transfer_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function transfer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






 // import Search from './search'


 // function noop () {
// }

var TransferDirection = 'left' | 'right';
var transfer_TransferItem = {
  key: vue_types["a" /* default */].string.isRequired,
  title: vue_types["a" /* default */].string.isRequired,
  description: vue_types["a" /* default */].string,
  disabled: vue_types["a" /* default */].bool
};
var TransferProps = {
  prefixCls: vue_types["a" /* default */].string,
  dataSource: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].shape(transfer_TransferItem).loose),
  targetKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
  selectedKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
  render: vue_types["a" /* default */].func,
  listStyle: vue_types["a" /* default */].object,
  operationStyle: vue_types["a" /* default */].object,
  titles: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
  operations: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
  showSearch: vue_types["a" /* default */].bool,
  filterOption: vue_types["a" /* default */].func,
  searchPlaceholder: vue_types["a" /* default */].string,
  notFoundContent: vue_types["a" /* default */].any,
  rowKey: vue_types["a" /* default */].func,
  lazy: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].object, vue_types["a" /* default */].bool])
};
var TransferLocale = {
  titles: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
  notFoundContent: vue_types["a" /* default */].string,
  searchPlaceholder: vue_types["a" /* default */].string,
  itemUnit: vue_types["a" /* default */].string,
  itemsUnit: vue_types["a" /* default */].string
};
var Transfer = {
  name: 'TaTransfer',
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(TransferProps, {
    dataSource: [],
    showSearch: false
  }),
  data: function data() {
    this.separatedDataSource = {
      leftDataSource: [],
      rightDataSource: []
    } | null;
    var _this$selectedKeys = this.selectedKeys,
        selectedKeys = _this$selectedKeys === void 0 ? [] : _this$selectedKeys,
        _this$targetKeys = this.targetKeys,
        targetKeys = _this$targetKeys === void 0 ? [] : _this$targetKeys;
    return {
      leftFilter: '',
      rightFilter: '',
      sourceSelectedKeys: selectedKeys.filter(function (key) {
        return targetKeys.indexOf(key) === -1;
      }),
      targetSelectedKeys: selectedKeys.filter(function (key) {
        return targetKeys.indexOf(key) > -1;
      })
    };
  },
  mounted: function mounted() {// this.currentProps = { ...this.$props }
  },
  watch: {
    targetKeys: function targetKeys() {
      this.updateState();

      if (this.selectedKeys) {
        var targetKeys = this.targetKeys || [];
        this.setState({
          sourceSelectedKeys: this.selectedKeys.filter(function (key) {
            return !targetKeys.includes(key);
          }),
          targetSelectedKeys: this.selectedKeys.filter(function (key) {
            return targetKeys.includes(key);
          })
        });
      }
    },
    dataSource: function dataSource() {
      this.updateState();
    },
    selectedKeys: function selectedKeys() {
      if (this.selectedKeys) {
        var targetKeys = this.targetKeys || [];
        this.setState({
          sourceSelectedKeys: this.selectedKeys.filter(function (key) {
            return !targetKeys.includes(key);
          }),
          targetSelectedKeys: this.selectedKeys.filter(function (key) {
            return targetKeys.includes(key);
          })
        });
      }
    }
  },
  methods: {
    updateState: function updateState() {
      var sourceSelectedKeys = this.sourceSelectedKeys,
          targetSelectedKeys = this.targetSelectedKeys;
      this.separatedDataSource = null;

      if (!this.selectedKeys) {
        // clear key nolonger existed
        // clear checkedKeys according to targetKeys
        var dataSource = this.dataSource,
            _this$targetKeys2 = this.targetKeys,
            targetKeys = _this$targetKeys2 === void 0 ? [] : _this$targetKeys2;
        var newSourceSelectedKeys = [];
        var newTargetSelectedKeys = [];
        dataSource.forEach(function (_ref) {
          var key = _ref.key;

          if (sourceSelectedKeys.includes(key) && !targetKeys.includes(key)) {
            newSourceSelectedKeys.push(key);
          }

          if (targetSelectedKeys.includes(key) && targetKeys.includes(key)) {
            newTargetSelectedKeys.push(key);
          }
        });
        this.setState({
          sourceSelectedKeys: newSourceSelectedKeys,
          targetSelectedKeys: newTargetSelectedKeys
        });
      }
    },
    separateDataSource: function separateDataSource(props) {
      if (this.separatedDataSource) {
        return this.separatedDataSource;
      }

      var dataSource = props.dataSource,
          rowKey = props.rowKey,
          _props$targetKeys = props.targetKeys,
          targetKeys = _props$targetKeys === void 0 ? [] : _props$targetKeys;
      var leftDataSource = [];
      var rightDataSource = new Array(targetKeys.length);
      dataSource.forEach(function (record) {
        if (rowKey) {
          record.key = rowKey(record);
        } // rightDataSource should be ordered by targetKeys
        // leftDataSource should be ordered by dataSource


        var indexOfKey = targetKeys.indexOf(record.key);

        if (indexOfKey !== -1) {
          rightDataSource[indexOfKey] = record;
        } else {
          leftDataSource.push(record);
        }
      });
      this.separatedDataSource = {
        leftDataSource: leftDataSource,
        rightDataSource: rightDataSource
      };
      return this.separatedDataSource;
    },
    moveTo: function moveTo(direction) {
      var _this$$props = this.$props,
          _this$$props$targetKe = _this$$props.targetKeys,
          targetKeys = _this$$props$targetKe === void 0 ? [] : _this$$props$targetKe,
          _this$$props$dataSour = _this$$props.dataSource,
          dataSource = _this$$props$dataSour === void 0 ? [] : _this$$props$dataSour;
      var sourceSelectedKeys = this.sourceSelectedKeys,
          targetSelectedKeys = this.targetSelectedKeys;
      var moveKeys = direction === 'right' ? sourceSelectedKeys : targetSelectedKeys; // filter the disabled options

      var newMoveKeys = moveKeys.filter(function (key) {
        return !dataSource.some(function (data) {
          return !!(key === data.key && data.disabled);
        });
      }); // move items to target box

      var newTargetKeys = direction === 'right' ? newMoveKeys.concat(targetKeys) : targetKeys.filter(function (targetKey) {
        return newMoveKeys.indexOf(targetKey) === -1;
      }); // empty checked keys

      var oppositeDirection = direction === 'right' ? 'left' : 'right';
      this.setState(transfer_defineProperty({}, this.getSelectedKeysName(oppositeDirection), []));
      this.handleSelectChange(oppositeDirection, []);
      this.$emit('change', newTargetKeys, direction, newMoveKeys);
    },
    moveToLeft: function moveToLeft() {
      this.moveTo('left');
    },
    moveToRight: function moveToRight() {
      this.moveTo('right');
    },
    handleSelectChange: function handleSelectChange(direction, holder) {
      var sourceSelectedKeys = this.sourceSelectedKeys,
          targetSelectedKeys = this.targetSelectedKeys;

      if (direction === 'left') {
        this.$emit('selectChange', holder, targetSelectedKeys);
      } else {
        this.$emit('selectChange', sourceSelectedKeys, holder);
      }
    },
    handleSelectAll: function handleSelectAll(direction, filteredDataSource, checkAll) {
      var originalSelectedKeys = this[this.getSelectedKeysName(direction)] || [];
      var currentKeys = filteredDataSource.map(function (item) {
        return item.key;
      }); // Only operate current keys from original selected keys

      var newKeys1 = originalSelectedKeys.filter(function (key) {
        return currentKeys.indexOf(key) === -1;
      });

      var newKeys2 = transfer_toConsumableArray(originalSelectedKeys);

      currentKeys.forEach(function (key) {
        if (newKeys2.indexOf(key) === -1) {
          newKeys2.push(key);
        }
      });
      var holder = checkAll ? newKeys1 : newKeys2;
      this.handleSelectChange(direction, holder);

      if (!this.selectedKeys) {
        this.setState(transfer_defineProperty({}, this.getSelectedKeysName(direction), holder));
      }
    },
    handleLeftSelectAll: function handleLeftSelectAll(filteredDataSource, checkAll) {
      this.handleSelectAll('left', filteredDataSource, checkAll);
    },
    handleRightSelectAll: function handleRightSelectAll(filteredDataSource, checkAll) {
      this.handleSelectAll('right', filteredDataSource, checkAll);
    },
    handleFilter: function handleFilter(direction, e) {
      this.setState(transfer_defineProperty({}, "".concat(direction, "Filter"), e.target.value));
      this.$emit('searchChange', direction, e);
    },
    handleLeftFilter: function handleLeftFilter(e) {
      this.handleFilter('left', e);
    },
    handleRightFilter: function handleRightFilter(e) {
      this.handleFilter('right', e);
    },
    handleClear: function handleClear(direction) {
      this.setState(transfer_defineProperty({}, "".concat(direction, "Filter"), ''));
    },
    handleLeftClear: function handleLeftClear() {
      this.handleClear('left');
    },
    handleRightClear: function handleRightClear() {
      this.handleClear('right');
    },
    handleSelect: function handleSelect(direction, selectedItem, checked) {
      var sourceSelectedKeys = this.sourceSelectedKeys,
          targetSelectedKeys = this.targetSelectedKeys;
      var holder = direction === 'left' ? transfer_toConsumableArray(sourceSelectedKeys) : transfer_toConsumableArray(targetSelectedKeys);
      var index = holder.indexOf(selectedItem.key);

      if (index > -1) {
        holder.splice(index, 1);
      }

      if (checked) {
        holder.push(selectedItem.key);
      }

      this.handleSelectChange(direction, holder);

      if (!this.selectedKeys) {
        this.setState(transfer_defineProperty({}, this.getSelectedKeysName(direction), holder));
      }
    },
    handleLeftSelect: function handleLeftSelect(selectedItem, checked) {
      return this.handleSelect('left', selectedItem, checked);
    },
    handleRightSelect: function handleRightSelect(selectedItem, checked) {
      return this.handleSelect('right', selectedItem, checked);
    },
    handleScroll: function handleScroll(direction, e) {
      this.$emit('scroll', direction, e);
    },
    handleLeftScroll: function handleLeftScroll(e) {
      this.handleScroll('left', e);
    },
    handleRightScroll: function handleRightScroll(e) {
      this.handleScroll('right', e);
    },
    getTitles: function getTitles(transferLocale) {
      if (this.titles) {
        return this.titles;
      }

      return transferLocale.titles || ['', ''];
    },
    getSelectedKeysName: function getSelectedKeysName(direction) {
      return direction === 'left' ? 'sourceSelectedKeys' : 'targetSelectedKeys';
    },
    renderTransfer: function renderTransfer(locale) {
      var h = this.$createElement;
      var props = Object(props_util["j" /* getOptionProps */])(this);
      var _props$prefixCls = props.prefixCls,
          prefixCls = _props$prefixCls === void 0 ? 'ant-transfer' : _props$prefixCls,
          _props$operations = props.operations,
          operations = _props$operations === void 0 ? [] : _props$operations,
          showSearch = props.showSearch,
          searchPlaceholder = props.searchPlaceholder,
          listStyle = props.listStyle,
          operationStyle = props.operationStyle,
          filterOption = props.filterOption,
          lazy = props.lazy;
      var notFoundContent = Object(props_util["g" /* getComponentFromProp */])(this, 'notFoundContent');
      var leftFilter = this.leftFilter,
          rightFilter = this.rightFilter,
          sourceSelectedKeys = this.sourceSelectedKeys,
          targetSelectedKeys = this.targetSelectedKeys,
          $scopedSlots = this.$scopedSlots;
      var body = $scopedSlots.body,
          footer = $scopedSlots.footer;
      var renderItem = props.render;

      var _this$separateDataSou = this.separateDataSource(this.$props),
          leftDataSource = _this$separateDataSou.leftDataSource,
          rightDataSource = _this$separateDataSou.rightDataSource;

      var leftActive = targetSelectedKeys.length > 0;
      var rightActive = sourceSelectedKeys.length > 0;
      var cls = classnames_default()(prefixCls);
      var titles = this.getTitles(locale);
      return h("div", {
        "class": cls
      }, [h(transfer_list, {
        attrs: {
          prefixCls: "".concat(prefixCls, "-list"),
          titleText: titles[0],
          dataSource: leftDataSource,
          filter: leftFilter,
          filterOption: filterOption,
          checkedKeys: sourceSelectedKeys,
          handleFilter: this.handleLeftFilter,
          handleClear: this.handleLeftClear,
          handleSelect: this.handleLeftSelect,
          handleSelectAll: this.handleLeftSelectAll,
          renderItem: renderItem,
          showSearch: showSearch,
          searchPlaceholder: searchPlaceholder || locale.searchPlaceholder,
          notFoundContent: notFoundContent || locale.notFoundContent,
          itemUnit: locale.itemUnit,
          itemsUnit: locale.itemsUnit,
          body: body,
          footer: footer,
          lazy: lazy
        },
        style: listStyle,
        on: {
          "scroll": this.handleLeftScroll
        }
      }), h(operation, {
        "class": "".concat(prefixCls, "-operation"),
        attrs: {
          rightActive: rightActive,
          rightArrowText: operations[0],
          moveToRight: this.moveToRight,
          leftActive: leftActive,
          leftArrowText: operations[1],
          moveToLeft: this.moveToLeft
        },
        style: operationStyle
      }), h(transfer_list, {
        attrs: {
          prefixCls: "".concat(prefixCls, "-list"),
          titleText: titles[1],
          dataSource: rightDataSource,
          filter: rightFilter,
          filterOption: filterOption,
          checkedKeys: targetSelectedKeys,
          handleFilter: this.handleRightFilter,
          handleClear: this.handleRightClear,
          handleSelect: this.handleRightSelect,
          handleSelectAll: this.handleRightSelectAll,
          renderItem: renderItem,
          showSearch: showSearch,
          searchPlaceholder: searchPlaceholder || locale.searchPlaceholder,
          notFoundContent: notFoundContent || locale.notFoundContent,
          itemUnit: locale.itemUnit,
          itemsUnit: locale.itemsUnit,
          body: body,
          footer: footer,
          lazy: lazy
        },
        style: listStyle,
        on: {
          "scroll": this.handleRightScroll
        }
      })]);
    }
  },
  render: function render() {
    var h = arguments[0];
    return h(LocaleReceiver, {
      attrs: {
        componentName: 'Transfer',
        defaultLocale: locale_provider_default.Transfer
      },
      scopedSlots: {
        "default": this.renderTransfer
      }
    });
  }
};
/* istanbul ignore next */

Transfer.install = function (Vue) {
  Vue.component(Transfer.name, Transfer);
};

/* harmony default export */ var transfer = (Transfer);
// EXTERNAL MODULE: ./src/components/vc-tree/index.js
var vc_tree = __webpack_require__(65);
var vc_tree_default = /*#__PURE__*/__webpack_require__.n(vc_tree);

// CONCATENATED MODULE: ./src/components/tree/Tree.jsx
function Tree_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Tree_defineProperty(target, key, source[key]); }); } return target; }

function Tree_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Tree_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Tree_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Tree_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







function TreeProps() {
  return {
    showLine: vue_types["a" /* default */].bool,

    /** 是否支持多选 */
    multiple: vue_types["a" /* default */].bool,

    /** 是否自动展开父节点 */
    autoExpandParent: vue_types["a" /* default */].bool,

    /** checkable状态下节点选择完全受控（父子节点选中状态不再关联） */
    checkStrictly: vue_types["a" /* default */].bool,

    /** 是否支持选中 */
    checkable: vue_types["a" /* default */].bool,

    /** 是否禁用树 */
    disabled: vue_types["a" /* default */].bool,

    /** 默认展开所有树节点 */
    defaultExpandAll: vue_types["a" /* default */].bool,

    /** 是否显示全选按钮 */
    showCheckAll: vue_types["a" /* default */].bool,

    /** 默认展开对应树节点 */
    defaultExpandParent: vue_types["a" /* default */].bool,

    /** 默认展开指定的树节点 */
    defaultExpandedKeys: vue_types["a" /* default */].arrayOf(String),

    /** （受控）展开指定的树节点 */
    expandedKeys: vue_types["a" /* default */].arrayOf(String),

    /** （受控）选中复选框的树节点 */
    checkedKeys: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string), vue_types["a" /* default */].shape({
      checked: vue_types["a" /* default */].arrayOf(String),
      halfChecked: vue_types["a" /* default */].arrayOf(String)
    }).loose]),

    /** 默认选中复选框的树节点 */
    defaultCheckedKeys: vue_types["a" /* default */].arrayOf(String),

    /** （受控）设置选中的树节点 */
    selectedKeys: vue_types["a" /* default */].arrayOf(String),

    /** 默认选中的树节点 */
    defaultSelectedKeys: vue_types["a" /* default */].arrayOf(String),
    selectable: vue_types["a" /* default */].bool,

    /** 展开/收起节点时触发 */
    // onExpand: (expandedKeys: string[], info: AntTreeNodeExpandedEvent) => void | PromiseLike<any>,

    /** 点击复选框触发 */
    // onCheck: (checkedKeys: string[] | { checked: string[]; halfChecked: string[] }, e: AntTreeNodeCheckedEvent) => void,

    /** 点击树节点触发 */
    // onSelect: (selectedKeys: string[], e: AntTreeNodeSelectedEvent) => void,

    /** 单击树节点触发 */
    // onClick: (e: React.MouseEvent<HTMLElement>, node: AntTreeNode) => void,

    /** 双击树节点触发 */
    // onDoubleClick: (e: React.MouseEvent<HTMLElement>, node: AntTreeNode) => void,

    /** filter some AntTreeNodes as you need. it should return true */
    filterAntTreeNode: vue_types["a" /* default */].func,

    /** 异步加载数据 */
    loadData: vue_types["a" /* default */].func,
    loadedKeys: vue_types["a" /* default */].arrayOf(String),
    // onLoaded: (loadedKeys: string[], info: { event: 'load', node: AntTreeNode; }) => void,

    /** 响应右键点击 */
    // onRightClick: (options: AntTreeNodeMouseEvent) => void,

    /** 设置节点可拖拽（IE>8） */
    draggable: vue_types["a" /* default */].bool,
    // /** 开始拖拽时调用 */
    // onDragStart: (options: AntTreeNodeMouseEvent) => void,
    // /** dragenter 触发时调用 */
    // onDragEnter: (options: AntTreeNodeMouseEvent) => void,
    // /** dragover 触发时调用 */
    // onDragOver: (options: AntTreeNodeMouseEvent) => void,
    // /** dragleave 触发时调用 */
    // onDragLeave: (options: AntTreeNodeMouseEvent) => void,
    // /** drop 触发时调用 */
    // onDrop: (options: AntTreeNodeMouseEvent) => void,
    showIcon: vue_types["a" /* default */].bool,
    icon: vue_types["a" /* default */].func,
    prefixCls: vue_types["a" /* default */].string,
    filterTreeNode: vue_types["a" /* default */].func,
    openAnimation: vue_types["a" /* default */].any,
    treeNodes: vue_types["a" /* default */].array,
    treeData: vue_types["a" /* default */].array
  };
}


/* harmony default export */ var Tree = ({
  name: 'TaTree',
  model: {
    prop: 'checkedKeys',
    event: 'check'
  },
  props: Object(props_util["q" /* initDefaultProps */])(TreeProps(), {
    prefixCls: 'ant-tree',
    checkable: false,
    showIcon: false,
    openAnimation: {
      on: _util_openAnimation,
      props: {
        appear: null
      }
    }
  }),
  created: function created() {
    browser_default()(!('treeNodes' in Object(props_util["j" /* getOptionProps */])(this)), '`treeNodes` is deprecated. please use treeData instead.');
  },
  TreeNode: vc_tree["TreeNode"],
  methods: {
    updataTreeData: function updataTreeData(treeData) {
      var _this = this;

      var $slots = this.$slots,
          $scopedSlots = this.$scopedSlots;
      return treeData.map(function (item) {
        var children = item.children,
            _item$on = item.on,
            on = _item$on === void 0 ? {} : _item$on,
            _item$slots = item.slots,
            slots = _item$slots === void 0 ? {} : _item$slots,
            _item$scopedSlots = item.scopedSlots,
            scopedSlots = _item$scopedSlots === void 0 ? {} : _item$scopedSlots,
            key = item.key,
            cls = item["class"],
            style = item.style,
            restProps = Tree_objectWithoutProperties(item, ["children", "on", "slots", "scopedSlots", "key", "class", "style"]);

        var treeNodeProps = Tree_objectSpread({}, restProps, {
          icon: $slots[slots.icon] || $scopedSlots[scopedSlots.icon] && $scopedSlots[scopedSlots.icon] || restProps.icon,
          title: $slots[slots.title] || $scopedSlots[scopedSlots.title] && $scopedSlots[scopedSlots.title](item) || restProps.title,
          dataRef: item,
          on: on,
          key: key,
          "class": cls,
          style: style
        });

        if (children) {
          return Tree_objectSpread({}, treeNodeProps, {
            children: _this.updataTreeData(children)
          });
        }

        return treeNodeProps;
      });
    }
  },
  render: function render() {
    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var prefixCls = props.prefixCls,
        showIcon = props.showIcon,
        treeNodes = props.treeNodes;
    var checkable = props.checkable;
    var treeData = props.treeData || treeNodes;

    if (treeData) {
      treeData = this.updataTreeData(treeData);
    }

    var vcTreeProps = {
      props: Tree_objectSpread({}, props, {
        checkable: checkable ? h("span", {
          "class": "".concat(prefixCls, "-checkbox-inner")
        }) : checkable,
        children: this.$slots["default"] || [],
        __propsSymbol__: Symbol()
      }),
      on: Tree_objectSpread({}, this.$listeners),
      "class": !showIcon && "".concat(prefixCls, "-icon-hide")
    };

    if (treeData) {
      vcTreeProps.props.treeData = treeData;
    }

    return h(vc_tree["Tree"], vcTreeProps);
  }
});
// EXTERNAL MODULE: ./src/components/vc-tree/src/util.js
var util = __webpack_require__(16);

// CONCATENATED MODULE: ./src/components/tree/util.js


var Record = {
  None: 'node',
  Start: 'start',
  End: 'end' // TODO: Move this logic into `rc-tree`

};

function traverseNodesKey(rootChildren, callback) {
  var nodeList = Object(util["j" /* getNodeChildren */])(rootChildren) || [];

  function processNode(node) {
    var key = node.key;
    var children = Object(props_util["m" /* getSlots */])(node)["default"];

    if (callback(key) !== false) {
      traverseNodesKey(children, callback);
    }
  }

  nodeList.forEach(processNode);
}

function getFullKeyList(children) {
  var _convertTreeToEntitie = Object(util["h" /* convertTreeToEntities */])(children),
      keyEntities = _convertTreeToEntitie.keyEntities;

  return Object.keys(keyEntities);
}
/** 计算选中范围，只考虑expanded情况以优化性能 */

function calcRangeKeys(rootChildren, expandedKeys, startKey, endKey) {
  var keys = [];
  var record = Record.None;

  if (startKey && startKey === endKey) {
    return [startKey];
  }

  if (!startKey || !endKey) {
    return [];
  }

  function matchKey(key) {
    return key === startKey || key === endKey;
  }

  traverseNodesKey(rootChildren, function (key) {
    if (record === Record.End) {
      return false;
    }

    if (matchKey(key)) {
      // Match test
      keys.push(key);

      if (record === Record.None) {
        record = Record.Start;
      } else if (record === Record.Start) {
        record = Record.End;
        return false;
      }
    } else if (record === Record.Start) {
      // Append selection
      keys.push(key);
    }

    if (expandedKeys.indexOf(key) === -1) {
      return false;
    }

    return true;
  });
  return keys;
}
// CONCATENATED MODULE: ./src/components/tree/DirectoryTree.jsx
function DirectoryTree_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DirectoryTree_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function DirectoryTree_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function DirectoryTree_toConsumableArray(arr) { return DirectoryTree_arrayWithoutHoles(arr) || DirectoryTree_iterableToArray(arr) || DirectoryTree_nonIterableSpread(); }

function DirectoryTree_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function DirectoryTree_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function DirectoryTree_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function DirectoryTree_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { DirectoryTree_defineProperty(target, key, source[key]); }); } return target; }

function DirectoryTree_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









 // export type ExpandAction = false | 'click' | 'doubleClick';
// export interface DirectoryTreeProps extends TreeProps {
//   expandAction?: ExpandAction;
// }
// export interface DirectoryTreeState {
//   expandedKeys?: string[];
//   selectedKeys?: string[];
// }

function getIcon(h, props) {
  var isLeaf = props.isLeaf,
      expanded = props.expanded;

  if (isLeaf) {
    return h(components_icon, {
      attrs: {
        type: 'file'
      }
    });
  }

  return h(components_icon, {
    attrs: {
      type: expanded ? 'folder-open' : 'folder'
    }
  });
}

/* harmony default export */ var DirectoryTree = ({
  mixins: [BaseMixin["a" /* default */]],
  name: 'TaDirectoryTree',
  model: {
    prop: 'checkedKeys',
    event: 'check'
  },
  props: Object(props_util["q" /* initDefaultProps */])(DirectoryTree_objectSpread({}, TreeProps(), {
    expandAction: vue_types["a" /* default */].oneOf([false, 'click', 'doubleclick'])
  }), {
    prefixCls: 'ant-tree',
    showIcon: true,
    expandAction: 'click'
  }),
  // state: DirectoryTreeState;
  // onDebounceExpand: (event, node: AntTreeNode) => void;
  // // Shift click usage
  // lastSelectedKey?: string;
  // cachedSelectedKeys?: string[];
  data: function data() {
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var defaultExpandAll = props.defaultExpandAll,
        defaultExpandParent = props.defaultExpandParent,
        expandedKeys = props.expandedKeys,
        defaultExpandedKeys = props.defaultExpandedKeys;

    var _convertTreeToEntitie = Object(util["h" /* convertTreeToEntities */])(this.$slots["default"]),
        keyEntities = _convertTreeToEntitie.keyEntities;

    var state = {}; // Selected keys

    state._selectedKeys = props.selectedKeys || props.defaultSelectedKeys || []; // Expanded keys

    if (defaultExpandAll) {
      state._expandedKeys = getFullKeyList(this.$slots["default"]);
    } else if (defaultExpandParent) {
      state._expandedKeys = Object(util["f" /* conductExpandParent */])(expandedKeys || defaultExpandedKeys, keyEntities);
    } else {
      state._expandedKeys = defaultExpandedKeys;
    }

    this.onDebounceExpand = debounce_default()(this.expandFolderNode, 200, {
      leading: true
    });
    return DirectoryTree_objectSpread({
      _selectedKeys: [],
      _expandedKeys: []
    }, state);
  },
  watch: {
    expandedKeys: function expandedKeys(val) {
      this.setState({
        _expandedKeys: val
      });
    },
    selectedKeys: function selectedKeys(val) {
      this.setState({
        _selectedKeys: val
      });
    }
  },
  methods: {
    onExpand: function onExpand(expandedKeys, info) {
      this.setUncontrolledState({
        _expandedKeys: expandedKeys
      });
      this.$emit('expand', expandedKeys, info);
      return undefined;
    },
    onClick: function onClick(event, node) {
      var expandAction = this.$props.expandAction; // Expand the tree

      if (expandAction === 'click') {
        this.onDebounceExpand(event, node);
      }

      this.$emit('click', event, node);
    },
    onDoubleClick: function onDoubleClick(event, node) {
      var expandAction = this.$props.expandAction; // Expand the tree

      if (expandAction === 'doubleclick') {
        this.onDebounceExpand(event, node);
      }

      this.$emit('doubleclick', event, node);
    },
    onSelect: function onSelect(keys, event) {
      var multiple = this.$props.multiple;
      var children = this.$slots["default"] || [];
      var _this$$data = this.$data,
          _this$$data$_expanded = _this$$data._expandedKeys,
          expandedKeys = _this$$data$_expanded === void 0 ? [] : _this$$data$_expanded,
          _this$$data$_selected = _this$$data._selectedKeys,
          selectedKeys = _this$$data$_selected === void 0 ? [] : _this$$data$_selected;
      var node = event.node,
          nativeEvent = event.nativeEvent;
      var _node$eventKey = node.eventKey,
          eventKey = _node$eventKey === void 0 ? '' : _node$eventKey;
      var newState = {}; // Windows / Mac single pick

      var ctrlPick = nativeEvent.ctrlKey || nativeEvent.metaKey;
      var shiftPick = nativeEvent.shiftKey; // Generate new selected keys

      var newSelectedKeys = selectedKeys.slice();

      if (multiple && ctrlPick) {
        // Control click
        newSelectedKeys = keys;
        this.lastSelectedKey = eventKey;
        this.cachedSelectedKeys = newSelectedKeys;
      } else if (multiple && shiftPick) {
        // Shift click
        newSelectedKeys = Array.from(new Set([].concat(DirectoryTree_toConsumableArray(this.cachedSelectedKeys || []), DirectoryTree_toConsumableArray(calcRangeKeys(children, expandedKeys, eventKey, this.lastSelectedKey)))));
      } else {
        // Single click
        newSelectedKeys = [eventKey];
        this.lastSelectedKey = eventKey;
        this.cachedSelectedKeys = newSelectedKeys;
      }

      newState._selectedKeys = newSelectedKeys;
      this.$emit('select', newSelectedKeys, event);
      this.setUncontrolledState(newState);
    },
    expandFolderNode: function expandFolderNode(event, node) {
      var _this$$data$_expanded2 = this.$data._expandedKeys,
          expandedKeys = _this$$data$_expanded2 === void 0 ? [] : _this$$data$_expanded2;
      var _node$eventKey2 = node.eventKey,
          eventKey = _node$eventKey2 === void 0 ? '' : _node$eventKey2,
          expanded = node.expanded,
          isLeaf = node.isLeaf;

      if (isLeaf || event.shiftKey || event.metaKey || event.ctrlKey) {
        return;
      }

      var newExpandedKeys = expandedKeys.slice();
      var index = newExpandedKeys.indexOf(eventKey);

      if (expanded && index >= 0) {
        newExpandedKeys.splice(index, 1);
      } else if (!expanded && index === -1) {
        newExpandedKeys.push(eventKey);
      }

      this.setUncontrolledState({
        _expandedKeys: newExpandedKeys
      });
      this.$emit('expand', newExpandedKeys, {
        expanded: !expanded,
        node: node,
        nativeEvent: event
      });
    },
    setUncontrolledState: function setUncontrolledState(state) {
      var newState = Object(es["a" /* default */])(state, Object.keys(Object(props_util["j" /* getOptionProps */])(this)).map(function (p) {
        return "_".concat(p);
      }));

      if (Object.keys(newState).length) {
        this.setState(newState);
      }
    }
  },
  render: function render() {
    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        prefixCls = _getOptionProps.prefixCls,
        props = DirectoryTree_objectWithoutProperties(_getOptionProps, ["prefixCls"]);

    var _this$$data2 = this.$data,
        expandedKeys = _this$$data2._expandedKeys,
        selectedKeys = _this$$data2._selectedKeys;
    var treeProps = {
      props: DirectoryTree_objectSpread({
        icon: getIcon
      }, props, {
        prefixCls: prefixCls,
        expandedKeys: expandedKeys,
        selectedKeys: selectedKeys
      }),
      "class": "".concat(prefixCls, "-directory"),
      on: DirectoryTree_objectSpread({}, this.$listeners, {
        select: this.onSelect,
        click: this.onClick,
        doubleclick: this.onDoubleClick,
        expand: this.onExpand
      })
    };
    return h(Tree, treeProps, [this.$slots["default"]]);
  }
});
// CONCATENATED MODULE: ./src/components/tree/index.jsx


Tree.TreeNode.name = 'TaTreeNode';
Tree.DirectoryTree = DirectoryTree;
/* istanbul ignore next */

Tree.install = function (Vue) {
  Vue.component(Tree.name, Tree);
  Vue.component(Tree.TreeNode.name, Tree.TreeNode);
  Vue.component(DirectoryTree.name, DirectoryTree);
};

/* harmony default export */ var tree = (Tree);
// EXTERNAL MODULE: ./node_modules/lodash/pick.js
var pick = __webpack_require__(416);
var pick_default = /*#__PURE__*/__webpack_require__.n(pick);

// CONCATENATED MODULE: ./src/components/vc-tree-select/src/util.js
function src_util_toConsumableArray(arr) {
  return src_util_arrayWithoutHoles(arr) || src_util_iterableToArray(arr) || src_util_nonIterableSpread();
}

function src_util_nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function src_util_iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function src_util_arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function util_objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = util_objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function util_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function src_util_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      src_util_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function src_util_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



function util_toTitle(title) {
  if (typeof title === 'string') {
    return title;
  }

  return null;
}
function util_getValuePropValue(child) {
  var props = Object(props_util["d" /* getAllProps */])(child);

  if ('value' in props) {
    return props.value;
  }

  if (Object(props_util["i" /* getKey */])(child) !== undefined) {
    return Object(props_util["i" /* getKey */])(child);
  }

  throw new Error("no key or value for ".concat(child));
}
function util_getPropValue(child, prop) {
  if (prop === 'value') {
    return util_getValuePropValue(child);
  }

  var slots = Object(props_util["m" /* getSlots */])(child);

  if (prop === 'children') {
    var newChild = child.$slots ? Object(vnode["b" /* cloneVNodes */])(child.$slots["default"], true) : Object(vnode["b" /* cloneVNodes */])(child.componentOptions.children, true);

    if (newChild.length === 1 && !newChild[0].tag) {
      return newChild[0].text;
    }

    return newChild;
  }

  if (slots[prop]) {
    return Object(vnode["b" /* cloneVNodes */])(slots[prop], true);
  }

  var data = Object(props_util["k" /* getPropsData */])(child);

  if (prop in data) {
    return data[prop];
  } else {
    return Object(props_util["e" /* getAttrs */])(child)[prop];
  }
}
function util_isMultiple(props) {
  return !!(props.multiple || props.treeCheckable);
}
function util_toArray(value) {
  var ret = value;

  if (value === undefined) {
    ret = [];
  } else if (!Array.isArray(value)) {
    ret = [value];
  }

  return ret;
}
function util_preventDefaultEvent(e) {
  e.preventDefault();
}
var util_UNSELECTABLE_STYLE = {
  userSelect: 'none',
  WebkitUserSelect: 'none'
};
var util_UNSELECTABLE_ATTRIBUTE = {
  unselectable: 'unselectable'
};
function labelCompatible(prop) {
  var newProp = prop;

  if (newProp === 'label') {
    newProp = 'title';
  }

  return newProp;
}
function isInclude(smallArray, bigArray) {
  // attention: [0,0,1] [0,0,10]
  return smallArray.every(function (ii, i) {
    return ii === bigArray[i];
  });
}
function isPositionPrefix(smallPos, bigPos) {
  if (!bigPos || !smallPos) {
    // console.log(smallPos, bigPos);
    return false;
  }

  if (bigPos.length < smallPos.length) {
    return false;
  } // attention: "0-0-1" "0-0-10"


  if (bigPos.length > smallPos.length && bigPos.charAt(smallPos.length) !== '-') {
    return false;
  }

  return bigPos.substr(0, smallPos.length) === smallPos;
}
/*
export function getCheckedKeys(node, checkedKeys, allCheckedNodesKeys) {
  const nodeKey = node.props.eventKey;
  let newCks = [...checkedKeys];
  let nodePos;
  const unCheck = allCheckedNodesKeys.some(item => {
    if (item.key === nodeKey) {
      nodePos = item.pos;
      return true;
    }
  });
  if (unCheck) {
    newCks = [];
    allCheckedNodesKeys.forEach(item => {
      if (isPositionPrefix(item.pos, nodePos) || isPositionPrefix(nodePos, item.pos)) {
        return;
      }
      newCks.push(item.key);
    });
  } else {
    newCks.push(nodeKey);
  }
  return newCks;
}
*/

function getChildrenlength(children) {
  var len = 1;

  if (Array.isArray(children)) {
    len = children.length;
  }

  return len;
}

function getSiblingPosition(index, len, siblingPosition) {
  if (len === 1) {
    siblingPosition.first = true;
    siblingPosition.last = true;
  } else {
    siblingPosition.first = index === 0;
    siblingPosition.last = index === len - 1;
  }

  return siblingPosition;
}

function filterChild(childs) {
  var newChilds = [];
  childs.forEach(function (child) {
    var options = Object(props_util["l" /* getSlotOptions */])(child);

    if (options.__ANT_TREE_NODE || options.__ANT_TREE_SELECT_NODE) {
      newChilds.push(child);
    }
  });
  return newChilds;
}

function loopAllChildren(childs, callback, parent) {
  var loop = function loop(children, level, _parent) {
    var len = getChildrenlength(children);
    children.forEach(function handler(item, index) {
      // eslint-disable-line
      var pos = "".concat(level, "-").concat(index);

      if (item && item.componentOptions && item.componentOptions.children) {
        loop(filterChild(item.componentOptions.children), pos, {
          node: item,
          pos: pos
        });
      }

      if (item) {
        callback(item, index, pos, item.key || pos, getSiblingPosition(index, len, {}), _parent);
      }
    });
  };

  loop(filterChild(childs), 0, parent);
} // export function loopAllChildren(childs, callback) {
//   const loop = (children, level) => {
//     React.Children.forEach(children, (item, index) => {
//       const pos = `${level}-${index}`;
//       if (item && item.props.children) {
//         loop(item.props.children, pos);
//       }
//       if (item) {
//         callback(item, index, pos, getValuePropValue(item));
//       }
//     });
//   };
//   loop(childs, 0);
// }
// TODO: Here has the side effect. Update node children data affect.

function flatToHierarchy(arr) {
  if (!arr.length) {
    return arr;
  }

  var hierarchyNodes = [];
  var levelObj = {};
  arr.forEach(function (item) {
    if (!item.pos) {
      return;
    }

    var posLen = item.pos.split('-').length;

    if (!levelObj[posLen]) {
      levelObj[posLen] = [];
    }

    levelObj[posLen].push(item);
  });
  var levelArr = Object.keys(levelObj).sort(function (a, b) {
    return b - a;
  }); // const s = Date.now();
  // todo: there are performance issues!

  levelArr.reduce(function (pre, cur) {
    if (cur && cur !== pre) {
      levelObj[pre].forEach(function (item) {
        var haveParent = false;
        levelObj[cur].forEach(function (ii) {
          if (isPositionPrefix(ii.pos, item.pos)) {
            haveParent = true;

            if (!ii.children) {
              ii.children = [];
            }

            ii.children.push(item);
          }
        });

        if (!haveParent) {
          hierarchyNodes.push(item);
        }
      });
    }

    return cur;
  }); // console.log(Date.now() - s);

  return levelObj[levelArr[levelArr.length - 1]].concat(hierarchyNodes);
} // arr.length === 628, use time: ~20ms

function filterParentPosition(arr) {
  var levelObj = {};
  arr.forEach(function (item) {
    var posLen = item.split('-').length;

    if (!levelObj[posLen]) {
      levelObj[posLen] = [];
    }

    levelObj[posLen].push(item);
  });
  var levelArr = Object.keys(levelObj).sort();

  var _loop = function _loop(i) {
    if (levelArr[i + 1]) {
      levelObj[levelArr[i]].forEach(function (ii) {
        var _loop2 = function _loop2(j) {
          levelObj[levelArr[j]].forEach(function (_i, index) {
            if (isPositionPrefix(ii, _i)) {
              levelObj[levelArr[j]][index] = null;
            }
          });
          levelObj[levelArr[j]] = levelObj[levelArr[j]].filter(function (p) {
            return p;
          });
        };

        for (var j = i + 1; j < levelArr.length; j++) {
          _loop2(j);
        }
      });
    }
  };

  for (var i = 0; i < levelArr.length; i++) {
    _loop(i);
  }

  var nArr = [];
  levelArr.forEach(function (i) {
    nArr = nArr.concat(levelObj[i]);
  });
  return nArr;
} // console.log(filterParentPosition(
// ['0-2', '0-3-3', '0-10', '0-10-0', '0-0-1', '0-0', '0-1-1', '0-1']
// ));

function stripTail(str) {
  var arr = str.match(/(.+)(-[^-]+)$/);
  var st = '';

  if (arr && arr.length === 3) {
    st = arr[1];
  }

  return st;
}

function splitPosition(pos) {
  return pos.split('-');
} // todo: do optimization.


function handleCheckState(obj, checkedPositionArr, checkIt) {
  // console.log(stripTail('0-101-000'));
  // let s = Date.now();
  var objKeys = Object.keys(obj);
  objKeys.forEach(function (i, index) {
    var iArr = splitPosition(i);
    var saved = false;
    checkedPositionArr.forEach(function (_pos) {
      var _posArr = splitPosition(_pos);

      if (iArr.length > _posArr.length && isInclude(_posArr, iArr)) {
        obj[i].halfChecked = false;
        obj[i].checked = checkIt;
        objKeys[index] = null;
      }

      if (iArr[0] === _posArr[0] && iArr[1] === _posArr[1]) {
        saved = true;
      }
    });

    if (!saved) {
      objKeys[index] = null;
    }
  });
  objKeys = objKeys.filter(function (i) {
    return i;
  }); // filter non null;

  var _loop3 = function _loop3(_pIndex) {
    // loop to set ancestral nodes's `checked` or `halfChecked`
    var loop = function loop(__pos) {
      var _posLen = splitPosition(__pos).length;

      if (_posLen <= 2) {
        pIndex = _pIndex; // e.g. '0-0', '0-1'

        return;
      }

      var sibling = 0;
      var siblingChecked = 0;
      var parentPosition = stripTail(__pos);
      objKeys.forEach(function (i
      /* , index */
      ) {
        var iArr = splitPosition(i);

        if (iArr.length === _posLen && isInclude(splitPosition(parentPosition), iArr)) {
          sibling++;

          if (obj[i].checked) {
            siblingChecked++;

            var _i = checkedPositionArr.indexOf(i);

            if (_i > -1) {
              checkedPositionArr.splice(_i, 1);

              if (_i <= _pIndex) {
                _pIndex--;
              }
            }
          } else if (obj[i].halfChecked) {
            siblingChecked += 0.5;
          } // objKeys[index] = null;

        }
      }); // objKeys = objKeys.filter(i => i); // filter non null;

      var parent = obj[parentPosition]; // not check, checked, halfChecked

      if (siblingChecked === 0) {
        parent.checked = false;
        parent.halfChecked = false;
      } else if (siblingChecked === sibling) {
        parent.checked = true;
        parent.halfChecked = false;
      } else {
        parent.halfChecked = true;
        parent.checked = false;
      }

      loop(parentPosition);
    };

    loop(checkedPositionArr[_pIndex], _pIndex);
    pIndex = _pIndex;
  };

  for (var pIndex = 0; pIndex < checkedPositionArr.length; pIndex++) {
    _loop3(pIndex);
  } // console.log(Date.now()-s, objKeys.length, checkIt);

}

function getCheck(treeNodesStates, checkedPositions) {
  var halfCheckedKeys = [];
  var checkedKeys = [];
  var checkedNodes = [];
  Object.keys(treeNodesStates).forEach(function (item) {
    var itemObj = treeNodesStates[item];

    if (itemObj.checked) {
      checkedKeys.push(itemObj.key); // checkedNodes.push(getValuePropValue(itemObj.node));

      checkedNodes.push(src_util_objectSpread({}, itemObj, {
        pos: item
      }));
    } else if (itemObj.halfChecked) {
      halfCheckedKeys.push(itemObj.key);
    }
  });
  return {
    halfCheckedKeys: halfCheckedKeys,
    checkedKeys: checkedKeys,
    checkedNodes: checkedNodes,
    treeNodesStates: treeNodesStates,
    checkedPositions: checkedPositions
  };
}

function getTreeNodesStates(children, values) {
  var checkedPositions = [];
  var treeNodesStates = {};
  loopAllChildren(children, function (item, index, pos, keyOrPos, siblingPosition) {
    treeNodesStates[pos] = {
      node: item,
      key: keyOrPos,
      checked: false,
      halfChecked: false,
      siblingPosition: siblingPosition
    };

    if (values.indexOf(util_getValuePropValue(item)) !== -1) {
      treeNodesStates[pos].checked = true;
      checkedPositions.push(pos);
    }
  });
  handleCheckState(treeNodesStates, filterParentPosition(checkedPositions.sort()), true);
  return getCheck(treeNodesStates, checkedPositions);
} // can add extra prop to every node.

function recursiveCloneChildren(children) {
  var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (ch) {
    return ch;
  }; // return React.Children.map(children, child => {

  return Array.from(children).map(function (child) {
    var newChild = cb(child);

    if (newChild && newChild.props && newChild.props.children) {
      return Object(vnode["a" /* cloneElement */])(newChild, {
        children: recursiveCloneChildren(newChild.props.children, cb)
      });
    }

    return newChild;
  });
} // const newChildren = recursiveCloneChildren(children, child => {
//   const extraProps = {};
//   if (child && child.type && child.type.xxx) {
//     extraProps._prop = true;
//     return React.cloneElement(child, extraProps);
//   }
//   return child;
// });

function recursiveGen(children) {
  var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return children.map(function (child, index) {
    var pos = "".concat(level, "-").concat(index);
    var props = Object(props_util["d" /* getAllProps */])(child);

    var title = props.title,
        label = props.label,
        value = props.value,
        rest = util_objectWithoutProperties(props, ["title", "label", "value"]);

    var subChildren = child.componentOptions.children;

    var o = src_util_objectSpread({}, rest, {
      title: title,
      label: label || title,
      value: value,
      key: child.key,
      _pos: pos
    });

    if (subChildren) {
      o.children = recursiveGen(subChildren, pos);
    }

    return o;
  });
}

function util_recursive(children, cb) {
  children.forEach(function (item) {
    cb(item);

    if (item.children) {
      util_recursive(item.children, cb);
    }
  });
} // Get the tree's checkedNodes (todo: can merge to the `handleCheckState` function)
// If one node checked, it's all children nodes checked.
// If sibling nodes all checked, the parent checked.


function filterAllCheckedData(vs, treeNodes) {
  var vals = src_util_toConsumableArray(vs);

  if (!vals.length) {
    return vals;
  }

  var data = recursiveGen(treeNodes);
  var checkedNodesPositions = [];

  function checkChildren(children) {
    children.forEach(function (item) {
      if (item.__checked) {
        return;
      }

      var ci = vals.indexOf(item.value);
      var childs = item.children;

      if (ci > -1) {
        item.__checked = true;
        checkedNodesPositions.push({
          node: item,
          pos: item._pos
        });
        vals.splice(ci, 1);

        if (childs) {
          util_recursive(childs, function (child) {
            child.__checked = true;
            checkedNodesPositions.push({
              node: child,
              pos: child._pos
            });
          });
        }
      } else {
        if (childs) {
          checkChildren(childs);
        }
      }
    });
  }

  function checkParent(children) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      root: true
    };
    var siblingChecked = 0;
    children.forEach(function (item) {
      var childs = item.children;

      if (childs && !item.__checked && !item.__halfChecked) {
        var p = checkParent(childs, item);

        if (p.__checked) {
          siblingChecked++;
        } else if (p.__halfChecked) {
          siblingChecked += 0.5;
        }
      } else if (item.__checked) {
        siblingChecked++;
      } else if (item.__halfChecked) {
        siblingChecked += 0.5;
      }
    });
    var len = children.length;

    if (siblingChecked === len) {
      parent.__checked = true;
      checkedNodesPositions.push({
        node: parent,
        pos: parent._pos
      });
    } else if (siblingChecked < len && siblingChecked > 0) {
      parent.__halfChecked = true;
    }

    if (parent.root) {
      return children;
    }

    return parent;
  }

  checkChildren(data);
  checkParent(data);
  checkedNodesPositions.forEach(function (i, index) {
    // clear private metadata
    delete checkedNodesPositions[index].node.__checked;
    delete checkedNodesPositions[index].node._pos; // create the same structure of `onCheck`'s return.

    checkedNodesPositions[index].node.props = {
      title: checkedNodesPositions[index].node.title,
      label: checkedNodesPositions[index].node.label || checkedNodesPositions[index].node.title,
      value: checkedNodesPositions[index].node.value
    };

    if (checkedNodesPositions[index].node.children) {
      checkedNodesPositions[index].node.props.children = checkedNodesPositions[index].node.children;
    }

    delete checkedNodesPositions[index].node.title;
    delete checkedNodesPositions[index].node.label;
    delete checkedNodesPositions[index].node.value;
    delete checkedNodesPositions[index].node.children;
  });
  return checkedNodesPositions;
}
function processSimpleTreeData(treeData, format) {
  function unflatten2(array) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : src_util_defineProperty({}, format.id, format.rootPId);
    var children = [];

    for (var i = 0; i < array.length; i++) {
      array[i] = src_util_objectSpread({}, array[i]); // copy, can not corrupts original data

      if (array[i][format.pId] === parent[format.id]) {
        array[i].key = array[i][format.id];
        children.push(array[i]);
        array.splice(i--, 1);
      }
    }

    if (children.length) {
      parent.children = children;
      children.forEach(function (child) {
        return unflatten2(array, child);
      });
    }

    if (parent[format.id] === format.rootPId) {
      return children;
    }
  }

  return unflatten2(treeData);
}
function src_util_saveRef(instance, name) {
  if (!instance.saveRefs) {
    instance.saveRefs = {};
  }

  if (!instance.saveRefs[name]) {
    instance.saveRefs[name] = function (node) {
      instance[name] = node;
    };
  }

  return instance.saveRefs[name];
}
// CONCATENATED MODULE: ./src/components/vc-tree-select/src/strategies.js
var SHOW_ALL = 'SHOW_ALL';
var SHOW_PARENT = 'SHOW_PARENT';
var SHOW_CHILD = 'SHOW_CHILD';
// CONCATENATED MODULE: ./src/components/vc-tree-select/src/PropTypes.js



function nonEmptyStringType(props, propsName) {
  var value = props[propsName];

  if (typeof value !== 'string' || !value) {
    return new Error(); // Just a flag, so don't need message.
  }
}

function valueType(props, propName, componentName) {
  var labelInValueShape = vue_types["a" /* default */].shape({
    value: nonEmptyStringType,
    label: vue_types["a" /* default */].node
  });

  if (props.labelInValue) {
    var validate = vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].arrayOf(labelInValueShape), labelInValueShape]);
    var error = validate.apply(void 0, arguments);

    if (error) {
      return new Error("Invalid prop `".concat(propName, "` supplied to `").concat(componentName, "`, ") + "when `labelInValue` is `true`, `".concat(propName, "` should in ") + "shape of `{ value: string, label?: string }`.");
    }
  } else if (props.treeCheckable && props.treeCheckStrictly) {
    var _validate = vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].arrayOf(labelInValueShape), labelInValueShape]);

    var _error = _validate.apply(void 0, arguments);

    if (_error) {
      return new Error("Invalid prop `".concat(propName, "` supplied to `").concat(componentName, "`, ") + "when `treeCheckable` and `treeCheckStrictly` are `true`, " + "`".concat(propName, "` should in shape of `{ value: string, label?: string }`."));
    }
  } else if (props.multiple && props[propName] === '') {
    return new Error("Invalid prop `".concat(propName, "` of type `string` supplied to `").concat(componentName, "`, ") + "expected `array` when `multiple` is `true`.");
  } else {
    var _validate2 = vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string), vue_types["a" /* default */].string]);

    return _validate2.apply(void 0, arguments);
  }
}

var PropTypes_SelectPropTypes = {
  // className: PropTypes.string,
  prefixCls: vue_types["a" /* default */].string,
  multiple: vue_types["a" /* default */].bool,
  filterTreeNode: vue_types["a" /* default */].any,
  showSearch: vue_types["a" /* default */].bool,
  disabled: vue_types["a" /* default */].bool,
  showArrow: vue_types["a" /* default */].bool,
  allowClear: vue_types["a" /* default */].bool,
  defaultOpen: vue_types["a" /* default */].bool,
  open: vue_types["a" /* default */].bool,
  transitionName: vue_types["a" /* default */].string,
  animation: vue_types["a" /* default */].string,
  choiceTransitionName: vue_types["a" /* default */].string,
  // onClick: PropTypes.func,
  // onChange: PropTypes.func,
  // onSelect: PropTypes.func,
  // onDeselect: PropTypes.func,
  // onSearch: PropTypes.func,
  searchPlaceholder: vue_types["a" /* default */].string,
  placeholder: vue_types["a" /* default */].any,
  inputValue: vue_types["a" /* default */].any,
  value: vue_types["a" /* default */].any,
  defaultValue: vue_types["a" /* default */].any,
  label: vue_types["a" /* default */].any,
  // vnode
  defaultLabel: vue_types["a" /* default */].any,
  labelInValue: vue_types["a" /* default */].bool,
  dropdownClassName: vue_types["a" /* default */].string,
  dropdownStyle: vue_types["a" /* default */].object,
  dropdownPopupAlign: vue_types["a" /* default */].object,
  dropdownVisibleChange: vue_types["a" /* default */].func,
  maxTagTextLength: vue_types["a" /* default */].number,
  showCheckedStrategy: vue_types["a" /* default */].oneOf([SHOW_ALL, SHOW_PARENT, SHOW_CHILD]),
  treeCheckStrictly: vue_types["a" /* default */].bool,
  treeIcon: vue_types["a" /* default */].bool,
  treeLine: vue_types["a" /* default */].bool,
  treeDefaultExpandAll: vue_types["a" /* default */].bool,
  treeCheckable: vue_types["a" /* default */].any,
  // bool vnode
  treeNodeLabelProp: vue_types["a" /* default */].string,
  treeNodeFilterProp: vue_types["a" /* default */].string,
  treeData: vue_types["a" /* default */].array,
  treeDataSimpleMode: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, vue_types["a" /* default */].object]),
  loadData: vue_types["a" /* default */].func,
  dropdownMatchSelectWidth: vue_types["a" /* default */].bool,
  notFoundContent: vue_types["a" /* default */].any,
  children: vue_types["a" /* default */].any,
  autoFocus: vue_types["a" /* default */].bool
};
// EXTERNAL MODULE: ./src/components/_util/vue-types/utils.js
var vue_types_utils = __webpack_require__(9);

// CONCATENATED MODULE: ./src/components/vc-tree-select/src/SelectTrigger.jsx


function src_SelectTrigger_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { src_SelectTrigger_defineProperty(target, key, source[key]); }); } return target; }

function src_SelectTrigger_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












var SelectTrigger_BUILT_IN_PLACEMENTS = {
  bottomLeft: {
    points: ['tl', 'bl'],
    offset: [0, 4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topLeft: {
    points: ['bl', 'tl'],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
var SelectTrigger_SelectTrigger = {
  mixins: [BaseMixin["a" /* default */]],
  name: 'SelectTrigger',
  props: src_SelectTrigger_objectSpread({}, PropTypes_SelectPropTypes, {
    dropdownMatchSelectWidth: vue_types["a" /* default */].bool,
    dropdownPopupAlign: vue_types["a" /* default */].object,
    visible: vue_types["a" /* default */].bool,
    filterTreeNode: vue_types["a" /* default */].any,
    treeNodes: vue_types["a" /* default */].any,
    inputValue: vue_types["a" /* default */].string,
    prefixCls: vue_types["a" /* default */].string,
    popupClassName: vue_types["a" /* default */].string,
    _cachetreeData: vue_types["a" /* default */].any,
    _treeNodesStates: vue_types["a" /* default */].any,
    halfCheckedValues: vue_types["a" /* default */].any,
    inputElement: vue_types["a" /* default */].any
  }),
  data: function data() {
    return {
      sExpandedKeys: [],
      fireOnExpand: false,
      dropdownWidth: null
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.setDropdownWidth();
    });
  },
  watch: {
    inputValue: function inputValue(val) {
      // set autoExpandParent to true
      this.setState({
        sExpandedKeys: [],
        fireOnExpand: false
      });
    }
  },
  updated: function updated() {
    var _this2 = this;

    this.$nextTick(function () {
      _this2.setDropdownWidth();
    });
  },
  methods: {
    onExpand: function onExpand(expandedKeys) {
      var _this3 = this;

      // rerender
      this.setState({
        sExpandedKeys: expandedKeys,
        fireOnExpand: true
      }, function () {
        // Fix https://github.com/ant-design/ant-design/issues/5689
        if (_this3.$refs.trigger && _this3.$refs.trigger.forcePopupAlign) {
          _this3.$refs.trigger.forcePopupAlign();
        }
      });
    },
    setDropdownWidth: function setDropdownWidth() {
      var width = this.$el.offsetWidth;

      if (width !== this.dropdownWidth) {
        this.setState({
          dropdownWidth: width
        });
      }
    },
    getPopupEleRefs: function getPopupEleRefs() {
      return this.$refs.popupEle;
    },
    getPopupDOMNode: function getPopupDOMNode() {
      return this.$refs.trigger.getPopupDomNode();
    },
    getDropdownTransitionName: function getDropdownTransitionName() {
      var props = this.$props;
      var transitionName = props.transitionName;

      if (!transitionName && props.animation) {
        transitionName = "".concat(this.getDropdownPrefixCls(), "-").concat(props.animation);
      }

      return transitionName;
    },
    getDropdownPrefixCls: function getDropdownPrefixCls() {
      return "".concat(this.prefixCls, "-dropdown");
    },
    highlightTreeNode: function highlightTreeNode(treeNode) {
      var props = this.$props;
      var filterVal = treeNode.$props[labelCompatible(props.treeNodeFilterProp)];

      if (typeof filterVal === 'string') {
        return props.inputValue && filterVal.indexOf(props.inputValue) > -1;
      }

      return false;
    },
    filterTreeNode_: function filterTreeNode_(input, child) {
      if (!input) {
        return true;
      }

      var filterTreeNode = this.filterTreeNode;

      if (!filterTreeNode) {
        return true;
      }

      var props = Object(props_util["d" /* getAllProps */])(child);

      if (props && props.disabled) {
        return false;
      }

      return filterTreeNode.call(this, input, child);
    },
    processTreeNode: function processTreeNode(treeNodes) {
      var _this4 = this;

      var filterPoss = [];
      this._expandedKeys = [];
      loopAllChildren(treeNodes, function (child, index, pos) {
        if (_this4.filterTreeNode_(_this4.inputValue, child)) {
          filterPoss.push(pos);

          _this4._expandedKeys.push(String(Object(props_util["i" /* getKey */])(child)));
        }
      }); // Include the filtered nodes's ancestral nodes.

      var processedPoss = [];
      filterPoss.forEach(function (pos) {
        var arr = pos.split('-');
        arr.reduce(function (pre, cur) {
          var res = "".concat(pre, "-").concat(cur);

          if (processedPoss.indexOf(res) < 0) {
            processedPoss.push(res);
          }

          return res;
        });
      });
      var filterNodesPositions = [];
      loopAllChildren(treeNodes, function (child, index, pos) {
        if (processedPoss.indexOf(pos) > -1) {
          filterNodesPositions.push({
            node: child,
            pos: pos
          });
        }
      });
      var hierarchyNodes = flatToHierarchy(filterNodesPositions);

      var recursive = function recursive(children) {
        return children.map(function (child) {
          if (child.children) {
            return Object(vnode["a" /* cloneElement */])(child.node, {
              children: recursive(child.children)
            });
          }

          return child.node;
        });
      };

      return recursive(hierarchyNodes);
    },
    onSelect: function onSelect() {
      this.__emit.apply(this, ['select'].concat(Array.prototype.slice.call(arguments)));
    },
    renderTree: function renderTree(keys, halfCheckedKeys, newTreeNodes, multiple) {
      var h = this.$createElement;
      var props = this.$props;
      var trProps = {
        multiple: multiple,
        prefixCls: "".concat(props.prefixCls, "-tree"),
        showIcon: props.treeIcon,
        showLine: props.treeLine,
        defaultExpandAll: props.treeDefaultExpandAll,
        defaultExpandedKeys: props.treeDefaultExpandedKeys,
        filterTreeNode: this.highlightTreeNode
      };
      var trListeners = {};

      if (props.treeCheckable) {
        trProps.selectable = false;
        trProps.checkable = props.treeCheckable;
        trListeners.check = this.onSelect;
        trProps.checkStrictly = props.treeCheckStrictly;

        if (props.inputValue) {
          // enable checkStrictly when search tree.
          trProps.checkStrictly = true;
        } else {
          trProps._treeNodesStates = props._treeNodesStates;
        }

        if (trProps.treeCheckStrictly && halfCheckedKeys.length) {
          trProps.checkedKeys = {
            checked: keys,
            halfChecked: halfCheckedKeys
          };
        } else {
          trProps.checkedKeys = keys;
        }
      } else {
        trProps.selectedKeys = keys;
        trListeners.select = this.onSelect;
      } // expand keys


      if (!trProps.defaultExpandAll && !trProps.defaultExpandedKeys && !props.loadData) {
        trProps.expandedKeys = keys;
      }

      trProps.autoExpandParent = true;
      trListeners.expand = this.onExpand;

      if (this._expandedKeys && this._expandedKeys.length) {
        trProps.expandedKeys = this._expandedKeys;
      }

      if (this.fireOnExpand) {
        trProps.expandedKeys = this.sExpandedKeys;
        trProps.autoExpandParent = false;
      } // async loadData


      if (props.loadData) {
        trProps.loadData = props.loadData;
      }

      return h(vc_tree_default.a, babel_helper_vue_jsx_merge_props_default()([{
        ref: 'popupEle'
      }, {
        props: trProps,
        on: trListeners
      }]), [newTreeNodes]);
    }
  },
  render: function render() {
    var _popupClassName;

    var h = arguments[0];
    var props = this.$props;
    var multiple = props.multiple;
    var dropdownPrefixCls = this.getDropdownPrefixCls();
    var popupClassName = (_popupClassName = {}, src_SelectTrigger_defineProperty(_popupClassName, props.dropdownClassName, !!props.dropdownClassName), src_SelectTrigger_defineProperty(_popupClassName, "".concat(dropdownPrefixCls, "--").concat(multiple ? 'multiple' : 'single'), 1), _popupClassName);
    var visible = props.visible;
    var search = multiple || !props.showSearch ? null : h("span", {
      "class": "".concat(dropdownPrefixCls, "-search")
    }, [props.inputElement]);

    var recursive = function recursive(children) {
      return children.map(function handler(child) {
        // eslint-disable-line
        // if (isEmptyElement(child) || (child.data && child.data.slot)) {
        //   return null
        // }
        if (!Object(props_util["l" /* getSlotOptions */])(child).__ANT_TREE_SELECT_NODE) {
          return null;
        }

        var treeNodeProps = src_SelectTrigger_objectSpread({}, child.data, {
          props: src_SelectTrigger_objectSpread({}, Object(props_util["d" /* getAllProps */])(child), {
            title: Object(props_util["g" /* getComponentFromProp */])(child, 'title') || Object(props_util["g" /* getComponentFromProp */])(child, 'label')
          }),
          key: String(child.key)
        });

        if (child && child.componentOptions.children) {
          // null or String has no Prop
          return h(vc_tree["TreeNode"], treeNodeProps, [recursive(child.componentOptions.children)]);
        }

        return h(vc_tree["TreeNode"], treeNodeProps);
      });
    }; // const s = Date.now();


    var treeNodes;

    if (props._cachetreeData && this.cacheTreeNodes) {
      treeNodes = this.cacheTreeNodes;
    } else {
      treeNodes = recursive(props.treeData || props.treeNodes);
      this.cacheTreeNodes = treeNodes;
    } // console.log(Date.now()-s);


    if (props.inputValue) {
      treeNodes = this.processTreeNode(treeNodes);
    }

    var keys = [];
    var halfCheckedKeys = [];
    loopAllChildren(treeNodes, function (child) {
      if (props.value.some(function (item) {
        return item.value === util_getValuePropValue(child);
      })) {
        keys.push(String(Object(props_util["i" /* getKey */])(child)));
      }

      if (props.halfCheckedValues && props.halfCheckedValues.some(function (item) {
        return item.value === util_getValuePropValue(child);
      })) {
        halfCheckedKeys.push(String(Object(props_util["i" /* getKey */])(child)));
      }
    });
    var notFoundContent;

    if (!treeNodes.length) {
      if (props.notFoundContent) {
        notFoundContent = h("span", {
          "class": "".concat(props.prefixCls, "-not-found")
        }, [props.notFoundContent]);
      } else if (!search) {
        visible = false;
      }
    }

    var popupElement = h("div", [search, notFoundContent || this.renderTree(keys, halfCheckedKeys, treeNodes, multiple)]);

    var popupStyle = src_SelectTrigger_objectSpread({}, props.dropdownStyle);

    var widthProp = props.dropdownMatchSelectWidth ? 'width' : 'minWidth';

    if (this.dropdownWidth) {
      popupStyle[widthProp] = "".concat(this.dropdownWidth, "px");
    }

    return h(components_trigger, {
      attrs: {
        action: props.disabled ? [] : ['click'],
        popupPlacement: 'bottomLeft',
        builtinPlacements: SelectTrigger_BUILT_IN_PLACEMENTS,
        popupAlign: props.dropdownPopupAlign,
        prefixCls: dropdownPrefixCls,
        popupTransitionName: this.getDropdownTransitionName(),
        popup: popupElement,
        popupVisible: visible,
        getPopupContainer: props.getPopupContainer,
        popupClassName: classnames_default()(popupClassName),
        popupStyle: popupStyle
      },
      ref: 'trigger',
      on: {
        "popupVisibleChange": props.dropdownVisibleChange
      }
    }, [this.$slots["default"]]);
  }
};
/* harmony default export */ var src_SelectTrigger = (SelectTrigger_SelectTrigger);
// CONCATENATED MODULE: ./src/components/vc-tree-select/src/TreeNode.jsx
function TreeNode_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { TreeNode_defineProperty(target, key, source[key]); }); } return target; }

function TreeNode_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/* harmony default export */ var TreeNode = ({
  name: 'TreeNode',
  __ANT_TREE_SELECT_NODE: true,
  props: TreeNode_objectSpread({}, vc_tree["TreeNode"].props, {
    value: String
  }),
  render: function render() {
    return this;
  }
});
// CONCATENATED MODULE: ./src/components/vc-tree-select/src/Select.jsx






function Select_toConsumableArray(arr) { return Select_arrayWithoutHoles(arr) || Select_iterableToArray(arr) || Select_nonIterableSpread(); }

function Select_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function Select_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function Select_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function Select_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Select_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Select_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function src_Select_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { src_Select_defineProperty(target, key, source[key]); }); } return target; }

function src_Select_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }















function src_Select_noop() {}

function Select_filterFn(input, child) {
  return String(util_getPropValue(child, labelCompatible(this.$props.treeNodeFilterProp))).indexOf(input) > -1;
}

var Select_defaultProps = {
  prefixCls: 'rc-tree-select',
  // filterTreeNode: filterFn, // [Legacy] TODO: Set false and filter not hide?
  showSearch: true,
  allowClear: false,
  // placeholder: '',
  // searchPlaceholder: '',
  labelInValue: false,
  // onClick: noop,
  // onChange: noop,
  // onSelect: noop,
  // onDeselect: noop,
  // onSearch: noop,
  showArrow: true,
  dropdownMatchSelectWidth: true,
  dropdownStyle: {},
  dropdownVisibleChange: function dropdownVisibleChange() {
    return true;
  },
  notFoundContent: 'Not Found',
  showCheckedStrategy: SHOW_CHILD,
  // skipHandleInitValue: false, // Deprecated (use treeCheckStrictly)
  treeCheckStrictly: false,
  treeIcon: false,
  treeLine: false,
  treeDataSimpleMode: false,
  treeDefaultExpandAll: false,
  treeCheckable: false,
  treeNodeFilterProp: 'value',
  treeNodeLabelProp: 'title'
};
var src_Select_Select = {
  mixins: [BaseMixin["a" /* default */]],
  name: 'VCTreeSelect',
  props: Object(props_util["q" /* initDefaultProps */])(src_Select_objectSpread({}, PropTypes_SelectPropTypes, {
    __propsSymbol__: vue_types["a" /* default */].any
  }), Select_defaultProps),
  data: function data() {
    var value = [];
    var props = Object(props_util["j" /* getOptionProps */])(this);
    this.preProps = src_Select_objectSpread({}, props);

    if ('value' in props) {
      value = util_toArray(props.value);
    } else {
      value = util_toArray(props.defaultValue);
    } // save parsed treeData, for performance (treeData may be very big)


    this.renderedTreeData = this.renderTreeData();
    value = this.addLabelToValue(props, value);
    value = this.getValue(props, value, props.inputValue ? '__strict' : true);
    var inputValue = props.inputValue || ''; // if (props.combobox) {
    //   inputValue = value.length ? String(value[0].value) : '';
    // }

    return {
      sValue: value,
      sInputValue: inputValue,
      sOpen: props.open || props.defaultOpen,
      sFocused: false
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      var autoFocus = _this.autoFocus,
          disabled = _this.disabled;

      if (util_isMultiple(_this.$props)) {
        var inputNode = _this.getInputDOMNode();

        if (inputNode.value) {
          inputNode.style.width = '';
          inputNode.style.width = "".concat(_this.$refs.inputMirrorInstance.clientWidth || _this.$refs.inputMirrorInstance.offsetWidth, "px");
        } else {
          inputNode.style.width = '';
        }
      }

      if (autoFocus && !disabled) {
        _this.focus();
      }
    });
  },
  watch: {
    // for performance (use __propsSymbol__ avoid deep watch)
    __propsSymbol__: function __propsSymbol__() {
      var nextProps = Object(props_util["j" /* getOptionProps */])(this); // save parsed treeData, for performance (treeData may be very big)

      this.renderedTreeData = this.renderTreeData(nextProps); // Detecting whether the object of `onChange`'s argument  is old ref.
      // Better to do a deep equal later.

      this._cacheTreeNodesStates = this._cacheTreeNodesStates !== 'no' && this._savedValue && nextProps.value === this._savedValue;

      if (this.preProps.treeData !== nextProps.treeData || this.preProps.children !== nextProps.children) {
        // refresh this._treeNodesStates cache
        this._treeNodesStates = getTreeNodesStates(this.renderedTreeData || nextProps.children, this.sValue.map(function (item) {
          return item.value;
        }));
      }

      if ('value' in nextProps) {
        var value = util_toArray(nextProps.value);
        value = this.addLabelToValue(nextProps, value);
        value = this.getValue(nextProps, value);
        this.setState({
          sValue: value
        }, this.forcePopupAlign); // if (nextProps.combobox) {
        //   this.setState({
        //     inputValue: value.length ? String(value[0].key) : '',
        //   });
        // }
      }

      if (nextProps.inputValue !== this.preProps.inputValue) {
        this.setState({
          sInputValue: nextProps.inputValue
        });
      }

      if ('open' in nextProps) {
        this.setState({
          sOpen: nextProps.open
        });
      }

      this.preProps = src_Select_objectSpread({}, nextProps);
    }
  },
  beforeUpdate: function beforeUpdate() {
    if (this._savedValue && this.$props.value && this.$props.value !== this._savedValue && this.$props.value === this.preProps.value) {
      this._cacheTreeNodesStates = false;
      this.getValue(this.$props, this.addLabelToValue(this.$props, util_toArray(this.$props.value)));
    }
  },
  updated: function updated() {
    var _this2 = this;

    var state = this.$data;
    var props = this.$props;

    if (state.sOpen && util_isMultiple(props)) {
      this.$nextTick(function () {
        var inputNode = _this2.getInputDOMNode();

        if (inputNode.value) {
          inputNode.style.width = '';
          inputNode.style.width = "".concat(_this2.$refs.inputMirrorInstance.clientWidth, "px");
        } else {
          inputNode.style.width = '';
        }
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.clearDelayTimer();

    if (this.dropdownContainer) {
      document.body.removeChild(this.dropdownContainer);
      this.dropdownContainer = null;
    }
  },
  methods: {
    loopTreeData: function loopTreeData(data) {
      var _this3 = this;

      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var treeCheckable = arguments.length > 2 ? arguments[2] : undefined;
      var h = this.$createElement;
      return data.map(function (item, index) {
        var pos = "".concat(level, "-").concat(index);

        var label = item.label,
            value = item.value,
            disabled = item.disabled,
            key = item.key,
            selectable = item.selectable,
            children = item.children,
            isLeaf = item.isLeaf,
            otherProps = Select_objectWithoutProperties(item, ["label", "value", "disabled", "key", "selectable", "children", "isLeaf"]);

        var tnProps = src_Select_objectSpread({}, pick_default()(item, ['on', 'class', 'style']), {
          props: src_Select_objectSpread({
            value: value,
            title: label,
            disabled: disabled || false,
            selectable: selectable === false ? selectable : !treeCheckable
          }, Object(es["a" /* default */])(otherProps, ['on', 'class', 'style'])),
          key: key || value || pos
        });

        var ret;

        if (children && children.length) {
          ret = h(TreeNode, tnProps, [_this3.loopTreeData(children, pos, treeCheckable)]);
        } else {
          ret = h(TreeNode, babel_helper_vue_jsx_merge_props_default()([tnProps, {
            attrs: {
              isLeaf: isLeaf
            }
          }]));
        }

        return ret;
      });
    },
    onInputChange: function onInputChange(event) {
      var val = event.target.value;
      var props = this.$props;
      this.setState({
        sInputValue: val,
        sOpen: true
      }, this.forcePopupAlign);

      if (props.treeCheckable && !val) {
        this.setState({
          sValue: this.getValue(props, Select_toConsumableArray(this.sValue), false)
        });
      }

      this.__emit('search', val);
    },
    onDropdownVisibleChange: function onDropdownVisibleChange(open) {
      // selection inside combobox cause click
      if (!open && document.activeElement === this.getInputDOMNode()) {// return;
      }

      this.setOpenState(open, undefined, !open);
    },
    // combobox ignore
    onKeyDown: function onKeyDown(event) {
      var props = this.$props;

      if (props.disabled) {
        return;
      }

      var keyCode = event.keyCode;

      if (this.sOpen && !this.getInputDOMNode()) {
        this.onInputKeyDown(event);
      } else if (keyCode === _util_KeyCode.ENTER || keyCode === _util_KeyCode.DOWN) {
        this.setOpenState(true);
        event.preventDefault();
      }
    },
    onInputKeyDown: function onInputKeyDown(event) {
      var props = this.$props;

      if (props.disabled) {
        return;
      }

      var state = this.$data;
      var keyCode = event.keyCode;

      if (util_isMultiple(props) && !event.target.value && keyCode === _util_KeyCode.BACKSPACE) {
        var value = state.sValue.concat();

        if (value.length) {
          var popValue = value.pop();
          this.removeSelected(this.isLabelInValue() ? popValue : popValue.value);
        }

        return;
      }

      if (keyCode === _util_KeyCode.DOWN) {
        if (!state.sOpen) {
          this.openIfHasChildren();
          event.preventDefault();
          event.stopPropagation();
        }
      } else if (keyCode === _util_KeyCode.ESC) {
        if (state.sOpen) {
          this.setOpenState(false);
          event.preventDefault();
          event.stopPropagation();
        }
      }
    },
    onSelect: function onSelect(selectedKeys, info) {
      var _this4 = this;

      var item = info.node;
      var value = this.sValue;
      var props = this.$props;
      var selectedValue = util_getValuePropValue(item);
      var selectedLabel = this.getLabelFromNode(item);
      var selectedNodeFromRoot = new Array();
      var selectedLabelFromRoot = '';
      var parent = item;

      while (true) {
        if (parent == undefined) {
          break;
        }

        var parentLabel = this.getLabelFromNode(parent);

        if (parentLabel == undefined) {
          break;
        }

        selectedLabelFromRoot = '/' + parentLabel + selectedLabelFromRoot;
        selectedNodeFromRoot.push(parent);
        parent = parent.$parent;
      }

      var checkableSelect = props.treeCheckable && info.event === 'select';
      var event = selectedValue;

      if (this.isLabelInValue()) {
        event = {
          value: event,
          label: selectedLabel
        };
      }

      if (info.selected === false) {
        this.onDeselect(info);
        if (!checkableSelect) return;
      }

      this.__emit('select', event, item, info);

      var checkEvt = info.event === 'check';

      if (util_isMultiple(props)) {
        this.$nextTick(function () {
          // clearSearchInput will change sInputValue
          _this4.clearSearchInput();
        });

        if (checkEvt) {
          value = this.getCheckedNodes(info, props).map(function (n) {
            return {
              value: util_getValuePropValue(n),
              label: _this4.getLabelFromNode(n)
            };
          });
        } else {
          if (value.some(function (i) {
            return i.value === selectedValue;
          })) {
            return;
          }

          value = value.concat([{
            value: selectedValue,
            label: selectedLabel
          }]);
        }
      } else {
        if (value.length && value[0].value === selectedValue) {
          this.setOpenState(false);
          return;
        }

        value = [{
          value: selectedValue,
          label: selectedLabel
        }];
        this.setOpenState(false);
      }

      var extraInfo = {
        triggerValue: selectedValue,
        triggerNode: item,
        triggerLabelFromRootToSelected: selectedLabelFromRoot,
        triggerNodeFromRootToSelected: selectedNodeFromRoot.reverse()
      };

      if (checkEvt) {
        extraInfo.checked = info.checked; // if inputValue existing, tree is checkStrictly

        extraInfo.allCheckedNodes = props.treeCheckStrictly || this.sInputValue ? info.checkedNodes : flatToHierarchy(info.checkedNodesPositions);
        this._checkedNodes = info.checkedNodesPositions;

        var _tree = this.getPopupComponentRefs();

        this._treeNodesStates = _tree.checkKeys;
      } else {
        extraInfo.selected = info.selected;
      }

      this.fireChange(value, extraInfo);

      if (props.inputValue === null) {
        this.setState({
          sInputValue: ''
        });
      }
    },
    onDeselect: function onDeselect(info) {
      this.removeSelected(util_getValuePropValue(info.node));

      if (!util_isMultiple(this.$props)) {
        this.setOpenState(false);
      } else {
        this.clearSearchInput();
      }
    },
    onPlaceholderClick: function onPlaceholderClick() {
      this.getInputDOMNode().focus();
    },
    onClearSelection: function onClearSelection(event) {
      var _this5 = this;

      var props = this.$props;
      var state = this.$data;

      if (props.disabled) {
        return;
      }

      event.stopPropagation();
      this._cacheTreeNodesStates = 'no';
      this._checkedNodes = [];

      if (state.sInputValue || state.sValue.length) {
        this.setOpenState(false);

        if (typeof props.inputValue === 'undefined') {
          this.setState({
            sInputValue: ''
          }, function () {
            _this5.fireChange([]);
          });
        } else {
          this.fireChange([]);
        }
      }
    },
    onChoiceAnimationLeave: function onChoiceAnimationLeave() {
      this.forcePopupAlign();
    },
    getLabelFromNode: function getLabelFromNode(child) {
      return util_getPropValue(child, this.$props.treeNodeLabelProp);
    },
    getLabelFromProps: function getLabelFromProps(props, value) {
      var _this6 = this;

      if (value === undefined) {
        return null;
      }

      var label = null;
      loopAllChildren(this.renderedTreeData || props.children, function (item) {
        if (util_getValuePropValue(item) === value) {
          label = _this6.getLabelFromNode(item);
        }
      });

      if (label === null) {
        return value;
      }

      return label;
    },
    getDropdownContainer: function getDropdownContainer() {
      if (!this.dropdownContainer) {
        this.dropdownContainer = document.createElement('div');
        document.body.appendChild(this.dropdownContainer);
      }

      return this.dropdownContainer;
    },
    getSearchPlaceholderElement: function getSearchPlaceholderElement(hidden) {
      var h = this.$createElement;
      var props = this.$props;
      var placeholder;

      if (util_isMultiple(props)) {
        placeholder = Object(props_util["g" /* getComponentFromProp */])(this, 'placeholder') || Object(props_util["g" /* getComponentFromProp */])(this, 'searchPlaceholder');
      } else {
        placeholder = Object(props_util["g" /* getComponentFromProp */])(this, 'searchPlaceholder');
      }

      if (placeholder) {
        return h("span", {
          style: {
            display: hidden ? 'none' : 'block'
          },
          on: {
            "click": this.onPlaceholderClick
          },
          "class": "".concat(props.prefixCls, "-search__field__placeholder")
        }, [placeholder]);
      }

      return null;
    },
    getInputElement: function getInputElement() {
      var h = this.$createElement;
      var sInputValue = this.$data.sInputValue;
      var _this$$props = this.$props,
          prefixCls = _this$$props.prefixCls,
          disabled = _this$$props.disabled;
      var multiple = util_isMultiple(this.$props);
      var inputListeners = {
        input: this.onInputChange,
        keydown: this.onInputKeyDown
      };

      if (multiple) {
        inputListeners.blur = this.onBlur;
        inputListeners.focus = this.onFocus;
      }

      return h("span", {
        "class": "".concat(prefixCls, "-search__field__wrap")
      }, [h("input", babel_helper_vue_jsx_merge_props_default()([{
        ref: 'inputInstance'
      }, {
        on: inputListeners
      }, {
        domProps: {
          "value": sInputValue
        },
        attrs: {
          disabled: disabled,
          role: 'textbox'
        },
        "class": "".concat(prefixCls, "-search__field")
      }])), h("span", {
        ref: 'inputMirrorInstance',
        "class": "".concat(prefixCls, "-search__field__mirror")
      }, [sInputValue, "\xA0"]), util_isMultiple(this.$props) ? null : this.getSearchPlaceholderElement(!!sInputValue)]);
    },
    getInputDOMNode: function getInputDOMNode() {
      return this.$refs.inputInstance;
    },
    getPopupDOMNode: function getPopupDOMNode() {
      return this.$refs.trigger.getPopupDOMNode();
    },
    getPopupComponentRefs: function getPopupComponentRefs() {
      return this.$refs.trigger.getPopupEleRefs();
    },
    getValue: function getValue(_props, val) {
      var _this7 = this;

      var init = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var value = val; // if inputValue existing, tree is checkStrictly

      var _strict = init === '__strict' || init && (this.sInputValue || this.inputValue !== _props.inputValue);

      if (_props.treeCheckable && (_props.treeCheckStrictly || _strict)) {
        this.halfCheckedValues = [];
        value = [];
        val.forEach(function (i) {
          if (!i.halfChecked) {
            value.push(i);
          } else {
            _this7.halfCheckedValues.push(i);
          }
        });
      } // if (!(_props.treeCheckable && !_props.treeCheckStrictly)) {


      if (!_props.treeCheckable || _props.treeCheckable && (_props.treeCheckStrictly || _strict)) {
        return value;
      }

      var checkedTreeNodes;

      if (this._cachetreeData && this._cacheTreeNodesStates && this._checkedNodes && !this.sInputValue) {
        this.checkedTreeNodes = checkedTreeNodes = this._checkedNodes;
      } else {
        /**
         * Note: `this._treeNodesStates`'s treeNodesStates must correspond to nodes of the
         * final tree (`processTreeNode` function from SelectTrigger.jsx produce the final tree).
         *
         * And, `this._treeNodesStates` from `onSelect` is previous value,
         * so it perhaps only have a few nodes, but the newly filtered tree can have many nodes,
         * thus, you cannot use previous _treeNodesStates.
         */
        // getTreeNodesStates is not effective.
        this._treeNodesStates = getTreeNodesStates(this.renderedTreeData || _props.children, value.map(function (item) {
          return item.value;
        }));
        this.checkedTreeNodes = checkedTreeNodes = this._treeNodesStates.checkedNodes;
      }

      var mapLabVal = function mapLabVal(arr) {
        return arr.map(function (itemObj) {
          return {
            value: util_getValuePropValue(itemObj.node),
            label: util_getPropValue(itemObj.node, _props.treeNodeLabelProp)
          };
        });
      };

      var props = this.$props;
      var checkedValues = [];

      if (props.showCheckedStrategy === SHOW_ALL) {
        checkedValues = mapLabVal(checkedTreeNodes);
      } else if (props.showCheckedStrategy === SHOW_PARENT) {
        var posArr = filterParentPosition(checkedTreeNodes.map(function (itemObj) {
          return itemObj.pos;
        }));
        checkedValues = mapLabVal(checkedTreeNodes.filter(function (itemObj) {
          return posArr.indexOf(itemObj.pos) !== -1;
        }));
      } else {
        checkedValues = mapLabVal(checkedTreeNodes.filter(function (itemObj) {
          return !itemObj.node.componentOptions.children;
        }));
      }

      return checkedValues;
    },
    getCheckedNodes: function getCheckedNodes(info, props) {
      // TODO treeCheckable does not support tags/dynamic
      var checkedNodes = info.checkedNodes; // if inputValue existing, tree is checkStrictly

      if (props.treeCheckStrictly || this.sInputValue) {
        return checkedNodes;
      }

      var checkedNodesPositions = info.checkedNodesPositions;

      if (props.showCheckedStrategy === SHOW_ALL) {// checkedNodes = checkedNodes
      } else if (props.showCheckedStrategy === SHOW_PARENT) {
        var posArr = filterParentPosition(checkedNodesPositions.map(function (itemObj) {
          return itemObj.pos;
        }));
        checkedNodes = checkedNodesPositions.filter(function (itemObj) {
          return posArr.indexOf(itemObj.pos) !== -1;
        }).map(function (itemObj) {
          return itemObj.node;
        });
      } else {
        checkedNodes = checkedNodes.filter(function (n) {
          return !n.componentOptions.children;
        });
      }

      return checkedNodes;
    },
    getDeselectedValue: function getDeselectedValue(selectedValue) {
      var checkedTreeNodes = this.checkedTreeNodes;
      var unCheckPos;
      checkedTreeNodes.forEach(function (itemObj) {
        var nodeProps = Object(props_util["d" /* getAllProps */])(itemObj.node);

        if (nodeProps.value === selectedValue) {
          unCheckPos = itemObj.pos;
        }
      });
      var newVals = [];
      var newCkTns = [];
      checkedTreeNodes.forEach(function (itemObj) {
        if (isPositionPrefix(itemObj.pos, unCheckPos) || isPositionPrefix(unCheckPos, itemObj.pos)) {
          // Filter ancestral and children nodes when uncheck a node.
          return;
        }

        var nodeProps = Object(props_util["d" /* getAllProps */])(itemObj.node);
        newCkTns.push(itemObj);
        newVals.push(nodeProps.value);
      });
      this.checkedTreeNodes = this._checkedNodes = newCkTns;
      var nv = this.sValue.filter(function (val) {
        return newVals.indexOf(val.value) !== -1;
      });
      this.fireChange(nv, {
        triggerValue: selectedValue,
        clear: true
      });
    },
    setOpenState: function setOpenState(open, needFocus) {
      var _this8 = this;

      var documentClickClose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      this.clearDelayTimer();
      var props = this.$props; // can not optimize, if children is empty
      // if (this.sOpen === open) {
      //   return;
      // }

      if (!this.$props.dropdownVisibleChange(open, {
        documentClickClose: documentClickClose
      })) {
        return;
      }

      this.setState({
        sOpen: open
      }, function () {
        if (needFocus || open) {
          // Input dom init after first time component render
          // Add delay for this to get focus
          setTimeout(function () {
            if (open || util_isMultiple(props)) {
              var input = _this8.getInputDOMNode();

              if (input && document.activeElement !== input) {
                input.focus();
              }
            } else if (_this8.$refs.selection) {
              _this8.$refs.selection.focus();
            }
          }, 0);
        }
      });
    },
    clearSearchInput: function clearSearchInput() {
      this.getInputDOMNode().focus();

      if (!Object(props_util["p" /* hasProp */])(this, 'inputValue')) {
        this.setState({
          sInputValue: ''
        });
      }
    },
    addLabelToValue: function addLabelToValue(props, value_) {
      var _this9 = this;

      var value = value_;

      if (this.isLabelInValue()) {
        value.forEach(function (v, i) {
          if (Object.prototype.toString.call(value[i]) !== '[object Object]') {
            value[i] = {
              value: '',
              label: ''
            };
            return;
          }

          v.label = v.label || _this9.getLabelFromProps(props, v.value);
        });
      } else {
        value = value.map(function (v) {
          return {
            value: v,
            label: _this9.getLabelFromProps(props, v)
          };
        });
      }

      return value;
    },
    clearDelayTimer: function clearDelayTimer() {
      if (this.delayTimer) {
        clearTimeout(this.delayTimer);
        this.delayTimer = null;
      }
    },
    removeSelected: function removeSelected(selectedVal, e) {
      var props = this.$props;

      if (props.disabled) {
        return;
      } // Do not trigger Trigger popup


      if (e && e.stopPropagation) {
        e.stopPropagation();
      }

      this._cacheTreeNodesStates = 'no';

      if (props.treeCheckable && (props.showCheckedStrategy === SHOW_ALL || props.showCheckedStrategy === SHOW_PARENT) && !(props.treeCheckStrictly || this.sInputValue)) {
        this.getDeselectedValue(selectedVal);
        return;
      } // click the node's `x`(in select box), likely trigger the TreeNode's `unCheck` event,
      // cautiously, they are completely different, think about it, the tree may not render at first,
      // but the nodes in select box are ready.


      var label;
      var value = this.sValue.filter(function (singleValue) {
        if (singleValue.value === selectedVal) {
          label = singleValue.label;
        }

        return singleValue.value !== selectedVal;
      });
      var canMultiple = util_isMultiple(props);

      if (canMultiple) {
        var event = selectedVal;

        if (this.isLabelInValue()) {
          event = {
            value: selectedVal,
            label: label
          };
        }

        this.__emit('deselect', event);
      }

      if (props.treeCheckable) {
        if (this.checkedTreeNodes && this.checkedTreeNodes.length) {
          this.checkedTreeNodes = this._checkedNodes = this.checkedTreeNodes.filter(function (item) {
            var nodeProps = Object(props_util["d" /* getAllProps */])(item.node);
            return value.some(function (i) {
              return i.value === nodeProps.value;
            });
          });
        }
      }

      this.fireChange(value, {
        triggerValue: selectedVal,
        clear: true
      });
    },
    openIfHasChildren: function openIfHasChildren() {
      var props = this.$props;

      if (props.children.length || props.treeData && props.treeData.length || !util_isMultiple(props)) {
        this.setOpenState(true);
      }
    },
    fireChange: function fireChange(value) {
      var _this10 = this;

      var extraInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var props = Object(props_util["j" /* getOptionProps */])(this);
      var vals = value.map(function (i) {
        return i.value;
      });
      var sv = this.sValue.map(function (i) {
        return i.value;
      });

      if (vals.length !== sv.length || !vals.every(function (val, index) {
        return sv[index] === val;
      })) {
        var ex = src_Select_objectSpread({
          preValue: Select_toConsumableArray(this.sValue)
        }, extraInfo);

        var labs = null;
        var vls = value;

        if (!this.isLabelInValue()) {
          labs = value.map(function (i) {
            return i.label;
          });
          vls = vls.map(function (v) {
            return v.value;
          });
        } else if (this.halfCheckedValues && this.halfCheckedValues.length) {
          this.halfCheckedValues.forEach(function (i) {
            if (!vls.some(function (v) {
              return v.value === i.value;
            })) {
              vls.push(i);
            }
          });
        }

        if (props.treeCheckable && ex.clear) {
          var treeData = this.renderedTreeData || props.children;
          ex.allCheckedNodes = flatToHierarchy(filterAllCheckedData(vals, treeData));
        }

        if (props.treeCheckable && this.sInputValue) {
          var _vls = Select_toConsumableArray(this.sValue);

          if (ex.checked) {
            value.forEach(function (i) {
              if (_vls.every(function (ii) {
                return ii.value !== i.value;
              })) {
                _vls.push(src_Select_objectSpread({}, i));
              }
            });
          } else {
            var index;

            var includeVal = _vls.some(function (i, ind) {
              if (i.value === ex.triggerValue) {
                index = ind;
                return true;
              }
            });

            if (includeVal) {
              _vls.splice(index, 1);
            }
          }

          vls = _vls;

          if (!this.isLabelInValue()) {
            labs = _vls.map(function (v) {
              return v.label;
            });
            vls = _vls.map(function (v) {
              return v.value;
            });
          }
        }

        this._savedValue = util_isMultiple(props) ? vls : vls[0];

        this.__emit('change', this._savedValue, labs, ex);

        if (!('value' in props)) {
          this._cacheTreeNodesStates = false;
          this.setState({
            sValue: this.getValue(props, util_toArray(this._savedValue).map(function (v, i) {
              return _this10.isLabelInValue() ? v : {
                value: v,
                label: labs && labs[i]
              };
            }))
          }, this.forcePopupAlign);
        }
      }
    },
    isLabelInValue: function isLabelInValue() {
      var _this$$props2 = this.$props,
          treeCheckable = _this$$props2.treeCheckable,
          treeCheckStrictly = _this$$props2.treeCheckStrictly,
          labelInValue = _this$$props2.labelInValue;

      if (treeCheckable && treeCheckStrictly) {
        return true;
      }

      return labelInValue || false;
    },
    onFocus: function onFocus(e) {
      this.__emit('focus', e);
    },
    onBlur: function onBlur(e) {
      this.__emit('blur', e);
    },
    focus: function focus() {
      if (!util_isMultiple(this.$props)) {
        this.$refs.selection.focus();
      } else {
        this.getInputDOMNode().focus();
      }
    },
    blur: function blur() {
      if (!util_isMultiple(this.$props)) {
        this.$refs.selection.blur();
      } else {
        this.getInputDOMNode().blur();
      }
    },
    forcePopupAlign: function forcePopupAlign() {
      this.$refs.trigger.$refs.trigger.forcePopupAlign();
    },
    renderTopControlNode: function renderTopControlNode() {
      var _this11 = this;

      var h = this.$createElement;
      var value = this.$data.sValue;
      var props = this.$props;
      var choiceTransitionName = props.choiceTransitionName,
          prefixCls = props.prefixCls,
          maxTagTextLength = props.maxTagTextLength;
      var multiple = util_isMultiple(props); // single and not combobox, input is inside dropdown

      if (!multiple) {
        var innerNode = h("span", {
          key: 'placeholder',
          "class": "".concat(prefixCls, "-selection__placeholder")
        }, [Object(props_util["g" /* getComponentFromProp */])(this, 'placeholder') || '']);

        if (value.length) {
          innerNode = h("span", {
            key: 'value',
            attrs: {
              title: util_toTitle(value[0].label)
            },
            "class": "".concat(prefixCls, "-selection-selected-value")
          }, [value[0].label]);
        }

        return h("span", {
          "class": "".concat(prefixCls, "-selection__rendered")
        }, [innerNode]);
      }

      var selectedValueNodes = value.map(function (singleValue) {
        var content = singleValue.label;
        var title = content;

        if (maxTagTextLength && typeof content === 'string' && content.length > maxTagTextLength) {
          content = "".concat(content.slice(0, maxTagTextLength), "...");
        }

        return h("li", babel_helper_vue_jsx_merge_props_default()([{
          style: util_UNSELECTABLE_STYLE,
          on: {
            "mousedown": util_preventDefaultEvent
          },
          "class": "".concat(prefixCls, "-selection__choice"),
          key: singleValue.value,
          attrs: {
            title: util_toTitle(title)
          }
        }, {
          attrs: util_UNSELECTABLE_ATTRIBUTE
        }]), [h("span", {
          "class": "".concat(prefixCls, "-selection__choice__remove"),
          on: {
            "click": function click(event) {
              _this11.removeSelected(singleValue.value, event);
            }
          }
        }), h("span", {
          "class": "".concat(prefixCls, "-selection__choice__content")
        }, [content])]);
      });
      selectedValueNodes.push(h("li", {
        "class": "".concat(prefixCls, "-search ").concat(prefixCls, "-search--inline"),
        key: '__input'
      }, [this.getInputElement()]));
      var className = "".concat(prefixCls, "-selection__rendered");

      if (choiceTransitionName) {
        var transitionProps = Object(getTransitionProps["a" /* default */])(choiceTransitionName, {
          tag: 'ul',
          afterLeave: this.onChoiceAnimationLeave
        });
        return h("transition-group", babel_helper_vue_jsx_merge_props_default()([{
          "class": className
        }, transitionProps]), [selectedValueNodes]);
      }

      return h("ul", {
        "class": className
      }, [selectedValueNodes]);
    },
    renderTreeData: function renderTreeData(props) {
      var validProps = props || this.$props;

      if (validProps.treeData) {
        if (props && props.treeData === this.preProps.treeData && this.renderedTreeData) {
          // cache and use pre data.
          this._cachetreeData = true;
          return this.renderedTreeData;
        }

        this._cachetreeData = false;

        var treeData = Select_toConsumableArray(validProps.treeData); // process treeDataSimpleMode


        if (validProps.treeDataSimpleMode) {
          var simpleFormat = {
            id: 'id',
            pId: 'pId',
            rootPId: null
          };

          if (Object.prototype.toString.call(validProps.treeDataSimpleMode) === '[object Object]') {
            simpleFormat = src_Select_objectSpread({}, simpleFormat, validProps.treeDataSimpleMode);
          }

          treeData = processSimpleTreeData(treeData, simpleFormat);
        }

        return this.loopTreeData(treeData, undefined, this.preProps.treeCheckable);
      }
    }
  },
  render: function render() {
    var _rootCls;

    var h = arguments[0];
    var props = this.$props;
    var multiple = util_isMultiple(props);
    var state = this.$data;
    var disabled = props.disabled,
        allowClear = props.allowClear,
        prefixCls = props.prefixCls;
    var ctrlNode = this.renderTopControlNode();
    var extraSelectionProps = {};

    if (!multiple) {
      extraSelectionProps = {
        on: {
          keydown: this.onKeyDown,
          blur: this.onBlur,
          focus: this.onFocus
        },
        attrs: {
          tabIndex: 0
        }
      };
    }

    var rootCls = (_rootCls = {}, src_Select_defineProperty(_rootCls, prefixCls, 1), src_Select_defineProperty(_rootCls, "".concat(prefixCls, "-open"), state.sOpen), src_Select_defineProperty(_rootCls, "".concat(prefixCls, "-focused"), state.sOpen || state.sFocused), src_Select_defineProperty(_rootCls, "".concat(prefixCls, "-disabled"), disabled), src_Select_defineProperty(_rootCls, "".concat(prefixCls, "-enabled"), !disabled), src_Select_defineProperty(_rootCls, "".concat(prefixCls, "-allow-clear"), !!props.allowClear), _rootCls);
    var clear = h("span", {
      key: 'clear',
      "class": "".concat(prefixCls, "-selection__clear"),
      on: {
        "click": this.onClearSelection
      }
    });
    var selectTriggerProps = {
      props: src_Select_objectSpread({}, props, {
        treeNodes: props.children,
        treeData: this.renderedTreeData,
        _cachetreeData: this._cachetreeData,
        _treeNodesStates: this._treeNodesStates,
        halfCheckedValues: this.halfCheckedValues,
        multiple: multiple,
        disabled: disabled,
        visible: state.sOpen,
        inputValue: state.sInputValue,
        inputElement: this.getInputElement(),
        value: state.sValue,
        dropdownVisibleChange: this.onDropdownVisibleChange,
        getPopupContainer: props.getPopupContainer,
        filterTreeNode: this.filterTreeNode === undefined ? Select_filterFn : this.filterTreeNode
      }),
      on: src_Select_objectSpread({}, this.$listeners, {
        select: this.onSelect
      }),
      ref: 'trigger'
    };
    return h(src_SelectTrigger, selectTriggerProps, [h("span", {
      on: {
        "click": props.onClick
      },
      "class": classnames_default()(rootCls)
    }, [h("span", babel_helper_vue_jsx_merge_props_default()([{
      ref: 'selection',
      key: 'selection',
      "class": "".concat(prefixCls, "-selection\n            ").concat(prefixCls, "-selection--").concat(multiple ? 'multiple' : 'single'),
      attrs: {
        role: 'combobox',
        "aria-autocomplete": 'list',
        "aria-haspopup": 'true',
        "aria-expanded": state.sOpen
      }
    }, extraSelectionProps]), [ctrlNode, allowClear && state.sValue.length && state.sValue[0].value ? clear : null, multiple || !props.showArrow ? null : h("span", {
      key: 'arrow',
      "class": "".concat(prefixCls, "-arrow"),
      style: {
        outline: 'none'
      }
    }, [h("b")]), multiple ? this.getSearchPlaceholderElement(!!state.sInputValue || state.sValue.length) : null])])]);
  }
};
src_Select_Select.SHOW_ALL = SHOW_ALL;
src_Select_Select.SHOW_PARENT = SHOW_PARENT;
src_Select_Select.SHOW_CHILD = SHOW_CHILD;
/* harmony default export */ var src_Select = (src_Select_Select);
// CONCATENATED MODULE: ./src/components/vc-tree-select/src/index.js
function src_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      vc_tree_select_src_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function vc_tree_select_src_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
} // export this package's api






src_Select.TreeNode = TreeNode;
/* harmony default export */ var vc_tree_select_src = ({
  functional: true,
  render: function render(h, context) {
    var props = context.props,
        listeners = context.listeners,
        _context$children = context.children,
        children = _context$children === void 0 ? [] : _context$children,
        data = context.data;

    var treeSelectProps = src_objectSpread({}, Object(es["a" /* default */])(data, ['attrs']), {
      props: src_objectSpread({}, props, {
        children: children,
        __propsSymbol__: Symbol()
      }),
      on: listeners
    });

    return h(src_Select, treeSelectProps);
  },
  TreeNode: TreeNode,
  SHOW_ALL: SHOW_ALL,
  SHOW_PARENT: SHOW_PARENT,
  SHOW_CHILD: SHOW_CHILD
});

// CONCATENATED MODULE: ./src/components/vc-tree-select/index.js
// rc-tree-select 1.12.13 tag
// export this package's api

/* harmony default export */ var vc_tree_select = (vc_tree_select_src);

// CONCATENATED MODULE: ./src/components/tree-select/interface.jsx
function tree_select_interface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { tree_select_interface_defineProperty(target, key, source[key]); }); } return target; }

function tree_select_interface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var TreeData = vue_types["a" /* default */].shape({
  key: vue_types["a" /* default */].string,
  value: vue_types["a" /* default */].string,
  label: vue_types["a" /* default */].any,
  scopedSlots: vue_types["a" /* default */].object,
  children: vue_types["a" /* default */].array
}).loose;
var interface_TreeSelectProps = function TreeSelectProps() {
  return tree_select_interface_objectSpread({}, select_AbstractSelectProps(), {
    value: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].object, vue_types["a" /* default */].array]),
    defaultValue: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].array]),
    multiple: vue_types["a" /* default */].bool,
    // onSelect: (value: any) => void,
    // onChange: (value: any, label: any) => void,
    // onSearch: (value: any) => void,
    searchPlaceholder: vue_types["a" /* default */].string,
    dropdownClassName: vue_types["a" /* default */].string,
    dropdownStyle: vue_types["a" /* default */].object,
    dropdownMatchSelectWidth: vue_types["a" /* default */].bool,
    treeDefaultExpandAll: vue_types["a" /* default */].bool,
    treeCheckable: vue_types["a" /* default */].bool,
    treeDefaultExpandedKeys: vue_types["a" /* default */].arrayOf(String),
    filterTreeNode: vue_types["a" /* default */].func,
    treeNodeFilterProp: vue_types["a" /* default */].string,
    treeNodeLabelProp: vue_types["a" /* default */].string,
    treeData: vue_types["a" /* default */].arrayOf(Object),
    treeDataSimpleMode: vue_types["a" /* default */].oneOfType([Boolean, Object]),
    loadData: vue_types["a" /* default */].func,
    showCheckedStrategy: vue_types["a" /* default */].oneOf(['SHOW_ALL', 'SHOW_PARENT', 'SHOW_CHILD']),
    labelInValue: vue_types["a" /* default */].bool,
    treeCheckStrictly: vue_types["a" /* default */].bool,
    getPopupContainer: vue_types["a" /* default */].func,
    title: vue_types["a" /* default */].string
  });
};
// CONCATENATED MODULE: ./src/components/tree-select/index.jsx
function tree_select_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = tree_select_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function tree_select_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function tree_select_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { tree_select_defineProperty(target, key, source[key]); }); } return target; }

function tree_select_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var TreeSelect = {
  TreeNode: tree_select_objectSpread({}, TreeNode, {
    name: 'TaTreeSelectNode'
  }),
  SHOW_ALL: SHOW_ALL,
  SHOW_PARENT: SHOW_PARENT,
  SHOW_CHILD: SHOW_CHILD,
  name: 'TaTreeSelect',
  props: Object(props_util["q" /* initDefaultProps */])(interface_TreeSelectProps(), {
    prefixCls: 'ant-select',
    transitionName: 'slide-up',
    choiceTransitionName: 'zoom',
    showSearch: false,
    title: 'label'
  }),
  model: {
    prop: 'value',
    event: 'change'
  },
  created: function created() {
    _util_warning(this.multiple !== false || !this.treeCheckable, '`multiple` will alway be `true` when `treeCheckable` is true');
  },
  methods: {
    focus: function focus() {
      this.$refs.vcTreeSelect.focus();
    },
    blur: function blur() {
      this.$refs.vcTreeSelect.blur();
    },
    onChange: function onChange() {
      this.$emit.apply(this, ['change'].concat(Array.prototype.slice.call(arguments)));
    },
    updateTreeData: function updateTreeData() {
      var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      debugger;

      for (var i = 0, len = list.length; i < len; i++) {
        var _list$i = list[i],
            title = _list$i.title,
            _list$i$scopedSlots = _list$i.scopedSlots,
            scopedSlots = _list$i$scopedSlots === void 0 ? {} : _list$i$scopedSlots,
            children = _list$i.children;
        var $scopedSlots = this.$scopedSlots;
        var label = list[i][this.title];
        var newLabel = typeof label === 'function' ? label(this.$createElement) : label;
        var newTitle = typeof title === 'function' ? title(this.$createElement) : title;

        if (!newLabel && scopedSlots.label && $scopedSlots[scopedSlots.label]) {
          newLabel = $scopedSlots.label(list[i]);
        }

        if (!newTitle && scopedSlots.title && $scopedSlots[scopedSlots.title]) {
          newTitle = $scopedSlots.title(list[i]);
        }

        var item = {
          // label: newLabel,
          title: newTitle || newLabel
        };
        this.updateTreeData(children || []);
        Object.assign(list[i], item);
      }
    },
    renderTreeSelect: function renderTreeSelect(locale) {
      var _cls;

      var h = this.$createElement;
      var props = Object(props_util["j" /* getOptionProps */])(this);

      var prefixCls = props.prefixCls,
          size = props.size,
          notFoundContent = props.notFoundContent,
          dropdownStyle = props.dropdownStyle,
          dropdownClassName = props.dropdownClassName,
          restProps = tree_select_objectWithoutProperties(props, ["prefixCls", "size", "notFoundContent", "dropdownStyle", "dropdownClassName"]);

      this.updateTreeData(props.treeData || []);
      var cls = (_cls = {}, tree_select_defineProperty(_cls, "".concat(prefixCls, "-lg"), size === 'large'), tree_select_defineProperty(_cls, "".concat(prefixCls, "-sm"), size === 'small'), _cls);
      var checkable = Object(props_util["g" /* getComponentFromProp */])(this, 'treeCheckable');

      if (checkable) {
        checkable = h("span", {
          "class": "".concat(prefixCls, "-tree-checkbox-inner")
        });
      }

      var VcTreeSelectProps = {
        props: tree_select_objectSpread({}, restProps, {
          dropdownClassName: classnames_default()(dropdownClassName, "".concat(prefixCls, "-tree-dropdown")),
          prefixCls: prefixCls,
          dropdownStyle: tree_select_objectSpread({
            maxHeight: '100vh',
            overflow: 'auto'
          }, dropdownStyle),
          treeCheckable: checkable,
          notFoundContent: notFoundContent || locale.notFoundContent
        }),
        "class": cls,
        on: tree_select_objectSpread({}, this.$listeners, {
          change: this.onChange
        }),
        ref: 'vcTreeSelect'
      };
      return h(vc_tree_select, VcTreeSelectProps, [Object(props_util["c" /* filterEmpty */])(this.$slots["default"])]);
    }
  },
  render: function render() {
    var h = arguments[0];
    return h(LocaleReceiver, {
      attrs: {
        componentName: 'Select',
        defaultLocale: {}
      },
      scopedSlots: {
        "default": this.renderTreeSelect
      }
    });
  }
};
/* istanbul ignore next */

TreeSelect.install = function (Vue) {
  Vue.component(TreeSelect.name, TreeSelect);
  Vue.component(TreeSelect.TreeNode.name, TreeSelect.TreeNode);
};

/* harmony default export */ var tree_select = (TreeSelect);
// CONCATENATED MODULE: ./src/components/timeline/TimelineItem.jsx
function TimelineItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var TimeLineItemProps = {
  prefixCls: vue_types["a" /* default */].string,
  color: vue_types["a" /* default */].string,
  dot: vue_types["a" /* default */].any,
  pending: vue_types["a" /* default */].bool
};
/* harmony default export */ var TimelineItem = ({
  name: 'TaTimelineItem',
  props: Object(props_util["q" /* initDefaultProps */])(TimeLineItemProps, {
    prefixCls: 'ant-timeline',
    color: 'blue',
    pending: false
  }),
  render: function render() {
    var _classNames, _classNames2;

    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        prefixCls = _getOptionProps.prefixCls,
        _getOptionProps$color = _getOptionProps.color,
        color = _getOptionProps$color === void 0 ? '' : _getOptionProps$color,
        pending = _getOptionProps.pending;

    var dot = Object(props_util["g" /* getComponentFromProp */])(this, 'dot');
    var itemClassName = classnames_default()((_classNames = {}, TimelineItem_defineProperty(_classNames, "".concat(prefixCls, "-item"), true), TimelineItem_defineProperty(_classNames, "".concat(prefixCls, "-item-pending"), pending), _classNames));
    var dotClassName = classnames_default()((_classNames2 = {}, TimelineItem_defineProperty(_classNames2, "".concat(prefixCls, "-item-head"), true), TimelineItem_defineProperty(_classNames2, "".concat(prefixCls, "-item-head-custom"), dot), TimelineItem_defineProperty(_classNames2, "".concat(prefixCls, "-item-head-").concat(color), true), _classNames2));
    var liProps = {
      "class": itemClassName,
      on: this.$listeners
    };
    return h("li", liProps, [h("div", {
      "class": "".concat(prefixCls, "-item-tail")
    }), h("div", {
      "class": dotClassName,
      style: {
        borderColor: /blue|red|green/.test(color) ? undefined : color
      }
    }, [dot]), h("div", {
      "class": "".concat(prefixCls, "-item-content")
    }, [this.$slots["default"]])]);
  }
});
// CONCATENATED MODULE: ./src/components/timeline/Timeline.jsx
function Timeline_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Timeline_defineProperty(target, key, source[key]); }); } return target; }

function Timeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Timeline_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Timeline_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Timeline_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var TimelineProps = {
  prefixCls: vue_types["a" /* default */].string,

  /** 指定最后一个幽灵节点是否存在或内容 */
  pending: vue_types["a" /* default */].any,
  pendingDot: vue_types["a" /* default */].string
};
/* harmony default export */ var Timeline = ({
  name: 'TaTimeline',
  props: Object(props_util["q" /* initDefaultProps */])(TimelineProps, {
    prefixCls: 'ant-timeline'
  }),
  render: function render() {
    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        prefixCls = _getOptionProps.prefixCls,
        restProps = Timeline_objectWithoutProperties(_getOptionProps, ["prefixCls"]);

    var pendingDot = Object(props_util["g" /* getComponentFromProp */])(this, 'pendingDot');
    var pending = Object(props_util["g" /* getComponentFromProp */])(this, 'pending');
    var pendingNode = typeof pending === 'boolean' ? null : pending;
    var classString = classnames_default()(prefixCls, Timeline_defineProperty({}, "".concat(prefixCls, "-pending"), !!pending)); // Remove falsy items

    var falsylessItems = Object(props_util["c" /* filterEmpty */])(this.$slots["default"]);
    var items = falsylessItems.map(function (item, idx) {
      return Object(vnode["a" /* cloneElement */])(item, {
        props: {
          last: falsylessItems.length - 1 === idx
        }
      });
    });
    var pendingItem = pending ? h(TimelineItem, {
      attrs: {
        pending: !!pending
      }
    }, [h("template", {
      slot: 'dot'
    }, [pendingDot || h(components_icon, {
      attrs: {
        type: 'loading'
      }
    })]), pendingNode]) : null;
    var timelineProps = {
      props: Timeline_objectSpread({}, restProps),
      "class": classString,
      on: this.$listeners
    };
    return h("ul", timelineProps, [items, pendingItem]);
  }
});
// CONCATENATED MODULE: ./src/components/timeline/index.jsx




Timeline.Item = TimelineItem;
/* istanbul ignore next */

Timeline.install = function (Vue) {
  Vue.component(Timeline.name, Timeline);
  Vue.component(TimelineItem.name, TimelineItem);
};

/* harmony default export */ var timeline = (Timeline);
// EXTERNAL MODULE: ./node_modules/lodash/uniqBy.js
var uniqBy = __webpack_require__(417);
var uniqBy_default = /*#__PURE__*/__webpack_require__.n(uniqBy);

// CONCATENATED MODULE: ./src/components/vc-upload/src/request.js
function getError(option, xhr) {
  var msg = "cannot post ".concat(option.action, " ").concat(xhr.status, "'");
  var err = new Error(msg);
  err.status = xhr.status;
  err.method = 'post';
  err.url = option.action;
  return err;
}

function getBody(xhr) {
  var text = xhr.responseText || xhr.response;

  if (!text) {
    return text;
  }

  try {
    return JSON.parse(text);
  } catch (e) {
    return text;
  }
} // option {
//  onProgress: (event: { percent: number }): void,
//  onError: (event: Error, body?: Object): void,
//  onSuccess: (body: Object): void,
//  data: Object,
//  filename: String,
//  file: File,
//  withCredentials: Boolean,
//  action: String,
//  headers: Object,
// }


function upload(option) {
  var xhr = new window.XMLHttpRequest();

  if (option.onProgress && xhr.upload) {
    xhr.upload.onprogress = function progress(e) {
      if (e.total > 0) {
        e.percent = e.loaded / e.total * 100;
      }

      option.onProgress(e);
    };
  }

  var formData = new window.FormData();

  if (option.data) {
    Object.keys(option.data).map(function (key) {
      formData.append(key, option.data[key]);
    });
  }

  formData.append(option.filename, option.file);

  xhr.onerror = function error(e) {
    option.onError(e);
  };

  xhr.onload = function onload() {
    // allow success when 2xx status
    // see https://github.com/react-component/upload/issues/34
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(option, xhr), getBody(xhr));
    }

    option.onSuccess(getBody(xhr), xhr);
  };

  xhr.open('post', option.action, true); // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179

  if (option.withCredentials && 'withCredentials' in xhr) {
    xhr.withCredentials = true;
  }

  var headers = option.headers || {}; // when set headers['X-Requested-With'] = null , can close default XHR header
  // see https://github.com/react-component/upload/issues/33

  if (headers['X-Requested-With'] !== null) {
    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
  }

  for (var h in headers) {
    if (headers.hasOwnProperty(h) && headers[h] !== null) {
      xhr.setRequestHeader(h, headers[h]);
    }
  }

  xhr.send(formData);
  return {
    abort: function abort() {
      xhr.abort();
    }
  };
}
// CONCATENATED MODULE: ./src/components/vc-upload/src/uid.js
var uid_now = +new Date();
var uid_index = 0;
function uid_uid() {
  return "vc-upload-".concat(uid_now, "-").concat(++uid_index);
}
// CONCATENATED MODULE: ./src/components/vc-upload/src/attr-accept.js
function endsWith(str, suffix) {
  return str.indexOf(suffix, str.length - suffix.length) !== -1;
}

/* harmony default export */ var attr_accept = (function (file, acceptedFiles) {
  if (file && acceptedFiles) {
    var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(',');
    var fileName = file.name || '';
    var mimeType = file.type || '';
    var baseMimeType = mimeType.replace(/\/.*$/, '');
    return acceptedFilesArray.some(function (type) {
      var validType = type.trim();

      if (validType.charAt(0) === '.') {
        return endsWith(fileName.toLowerCase(), validType.toLowerCase());
      } else if (/\/\*$/.test(validType)) {
        // This is something like a image/* mime type
        return baseMimeType === validType.replace(/\/.*$/, '');
      }

      return mimeType === validType;
    });
  }

  return true;
});
// CONCATENATED MODULE: ./src/components/vc-upload/src/traverseFileTree.js
var traverseFileTree = function traverseFileTree(files, callback, isAccepted) {
  var _traverseFileTree = function _traverseFileTree(item, path) {
    path = path || '';

    if (item.isFile) {
      item.file(function (file) {
        if (isAccepted(file)) {
          callback([file]);
        }
      });
    } else if (item.isDirectory) {
      var dirReader = item.createReader();
      dirReader.readEntries(function (entries) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var entrieItem = _step.value;

            _traverseFileTree(entrieItem, "".concat(path).concat(item.name, "/"));
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      });
    }
  };

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = files[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var file = _step2.value;

      _traverseFileTree(file.webkitGetAsEntry());
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
};

/* harmony default export */ var src_traverseFileTree = (traverseFileTree);
// CONCATENATED MODULE: ./src/components/vc-upload/src/AjaxUploader.jsx
function AjaxUploader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { AjaxUploader_defineProperty(target, key, source[key]); }); } return target; }

function AjaxUploader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var upLoadPropTypes = {
  componentTag: vue_types["a" /* default */].string,
  // style: PropTypes.object,
  prefixCls: vue_types["a" /* default */].string,
  name: vue_types["a" /* default */].string,
  // className: PropTypes.string,
  multiple: vue_types["a" /* default */].bool,
  directory: vue_types["a" /* default */].bool,
  disabled: vue_types["a" /* default */].bool,
  accept: vue_types["a" /* default */].string,
  // children: PropTypes.any,
  // onStart: PropTypes.func,
  data: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].object, vue_types["a" /* default */].func]),
  action: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].func]),
  headers: vue_types["a" /* default */].object,
  beforeUpload: vue_types["a" /* default */].func,
  customRequest: vue_types["a" /* default */].func,
  // onProgress: PropTypes.func,
  withCredentials: vue_types["a" /* default */].bool
};
var AjaxUploader = {
  name: 'ajaxUploader',
  mixins: [BaseMixin["a" /* default */]],
  props: upLoadPropTypes,
  data: function data() {
    this.reqs = {};
    return {
      uid: uid_uid()
    };
  },
  methods: {
    onChange: function onChange(e) {
      var files = e.target.files;
      this.uploadFiles(files);
      this.reset();
    },
    onClick: function onClick() {
      var el = this.$refs.fileInputRef;

      if (!el) {
        return;
      }

      el.click();
    },
    onKeyDown: function onKeyDown(e) {
      if (e.key === 'Enter') {
        this.onClick();
      }
    },
    onFileDrop: function onFileDrop(e) {
      var _this = this;

      e.preventDefault();

      if (e.type === 'dragover') {
        return;
      }

      if (this.directory) {
        src_traverseFileTree(e.dataTransfer.items, this.uploadFiles, function (_file) {
          return attr_accept(_file, _this.accept);
        });
      } else {
        var files = Array.prototype.slice.call(e.dataTransfer.files).filter(function (file) {
          return attr_accept(file, _this.accept);
        });
        this.uploadFiles(files);
      }
    },
    uploadFiles: function uploadFiles(files) {
      var _this2 = this;

      var postFiles = Array.prototype.slice.call(files);
      postFiles.forEach(function (file) {
        file.uid = uid_uid();

        _this2.upload(file, postFiles);
      });
    },
    upload: function upload(file, fileList) {
      var _this3 = this;

      if (!this.beforeUpload) {
        // always async in case use react state to keep fileList
        return setTimeout(function () {
          return _this3.post(file);
        }, 0);
      }

      var before = this.beforeUpload(file, fileList);

      if (before && before.then) {
        before.then(function (processedFile) {
          var processedFileType = Object.prototype.toString.call(processedFile);

          if (processedFileType === '[object File]' || processedFileType === '[object Blob]') {
            return _this3.post(processedFile);
          }

          return _this3.post(file);
        })["catch"](function (e) {
          console && console.log(e); // eslint-disable-line
        });
      } else if (before !== false) {
        setTimeout(function () {
          return _this3.post(file);
        }, 0);
      }
    },
    post: function post(file) {
      var _this4 = this;

      if (!this._isMounted) {
        return;
      }

      var data = this.$props.data;

      if (typeof data === 'function') {
        data = data(file);
      }

      new Promise(function (resolve) {
        var action = _this4.action;

        if (typeof action === 'function') {
          return resolve(action(file));
        }

        resolve(action);
      }).then(function (action) {
        var uid = file.uid;
        var request = _this4.customRequest || upload;
        _this4.reqs[uid] = request({
          action: action,
          filename: _this4.name,
          file: file,
          data: data,
          headers: _this4.headers,
          withCredentials: _this4.withCredentials,
          onProgress: function onProgress(e) {
            _this4.$emit('progress', e, file);
          },
          onSuccess: function onSuccess(ret, xhr) {
            delete _this4.reqs[uid];

            _this4.$emit('success', ret, file, xhr);
          },
          onError: function onError(err, ret) {
            delete _this4.reqs[uid];

            _this4.$emit('error', err, ret, file);
          }
        });

        _this4.$emit('start', file);
      });
    },
    reset: function reset() {
      this.setState({
        uid: uid_uid()
      });
    },
    abort: function abort(file) {
      var reqs = this.reqs;

      if (file) {
        var uid = file;

        if (file && file.uid) {
          uid = file.uid;
        }

        if (reqs[uid]) {
          reqs[uid].abort();
          delete reqs[uid];
        }
      } else {
        Object.keys(reqs).forEach(function (uid) {
          if (reqs[uid]) {
            reqs[uid].abort();
          }

          delete reqs[uid];
        });
      }
    }
  },
  mounted: function mounted() {
    var _this5 = this;

    this.$nextTick(function () {
      _this5._isMounted = true;
    });
  },
  beforeDestroy: function beforeDestroy() {
    this._isMounted = false;
    this.abort();
  },
  render: function render() {
    var _classNames;

    var h = arguments[0];
    var _this$$props = this.$props,
        Tag = _this$$props.componentTag,
        prefixCls = _this$$props.prefixCls,
        disabled = _this$$props.disabled,
        multiple = _this$$props.multiple,
        accept = _this$$props.accept,
        directory = _this$$props.directory;
    var cls = classnames_default()((_classNames = {}, AjaxUploader_defineProperty(_classNames, prefixCls, true), AjaxUploader_defineProperty(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
    var events = disabled ? {} : {
      click: this.onClick,
      keydown: this.onKeyDown,
      drop: this.onFileDrop,
      dragover: this.onFileDrop
    };
    var tagProps = {
      on: AjaxUploader_objectSpread({}, events, this.$listeners),
      attrs: {
        role: 'button',
        tabIndex: disabled ? null : '0'
      },
      "class": cls
    };
    return h(Tag, tagProps, [h("input", {
      attrs: {
        type: 'file',
        accept: accept,
        directory: directory ? 'directory' : null,
        webkitdirectory: directory ? 'webkitdirectory' : null,
        multiple: multiple
      },
      ref: 'fileInputRef',
      key: this.uid,
      style: {
        display: 'none'
      },
      on: {
        "change": this.onChange
      }
    }), this.$slots["default"]]);
  }
};
/* harmony default export */ var src_AjaxUploader = (AjaxUploader);
// CONCATENATED MODULE: ./src/components/vc-upload/src/IframeUploader.jsx
function IframeUploader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { IframeUploader_defineProperty(target, key, source[key]); }); } return target; }

function IframeUploader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var IFRAME_STYLE = {
  position: 'absolute',
  top: 0,
  opacity: 0,
  filter: 'alpha(opacity=0)',
  left: 0,
  zIndex: 9999 // diferent from AjaxUpload, can only upload on at one time, serial seriously

};
var IframeUploader = {
  mixins: [BaseMixin["a" /* default */]],
  props: {
    componentTag: vue_types["a" /* default */].string,
    // style: PropTypes.object,
    disabled: vue_types["a" /* default */].bool,
    prefixCls: vue_types["a" /* default */].string,
    // className: PropTypes.string,
    accept: vue_types["a" /* default */].string,
    // onStart: PropTypes.func,
    multiple: vue_types["a" /* default */].bool,
    // children: PropTypes.any,
    data: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].object, vue_types["a" /* default */].func]),
    action: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].func]),
    name: vue_types["a" /* default */].string
  },
  data: function data() {
    this.file = {};
    return {
      uploading: false
    };
  },
  methods: {
    onLoad: function onLoad() {
      if (!this.uploading) {
        return;
      }

      var file = this.file;
      var response;

      try {
        var doc = this.getIframeDocument();
        var script = doc.getElementsByTagName('script')[0];

        if (script && script.parentNode === doc.body) {
          doc.body.removeChild(script);
        }

        response = doc.body.innerHTML;
        this.$emit('success', response, file);
      } catch (err) {
        _util_warning(false, 'cross domain error for Upload. Maybe server should return document.domain script. see Note from https://github.com/react-component/upload');
        response = 'cross-domain';
        this.$emit('error', err, null, file);
      }

      this.endUpload();
    },
    onChange: function onChange() {
      var _this = this;

      var target = this.getFormInputNode(); // ie8/9 don't support FileList Object
      // http://stackoverflow.com/questions/12830058/ie8-input-type-file-get-files

      var file = this.file = {
        uid: uid_uid(),
        name: target.value
      };
      this.startUpload();
      var props = this.$props;

      if (!props.beforeUpload) {
        return this.post(file);
      }

      var before = props.beforeUpload(file);

      if (before && before.then) {
        before.then(function () {
          _this.post(file);
        }, function () {
          _this.endUpload();
        });
      } else if (before !== false) {
        this.post(file);
      } else {
        this.endUpload();
      }
    },
    getIframeNode: function getIframeNode() {
      return this.$refs.iframeRef;
    },
    getIframeDocument: function getIframeDocument() {
      return this.getIframeNode().contentDocument;
    },
    getFormNode: function getFormNode() {
      return this.getIframeDocument().getElementById('form');
    },
    getFormInputNode: function getFormInputNode() {
      return this.getIframeDocument().getElementById('input');
    },
    getFormDataNode: function getFormDataNode() {
      return this.getIframeDocument().getElementById('data');
    },
    getFileForMultiple: function getFileForMultiple(file) {
      return this.multiple ? [file] : file;
    },
    getIframeHTML: function getIframeHTML(domain) {
      var domainScript = '';
      var domainInput = '';

      if (domain) {
        var script = 'script';
        domainScript = "<".concat(script, ">document.domain=\"").concat(domain, "\";</").concat(script, ">");
        domainInput = "<input name=\"_documentDomain\" value=\"".concat(domain, "\" />");
      }

      return "\n      <!DOCTYPE html>\n      <html>\n      <head>\n      <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n      <style>\n      body,html {padding:0;margin:0;border:0;overflow:hidden;}\n      </style>\n      ".concat(domainScript, "\n      </head>\n      <body>\n      <form method=\"post\"\n      encType=\"multipart/form-data\"\n      action=\"\" id=\"form\"\n      style=\"display:block;height:9999px;position:relative;overflow:hidden;\">\n      <input id=\"input\" type=\"file\"\n       name=\"").concat(this.name, "\"\n       style=\"position:absolute;top:0;right:0;height:9999px;font-size:9999px;cursor:pointer;\"/>\n      ").concat(domainInput, "\n      <span id=\"data\"></span>\n      </form>\n      </body>\n      </html>\n      ");
    },
    initIframeSrc: function initIframeSrc() {
      if (this.domain) {
        this.getIframeNode().src = "javascript:void((function(){\n          var d = document;\n          d.open();\n          d.domain='".concat(this.domain, "';\n          d.write('');\n          d.close();\n        })())");
      }
    },
    initIframe: function initIframe() {
      var iframeNode = this.getIframeNode();
      var win = iframeNode.contentWindow;
      var doc;
      this.domain = this.domain || '';
      this.initIframeSrc();

      try {
        doc = win.document;
      } catch (e) {
        this.domain = document.domain;
        this.initIframeSrc();
        win = iframeNode.contentWindow;
        doc = win.document;
      }

      doc.open('text/html', 'replace');
      doc.write(this.getIframeHTML(this.domain));
      doc.close();
      this.getFormInputNode().onchange = this.onChange;
    },
    endUpload: function endUpload() {
      if (this.uploading) {
        this.file = {}; // hack avoid batch

        this.uploading = false;
        this.setState({
          uploading: false
        });
        this.initIframe();
      }
    },
    startUpload: function startUpload() {
      if (!this.uploading) {
        this.uploading = true;
        this.setState({
          uploading: true
        });
      }
    },
    updateIframeWH: function updateIframeWH() {
      var rootNode = this.$el;
      var iframeNode = this.getIframeNode();
      iframeNode.style.height = "".concat(rootNode.offsetHeight, "px");
      iframeNode.style.width = "".concat(rootNode.offsetWidth, "px");
    },
    abort: function abort(file) {
      if (file) {
        var uid = file;

        if (file && file.uid) {
          uid = file.uid;
        }

        if (uid === this.file.uid) {
          this.endUpload();
        }
      } else {
        this.endUpload();
      }
    },
    post: function post(file) {
      var _this2 = this;

      var formNode = this.getFormNode();
      var dataSpan = this.getFormDataNode();
      var data = this.$props.data;

      if (typeof data === 'function') {
        data = data(file);
      }

      var inputs = document.createDocumentFragment();

      for (var key in data) {
        if (data.hasOwnProperty(key)) {
          var input = document.createElement('input');
          input.setAttribute('name', key);
          input.value = data[key];
          inputs.appendChild(input);
        }
      }

      dataSpan.appendChild(inputs);
      new Promise(function (resolve) {
        var action = _this2.action;

        if (typeof action === 'function') {
          return resolve(action(file));
        }

        resolve(action);
      }).then(function (action) {
        formNode.setAttribute('action', action);
        formNode.submit();
        dataSpan.innerHTML = '';

        _this2.$emit('start', file);
      });
    }
  },
  mounted: function mounted() {
    var _this3 = this;

    this.$nextTick(function () {
      _this3.updateIframeWH();

      _this3.initIframe();
    });
  },
  updated: function updated() {
    var _this4 = this;

    this.$nextTick(function () {
      _this4.updateIframeWH();
    });
  },
  render: function render() {
    var _classNames;

    var h = arguments[0];
    var _this$$props = this.$props,
        Tag = _this$$props.componentTag,
        disabled = _this$$props.disabled,
        prefixCls = _this$$props.prefixCls;

    var iframeStyle = IframeUploader_objectSpread({}, IFRAME_STYLE, {
      display: this.uploading || disabled ? 'none' : ''
    });

    var cls = classnames_default()((_classNames = {}, IframeUploader_defineProperty(_classNames, prefixCls, true), IframeUploader_defineProperty(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
    return h(Tag, {
      attrs: {
        className: cls
      },
      style: {
        position: 'relative',
        zIndex: 0
      }
    }, [h("iframe", {
      ref: 'iframeRef',
      on: {
        "load": this.onLoad
      },
      style: iframeStyle
    }), this.$slots["default"]]);
  }
};
/* harmony default export */ var src_IframeUploader = (IframeUploader);
// CONCATENATED MODULE: ./src/components/vc-upload/src/Upload.jsx
function Upload_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Upload_defineProperty(target, key, source[key]); }); } return target; }

function Upload_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







function empty() {}

var uploadProps = {
  componentTag: vue_types["a" /* default */].string,
  prefixCls: vue_types["a" /* default */].string,
  action: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].func]),
  name: vue_types["a" /* default */].string,
  multipart: vue_types["a" /* default */].bool,
  directory: vue_types["a" /* default */].bool,
  // onError: PropTypes.func,
  // onSuccess: PropTypes.func,
  // onProgress: PropTypes.func,
  // onStart: PropTypes.func,
  data: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].object, vue_types["a" /* default */].func]),
  headers: vue_types["a" /* default */].object,
  accept: vue_types["a" /* default */].string,
  multiple: vue_types["a" /* default */].bool,
  disabled: vue_types["a" /* default */].bool,
  beforeUpload: vue_types["a" /* default */].func,
  customRequest: vue_types["a" /* default */].func,
  // onReady: PropTypes.func,
  withCredentials: vue_types["a" /* default */].bool,
  supportServerRender: vue_types["a" /* default */].bool
};
/* harmony default export */ var Upload = ({
  name: 'Upload',
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(uploadProps, {
    componentTag: 'span',
    prefixCls: 'rc-upload',
    data: {},
    headers: {},
    name: 'file',
    multipart: false,
    // onReady: empty,
    // onStart: empty,
    // onError: empty,
    // onSuccess: empty,
    supportServerRender: false,
    multiple: false,
    beforeUpload: empty,
    withCredentials: false
  }),
  data: function data() {
    return {
      Component: null
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      if (_this.supportServerRender) {
        /* eslint react/no-did-mount-set-state:0 */
        _this.setState({
          Component: _this.getComponent()
        }, function () {
          _this.$emit('ready');
        });
      }
    });
  },
  methods: {
    getComponent: function getComponent() {
      return typeof File !== 'undefined' ? src_AjaxUploader : src_IframeUploader;
    },
    abort: function abort(file) {
      this.$refs.uploaderRef.abort(file);
    }
  },
  render: function render() {
    var h = arguments[0];
    var componentProps = {
      props: Upload_objectSpread({}, this.$props),
      on: this.$listeners,
      ref: 'uploaderRef'
    };

    if (this.supportServerRender) {
      var _ComponentUploader = this.Component;

      if (_ComponentUploader) {
        return h(_ComponentUploader, componentProps, [this.$slots["default"]]);
      }

      return null;
    }

    var ComponentUploader = this.getComponent();
    return h(ComponentUploader, componentProps, [this.$slots["default"]]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-upload/src/index.js
// based on rc-upload 2.4.4
// export this package's api

/* harmony default export */ var vc_upload_src = (Upload);
// CONCATENATED MODULE: ./src/components/vc-upload/index.js
// rc-upload 2.5.1

/* harmony default export */ var vc_upload = (vc_upload_src);
// CONCATENATED MODULE: ./src/components/upload/interface.jsx
function interface_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { interface_typeof = function _typeof(obj) { return typeof obj; }; } else { interface_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return interface_typeof(obj); }


var UploadFileStatus = vue_types["a" /* default */].oneOf(['error', 'success', 'done', 'uploading', 'removed']); // export const HttpRequestHeader {
//   [key: string]: string;
// }
// export const UploadFile = PropsTypes.shape({
//   uid: PropsTypes.oneOfType([
//     PropsTypes.string,
//     PropsTypes.number,
//   ]),
//   size: PropsTypes.number,
//   name: PropsTypes.string,
//   filename: PropsTypes.string,
//   lastModified: PropsTypes.number,
//   lastModifiedDate: PropsTypes.any,
//   url: PropsTypes.string,
//   status: UploadFileStatus,
//   percent: PropsTypes.number,
//   thumbUrl: PropsTypes.string,
//   originFileObj: PropsTypes.any,
//   response: PropsTypes.any,
//   error: PropsTypes.any,
//   linkProps: PropsTypes.any,
//   type: PropsTypes.string,
// }).loose

function UploadFile(_ref) {
  var uid = _ref.uid,
      name = _ref.name;
  if (!uid && uid !== 0) return false;
  if (!['string', 'number'].includes(interface_typeof(uid))) return false;
  if (name === '' || typeof name !== 'string') return false;
  return true;
}

var UploadChangeParam = {
  file: vue_types["a" /* default */].custom(UploadFile),
  fileList: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].custom(UploadFile)),
  event: vue_types["a" /* default */].object
};
var ShowUploadListInterface = vue_types["a" /* default */].shape({
  showRemoveIcon: vue_types["a" /* default */].bool,
  showPreviewIcon: vue_types["a" /* default */].bool
}).loose;
var UploadLocale = vue_types["a" /* default */].shape({
  uploading: vue_types["a" /* default */].string,
  removeFile: vue_types["a" /* default */].string,
  uploadError: vue_types["a" /* default */].string,
  previewFile: vue_types["a" /* default */].string
}).loose;
var UploadProps = {
  type: vue_types["a" /* default */].oneOf(['drag', 'select']),
  name: vue_types["a" /* default */].string,
  defaultFileList: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].custom(UploadFile)),
  fileList: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].custom(UploadFile)),
  action: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].func]),
  directory: vue_types["a" /* default */].bool,
  data: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].object, vue_types["a" /* default */].func]),
  headers: vue_types["a" /* default */].object,
  showUploadList: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].bool, ShowUploadListInterface]),
  multiple: vue_types["a" /* default */].bool,
  accept: vue_types["a" /* default */].string,
  beforeUpload: vue_types["a" /* default */].func,
  // onChange: PropsTypes.func,
  listType: vue_types["a" /* default */].oneOf(['text', 'picture', 'picture-card']),
  // className: PropsTypes.string,
  // onPreview: PropsTypes.func,
  // onRemove: PropsTypes.func,
  supportServerRender: vue_types["a" /* default */].bool,
  // style: PropsTypes.object,
  disabled: vue_types["a" /* default */].bool,
  prefixCls: vue_types["a" /* default */].string,
  customRequest: vue_types["a" /* default */].func,
  withCredentials: vue_types["a" /* default */].bool,
  locale: UploadLocale,
  height: vue_types["a" /* default */].number
};
var UploadState = {
  fileList: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].custom(UploadFile)),
  dragState: vue_types["a" /* default */].string
};
var UploadListProps = {
  listType: vue_types["a" /* default */].oneOf(['text', 'picture', 'picture-card']),
  // onPreview: PropsTypes.func,
  // onRemove: PropsTypes.func,
  // items: PropsTypes.arrayOf(UploadFile),
  items: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].custom(UploadFile)),
  // items: PropsTypes.any,
  progressAttr: vue_types["a" /* default */].object,
  prefixCls: vue_types["a" /* default */].string,
  showRemoveIcon: vue_types["a" /* default */].bool,
  showPreviewIcon: vue_types["a" /* default */].bool,
  locale: UploadLocale
};
// CONCATENATED MODULE: ./src/components/upload/Dragger.jsx
function Dragger_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Dragger_defineProperty(target, key, source[key]); }); } return target; }

function Dragger_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/* harmony default export */ var Dragger = ({
  name: 'TaUploadDragger',
  props: UploadProps,
  render: function render() {
    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);
    var draggerProps = {
      props: Dragger_objectSpread({}, props, {
        type: 'drag'
      }),
      on: this.$listeners,
      style: {
        height: this.height
      }
    };
    return h(upload_Upload, draggerProps, [this.$slots["default"]]);
  }
});
// CONCATENATED MODULE: ./src/components/upload/UploadList.jsx



function UploadList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { UploadList_defineProperty(target, key, source[key]); }); } return target; }

function UploadList_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








 // https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsDataURL

var previewFile = function previewFile(file, callback) {
  var reader = new window.FileReader();

  reader.onloadend = function () {
    return callback(reader.result);
  };

  reader.readAsDataURL(file);
};

var extname = function extname(url) {
  if (!url) {
    return '';
  }

  var temp = url.split('/');
  var filename = temp[temp.length - 1];
  var filenameWithoutSuffix = filename.split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [''])[0];
};

var imageTypes = ['image', 'webp', 'png', 'svg', 'gif', 'jpg', 'jpeg', 'bmp'];

var isImageUrl = function isImageUrl(file) {
  if (imageTypes.includes(file.type)) {
    return true;
  }

  var url = file.thumbUrl || file.url;
  var extension = extname(url);

  if (/^data:image\//.test(url) || /(webp|svg|png|gif|jpg|jpeg|bmp)$/i.test(extension)) {
    return true;
  } else if (/^data:/.test(url)) {
    // other file types of base64
    return false;
  } else if (extension) {
    // other file types which have extension
    return false;
  }

  return true;
};

/* harmony default export */ var UploadList = ({
  name: 'AUploadList',
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(UploadListProps, {
    listType: 'text',
    // or picture
    progressAttr: {
      strokeWidth: 2,
      showInfo: false
    },
    prefixCls: 'ant-upload',
    showRemoveIcon: true,
    showPreviewIcon: true
  }),
  updated: function updated() {
    var _this = this;

    this.$nextTick(function () {
      if (_this.listType !== 'picture' && _this.listType !== 'picture-card') {
        return;
      }

      (_this.items || []).forEach(function (file) {
        if (typeof document === 'undefined' || typeof window === 'undefined' || !window.FileReader || !window.File || !(file.originFileObj instanceof window.File) || file.thumbUrl !== undefined) {
          return;
        }
        /*eslint-disable */


        file.thumbUrl = '';
        /*eslint -enable */

        previewFile(file.originFileObj, function (previewDataUrl) {
          /*eslint-disable */
          file.thumbUrl = previewDataUrl;
          /*eslint -enable todo */
          // this.forceUpdate()
        });
      });
    });
  },
  methods: {
    handleClose: function handleClose(file) {
      this.$emit('remove', file);
    },
    handlePreview: function handlePreview(file, e) {
      var preview = this.$listeners.preview;

      if (!preview) {
        return;
      }

      e.preventDefault();
      return this.$emit('preview', file);
    }
  },
  render: function render() {
    var _this2 = this,
        _classNames2;

    var h = arguments[0];

    var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
        prefixCls = _getOptionProps.prefixCls,
        _getOptionProps$items = _getOptionProps.items,
        items = _getOptionProps$items === void 0 ? [] : _getOptionProps$items,
        listType = _getOptionProps.listType,
        showPreviewIcon = _getOptionProps.showPreviewIcon,
        showRemoveIcon = _getOptionProps.showRemoveIcon,
        locale = _getOptionProps.locale;

    var list = items.map(function (file) {
      var _classNames;

      var progress;
      var icon = h(components_icon, {
        attrs: {
          type: file.status === 'uploading' ? 'loading' : 'paper-clip'
        }
      });

      if (listType === 'picture' || listType === 'picture-card') {
        if (listType === 'picture-card' && file.status === 'uploading') {
          icon = h("div", {
            "class": "".concat(prefixCls, "-list-item-uploading-text")
          }, [locale.uploading]);
        } else if (!file.thumbUrl && !file.url) {
          icon = h(components_icon, {
            "class": "".concat(prefixCls, "-list-item-thumbnail"),
            attrs: {
              type: 'picture'
            }
          });
        } else {
          var thumbnail = isImageUrl(file) ? h("img", {
            attrs: {
              src: file.thumbUrl || file.url,
              alt: file.name
            }
          }) : h(components_icon, {
            attrs: {
              type: 'file'
            },
            style: {
              fontSize: '48px',
              color: 'rgba(0,0,0,0.5)'
            }
          });
          icon = h("a", {
            "class": "".concat(prefixCls, "-list-item-thumbnail"),
            on: {
              "click": function click(e) {
                return _this2.handlePreview(file, e);
              }
            },
            attrs: {
              href: file.url || file.thumbUrl,
              target: '_blank',
              rel: 'noopener noreferrer'
            }
          }, [thumbnail]);
        }
      }

      if (file.status === 'uploading') {
        var progressProps = {
          props: UploadList_objectSpread({}, _this2.progressAttr, {
            type: 'line',
            percent: file.percent
          }) // show loading icon if upload progress listener is disabled

        };
        var loadingProgress = 'percent' in file ? h(components_progress, progressProps) : null;
        progress = h("div", {
          "class": "".concat(prefixCls, "-list-item-progress"),
          key: 'progress'
        }, [loadingProgress]);
      }

      var infoUploadingClass = classnames_default()((_classNames = {}, UploadList_defineProperty(_classNames, "".concat(prefixCls, "-list-item"), true), UploadList_defineProperty(_classNames, "".concat(prefixCls, "-list-item-").concat(file.status), true), _classNames));
      var preview = file.url ? h("a", babel_helper_vue_jsx_merge_props_default()([file.linkProps, {
        attrs: {
          href: file.url,
          target: '_blank',
          rel: 'noopener noreferrer',
          title: file.name
        },
        "class": "".concat(prefixCls, "-list-item-name"),
        on: {
          "click": function click(e) {
            return _this2.handlePreview(file, e);
          }
        }
      }]), [file.name]) : h("span", {
        "class": "".concat(prefixCls, "-list-item-name"),
        on: {
          "click": function click(e) {
            return _this2.handlePreview(file, e);
          }
        },
        attrs: {
          title: file.name
        }
      }, [file.name]);
      var style = file.url || file.thumbUrl ? undefined : {
        pointerEvents: 'none',
        opacity: 0.5
      };
      var previewIcon = showPreviewIcon ? h("a", {
        attrs: {
          href: file.url || file.thumbUrl,
          target: '_blank',
          rel: 'noopener noreferrer',
          title: locale.previewFile
        },
        style: style,
        on: {
          "click": function click(e) {
            return _this2.handlePreview(file, e);
          }
        }
      }, [h(components_icon, {
        attrs: {
          type: 'eye-o'
        }
      })]) : null;
      var iconProps = {
        props: {
          type: 'delete',
          title: locale.removeFile
        },
        on: {
          click: function click() {
            _this2.handleClose(file);
          }
        }
      };

      var iconProps1 = UploadList_objectSpread({}, iconProps, {
        props: {
          type: 'cross'
        }
      });

      var removeIcon = showRemoveIcon ? h(components_icon, iconProps) : null;
      var removeIconCross = showRemoveIcon ? h(components_icon, iconProps1) : null;
      var actions = listType === 'picture-card' && file.status !== 'uploading' ? h("span", {
        "class": "".concat(prefixCls, "-list-item-actions")
      }, [previewIcon, removeIcon]) : removeIconCross;
      var message;

      if (file.response && typeof file.response === 'string') {
        message = file.response;
      } else {
        message = file.error && file.error.statusText || locale.uploadError;
      }

      var iconAndPreview = file.status === 'error' ? h(tooltip, {
        attrs: {
          title: message
        }
      }, [icon, preview]) : h("span", [icon, preview]);
      var transitionProps = Object(getTransitionProps["a" /* default */])('fade');
      return h("div", {
        "class": infoUploadingClass,
        key: file.uid
      }, [h("div", {
        "class": "".concat(prefixCls, "-list-item-info")
      }, [iconAndPreview]), actions, h("transition", transitionProps, [progress])]);
    });
    var listClassNames = classnames_default()((_classNames2 = {}, UploadList_defineProperty(_classNames2, "".concat(prefixCls, "-list"), true), UploadList_defineProperty(_classNames2, "".concat(prefixCls, "-list-").concat(listType), true), _classNames2));
    var animationDirection = listType === 'picture-card' ? 'animate-inline' : 'animate';
    var transitionGroupProps = Object(getTransitionProps["a" /* default */])("".concat(prefixCls, "-").concat(animationDirection));
    return h("transition-group", babel_helper_vue_jsx_merge_props_default()([transitionGroupProps, {
      attrs: {
        tag: 'div'
      },
      "class": listClassNames
    }]), [list]);
  }
});
// CONCATENATED MODULE: ./src/components/upload/utils.jsx
function upload_utils_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { upload_utils_defineProperty(target, key, source[key]); }); } return target; }

function upload_utils_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function T() {
  return true;
} // Fix IE file.status problem
// via coping a new Object

function fileToObject(file) {
  return upload_utils_objectSpread({}, file, {
    lastModified: file.lastModified,
    lastModifiedDate: file.lastModifiedDate,
    name: file.name,
    size: file.size,
    type: file.type,
    uid: file.uid,
    percent: 0,
    originFileObj: file
  });
}
/**
 * 生成Progress percent: 0.1 -> 0.98
 *   - for ie
 */

function genPercentAdd() {
  var k = 0.1;
  var i = 0.01;
  var end = 0.98;
  return function (s) {
    var start = s;

    if (start >= end) {
      return start;
    }

    start += k;
    k = k - i;

    if (k < 0.001) {
      k = 0.001;
    }

    return start;
  };
}
function getFileItem(file, fileList) {
  var matchKey = file.uid !== undefined ? 'uid' : 'name';
  return fileList.filter(function (item) {
    return item[matchKey] === file[matchKey];
  })[0];
}
function removeFileItem(file, fileList) {
  var matchKey = file.uid !== undefined ? 'uid' : 'name';
  var removed = fileList.filter(function (item) {
    return item[matchKey] !== file[matchKey];
  });

  if (removed.length === fileList.length) {
    return null;
  }

  return removed;
}
// CONCATENATED MODULE: ./src/components/upload/Upload.jsx
function upload_Upload_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { upload_Upload_defineProperty(target, key, source[key]); }); } return target; }

function upload_Upload_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













/* harmony default export */ var upload_Upload = ({
  name: 'TaUpload',
  Dragger: Dragger,
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(UploadProps, {
    prefixCls: 'ant-upload',
    type: 'select',
    multiple: false,
    action: '',
    data: {},
    accept: '',
    beforeUpload: T,
    showUploadList: true,
    listType: 'text',
    // or pictrue
    disabled: false,
    supportServerRender: true
  }),
  // recentUploadStatus: boolean | PromiseLike<any>;
  data: function data() {
    this.progressTimer = null;
    return {
      sFileList: this.fileList || this.defaultFileList || [],
      dragState: 'drop'
    };
  },
  beforeDestroy: function beforeDestroy() {
    this.clearProgressTimer();
  },
  watch: {
    fileList: function fileList(val) {
      this.sFileList = val;
    }
  },
  methods: {
    onStart: function onStart(file) {
      var nextFileList = this.sFileList.concat();
      var targetItem = fileToObject(file);
      targetItem.status = 'uploading';
      nextFileList.push(targetItem);
      this.onChange({
        file: targetItem,
        fileList: nextFileList
      }); // fix ie progress

      if (!window.FormData) {
        this.autoUpdateProgress(0, targetItem);
      }
    },
    autoUpdateProgress: function autoUpdateProgress(_, file) {
      var _this = this;

      var getPercent = genPercentAdd();
      var curPercent = 0;
      this.clearProgressTimer();
      this.progressTimer = setInterval(function () {
        curPercent = getPercent(curPercent);

        _this.onProgress({
          percent: curPercent * 100
        }, file);
      }, 200);
    },
    onSuccess: function onSuccess(response, file) {
      this.clearProgressTimer();

      try {
        if (typeof response === 'string') {
          response = JSON.parse(response);
        }
      } catch (e) {
        /* do nothing */
      }

      var fileList = this.sFileList;
      var targetItem = getFileItem(file, fileList); // removed

      if (!targetItem) {
        return;
      }

      targetItem.status = 'done';
      targetItem.response = response;
      this.onChange({
        file: upload_Upload_objectSpread({}, targetItem),
        fileList: fileList
      });
    },
    onProgress: function onProgress(e, file) {
      var fileList = this.sFileList;
      var targetItem = getFileItem(file, fileList); // removed

      if (!targetItem) {
        return;
      }

      targetItem.percent = e.percent;
      this.onChange({
        event: e,
        file: upload_Upload_objectSpread({}, targetItem),
        fileList: this.sFileList
      });
    },
    onError: function onError(error, response, file) {
      this.clearProgressTimer();
      var fileList = this.sFileList;
      var targetItem = getFileItem(file, fileList); // removed

      if (!targetItem) {
        return;
      }

      targetItem.error = error;
      targetItem.response = response;
      targetItem.status = 'error';
      this.onChange({
        file: upload_Upload_objectSpread({}, targetItem),
        fileList: fileList
      });
    },
    handleRemove: function handleRemove(file) {
      var _this2 = this;

      Promise.resolve(this.$emit('remove', file)).then(function (ret) {
        // Prevent removing file
        if (ret === false) {
          return;
        }

        var removedFileList = removeFileItem(file, _this2.sFileList);

        if (removedFileList) {
          _this2.onChange({
            file: file,
            fileList: removedFileList
          });
        }
      });
    },
    handleManualRemove: function handleManualRemove(file) {
      this.$refs.uploadRef.abort(file);
      file.status = 'removed'; // eslint-disable-line

      this.handleRemove(file);
    },
    onChange: function onChange(info) {
      if (!Object(props_util["p" /* hasProp */])(this, 'fileList')) {
        this.setState({
          sFileList: info.fileList
        });
      }

      this.$emit('change', info);
    },
    onFileDrop: function onFileDrop(e) {
      this.setState({
        dragState: e.type
      });
    },
    reBeforeUpload: function reBeforeUpload(file, fileList) {
      if (!this.beforeUpload) {
        return true;
      }

      var result = this.beforeUpload(file, fileList);

      if (result === false) {
        this.onChange({
          file: file,
          fileList: uniqBy_default()(this.sFileList.concat(fileList.map(fileToObject)), function (item) {
            return item.uid;
          })
        });
        return false;
      } else if (result && result.then) {
        return result;
      }

      return true;
    },
    clearProgressTimer: function clearProgressTimer() {
      clearInterval(this.progressTimer);
    },
    renderUploadList: function renderUploadList(locale) {
      var h = this.$createElement;

      var _getOptionProps = Object(props_util["j" /* getOptionProps */])(this),
          _getOptionProps$showU = _getOptionProps.showUploadList,
          showUploadList = _getOptionProps$showU === void 0 ? {} : _getOptionProps$showU,
          listType = _getOptionProps.listType;

      var showRemoveIcon = showUploadList.showRemoveIcon,
          showPreviewIcon = showUploadList.showPreviewIcon;
      var uploadListProps = {
        props: {
          listType: listType,
          items: this.sFileList,
          showRemoveIcon: showRemoveIcon,
          showPreviewIcon: showPreviewIcon,
          locale: upload_Upload_objectSpread({}, locale, this.$props.locale)
        },
        on: {
          remove: this.handleManualRemove
        }
      };

      if (this.$listeners.preview) {
        uploadListProps.on.preview = this.$listeners.preview;
      }

      return h(UploadList, uploadListProps);
    }
  },
  render: function render() {
    var _classNames2;

    var h = arguments[0];

    var _getOptionProps2 = Object(props_util["j" /* getOptionProps */])(this),
        _getOptionProps2$pref = _getOptionProps2.prefixCls,
        prefixCls = _getOptionProps2$pref === void 0 ? '' : _getOptionProps2$pref,
        showUploadList = _getOptionProps2.showUploadList,
        listType = _getOptionProps2.listType,
        type = _getOptionProps2.type,
        disabled = _getOptionProps2.disabled;

    var vcUploadProps = {
      props: upload_Upload_objectSpread({}, this.$props, {
        beforeUpload: this.reBeforeUpload
      }),
      on: {
        // ...this.$listeners,
        start: this.onStart,
        error: this.onError,
        progress: this.onProgress,
        success: this.onSuccess
      },
      ref: 'uploadRef',
      "class": "".concat(prefixCls, "-btn")
    };
    var uploadList = showUploadList ? h(LocaleReceiver, {
      attrs: {
        componentName: 'Upload',
        defaultLocale: locale_provider_default.Upload
      },
      scopedSlots: {
        "default": this.renderUploadList
      }
    }) : null;
    var children = this.$slots["default"];

    if (type === 'drag') {
      var _classNames;

      var dragCls = classnames_default()(prefixCls, (_classNames = {}, upload_Upload_defineProperty(_classNames, "".concat(prefixCls, "-drag"), true), upload_Upload_defineProperty(_classNames, "".concat(prefixCls, "-drag-uploading"), this.sFileList.some(function (file) {
        return file.status === 'uploading';
      })), upload_Upload_defineProperty(_classNames, "".concat(prefixCls, "-drag-hover"), this.dragState === 'dragover'), upload_Upload_defineProperty(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
      return h("span", [h("div", {
        "class": dragCls,
        on: {
          "drop": this.onFileDrop,
          "dragover": this.onFileDrop,
          "dragleave": this.onFileDrop
        }
      }, [h(vc_upload, vcUploadProps, [h("div", {
        "class": "".concat(prefixCls, "-drag-container")
      }, [children])])]), uploadList]);
    }

    var uploadButtonCls = classnames_default()(prefixCls, (_classNames2 = {}, upload_Upload_defineProperty(_classNames2, "".concat(prefixCls, "-select"), true), upload_Upload_defineProperty(_classNames2, "".concat(prefixCls, "-select-").concat(listType), true), upload_Upload_defineProperty(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _classNames2));
    var uploadButton = h("div", {
      "class": uploadButtonCls,
      style: {
        display: children ? '' : 'none'
      }
    }, [h(vc_upload, vcUploadProps, [children])]);

    if (listType === 'picture-card') {
      return h("span", [uploadList, uploadButton]);
    }

    return h("span", [uploadButton, uploadList]);
  }
});
// CONCATENATED MODULE: ./src/components/upload/index.jsx



upload_Upload.Dragger = Dragger;
/* istanbul ignore next */

upload_Upload.install = function (Vue) {
  Vue.component(upload_Upload.name, upload_Upload);
  Vue.component(Dragger.name, Dragger);
};

/* harmony default export */ var components_upload = (upload_Upload);
// EXTERNAL MODULE: ./package.json
var package_0 = __webpack_require__(418);

// CONCATENATED MODULE: ./src/components/version/index.js

/* harmony default export */ var version = (package_0["a" /* version */]);
// CONCATENATED MODULE: ./src/components/vc-drawer/src/drawerProps.js

/* harmony default export */ var drawerProps = ({
  wrapClassName: vue_types["a" /* default */].string,
  width: vue_types["a" /* default */].any,
  height: vue_types["a" /* default */].any,
  defaultOpen: vue_types["a" /* default */].bool,
  firstEnter: vue_types["a" /* default */].bool,
  open: vue_types["a" /* default */].bool,
  prefixCls: vue_types["a" /* default */].string,
  placement: vue_types["a" /* default */].string,
  level: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].array]),
  levelMove: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].number, vue_types["a" /* default */].func, vue_types["a" /* default */].array]),
  ease: vue_types["a" /* default */].string,
  duration: vue_types["a" /* default */].string,
  getContainer: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].func, vue_types["a" /* default */].object, vue_types["a" /* default */].bool]),
  handler: vue_types["a" /* default */].any,
  showMask: vue_types["a" /* default */].bool,
  maskStyle: vue_types["a" /* default */].object
});
// CONCATENATED MODULE: ./src/components/vc-drawer/src/utils.js
function dataToArray(vars) {
  if (Array.isArray(vars)) {
    return vars;
  }

  return [vars];
}
var trnasitionEndObject = {
  transition: 'transitionend',
  WebkitTransition: 'webkitTransitionEnd',
  MozTransition: 'transitionend',
  OTransition: 'oTransitionEnd otransitionend'
};
var trnasitionStr = Object.keys(trnasitionEndObject).filter(function (key) {
  if (typeof document === 'undefined') {
    return false;
  }

  var html = document.getElementsByTagName('html')[0];
  return key in (html ? html.style : {});
})[0];
var transitionEnd = trnasitionEndObject[trnasitionStr];
function addEventListener(target, eventType, callback, options) {
  if (target.addEventListener) {
    target.addEventListener(eventType, callback, options);
  } else if (target.attachEvent) {
    target.attachEvent("on".concat(eventType), callback);
  }
}
function removeEventListener(target, eventType, callback, options) {
  if (target.removeEventListener) {
    target.removeEventListener(eventType, callback, options);
  } else if (target.attachEvent) {
    target.detachEvent("on".concat(eventType), callback);
  }
}
function transformArguments(arg, cb) {
  var result;

  if (typeof arg === 'function') {
    result = arg(cb);
  } else {
    result = arg;
  }

  if (Array.isArray(result)) {
    if (result.length === 2) {
      return result;
    }

    return [result[0], result[1]];
  }

  return [result];
}
var utils_isNumeric = function isNumeric(value) {
  return !isNaN(parseFloat(value)) && isFinite(value); // eslint-disable-line
};
// CONCATENATED MODULE: ./src/components/vc-drawer/src/Drawer.js
function Drawer_typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Drawer_typeof2 = function _typeof2(obj) { return typeof obj; }; } else { Drawer_typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Drawer_typeof2(obj); }






function Drawer_typeof(obj) {
  if (typeof Symbol === "function" && Drawer_typeof2(Symbol.iterator) === "symbol") {
    Drawer_typeof = function _typeof(obj) {
      return Drawer_typeof2(obj);
    };
  } else {
    Drawer_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : Drawer_typeof2(obj);
    };
  }

  return Drawer_typeof(obj);
}

function Drawer_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      Drawer_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function Drawer_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}












function Drawer_noop() {}

var currentDrawer = {};
var windowIsUndefined = !(typeof window !== 'undefined' && window.document && window.document.createElement);
external_Vue_default.a.use(antRefDirective["a" /* default */]);
var Drawer = {
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])(drawerProps, {
    prefixCls: 'drawer',
    placement: 'left',
    getContainer: 'body',
    level: 'all',
    duration: '.3s',
    ease: 'cubic-bezier(0.78, 0.14, 0.15, 0.86)',
    firstEnter: false,
    // 记录首次进入.
    showMask: true,
    handler: true,
    maskStyle: {},
    wrapClassName: ''
  }),
  data: function data() {
    this.levelDom = [];
    this.contentDom = null;
    this.maskDom = null;
    this.handlerdom = null;
    this.mousePos = null;
    this.sFirstEnter = this.firstEnter;
    this.timeout = null;
    this.children = null;
    this.drawerId = Number((Date.now() + Math.random()).toString().replace('.', Math.round(Math.random() * 9))).toString(16);
    var open = this.open !== undefined ? this.open : !!this.defaultOpen;
    currentDrawer[this.drawerId] = open;
    this.orignalOpen = this.open;
    this.preProps = Drawer_objectSpread({}, this.$props);
    return {
      sOpen: open
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      if (!windowIsUndefined) {
        var passiveSupported = false;
        window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
          get: function get() {
            passiveSupported = true;
            return null;
          }
        }));
        _this.passive = passiveSupported ? {
          passive: false
        } : false;
      }

      var open = _this.getOpen();

      if (_this.handler || open || _this.sFirstEnter) {
        _this.getDefault(_this.$props);

        if (open) {
          _this.isOpenChange = true;
        }

        _this.$forceUpdate();
      }
    });
  },
  watch: {
    open: function (_open) {
      function open(_x) {
        return _open.apply(this, arguments);
      }

      open.toString = function () {
        return _open.toString();
      };

      return open;
    }(function (val) {
      if (val !== undefined && val !== this.preProps.open) {
        this.isOpenChange = true; // 没渲染 dom 时，获取默认数据;

        if (!this.container) {
          this.getDefault(this.$props);
        }

        this.setState({
          sOpen: open
        });
      }

      this.preProps.open = val;
    }),
    placement: function placement(val) {
      if (val !== this.preProps.placement) {
        // test 的 bug, 有动画过场，删除 dom
        this.contentDom = null;
      }

      this.preProps.placement = val;
    },
    level: function level(val) {
      if (this.preProps.level !== val) {
        this.getParentAndLevelDom(this.$props);
      }

      this.preProps.level = val;
    }
  },
  updated: function updated() {
    var _this2 = this;

    this.$nextTick(function () {
      // dom 没渲染时，重走一遍。
      if (!_this2.sFirstEnter && _this2.container) {
        _this2.$forceUpdate();

        _this2.sFirstEnter = true;
      }
    });
  },
  beforeDestroy: function beforeDestroy() {
    delete currentDrawer[this.drawerId];
    delete this.isOpenChange;

    if (this.container) {
      if (this.sOpen) {
        this.setLevelDomTransform(false, true);
      }

      document.body.style.overflow = ''; // 拦不住。。直接删除；

      if (this.getSelfContainer) {
        this.container.parentNode.removeChild(this.container);
      }
    }

    this.sFirstEnter = false;
    clearTimeout(this.timeout); // 需要 didmount 后也会渲染，直接 unmount 将不会渲染，加上判断.

    if (this.renderComponent) {
      this.renderComponent({
        afterClose: this.removeContainer,
        onClose: function onClose() {},
        visible: false
      });
    }
  },
  methods: {
    onMaskTouchEnd: function onMaskTouchEnd(e) {
      this.$emit('maskClick', e);
      this.onTouchEnd(e, true);
    },
    onIconTouchEnd: function onIconTouchEnd(e) {
      this.$emit('handleClick', e);
      this.onTouchEnd(e);
    },
    onTouchEnd: function onTouchEnd(e, close) {
      if (this.open !== undefined) {
        return;
      }

      var open = close || this.sOpen;
      this.isOpenChange = true;
      this.setState({
        sOpen: !open
      });
    },
    onWrapperTransitionEnd: function onWrapperTransitionEnd(e) {
      if (e.target === this.contentWrapper) {
        this.dom.style.transition = '';

        if (!this.sOpen && this.getCrrentDrawerSome()) {
          document.body.style.overflowX = '';

          if (this.maskDom) {
            this.maskDom.style.left = '';
            this.maskDom.style.width = '';
          }
        }
      }
    },
    getDefault: function getDefault(props) {
      this.getParentAndLevelDom(props);

      if (props.getContainer || props.parent) {
        this.container = this.defaultGetContainer();
      }
    },
    getCrrentDrawerSome: function getCrrentDrawerSome() {
      return !Object.keys(currentDrawer).some(function (key) {
        return currentDrawer[key];
      });
    },
    getSelfContainer: function getSelfContainer() {
      return this.container;
    },
    getParentAndLevelDom: function getParentAndLevelDom(props) {
      var _this3 = this;

      if (windowIsUndefined) {
        return;
      }

      var level = props.level,
          getContainer = props.getContainer;
      this.levelDom = [];

      if (getContainer) {
        if (typeof getContainer === 'string') {
          var dom = document.querySelectorAll(getContainer)[0];
          this.parent = dom;
        }

        if (typeof getContainer === 'function') {
          this.parent = getContainer();
        }

        if (Drawer_typeof(getContainer) === 'object' && getContainer instanceof window.HTMLElement) {
          this.parent = getContainer;
        }
      }

      if (!getContainer && this.container) {
        this.parent = this.container.parentNode;
      }

      if (level === 'all') {
        var children = Array.prototype.slice.call(this.parent.children);
        children.forEach(function (child) {
          if (child.nodeName !== 'SCRIPT' && child.nodeName !== 'STYLE' && child.nodeName !== 'LINK' && child !== _this3.container) {
            _this3.levelDom.push(child);
          }
        });
      } else if (level) {
        dataToArray(level).forEach(function (key) {
          document.querySelectorAll(key).forEach(function (item) {
            _this3.levelDom.push(item);
          });
        });
      }
    },
    setLevelDomTransform: function setLevelDomTransform(open, openTransition, placementName, value) {
      var _this4 = this;

      var _this$$props = this.$props,
          placement = _this$$props.placement,
          levelMove = _this$$props.levelMove,
          duration = _this$$props.duration,
          ease = _this$$props.ease,
          getContainer = _this$$props.getContainer;

      if (!windowIsUndefined) {
        this.levelDom.forEach(function (dom) {
          if (_this4.isOpenChange || openTransition) {
            /* eslint no-param-reassign: "error" */
            dom.style.transition = "transform ".concat(duration, " ").concat(ease);
            addEventListener(dom, transitionEnd, _this4.trnasitionEnd);
            var levelValue = open ? value : 0;

            if (levelMove) {
              var $levelMove = transformArguments(levelMove, {
                target: dom,
                open: open
              });
              levelValue = open ? $levelMove[0] : $levelMove[1] || 0;
            }

            var $value = typeof levelValue === 'number' ? "".concat(levelValue, "px") : levelValue;
            var placementPos = placement === 'left' || placement === 'top' ? $value : "-".concat($value);
            dom.style.transform = levelValue ? "".concat(placementName, "(").concat(placementPos, ")") : '';
            dom.style.msTransform = levelValue ? "".concat(placementName, "(").concat(placementPos, ")") : '';
          }
        }); // 处理 body 滚动

        if (getContainer === 'body') {
          var eventArray = ['touchstart'];
          var domArray = [document.body, this.maskDom, this.handlerdom, this.contentDom];
          var right = document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth ? getScrollBarSize(1) : 0;
          var widthTransition = "width ".concat(duration, " ").concat(ease);
          var trannsformTransition = "transform ".concat(duration, " ").concat(ease);

          if (open && document.body.style.overflow !== 'hidden') {
            document.body.style.overflow = 'hidden';

            if (right) {
              document.body.style.position = 'relative';
              document.body.style.width = "calc(100% - ".concat(right, "px)");
              this.dom.style.transition = 'none';

              switch (placement) {
                case 'right':
                  this.dom.style.transform = "translateX(-".concat(right, "px)");
                  this.dom.style.msTransform = "translateX(-".concat(right, "px)");
                  break;

                case 'top':
                case 'bottom':
                  this.dom.style.width = "calc(100% - ".concat(right, "px)");
                  this.dom.style.transform = 'translateZ(0)';
                  break;

                default:
                  break;
              }

              clearTimeout(this.timeout);
              this.timeout = setTimeout(function () {
                _this4.dom.style.transition = "".concat(trannsformTransition, ",").concat(widthTransition);
                _this4.dom.style.width = '';
                _this4.dom.style.transform = '';
                _this4.dom.style.msTransform = '';
              });
            } // 手机禁滚


            domArray.forEach(function (item, i) {
              if (!item) {
                return;
              }

              addEventListener(item, eventArray[i] || 'touchmove', i ? _this4.removeMoveHandler : _this4.removeStartHandler, _this4.passive);
            });
          } else if (this.getCrrentDrawerSome()) {
            document.body.style.overflow = '';

            if ((this.isOpenChange || openTransition) && right) {
              document.body.style.position = '';
              document.body.style.width = '';

              if (trnasitionStr) {
                document.body.style.overflowX = 'hidden';
              }

              this.dom.style.transition = 'none';
              var heightTransition;

              switch (placement) {
                case 'right':
                  {
                    this.dom.style.transform = "translateX(".concat(right, "px)");
                    this.dom.style.msTransform = "translateX(".concat(right, "px)");
                    this.dom.style.width = '100%';
                    widthTransition = "width 0s ".concat(ease, " ").concat(duration);

                    if (this.maskDom) {
                      this.maskDom.style.left = "-".concat(right, "px");
                      this.maskDom.style.width = "calc(100% + ".concat(right, "px)");
                    }

                    break;
                  }

                case 'top':
                case 'bottom':
                  {
                    this.dom.style.width = "calc(100% + ".concat(right, "px)");
                    this.dom.style.height = '100%';
                    this.dom.style.transform = 'translateZ(0)';
                    heightTransition = "height 0s ".concat(ease, " ").concat(duration);
                    break;
                  }

                default:
                  break;
              }

              clearTimeout(this.timeout);
              this.timeout = setTimeout(function () {
                _this4.dom.style.transition = "".concat(trannsformTransition, ",").concat(heightTransition ? "".concat(heightTransition, ",") : '').concat(widthTransition);
                _this4.dom.style.transform = '';
                _this4.dom.style.msTransform = '';
                _this4.dom.style.width = '';
                _this4.dom.style.height = '';
              });
            }

            domArray.forEach(function (item, i) {
              if (!item) {
                return;
              }

              removeEventListener(item, eventArray[i] || 'touchmove', i ? _this4.removeMoveHandler : _this4.removeStartHandler, _this4.passive);
            });
          }
        }
      }

      var change = this.$listeners.change;

      if (change && this.isOpenChange && this.sFirstEnter) {
        change(open);
        this.isOpenChange = false;
      }
    },
    getChildToRender: function getChildToRender(open) {
      var _classnames,
          _this5 = this;

      var h = this.$createElement;
      var _this$$props2 = this.$props,
          prefixCls = _this$$props2.prefixCls,
          placement = _this$$props2.placement,
          handler = _this$$props2.handler,
          showMask = _this$$props2.showMask,
          maskStyle = _this$$props2.maskStyle,
          width = _this$$props2.width,
          height = _this$$props2.height,
          wrapClassName = _this$$props2.wrapClassName;
      var children = this.$slots["default"];
      var wrapperClassname = classnames_default()(prefixCls, (_classnames = {}, Drawer_defineProperty(_classnames, "".concat(prefixCls, "-").concat(placement), true), Drawer_defineProperty(_classnames, "".concat(prefixCls, "-open"), open), Drawer_defineProperty(_classnames, wrapClassName, !!wrapClassName), _classnames));
      var isOpenChange = this.isOpenChange;
      var isHorizontal = placement === 'left' || placement === 'right';
      var placementName = "translate".concat(isHorizontal ? 'X' : 'Y'); // 百分比与像素动画不同步，第一次打用后全用像素动画。
      // const defaultValue = !this.contentDom || !level ? '100%' : `${value}px`;

      var placementPos = placement === 'left' || placement === 'top' ? '-100%' : '100%';
      var transform = open ? '' : "".concat(placementName, "(").concat(placementPos, ")");

      if (isOpenChange === undefined || isOpenChange) {
        var contentValue = this.contentDom ? this.contentDom.getBoundingClientRect()[isHorizontal ? 'width' : 'height'] : 0;
        var value = (isHorizontal ? width : height) || contentValue;
        this.setLevelDomTransform(open, false, placementName, value);
      }

      var handlerCildren;

      if (handler !== false) {
        var handlerDefalut = h("div", {
          "class": 'drawer-handle'
        }, [h("i", {
          "class": 'drawer-handle-icon'
        })]);
        var handlerSlot = this.$slots.handler;
        var handlerSlotVnode = handlerSlot || handlerDefalut;

        var _getEvents = Object(props_util["h" /* getEvents */])(handlerSlotVnode),
            handleIconClick = _getEvents.click;

        handlerCildren = Object(vnode["a" /* cloneElement */])(handlerSlotVnode, {
          on: {
            click: function click(e) {
              handleIconClick && handleIconClick();

              _this5.onIconTouchEnd(e);
            }
          },
          directives: [{
            name: 'ant-ref',
            value: function value(c) {
              _this5.handlerdom = c;
            }
          }]
        });
      }

      var domContProps = {
        "class": wrapperClassname,
        directives: [{
          name: 'ant-ref',
          value: function value(c) {
            _this5.dom = c;
          }
        }],
        on: {
          transitionend: this.onWrapperTransitionEnd
        }
      };
      var directivesMaskDom = [{
        name: 'ant-ref',
        value: function value(c) {
          _this5.maskDom = c;
        }
      }];
      var directivesContentWrapper = [{
        name: 'ant-ref',
        value: function value(c) {
          _this5.contentWrapper = c;
        }
      }];
      var directivesContentDom = [{
        name: 'ant-ref',
        value: function value(c) {
          _this5.contentDom = c;
        }
      }];
      return h("div", domContProps, [showMask && h("div", babel_helper_vue_jsx_merge_props_default()([{
        "class": "".concat(prefixCls, "-mask"),
        on: {
          "click": this.onMaskTouchEnd
        },
        style: maskStyle
      }, {
        directives: directivesMaskDom
      }])), h("div", babel_helper_vue_jsx_merge_props_default()([{
        "class": "".concat(prefixCls, "-content-wrapper"),
        style: {
          transform: transform,
          msTransform: transform,
          width: utils_isNumeric(width) ? "".concat(width, "px") : width,
          height: utils_isNumeric(height) ? "".concat(height, "px") : height
        }
      }, {
        directives: directivesContentWrapper
      }]), [h("div", babel_helper_vue_jsx_merge_props_default()([{
        "class": "".concat(prefixCls, "-content")
      }, {
        directives: directivesContentDom
      }, {
        on: {
          "touchstart": open ? this.removeStartHandler : Drawer_noop,
          "touchmove": open ? this.removeMoveHandler : Drawer_noop
        }
      }]), [children]), handlerCildren])]);
    },
    getOpen: function getOpen() {
      return this.open !== undefined ? this.open : this.sOpen;
    },
    getTouchParentScroll: function getTouchParentScroll(root, currentTarget, differX, differY) {
      if (!currentTarget) {
        return false;
      } // root 为 drawer-content 设定了 overflow, 判断为 root 的 parent 时结束滚动；


      if (currentTarget === root.parentNode) {
        return true;
      }

      var isY = Math.max(Math.abs(differX), Math.abs(differY)) === Math.abs(differY);
      var isX = Math.max(Math.abs(differX), Math.abs(differY)) === Math.abs(differX);
      var scrollY = currentTarget.scrollHeight - currentTarget.clientHeight;
      var scrollX = currentTarget.scrollWidth - currentTarget.clientWidth;
      /**
       * <div style="height: 300px">
       *   <div style="height: 900px"></div>
       * </div>
       * 在没设定 overflow: auto 或 scroll 时，currentTarget 里获取不到 scrollTop 或 scrollLeft,
       * 预先用 scrollTo 来滚动，如果取出的值跟滚动前取出不同，则 currnetTarget 被设定了 overflow; 否则就是上面这种。
       */

      var t = currentTarget.scrollTop;
      var l = currentTarget.scrollLeft;
      currentTarget.scrollTo(currentTarget.scrollLeft + 1, currentTarget.scrollTop + 1);
      var currentT = currentTarget.scrollTop;
      var currentL = currentTarget.scrollLeft;
      currentTarget.scrollTo(currentTarget.scrollLeft - 1, currentTarget.scrollTop - 1);

      if (isY && (!scrollY || !(currentT - t) || scrollY && (currentTarget.scrollTop >= scrollY && differY < 0 || currentTarget.scrollTop <= 0 && differY > 0)) || isX && (!scrollX || !(currentL - l) || scrollX && (currentTarget.scrollLeft >= scrollX && differX < 0 || currentTarget.scrollLeft <= 0 && differX > 0))) {
        return this.getTouchParentScroll(root, currentTarget.parentNode, differX, differY);
      }

      return false;
    },
    removeStartHandler: function removeStartHandler(e) {
      if (e.touches.length > 1) {
        return;
      }

      this.startPos = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY
      };
    },
    removeMoveHandler: function removeMoveHandler(e) {
      if (e.changedTouches.length > 1) {
        return;
      }

      var currentTarget = e.currentTarget;
      var differX = e.changedTouches[0].clientX - this.startPos.x;
      var differY = e.changedTouches[0].clientY - this.startPos.y;

      if (currentTarget === this.maskDom || currentTarget === this.handlerdom || currentTarget === this.contentDom && this.getTouchParentScroll(currentTarget, e.target, differX, differY)) {
        e.preventDefault();
      }
    },
    trnasitionEnd: function trnasitionEnd(e) {
      removeEventListener(e.target, transitionEnd, this.trnasitionEnd);
      e.target.style.transition = '';
    },
    defaultGetContainer: function defaultGetContainer() {
      if (windowIsUndefined) {
        return null;
      }

      var container = document.createElement('div');
      this.parent.appendChild(container);

      if (this.wrapperClassName) {
        container.className = this.wrapperClassName;
      }

      return container;
    }
  },
  render: function render() {
    var _this6 = this;

    var h = arguments[0];
    var _this$$props3 = this.$props,
        getContainer = _this$$props3.getContainer,
        wrapperClassName = _this$$props3.wrapperClassName;
    var open = this.getOpen();
    currentDrawer[this.drawerId] = open ? this.container : open;
    var children = this.getChildToRender(this.sFirstEnter ? open : false);

    if (!getContainer) {
      var directives = [{
        name: 'ant-ref',
        value: function value(c) {
          _this6.container = c;
        }
      }];
      return h("div", babel_helper_vue_jsx_merge_props_default()([{
        "class": wrapperClassName
      }, {
        directives: directives
      }]), [children]);
    }

    if (!this.container || !open && !this.sFirstEnter) {
      return null;
    }

    return h(ContainerRender, {
      attrs: {
        parent: this,
        visible: true,
        autoMount: true,
        autoDestroy: false,
        getComponent: function getComponent() {
          return children;
        },
        getContainer: this.getSelfContainer,
        children: function children(_ref) {
          var renderComponent = _ref.renderComponent,
              removeContainer = _ref.removeContainer;
          _this6.renderComponent = renderComponent;
          _this6.removeContainer = removeContainer;
          return null;
        }
      }
    });
  }
};
/* harmony default export */ var src_Drawer = (Drawer);
// CONCATENATED MODULE: ./src/components/vc-drawer/src/index.js
// base in 1.7.6
// export this package's api

/* harmony default export */ var vc_drawer_src = (src_Drawer);
// CONCATENATED MODULE: ./src/components/drawer/index.jsx
function drawer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { drawer_defineProperty(target, key, source[key]); }); } return target; }

function drawer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function drawer_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = drawer_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function drawer_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





var drawer_Drawer = {
  name: 'TaDrawer',
  props: {
    closable: vue_types["a" /* default */].bool.def(true),
    destroyOnClose: vue_types["a" /* default */].bool,
    getContainer: vue_types["a" /* default */].any,
    maskClosable: vue_types["a" /* default */].bool.def(true),
    mask: vue_types["a" /* default */].bool,
    maskStyle: vue_types["a" /* default */].object,
    title: vue_types["a" /* default */].any,
    visible: vue_types["a" /* default */].bool,
    width: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]).def(256),
    zIndex: vue_types["a" /* default */].number,
    prefixCls: vue_types["a" /* default */].string.def('ant-drawer'),
    placement: vue_types["a" /* default */].string.def('right'),
    level: vue_types["a" /* default */].any.def(null),
    wrapClassName: vue_types["a" /* default */].string,
    // add by cy 添加抽屉头部高度参数 ,如果fixedHeader是true那么默认是px,否则那么默认是auto
    headerHeight: vue_types["a" /* default */].string.def('auto'),
    // add by cy 添加抽屉头部是否固定 默认固定
    fixedHeader: vue_types["a" /* default */].bool.def(true),
    // add by cy 添加抽屉底部footer 高度40px
    footer: vue_types["a" /* default */].any,
    //add by cy footer的高度 px 默认55px
    footerHeight: vue_types["a" /* default */].string.def('55px')
  },
  mixins: [BaseMixin["a" /* default */]],
  data: function data() {
    this.destoryClose = false;
    this.preVisible = this.$props.visible;
    return {
      _push: false
    };
  },
  inject: {
    parentDrawer: {
      "default": null
    }
  },
  provide: function provide() {
    return {
      parentDrawer: this
    };
  },
  updated: function updated() {
    var _this = this;

    this.$nextTick(function () {
      if (_this.preVisible !== _this.visible && _this.parentDrawer) {
        if (_this.visible) {
          _this.parentDrawer.push();
        } else {
          _this.parentDrawer.pull();
        }
      }

      _this.preVisible = _this.visible;
    });
  },
  methods: {
    close: function close(e) {
      if (this.visible !== undefined) {
        this.$emit('close', e);
      }
    },
    onMaskClick: function onMaskClick(e) {
      if (!this.maskClosable) {
        return;
      }

      this.close(e);
    },
    push: function push() {
      this.setState({
        _push: true
      });
    },
    pull: function pull() {
      this.setState({
        _push: false
      });
    },
    onDestoryTransitionEnd: function onDestoryTransitionEnd() {
      var isDestroyOnClose = this.getDestoryOnClose();

      if (!isDestroyOnClose) {
        return;
      }

      if (!this.visible) {
        this.destoryClose = true;
        this.$forceUpdate();
      }
    },
    getDestoryOnClose: function getDestoryOnClose() {
      return this.destroyOnClose && !this.visible;
    },
    renderBody: function renderBody() {
      var h = this.$createElement;

      if (this.destoryClose && !this.visible) {
        return null;
      }

      this.destoryClose = false;

      var _Object$assign = Object.assign({
        placement: {},
        bodyStyle: {}
      }, this.$props),
          placement = _Object$assign.placement,
          bodyStyle = _Object$assign.bodyStyle;

      var containerStyle = placement === 'left' || placement === 'right' ? {
        overflow: 'auto',
        height: '100%'
      } : {};
      var isDestroyOnClose = this.getDestoryOnClose();

      if (isDestroyOnClose) {
        // Increase the opacity transition, delete children after closing.
        containerStyle.opacity = 0;
        containerStyle.transition = 'opacity .3s';
      }

      var _this$$props = this.$props,
          prefixCls = _this$$props.prefixCls,
          closable = _this$$props.closable;
      var title = Object(props_util["g" /* getComponentFromProp */])(this, 'title');
      var foot = Object(props_util["g" /* getComponentFromProp */])(this, 'footer');
      var header;

      if (title) {
        // 如果有头
        var headerStyle = {};

        if (this.fixedHeader) {
          // 如果是固定头部,那么头部一定要有高度,不能是auto
          var ht = this.headerHeight == 'auto' ? '55px' : this.headerHeight;
          headerStyle = {
            height: ht,
            overflow: 'hidden' // 如果固定头部,那么body部分添加一个头部高度的padding

          };
          bodyStyle = Object.assign(bodyStyle, {
            width: '100%',
            position: 'absolute',
            overflow: 'auto',
            top: ht,
            bottom: '0px'
          });
        } else {
          // 如果不是固定头部那么headerHeight可以为px,%,auto
          headerStyle = {
            height: this.headerHeight,
            overflow: 'hidden'
          };
        }

        header = h("div", {
          key: 'header',
          "class": "".concat(prefixCls, "-header"),
          style: headerStyle
        }, [h("div", {
          "class": "".concat(prefixCls, "-title")
        }, [title])]);
      }

      var closer;

      if (closable) {
        closer = h("button", {
          key: 'closer',
          on: {
            "click": this.close
          },
          attrs: {
            "aria-label": 'Close'
          },
          "class": "".concat(prefixCls, "-close")
        }, [h("span", {
          "class": "".concat(prefixCls, "-close-x")
        })]);
      }

      var footer;

      if (foot) {
        var footerStyle = {
          'position': 'absolute',
          'bottom': '0px',
          'width': '100%',
          'borderTop': '1px solid #e8e8e8',
          'height': this.footerHeight,
          'background': '#fff',
          'padding': '10px 15px',
          'boxSizing': 'border-box',
          'textAlign': 'right'
        };
        bodyStyle = Object.assign(bodyStyle || {}, {
          'paddingBottom': this.footerHeight
        });
        footer = h("div", {
          "class": "footer",
          style: footerStyle
        }, [foot]);
      }

      return h("div", {
        "class": "".concat(prefixCls, "-wrapper-body"),
        style: containerStyle,
        on: {
          "transitionend": this.onDestoryTransitionEnd
        }
      }, [header, closer, h("div", {
        key: 'body',
        "class": "".concat(prefixCls, "-body"),
        style: bodyStyle
      }, [this.$slots["default"]]), footer]);
    }
  },
  render: function render() {
    var h = arguments[0];
    var props = Object(props_util["j" /* getOptionProps */])(this);

    var zIndex = props.zIndex,
        visible = props.visible,
        placement = props.placement,
        mask = props.mask,
        wrapClassName = props.wrapClassName,
        rest = drawer_objectWithoutProperties(props, ["zIndex", "visible", "placement", "mask", "wrapClassName"]);

    var vcDrawerStyle = this.$data._push ? {
      zIndex: zIndex,
      transform: "translateX(".concat(placement === 'left' ? 180 : -180, "px)")
    } : {
      zIndex: zIndex
    };
    var vcDrawerProps = {
      props: drawer_objectSpread({
        handler: false,
        open: visible,
        showMask: mask,
        placement: placement,
        wrapClassName: wrapClassName
      }, rest),
      on: drawer_objectSpread({
        maskClick: this.onMaskClick
      }, this.$listeners),
      style: vcDrawerStyle
    };
    return h(vc_drawer_src, vcDrawerProps, [this.renderBody()]);
  }
};
/* istanbul ignore next */

drawer_Drawer.install = function (Vue) {
  Vue.component(drawer_Drawer.name, drawer_Drawer);
};

/* harmony default export */ var drawer = (drawer_Drawer);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/eTree/src/tree.vue?vue&type=template&id=8aaac264&
var treevue_type_template_id_8aaac264_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"el-tree",class:{
    'el-tree--highlight-current': _vm.highlightCurrent,
    'is-dragging': !!_vm.dragState.draggingNode,
    'is-drop-not-allow': !_vm.dragState.allowDrop,
    'is-drop-inner': _vm.dragState.dropType === 'inner'
  },attrs:{"role":"tree"}},[(_vm.showCheckAll&&_vm.nodeKey&&_vm.showCheckbox)?_c('ta-button',{attrs:{"type":"primary","size":"small"},on:{"click":_vm.fnCheckAll}},[_vm._v(_vm._s(_vm.isCheckedAll?'反选':'全选'))]):_vm._e(),_vm._v(" "),_vm._l((_vm.root.childNodes),function(child){return _c('el-tree-node',{key:_vm.getNodeKey(child),attrs:{"node":child,"props":_vm.props,"render-after-expand":_vm.renderAfterExpand,"render-content":_vm.renderContent},on:{"node-expand":_vm.handleNodeExpand}})}),_vm._v(" "),(_vm.isEmpty)?_c('div',{staticClass:"el-tree__empty-block"},[_c('span',{staticClass:"el-tree__empty-text"},[_vm._v(_vm._s(_vm.emptyText))])]):_vm._e(),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.dragState.showDropIndicator),expression:"dragState.showDropIndicator"}],ref:"dropIndicator",staticClass:"el-tree__drop-indicator"})],2)}
var treevue_type_template_id_8aaac264_staticRenderFns = []


// CONCATENATED MODULE: ./src/components/eTree/src/tree.vue?vue&type=template&id=8aaac264&

// EXTERNAL MODULE: ./node_modules/element-ui/src/utils/merge.js
var utils_merge = __webpack_require__(63);

// CONCATENATED MODULE: ./src/components/eTree/src/model/util.js
var NODE_KEY = '$treeNodeId';
var markNodeData = function markNodeData(node, data) {
  if (!data || data[NODE_KEY]) return;
  Object.defineProperty(data, NODE_KEY, {
    value: node.id,
    enumerable: false,
    configurable: false,
    writable: false
  });
};
var util_getNodeKey = function getNodeKey(key, data) {
  if (!key) return data[NODE_KEY];
  return data[key];
};
var findNearestComponent = function findNearestComponent(element, componentName) {
  var target = element;

  while (target && target.tagName !== 'BODY') {
    if (target.__vue__ && target.__vue__.$options.name === componentName) {
      return target.__vue__;
    }

    target = target.parentNode;
  }

  return null;
};
// CONCATENATED MODULE: ./src/components/eTree/src/model/node.js
function node_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function node_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function node_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) node_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) node_defineProperties(Constructor, staticProps);
  return Constructor;
}



var getChildState = function getChildState(node) {
  var all = true;
  var none = true;
  var allWithoutDisable = true;

  for (var i = 0, j = node.length; i < j; i++) {
    var n = node[i];

    if (n.checked !== true || n.indeterminate) {
      all = false;

      if (!n.disabled) {
        allWithoutDisable = false;
      }
    }

    if (n.checked !== false || n.indeterminate) {
      none = false;
    }
  }

  return {
    all: all,
    none: none,
    allWithoutDisable: allWithoutDisable,
    half: !all && !none
  };
};

var reInitChecked = function reInitChecked(node) {
  if (node.childNodes.length === 0) return;

  var _getChildState = getChildState(node.childNodes),
      all = _getChildState.all,
      none = _getChildState.none,
      half = _getChildState.half;

  if (all) {
    node.checked = true;
    node.indeterminate = false;
  } else if (half) {
    node.checked = false;
    node.indeterminate = true;
  } else if (none) {
    node.checked = false;
    node.indeterminate = false;
  }

  var parent = node.parent;
  if (!parent || parent.level === 0) return;

  if (!node.store.checkStrictly) {
    reInitChecked(parent);
  }
};

var getPropertyFromData = function getPropertyFromData(node, prop) {
  var props = node.store.props;
  var data = node.data || {};
  var config = props[prop];

  if (typeof config === 'function') {
    return config(data, node);
  } else if (typeof config === 'string') {
    return data[config];
  } else if (typeof config === 'undefined') {
    var dataProp = data[prop];
    return dataProp === undefined ? '' : dataProp;
  }
};

var nodeIdSeed = 0;

var node_Node =
/*#__PURE__*/
function () {
  function Node(options) {
    node_classCallCheck(this, Node);

    this.id = nodeIdSeed++;
    this.text = null;
    this.checked = false;
    this.indeterminate = false;
    this.data = null;
    this.expanded = false;
    this.parent = null;
    this.visible = true;

    for (var name in options) {
      if (options.hasOwnProperty(name)) {
        this[name] = options[name];
      }
    } // internal


    this.level = 0;
    this.loaded = false;
    this.childNodes = [];
    this.loading = false;

    if (this.parent) {
      this.level = this.parent.level + 1;
    }

    var store = this.store;

    if (!store) {
      throw new Error('[Node]store is required!');
    }

    store.registerNode(this);
    var props = store.props;

    if (props && typeof props.isLeaf !== 'undefined') {
      var isLeaf = getPropertyFromData(this, 'isLeaf');

      if (typeof isLeaf === 'boolean') {
        this.isLeafByUser = isLeaf;
      }
    }

    if (store.lazy !== true && this.data) {
      this.setData(this.data);

      if (store.defaultExpandAll) {
        this.expanded = true;
      }
    } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {
      this.expand();
    }

    if (!Array.isArray(this.data)) {
      markNodeData(this, this.data);
    }

    if (!this.data) return;
    var defaultExpandedKeys = store.defaultExpandedKeys;
    var key = store.key;

    if (key && defaultExpandedKeys && defaultExpandedKeys.indexOf(this.key) !== -1) {
      this.expand(null, store.autoExpandParent);
    }

    if (key && store.currentNodeKey !== undefined && this.key === store.currentNodeKey) {
      store.currentNode = this;
    }

    if (store.lazy) {
      store._initDefaultCheckedNode(this);
    }

    this.updateLeafState();
  }

  node_createClass(Node, [{
    key: "setData",
    value: function setData(data) {
      if (!Array.isArray(data)) {
        markNodeData(this, data);
      }

      this.data = data;
      this.childNodes = [];
      var children;

      if (this.level === 0 && this.data instanceof Array) {
        children = this.data;
      } else {
        children = getPropertyFromData(this, 'children') || [];
      }

      for (var i = 0, j = children.length; i < j; i++) {
        this.insertChild({
          data: children[i]
        });
      }
    }
  }, {
    key: "contains",
    value: function contains(target) {
      var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var walk = function walk(parent) {
        var children = parent.childNodes || [];
        var result = false;

        for (var i = 0, j = children.length; i < j; i++) {
          var child = children[i];

          if (child === target || deep && walk(child)) {
            result = true;
            break;
          }
        }

        return result;
      };

      return walk(this);
    }
  }, {
    key: "remove",
    value: function remove() {
      var parent = this.parent;

      if (parent) {
        parent.removeChild(this);
      }
    }
  }, {
    key: "insertChild",
    value: function insertChild(child, index, batch) {
      if (!child) throw new Error('insertChild error: child is required.');

      if (!(child instanceof Node)) {
        if (!batch) {
          var children = this.getChildren(true);

          if (children.indexOf(child.data) === -1) {
            if (typeof index === 'undefined' || index < 0) {
              children.push(child.data);
            } else {
              children.splice(index, 0, child.data);
            }
          }
        }

        Object(utils_merge["a" /* default */])(child, {
          parent: this,
          store: this.store
        });
        child = new Node(child);
      }

      child.level = this.level + 1;

      if (typeof index === 'undefined' || index < 0) {
        this.childNodes.push(child);
      } else {
        this.childNodes.splice(index, 0, child);
      }

      this.updateLeafState();
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(child, ref) {
      var index;

      if (ref) {
        index = this.childNodes.indexOf(ref);
      }

      this.insertChild(child, index);
    }
  }, {
    key: "insertAfter",
    value: function insertAfter(child, ref) {
      var index;

      if (ref) {
        index = this.childNodes.indexOf(ref);
        if (index !== -1) index += 1;
      }

      this.insertChild(child, index);
    }
  }, {
    key: "removeChild",
    value: function removeChild(child) {
      var children = this.getChildren() || [];
      var dataIndex = children.indexOf(child.data);

      if (dataIndex > -1) {
        children.splice(dataIndex, 1);
      }

      var index = this.childNodes.indexOf(child);

      if (index > -1) {
        this.store && this.store.deregisterNode(child);
        child.parent = null;
        this.childNodes.splice(index, 1);
      }

      this.updateLeafState();
    }
  }, {
    key: "removeChildByData",
    value: function removeChildByData(data) {
      var targetNode = null;

      for (var i = 0; i < this.childNodes.length; i++) {
        if (this.childNodes[i].data === data) {
          targetNode = this.childNodes[i];
          break;
        }
      }

      if (targetNode) {
        this.removeChild(targetNode);
      }
    }
  }, {
    key: "expand",
    value: function expand(callback, expandParent) {
      var _this = this;

      var done = function done() {
        if (expandParent) {
          var parent = _this.parent;

          while (parent.level > 0) {
            parent.expanded = true;
            parent = parent.parent;
          }
        }

        _this.expanded = true;
        if (callback) callback();
      };

      if (this.shouldLoadData()) {
        this.loadData(function (data) {
          if (data instanceof Array) {
            if (_this.checked) {
              _this.setChecked(true, true);
            } else if (!_this.store.checkStrictly) {
              reInitChecked(_this);
            }

            done();
          }
        });
      } else {
        done();
      }
    }
  }, {
    key: "doCreateChildren",
    value: function doCreateChildren(array) {
      var _this2 = this;

      var defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      array.forEach(function (item) {
        _this2.insertChild(Object(utils_merge["a" /* default */])({
          data: item
        }, defaultProps), undefined, true);
      });
    }
  }, {
    key: "collapse",
    value: function collapse() {
      this.expanded = false;
    }
  }, {
    key: "shouldLoadData",
    value: function shouldLoadData() {
      return this.store.lazy === true && this.store.load && !this.loaded;
    }
  }, {
    key: "updateLeafState",
    value: function updateLeafState() {
      if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== 'undefined') {
        this.isLeaf = this.isLeafByUser;
        return;
      }

      var childNodes = this.childNodes;

      if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {
        this.isLeaf = !childNodes || childNodes.length === 0;
        return;
      }

      this.isLeaf = false;
    }
  }, {
    key: "setChecked",
    value: function setChecked(value, deep, recursion, passValue) {
      var _this3 = this;

      this.indeterminate = value === 'half';
      this.checked = value === true;
      if (this.store.checkStrictly) return;

      if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
        var _getChildState2 = getChildState(this.childNodes),
            all = _getChildState2.all,
            allWithoutDisable = _getChildState2.allWithoutDisable;

        if (!this.isLeaf && !all && allWithoutDisable) {
          this.checked = false;
          value = false;
        }

        var handleDescendants = function handleDescendants() {
          if (deep) {
            var childNodes = _this3.childNodes;

            for (var i = 0, j = childNodes.length; i < j; i++) {
              var child = childNodes[i];
              passValue = passValue || value !== false;
              var isCheck = child.disabled ? child.checked : passValue;
              child.setChecked(isCheck, deep, true, passValue);
            }

            var _getChildState3 = getChildState(childNodes),
                half = _getChildState3.half,
                _all = _getChildState3.all;

            if (!_all) {
              _this3.checked = _all;
              _this3.indeterminate = half;
            }
          }
        };

        if (this.shouldLoadData()) {
          // Only work on lazy load data.
          this.loadData(function () {
            handleDescendants();
            reInitChecked(_this3);
          }, {
            checked: value !== false
          });
          return;
        } else {
          handleDescendants();
        }
      }

      var parent = this.parent;
      if (!parent || parent.level === 0) return;

      if (!recursion) {
        reInitChecked(parent);
      }
    }
  }, {
    key: "getChildren",
    value: function getChildren() {
      var forceInit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; // this is data

      if (this.level === 0) return this.data;
      var data = this.data;
      if (!data) return null;
      var props = this.store.props;
      var children = 'children';

      if (props) {
        children = props.children || 'children';
      }

      if (data[children] === undefined) {
        data[children] = null;
      }

      if (forceInit && !data[children]) {
        data[children] = [];
      }

      return data[children];
    }
  }, {
    key: "updateChildren",
    value: function updateChildren() {
      var _this4 = this;

      var newData = this.getChildren() || [];
      var oldData = this.childNodes.map(function (node) {
        return node.data;
      });
      var newDataMap = {};
      var newNodes = [];
      newData.forEach(function (item, index) {
        if (item[NODE_KEY]) {
          newDataMap[item[NODE_KEY]] = {
            index: index,
            data: item
          };
        } else {
          newNodes.push({
            index: index,
            data: item
          });
        }
      });

      if (!this.store.lazy) {
        oldData.forEach(function (item) {
          if (!newDataMap[item[NODE_KEY]]) _this4.removeChildByData(item);
        });
      }

      newNodes.forEach(function (_ref) {
        var index = _ref.index,
            data = _ref.data;

        _this4.insertChild({
          data: data
        }, index);
      });
      this.updateLeafState();
    }
  }, {
    key: "loadData",
    value: function loadData(callback) {
      var _this5 = this;

      var defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps).length)) {
        this.loading = true;

        var resolve = function resolve(children) {
          _this5.loaded = true;
          _this5.loading = false;
          _this5.childNodes = [];

          _this5.doCreateChildren(children, defaultProps);

          _this5.updateLeafState();

          if (callback) {
            callback.call(_this5, children);
          }
        };

        this.store.load(this, resolve);
      } else {
        if (callback) {
          callback.call(this);
        }
      }
    }
  }, {
    key: "label",
    get: function get() {
      return getPropertyFromData(this, 'label');
    }
  }, {
    key: "icon",
    get: function get() {
      return getPropertyFromData(this, 'icon');
    }
  }, {
    key: "key",
    get: function get() {
      var nodeKey = this.store.key;
      if (this.data) return this.data[nodeKey];
      return null;
    }
  }, {
    key: "disabled",
    get: function get() {
      return getPropertyFromData(this, 'disabled');
    }
  }, {
    key: "nextSibling",
    get: function get() {
      var parent = this.parent;

      if (parent) {
        var index = parent.childNodes.indexOf(this);

        if (index > -1) {
          return parent.childNodes[index + 1];
        }
      }

      return null;
    }
  }, {
    key: "previousSibling",
    get: function get() {
      var parent = this.parent;

      if (parent) {
        var index = parent.childNodes.indexOf(this);

        if (index > -1) {
          return index > 0 ? parent.childNodes[index - 1] : null;
        }
      }

      return null;
    }
  }]);

  return Node;
}();


// CONCATENATED MODULE: ./src/components/eTree/src/model/tree-store.js
function tree_store_typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { tree_store_typeof2 = function _typeof2(obj) { return typeof obj; }; } else { tree_store_typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return tree_store_typeof2(obj); }

function tree_store_typeof(obj) {
  if (typeof Symbol === "function" && tree_store_typeof2(Symbol.iterator) === "symbol") {
    tree_store_typeof = function _typeof(obj) {
      return tree_store_typeof2(obj);
    };
  } else {
    tree_store_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : tree_store_typeof2(obj);
    };
  }

  return tree_store_typeof(obj);
}

function tree_store_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function tree_store_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function tree_store_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) tree_store_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) tree_store_defineProperties(Constructor, staticProps);
  return Constructor;
}




var tree_store_TreeStore =
/*#__PURE__*/
function () {
  function TreeStore(options) {
    var _this = this;

    tree_store_classCallCheck(this, TreeStore);

    this.currentNode = null;
    this.currentNodeKey = null;

    for (var option in options) {
      if (options.hasOwnProperty(option)) {
        this[option] = options[option];
      }
    }

    this.nodesMap = {};
    this.root = new node_Node({
      data: this.data,
      store: this
    });

    if (this.lazy && this.load) {
      var loadFn = this.load;
      loadFn(this.root, function (data) {
        _this.root.doCreateChildren(data);

        _this._initDefaultCheckedNodes();
      });
    } else {
      this._initDefaultCheckedNodes();
    }
  }

  tree_store_createClass(TreeStore, [{
    key: "filter",
    value: function filter(value) {
      var filterNodeMethod = this.filterNodeMethod;
      var lazy = this.lazy;

      var traverse = function traverse(node) {
        var childNodes = node.root ? node.root.childNodes : node.childNodes;
        childNodes.forEach(function (child) {
          child.visible = filterNodeMethod.call(child, value, child.data, child);
          traverse(child);
        });

        if (!node.visible && childNodes.length) {
          var allHidden = true;
          childNodes.forEach(function (child) {
            if (child.visible) allHidden = false;
          });

          if (node.root) {
            node.root.visible = allHidden === false;
          } else {
            node.visible = allHidden === false;
          }
        }

        if (!value) return;
        if (node.visible && !node.isLeaf && !lazy) node.expand();
      };

      traverse(this);
    }
  }, {
    key: "setData",
    value: function setData(newVal) {
      var instanceChanged = newVal !== this.root.data;

      if (instanceChanged) {
        this.root.setData(newVal);

        this._initDefaultCheckedNodes();
      } else {
        this.root.updateChildren();
      }
    }
  }, {
    key: "getNode",
    value: function getNode(data) {
      if (data instanceof node_Node) return data;
      var key = tree_store_typeof(data) !== 'object' ? data : util_getNodeKey(this.key, data);
      return this.nodesMap[key] || null;
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(data, refData) {
      var refNode = this.getNode(refData);
      refNode.parent.insertBefore({
        data: data
      }, refNode);
    }
  }, {
    key: "insertAfter",
    value: function insertAfter(data, refData) {
      var refNode = this.getNode(refData);
      refNode.parent.insertAfter({
        data: data
      }, refNode);
    }
  }, {
    key: "remove",
    value: function remove(data) {
      var node = this.getNode(data);

      if (node && node.parent) {
        node.parent.removeChild(node);
      }
    }
  }, {
    key: "append",
    value: function append(data, parentData) {
      var parentNode = parentData ? this.getNode(parentData) : this.root;

      if (parentNode) {
        parentNode.insertChild({
          data: data
        });
      }
    }
  }, {
    key: "_initDefaultCheckedNodes",
    value: function _initDefaultCheckedNodes() {
      var _this2 = this;

      var defaultCheckedKeys = this.defaultCheckedKeys || [];
      var nodesMap = this.nodesMap;
      defaultCheckedKeys.forEach(function (checkedKey) {
        var node = nodesMap[checkedKey];

        if (node) {
          node.setChecked(true, !_this2.checkStrictly);
        }
      });
    }
  }, {
    key: "_initDefaultCheckedNode",
    value: function _initDefaultCheckedNode(node) {
      var defaultCheckedKeys = this.defaultCheckedKeys || [];

      if (defaultCheckedKeys.indexOf(node.key) !== -1) {
        node.setChecked(true, !this.checkStrictly);
      }
    }
  }, {
    key: "setDefaultCheckedKey",
    value: function setDefaultCheckedKey(newVal) {
      if (newVal !== this.defaultCheckedKeys) {
        this.defaultCheckedKeys = newVal;

        this._initDefaultCheckedNodes();
      }
    }
  }, {
    key: "registerNode",
    value: function registerNode(node) {
      var key = this.key;
      if (!key || !node || !node.data) return;
      var nodeKey = node.key;
      if (nodeKey !== undefined) this.nodesMap[node.key] = node;
    }
  }, {
    key: "deregisterNode",
    value: function deregisterNode(node) {
      var _this3 = this;

      var key = this.key;
      if (!key || !node || !node.data) return;
      node.childNodes.forEach(function (child) {
        _this3.deregisterNode(child);
      });
      delete this.nodesMap[node.key];
    }
  }, {
    key: "getCheckedNodes",
    value: function getCheckedNodes() {
      var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var includeHalfChecked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var checkedNodes = [];

      var traverse = function traverse(node) {
        var childNodes = node.root ? node.root.childNodes : node.childNodes;
        childNodes.forEach(function (child) {
          if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {
            checkedNodes.push(child.data);
          }

          traverse(child);
        });
      };

      traverse(this);
      return checkedNodes;
    }
  }, {
    key: "getCheckedKeys",
    value: function getCheckedKeys() {
      var _this4 = this;

      var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this.getCheckedNodes(leafOnly).map(function (data) {
        return (data || {})[_this4.key];
      });
    }
  }, {
    key: "getHalfCheckedNodes",
    value: function getHalfCheckedNodes() {
      var nodes = [];

      var traverse = function traverse(node) {
        var childNodes = node.root ? node.root.childNodes : node.childNodes;
        childNodes.forEach(function (child) {
          if (child.indeterminate) {
            nodes.push(child.data);
          }

          traverse(child);
        });
      };

      traverse(this);
      return nodes;
    }
  }, {
    key: "getHalfCheckedKeys",
    value: function getHalfCheckedKeys() {
      var _this5 = this;

      return this.getHalfCheckedNodes().map(function (data) {
        return (data || {})[_this5.key];
      });
    }
  }, {
    key: "_getAllNodes",
    value: function _getAllNodes() {
      var allNodes = [];
      var nodesMap = this.nodesMap;

      for (var nodeKey in nodesMap) {
        if (nodesMap.hasOwnProperty(nodeKey)) {
          allNodes.push(nodesMap[nodeKey]);
        }
      }

      return allNodes;
    }
  }, {
    key: "updateChildren",
    value: function updateChildren(key, data) {
      var node = this.nodesMap[key];
      if (!node) return;
      var childNodes = node.childNodes;

      for (var i = childNodes.length - 1; i >= 0; i--) {
        var child = childNodes[i];
        this.remove(child.data);
      }

      for (var _i = 0, j = data.length; _i < j; _i++) {
        var _child = data[_i];
        this.append(_child, node.data);
      }
    }
  }, {
    key: "_setCheckedKeys",
    value: function _setCheckedKeys(key) {
      var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var checkedKeys = arguments.length > 2 ? arguments[2] : undefined;

      var allNodes = this._getAllNodes().sort(function (a, b) {
        return b.level - a.level;
      });

      var cache = Object.create(null);
      var keys = Object.keys(checkedKeys);
      allNodes.forEach(function (node) {
        return node.setChecked(false, false);
      });

      for (var i = 0, j = allNodes.length; i < j; i++) {
        var node = allNodes[i];
        var nodeKey = node.data[key].toString();
        var checked = keys.indexOf(nodeKey) > -1;

        if (!checked) {
          if (node.checked && !cache[nodeKey]) {
            node.setChecked(false, false);
          }

          continue;
        }

        var parent = node.parent;

        while (parent && parent.level > 0) {
          cache[parent.data[key]] = true;
          parent = parent.parent;
        }

        if (node.isLeaf || this.checkStrictly) {
          node.setChecked(true, false);
          continue;
        }

        node.setChecked(true, true);

        if (leafOnly) {
          (function () {
            node.setChecked(false, false);

            var traverse = function traverse(node) {
              var childNodes = node.childNodes;
              childNodes.forEach(function (child) {
                if (!child.isLeaf) {
                  child.setChecked(false, false);
                }

                traverse(child);
              });
            };

            traverse(node);
          })();
        }
      }
    }
  }, {
    key: "setCheckedNodes",
    value: function setCheckedNodes(array) {
      var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var key = this.key;
      var checkedKeys = {};
      array.forEach(function (item) {
        checkedKeys[(item || {})[key]] = true;
      });

      this._setCheckedKeys(key, leafOnly, checkedKeys);
    }
  }, {
    key: "setCheckedKeys",
    value: function setCheckedKeys(keys) {
      var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.defaultCheckedKeys = keys;
      var key = this.key;
      var checkedKeys = {};
      keys.forEach(function (key) {
        checkedKeys[key] = true;
      });

      this._setCheckedKeys(key, leafOnly, checkedKeys);
    }
  }, {
    key: "setDefaultExpandedKeys",
    value: function setDefaultExpandedKeys(keys) {
      var _this6 = this;

      keys = keys || [];
      this.defaultExpandedKeys = keys;
      keys.forEach(function (key) {
        var node = _this6.getNode(key);

        if (node) node.expand(null, _this6.autoExpandParent);
      });
    }
  }, {
    key: "setChecked",
    value: function setChecked(data, checked, deep) {
      var node = this.getNode(data);

      if (node) {
        node.setChecked(!!checked, deep);
      }
    }
  }, {
    key: "getCurrentNode",
    value: function getCurrentNode() {
      return this.currentNode;
    }
  }, {
    key: "setCurrentNode",
    value: function setCurrentNode(node) {
      this.currentNode = node;
    }
  }, {
    key: "setUserCurrentNode",
    value: function setUserCurrentNode(node) {
      var key = node[this.key];
      var currNode = this.nodesMap[key];
      this.setCurrentNode(currNode);
    }
  }, {
    key: "setCurrentNodeKey",
    value: function setCurrentNodeKey(key) {
      if (key === null) {
        this.currentNode = null;
        return;
      }

      var node = this.getNode(key);

      if (node) {
        this.currentNode = node;
      }
    }
  }]);

  return TreeStore;
}();


;
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/eTree/src/tree-node.vue?vue&type=template&id=5b1ffe81&
var tree_nodevue_type_template_id_5b1ffe81_render = function () {
var this$1 = this;
var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.node.visible),expression:"node.visible"}],ref:"node",staticClass:"el-tree-node",class:{
    'is-expanded': _vm.expanded,
    'is-current': _vm.tree.store.currentNode === _vm.node,
    'is-hidden': !_vm.node.visible,
    'is-focusable': !_vm.node.disabled,
    'is-checked': !_vm.node.disabled && _vm.node.checked
  },attrs:{"role":"treeitem","tabindex":"-1","aria-expanded":_vm.expanded,"aria-disabled":_vm.node.disabled,"aria-checked":_vm.node.checked,"draggable":_vm.tree.draggable},on:{"click":function($event){$event.stopPropagation();return _vm.handleClick($event)},"contextmenu":function ($event) { return this$1.handleContextMenu($event); },"dragstart":function($event){$event.stopPropagation();return _vm.handleDragStart($event)},"dragover":function($event){$event.stopPropagation();return _vm.handleDragOver($event)},"dragend":function($event){$event.stopPropagation();return _vm.handleDragEnd($event)},"drop":function($event){$event.stopPropagation();return _vm.handleDrop($event)}}},[_c('div',{staticClass:"el-tree-node__content",style:({ 'padding-left': (_vm.node.level - 1) * _vm.tree.indent + 'px' })},[_c('span',{staticClass:"el-tree-node__expand-icon el-icon-caret-right",class:{ 'is-leaf': _vm.node.isLeaf, expanded: !_vm.node.isLeaf && _vm.expanded },on:{"click":function($event){$event.stopPropagation();return _vm.handleExpandIconClick($event)}}}),_vm._v(" "),(_vm.showCheckbox)?_c('el-checkbox',{attrs:{"indeterminate":_vm.node.indeterminate,"disabled":!!_vm.node.disabled},on:{"change":_vm.handleCheckChange},nativeOn:{"click":function($event){$event.stopPropagation();}},model:{value:(_vm.node.checked),callback:function ($$v) {_vm.$set(_vm.node, "checked", $$v)},expression:"node.checked"}}):_vm._e(),_vm._v(" "),(_vm.node.loading)?_c('span',{staticClass:"el-tree-node__loading-icon el-icon-loading"}):_vm._e(),_vm._v(" "),_c('node-content',{attrs:{"node":_vm.node}})],1),_vm._v(" "),_c('el-collapse-transition',[(!_vm.renderAfterExpand || _vm.childNodeRendered)?_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.expanded),expression:"expanded"}],staticClass:"el-tree-node__children",attrs:{"role":"group","aria-expanded":_vm.expanded}},_vm._l((_vm.node.childNodes),function(child){return _c('el-tree-node',{key:_vm.getNodeKey(child),attrs:{"render-content":_vm.renderContent,"render-after-expand":_vm.renderAfterExpand,"node":child},on:{"node-expand":_vm.handleChildNodeExpand}})}),1):_vm._e()])],1)}
var tree_nodevue_type_template_id_5b1ffe81_staticRenderFns = []


// CONCATENATED MODULE: ./src/components/eTree/src/tree-node.vue?vue&type=template&id=5b1ffe81&

// EXTERNAL MODULE: ./node_modules/element-ui/src/utils/dom.js
var utils_dom = __webpack_require__(7);

// CONCATENATED MODULE: ./node_modules/element-ui/src/transitions/collapse-transition.js
function collapse_transition_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function collapse_transition_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function collapse_transition_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) collapse_transition_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) collapse_transition_defineProperties(Constructor, staticProps);
  return Constructor;
}



var collapse_transition_Transition =
/*#__PURE__*/
function () {
  function Transition() {
    collapse_transition_classCallCheck(this, Transition);
  }

  collapse_transition_createClass(Transition, [{
    key: "beforeEnter",
    value: function beforeEnter(el) {
      Object(utils_dom["a" /* addClass */])(el, 'collapse-transition');
      if (!el.dataset) el.dataset = {};
      el.dataset.oldPaddingTop = el.style.paddingTop;
      el.dataset.oldPaddingBottom = el.style.paddingBottom;
      el.style.height = '0';
      el.style.paddingTop = 0;
      el.style.paddingBottom = 0;
    }
  }, {
    key: "enter",
    value: function enter(el) {
      el.dataset.oldOverflow = el.style.overflow;

      if (el.scrollHeight !== 0) {
        el.style.height = el.scrollHeight + 'px';
        el.style.paddingTop = el.dataset.oldPaddingTop;
        el.style.paddingBottom = el.dataset.oldPaddingBottom;
      } else {
        el.style.height = '';
        el.style.paddingTop = el.dataset.oldPaddingTop;
        el.style.paddingBottom = el.dataset.oldPaddingBottom;
      }

      el.style.overflow = 'hidden';
    }
  }, {
    key: "afterEnter",
    value: function afterEnter(el) {
      // for safari: remove class then reset height is necessary
      Object(utils_dom["f" /* removeClass */])(el, 'collapse-transition');
      el.style.height = '';
      el.style.overflow = el.dataset.oldOverflow;
    }
  }, {
    key: "beforeLeave",
    value: function beforeLeave(el) {
      if (!el.dataset) el.dataset = {};
      el.dataset.oldPaddingTop = el.style.paddingTop;
      el.dataset.oldPaddingBottom = el.style.paddingBottom;
      el.dataset.oldOverflow = el.style.overflow;
      el.style.height = el.scrollHeight + 'px';
      el.style.overflow = 'hidden';
    }
  }, {
    key: "leave",
    value: function leave(el) {
      if (el.scrollHeight !== 0) {
        // for safari: add class after set height, or it will jump to zero height suddenly, weired
        Object(utils_dom["a" /* addClass */])(el, 'collapse-transition');
        el.style.height = 0;
        el.style.paddingTop = 0;
        el.style.paddingBottom = 0;
      }
    }
  }, {
    key: "afterLeave",
    value: function afterLeave(el) {
      Object(utils_dom["f" /* removeClass */])(el, 'collapse-transition');
      el.style.height = '';
      el.style.overflow = el.dataset.oldOverflow;
      el.style.paddingTop = el.dataset.oldPaddingTop;
      el.style.paddingBottom = el.dataset.oldPaddingBottom;
    }
  }]);

  return Transition;
}();

/* harmony default export */ var collapse_transition = ({
  name: 'ElCollapseTransition',
  functional: true,
  render: function render(h, _ref) {
    var children = _ref.children;
    var data = {
      on: new collapse_transition_Transition()
    };
    return h('transition', data, children);
  }
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/element-ui/packages/checkbox/src/checkbox.vue?vue&type=template&id=322e3709&
var checkboxvue_type_template_id_322e3709_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{staticClass:"el-checkbox",class:[
    _vm.border && _vm.checkboxSize ? 'el-checkbox--' + _vm.checkboxSize : '',
    { 'is-disabled': _vm.isDisabled },
    { 'is-bordered': _vm.border },
    { 'is-checked': _vm.isChecked }
  ],attrs:{"role":"checkbox","aria-checked":_vm.indeterminate ? 'mixed': _vm.isChecked,"aria-disabled":_vm.isDisabled,"id":_vm.id}},[_c('span',{staticClass:"el-checkbox__input",class:{
      'is-disabled': _vm.isDisabled,
      'is-checked': _vm.isChecked,
      'is-indeterminate': _vm.indeterminate,
      'is-focus': _vm.focus
    },attrs:{"aria-checked":"mixed"}},[_c('span',{staticClass:"el-checkbox__inner"}),_vm._v(" "),(_vm.trueLabel || _vm.falseLabel)?_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.model),expression:"model"}],staticClass:"el-checkbox__original",attrs:{"type":"checkbox","aria-hidden":"true","name":_vm.name,"disabled":_vm.isDisabled,"true-value":_vm.trueLabel,"false-value":_vm.falseLabel},domProps:{"checked":Array.isArray(_vm.model)?_vm._i(_vm.model,null)>-1:_vm._q(_vm.model,_vm.trueLabel)},on:{"change":[function($event){var $$a=_vm.model,$$el=$event.target,$$c=$$el.checked?(_vm.trueLabel):(_vm.falseLabel);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.model=$$a.concat([$$v]))}else{$$i>-1&&(_vm.model=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.model=$$c}},_vm.handleChange],"focus":function($event){_vm.focus = true},"blur":function($event){_vm.focus = false}}}):_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.model),expression:"model"}],staticClass:"el-checkbox__original",attrs:{"type":"checkbox","aria-hidden":"true","disabled":_vm.isDisabled,"name":_vm.name},domProps:{"value":_vm.label,"checked":Array.isArray(_vm.model)?_vm._i(_vm.model,_vm.label)>-1:(_vm.model)},on:{"change":[function($event){var $$a=_vm.model,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=_vm.label,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.model=$$a.concat([$$v]))}else{$$i>-1&&(_vm.model=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.model=$$c}},_vm.handleChange],"focus":function($event){_vm.focus = true},"blur":function($event){_vm.focus = false}}})]),_vm._v(" "),(_vm.$slots.default || _vm.label)?_c('span',{staticClass:"el-checkbox__label"},[_vm._t("default"),_vm._v(" "),(!_vm.$slots.default)?[_vm._v(_vm._s(_vm.label))]:_vm._e()],2):_vm._e()])}
var checkboxvue_type_template_id_322e3709_staticRenderFns = []


// CONCATENATED MODULE: ./node_modules/element-ui/packages/checkbox/src/checkbox.vue?vue&type=template&id=322e3709&

// CONCATENATED MODULE: ./node_modules/element-ui/src/mixins/emitter.js
function _broadcast(componentName, eventName, params) {
  this.$children.forEach(function (child) {
    var name = child.$options.componentName;

    if (name === componentName) {
      child.$emit.apply(child, [eventName].concat(params));
    } else {
      _broadcast.apply(child, [componentName, eventName].concat([params]));
    }
  });
}

/* harmony default export */ var emitter = ({
  methods: {
    dispatch: function dispatch(componentName, eventName, params) {
      var parent = this.$parent || this.$root;
      var name = parent.$options.componentName;

      while (parent && (!name || name !== componentName)) {
        parent = parent.$parent;

        if (parent) {
          name = parent.$options.componentName;
        }
      }

      if (parent) {
        parent.$emit.apply(parent, [eventName].concat(params));
      }
    },
    broadcast: function broadcast(componentName, eventName, params) {
      _broadcast.call(this, componentName, eventName, params);
    }
  }
});
// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--1!./node_modules/babel-loader/lib??ref--12-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/element-ui/packages/checkbox/src/checkbox.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var checkboxvue_type_script_lang_js_ = ({
  name: 'ElCheckbox',
  mixins: [emitter],
  inject: {
    elForm: {
      "default": ''
    },
    elFormItem: {
      "default": ''
    }
  },
  componentName: 'ElCheckbox',
  data: function data() {
    return {
      selfModel: false,
      focus: false,
      isLimitExceeded: false
    };
  },
  computed: {
    model: {
      get: function get() {
        return this.isGroup ? this.store : this.value !== undefined ? this.value : this.selfModel;
      },
      set: function set(val) {
        if (this.isGroup) {
          this.isLimitExceeded = false;
          this._checkboxGroup.min !== undefined && val.length < this._checkboxGroup.min && (this.isLimitExceeded = true);
          this._checkboxGroup.max !== undefined && val.length > this._checkboxGroup.max && (this.isLimitExceeded = true);
          this.isLimitExceeded === false && this.dispatch('ElCheckboxGroup', 'input', [val]);
        } else {
          this.$emit('input', val);
          this.selfModel = val;
        }
      }
    },
    isChecked: function isChecked() {
      if ({}.toString.call(this.model) === '[object Boolean]') {
        return this.model;
      } else if (Array.isArray(this.model)) {
        return this.model.indexOf(this.label) > -1;
      } else if (this.model !== null && this.model !== undefined) {
        return this.model === this.trueLabel;
      }
    },
    isGroup: function isGroup() {
      var parent = this.$parent;

      while (parent) {
        if (parent.$options.componentName !== 'ElCheckboxGroup') {
          parent = parent.$parent;
        } else {
          this._checkboxGroup = parent;
          return true;
        }
      }

      return false;
    },
    store: function store() {
      return this._checkboxGroup ? this._checkboxGroup.value : this.value;
    },
    isDisabled: function isDisabled() {
      return this.isGroup ? this._checkboxGroup.disabled || this.disabled || (this.elForm || {}).disabled : this.disabled || (this.elForm || {}).disabled;
    },
    _elFormItemSize: function _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },
    checkboxSize: function checkboxSize() {
      var temCheckboxSize = this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
      return this.isGroup ? this._checkboxGroup.checkboxGroupSize || temCheckboxSize : temCheckboxSize;
    }
  },
  props: {
    value: {},
    label: {},
    indeterminate: Boolean,
    disabled: Boolean,
    checked: Boolean,
    name: String,
    trueLabel: [String, Number],
    falseLabel: [String, Number],
    id: String,

    /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系*/
    controls: String,

    /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系*/
    border: Boolean,
    size: String
  },
  methods: {
    addToStore: function addToStore() {
      if (Array.isArray(this.model) && this.model.indexOf(this.label) === -1) {
        this.model.push(this.label);
      } else {
        this.model = this.trueLabel || true;
      }
    },
    handleChange: function handleChange(ev) {
      var _this = this;

      if (this.isLimitExceeded) return;
      var value;

      if (ev.target.checked) {
        value = this.trueLabel === undefined ? true : this.trueLabel;
      } else {
        value = this.falseLabel === undefined ? false : this.falseLabel;
      }

      this.$emit('change', value, ev);
      this.$nextTick(function () {
        if (_this.isGroup) {
          _this.dispatch('ElCheckboxGroup', 'change', [_this._checkboxGroup.value]);
        }
      });
    }
  },
  created: function created() {
    this.checked && this.addToStore();
  },
  mounted: function mounted() {
    // 为indeterminate元素 添加aria-controls 属性
    if (this.indeterminate) {
      this.$el.setAttribute('aria-controls', this.controls);
    }
  },
  watch: {
    value: function value(_value) {
      this.dispatch('ElFormItem', 'el.form.change', _value);
    }
  }
});
// CONCATENATED MODULE: ./node_modules/element-ui/packages/checkbox/src/checkbox.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_checkboxvue_type_script_lang_js_ = (checkboxvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./node_modules/element-ui/packages/checkbox/src/checkbox.vue





/* normalize component */

var checkbox_component = Object(componentNormalizer["a" /* default */])(
  src_checkboxvue_type_script_lang_js_,
  checkboxvue_type_template_id_322e3709_render,
  checkboxvue_type_template_id_322e3709_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_checkbox = (checkbox_component.exports);
// CONCATENATED MODULE: ./node_modules/element-ui/packages/checkbox/index.js

/* istanbul ignore next */

src_checkbox.install = function (Vue) {
  Vue.component(src_checkbox.name, src_checkbox);
};

/* harmony default export */ var packages_checkbox = (src_checkbox);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--1!./node_modules/babel-loader/lib??ref--12-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/eTree/src/tree-node.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var tree_nodevue_type_script_lang_js_ = ({
  name: 'ElTreeNode',
  componentName: 'ElTreeNode',
  mixins: [emitter],
  props: {
    node: {
      "default": function _default() {
        return {};
      }
    },
    props: {},
    renderContent: Function,
    renderAfterExpand: {
      type: Boolean,
      "default": true
    }
  },
  components: {
    ElCollapseTransition: collapse_transition,
    ElCheckbox: packages_checkbox,
    NodeContent: {
      props: {
        node: {
          required: true
        }
      },
      render: function render(h) {
        var parent = this.$parent;
        var tree = parent.tree;
        var node = this.node;
        var data = node.data,
            store = node.store;
        return parent.renderContent ? parent.renderContent.call(parent._renderProxy, h, {
          _self: tree.$vnode.context,
          node: node,
          data: data,
          store: store
        }) : tree.$scopedSlots["default"] ? tree.$scopedSlots["default"]({
          node: node,
          data: data
        }) : h("span", {
          "class": "el-tree-node__label"
        }, [node.label]);
      }
    }
  },
  data: function data() {
    return {
      tree: null,
      expanded: false,
      childNodeRendered: false,
      showCheckbox: false,
      oldChecked: null,
      oldIndeterminate: null
    };
  },
  watch: {
    'node.indeterminate': function nodeIndeterminate(val) {
      this.handleSelectChange(this.node.checked, val);
    },
    'node.checked': function nodeChecked(val) {
      this.handleSelectChange(val, this.node.indeterminate);
    },
    'node.expanded': function nodeExpanded(val) {
      var _this = this;

      this.$nextTick(function () {
        _this.expanded = val;
      });

      if (val) {
        this.childNodeRendered = true;
      }
    }
  },
  methods: {
    getNodeKey: function getNodeKey(node) {
      return util_getNodeKey(this.tree.nodeKey, node.data);
    },
    handleSelectChange: function handleSelectChange(checked, indeterminate) {
      if (this.oldChecked !== checked && this.oldIndeterminate !== indeterminate) {
        this.tree.$emit('check-change', this.node.data, checked, indeterminate);
      }

      this.oldChecked = checked;
      this.indeterminate = indeterminate;
    },
    handleClick: function handleClick() {
      var store = this.tree.store;
      store.setCurrentNode(this.node);
      this.tree.$emit('current-change', store.currentNode ? store.currentNode.data : null, store.currentNode);
      this.tree.currentNode = this;

      if (this.tree.expandOnClickNode) {
        this.handleExpandIconClick();
      }

      if (this.tree.checkOnClickNode && !this.node.disabled) {
        this.handleCheckChange(null, {
          target: {
            checked: !this.node.checked
          }
        });
      }

      this.tree.$emit('node-click', this.node.data, this.node, this);
    },
    handleContextMenu: function handleContextMenu(event) {
      if (this.tree._events['node-contextmenu'] && this.tree._events['node-contextmenu'].length > 0) {
        event.stopPropagation();
        event.preventDefault();
      }

      this.tree.$emit('node-contextmenu', event, this.node.data, this.node, this);
    },
    handleExpandIconClick: function handleExpandIconClick() {
      if (this.node.isLeaf) return;

      if (this.expanded) {
        this.tree.$emit('node-collapse', this.node.data, this.node, this);
        this.node.collapse();
      } else {
        this.node.expand();
        this.$emit('node-expand', this.node.data, this.node, this);
      }
    },
    handleCheckChange: function handleCheckChange(value, ev) {
      var _this2 = this;

      this.node.setChecked(ev.target.checked, !this.tree.checkStrictly);
      this.$nextTick(function () {
        var store = _this2.tree.store;

        _this2.tree.$emit('check', _this2.node.data, {
          checkedNodes: store.getCheckedNodes(),
          checkedKeys: store.getCheckedKeys(),
          halfCheckedNodes: store.getHalfCheckedNodes(),
          halfCheckedKeys: store.getHalfCheckedKeys()
        });
      });
    },
    handleChildNodeExpand: function handleChildNodeExpand(nodeData, node, instance) {
      this.broadcast('ElTreeNode', 'tree-node-expand', node);
      this.tree.$emit('node-expand', nodeData, node, instance);
    },
    handleDragStart: function handleDragStart(event) {
      if (!this.tree.draggable) return;
      this.tree.$emit('tree-node-drag-start', event, this);
    },
    handleDragOver: function handleDragOver(event) {
      if (!this.tree.draggable) return;
      this.tree.$emit('tree-node-drag-over', event, this);
      event.preventDefault();
    },
    handleDrop: function handleDrop(event) {
      event.preventDefault();
    },
    handleDragEnd: function handleDragEnd(event) {
      if (!this.tree.draggable) return;
      this.tree.$emit('tree-node-drag-end', event, this);
    }
  },
  created: function created() {
    var _this3 = this;

    var parent = this.$parent;

    if (parent.isTree) {
      this.tree = parent;
    } else {
      this.tree = parent.tree;
    }

    var tree = this.tree;

    if (!tree) {
      console.warn('Can not find node\'s tree.');
    }

    var props = tree.props || {};
    var childrenKey = props['children'] || 'children';
    this.$watch("node.data.".concat(childrenKey), function () {
      _this3.node.updateChildren();
    });
    this.showCheckbox = tree.showCheckbox;

    if (this.node.expanded) {
      this.expanded = true;
      this.childNodeRendered = true;
    }

    if (this.tree.accordion) {
      this.$on('tree-node-expand', function (node) {
        if (_this3.node !== node) {
          _this3.node.collapse();
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./src/components/eTree/src/tree-node.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_tree_nodevue_type_script_lang_js_ = (tree_nodevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./src/components/eTree/src/tree-node.vue





/* normalize component */

var tree_node_component = Object(componentNormalizer["a" /* default */])(
  src_tree_nodevue_type_script_lang_js_,
  tree_nodevue_type_template_id_5b1ffe81_render,
  tree_nodevue_type_template_id_5b1ffe81_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var tree_node = (tree_node_component.exports);
// CONCATENATED MODULE: ./node_modules/element-ui/src/locale/lang/zh-CN.js
/* harmony default export */ var lang_zh_CN = ({
  el: {
    colorpicker: {
      confirm: '确定',
      clear: '清空'
    },
    datepicker: {
      now: '此刻',
      today: '今天',
      cancel: '取消',
      clear: '清空',
      confirm: '确定',
      selectDate: '选择日期',
      selectTime: '选择时间',
      startDate: '开始日期',
      startTime: '开始时间',
      endDate: '结束日期',
      endTime: '结束时间',
      prevYear: '前一年',
      nextYear: '后一年',
      prevMonth: '上个月',
      nextMonth: '下个月',
      year: '年',
      month1: '1 月',
      month2: '2 月',
      month3: '3 月',
      month4: '4 月',
      month5: '5 月',
      month6: '6 月',
      month7: '7 月',
      month8: '8 月',
      month9: '9 月',
      month10: '10 月',
      month11: '11 月',
      month12: '12 月',
      // week: '周次',
      weeks: {
        sun: '日',
        mon: '一',
        tue: '二',
        wed: '三',
        thu: '四',
        fri: '五',
        sat: '六'
      },
      months: {
        jan: '一月',
        feb: '二月',
        mar: '三月',
        apr: '四月',
        may: '五月',
        jun: '六月',
        jul: '七月',
        aug: '八月',
        sep: '九月',
        oct: '十月',
        nov: '十一月',
        dec: '十二月'
      }
    },
    select: {
      loading: '加载中',
      noMatch: '无匹配数据',
      noData: '无数据',
      placeholder: '请选择'
    },
    cascader: {
      noMatch: '无匹配数据',
      loading: '加载中',
      placeholder: '请选择'
    },
    pagination: {
      "goto": '前往',
      pagesize: '条/页',
      total: '共 {total} 条',
      pageClassifier: '页'
    },
    messagebox: {
      title: '提示',
      confirm: '确定',
      cancel: '取消',
      error: '输入的数据不合法!'
    },
    upload: {
      deleteTip: '按 delete 键可删除',
      "delete": '删除',
      preview: '查看图片',
      "continue": '继续上传'
    },
    table: {
      emptyText: '暂无数据',
      confirmFilter: '筛选',
      resetFilter: '重置',
      clearFilter: '全部',
      sumText: '合计'
    },
    tree: {
      emptyText: '暂无数据'
    },
    transfer: {
      noMatch: '无匹配数据',
      noData: '无数据',
      titles: ['列表 1', '列表 2'],
      filterPlaceholder: '请输入搜索内容',
      noCheckedFormat: '共 {total} 项',
      hasCheckedFormat: '已选 {checked}/{total} 项'
    }
  }
});
// EXTERNAL MODULE: ./node_modules/deepmerge/dist/cjs.js
var cjs = __webpack_require__(419);
var cjs_default = /*#__PURE__*/__webpack_require__.n(cjs);

// EXTERNAL MODULE: ./node_modules/element-ui/src/utils/util.js
var utils_util = __webpack_require__(72);

// CONCATENATED MODULE: ./node_modules/element-ui/src/locale/format.js
function format_typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { format_typeof2 = function _typeof2(obj) { return typeof obj; }; } else { format_typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return format_typeof2(obj); }

function format_typeof(obj) {
  if (typeof Symbol === "function" && format_typeof2(Symbol.iterator) === "symbol") {
    format_typeof = function _typeof(obj) {
      return format_typeof2(obj);
    };
  } else {
    format_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : format_typeof2(obj);
    };
  }

  return format_typeof(obj);
}


var RE_NARGS = /(%|)\{([0-9a-zA-Z_]+)\}/g;
/**
 *  String format template
 *  - Inspired:
 *    https://github.com/Matt-Esch/string-template/index.js
 */

/* harmony default export */ var locale_format = (function (Vue) {
  /**
   * template
   *
   * @param {String} string
   * @param {Array} ...args
   * @return {String}
   */
  function template(string) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (args.length === 1 && format_typeof(args[0]) === 'object') {
      args = args[0];
    }

    if (!args || !args.hasOwnProperty) {
      args = {};
    }

    return string.replace(RE_NARGS, function (match, prefix, i, index) {
      var result;

      if (string[index - 1] === '{' && string[index + match.length] === '}') {
        return i;
      } else {
        result = Object(utils_util["b" /* hasOwn */])(args, i) ? args[i] : null;

        if (result === null || result === undefined) {
          return '';
        }

        return result;
      }
    });
  }

  return template;
});
// CONCATENATED MODULE: ./node_modules/element-ui/src/locale/index.js




var src_locale_format = locale_format(external_Vue_default.a);
var lang = lang_zh_CN;
var merged = false;

var locale_i18nHandler = function i18nHandler() {
  var vuei18n = Object.getPrototypeOf(this || external_Vue_default.a).$t;

  if (typeof vuei18n === 'function' && !!external_Vue_default.a.locale) {
    if (!merged) {
      merged = true;
      external_Vue_default.a.locale(external_Vue_default.a.config.lang, cjs_default()(lang, external_Vue_default.a.locale(external_Vue_default.a.config.lang) || {}, {
        clone: true
      }));
    }

    return vuei18n.apply(this, arguments);
  }
};

var locale_t = function t(path, options) {
  var value = locale_i18nHandler.apply(this, arguments);
  if (value !== null && value !== undefined) return value;
  var array = path.split('.');
  var current = lang;

  for (var i = 0, j = array.length; i < j; i++) {
    var property = array[i];
    value = current[property];
    if (i === j - 1) return src_locale_format(value, options);
    if (!value) return '';
    current = value;
  }

  return '';
};
var use = function use(l) {
  lang = l || lang;
};
var i18n = function i18n(fn) {
  locale_i18nHandler = fn || locale_i18nHandler;
};
/* harmony default export */ var src_locale = ({
  use: use,
  t: locale_t,
  i18n: i18n
});
// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--1!./node_modules/babel-loader/lib??ref--12-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/eTree/src/tree.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






/* harmony default export */ var treevue_type_script_lang_js_ = ({
  name: 'TaETree',
  mixins: [emitter],
  components: {
    ElTreeNode: tree_node
  },
  data: function data() {
    return {
      store: null,
      root: null,
      currentNode: null,
      treeItems: null,
      checkboxItems: [],
      dragState: {
        showDropIndicator: false,
        draggingNode: null,
        dropNode: null,
        allowDrop: true
      },
      checkedAll: false
    };
  },
  props: {
    data: {
      type: Array
    },
    emptyText: {
      type: String,
      "default": function _default() {
        return locale_t('el.tree.emptyText');
      }
    },
    renderAfterExpand: {
      type: Boolean,
      "default": true
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      "default": true
    },
    checkOnClickNode: Boolean,
    checkDescendants: {
      type: Boolean,
      "default": false
    },
    autoExpandParent: {
      type: Boolean,
      "default": true
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      "default": false
    },
    draggable: {
      type: Boolean,
      "default": false
    },
    allowDrag: Function,
    allowDrop: Function,
    props: {
      "default": function _default() {
        return {
          children: 'children',
          label: 'label',
          icon: 'icon',
          disabled: 'disabled'
        };
      }
    },
    lazy: {
      type: Boolean,
      "default": false
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      "default": 18
    },
    showCheckAll: {
      type: Boolean,
      "default": false
    }
  },
  computed: {
    children: {
      set: function set(value) {
        this.data = value;
      },
      get: function get() {
        return this.data;
      }
    },
    treeItemArray: function treeItemArray() {
      return Array.prototype.slice.call(this.treeItems);
    },
    isEmpty: function isEmpty() {
      var childNodes = this.root.childNodes;
      return !childNodes || childNodes.length === 0 || childNodes.every(function (_ref) {
        var visible = _ref.visible;
        return !visible;
      });
    },
    isCheckedAll: {
      set: function set(value) {
        this.checkedAll = value;
      },
      get: function get() {
        return this.checkedAll;
      }
    }
  },
  watch: {
    defaultCheckedKeys: function defaultCheckedKeys(newVal) {
      this.store.setDefaultCheckedKey(newVal);
    },
    defaultExpandedKeys: function defaultExpandedKeys(newVal) {
      this.store.defaultExpandedKeys = newVal;
      this.store.setDefaultExpandedKeys(newVal);
    },
    data: function data(newVal) {
      this.store.setData(newVal);
    },
    checkboxItems: function checkboxItems(val) {
      Array.prototype.forEach.call(val, function (checkbox) {
        checkbox.setAttribute('tabindex', -1);
      });
    },
    checkStrictly: function checkStrictly(newVal) {
      this.store.checkStrictly = newVal;
    }
  },
  methods: {
    filter: function filter(value) {
      if (!this.filterNodeMethod) throw new Error('[Tree] filterNodeMethod is required when filter');
      this.store.filter(value);
    },
    getNodeKey: function getNodeKey(node) {
      return util_getNodeKey(this.nodeKey, node.data);
    },
    getNodePath: function getNodePath(data) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in getNodePath');
      var node = this.store.getNode(data);
      if (!node) return [];
      var path = [node.data];
      var parent = node.parent;

      while (parent && parent !== this.root) {
        path.push(parent.data);
        parent = parent.parent;
      }

      return path.reverse();
    },
    getCheckedNodes: function getCheckedNodes(leafOnly, includeHalfChecked) {
      return this.store.getCheckedNodes(leafOnly, includeHalfChecked);
    },
    getCheckedKeys: function getCheckedKeys(leafOnly) {
      return this.store.getCheckedKeys(leafOnly);
    },
    getCurrentNode: function getCurrentNode() {
      var currentNode = this.store.getCurrentNode();
      return currentNode ? currentNode.data : null;
    },
    getCurrentKey: function getCurrentKey() {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in getCurrentKey');
      var currentNode = this.getCurrentNode();
      return currentNode ? currentNode[this.nodeKey] : null;
    },
    setCheckedNodes: function setCheckedNodes(nodes, leafOnly) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedNodes');
      this.store.setCheckedNodes(nodes, leafOnly);
    },
    setCheckedKeys: function setCheckedKeys(keys, leafOnly) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedKeys');
      this.store.setCheckedKeys(keys, leafOnly);
    },
    setChecked: function setChecked(data, checked, deep) {
      this.store.setChecked(data, checked, deep);
    },
    getHalfCheckedNodes: function getHalfCheckedNodes() {
      return this.store.getHalfCheckedNodes();
    },
    getHalfCheckedKeys: function getHalfCheckedKeys() {
      return this.store.getHalfCheckedKeys();
    },
    setCurrentNode: function setCurrentNode(node) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCurrentNode');
      this.store.setUserCurrentNode(node);
    },
    setCurrentKey: function setCurrentKey(key) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCurrentKey');
      this.store.setCurrentNodeKey(key);
    },
    getNode: function getNode(data) {
      return this.store.getNode(data);
    },
    remove: function remove(data) {
      this.store.remove(data);
    },
    append: function append(data, parentNode) {
      this.store.append(data, parentNode);
    },
    insertBefore: function insertBefore(data, refNode) {
      this.store.insertBefore(data, refNode);
    },
    insertAfter: function insertAfter(data, refNode) {
      this.store.insertAfter(data, refNode);
    },
    handleNodeExpand: function handleNodeExpand(nodeData, node, instance) {
      this.broadcast('ElTreeNode', 'tree-node-expand', node);
      this.$emit('node-expand', nodeData, node, instance);
    },
    updateKeyChildren: function updateKeyChildren(key, data) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in updateKeyChild');
      this.store.updateChildren(key, data);
    },
    initTabIndex: function initTabIndex() {
      this.treeItems = this.$el.querySelectorAll('.is-focusable[role=treeitem]');
      this.checkboxItems = this.$el.querySelectorAll('input[type=checkbox]');
      var checkedItem = this.$el.querySelectorAll('.is-checked[role=treeitem]');

      if (checkedItem.length) {
        checkedItem[0].setAttribute('tabindex', 0);
        return;
      }

      this.treeItems[0] && this.treeItems[0].setAttribute('tabindex', 0);
    },
    handleKeydown: function handleKeydown(ev) {
      var currentItem = ev.target;
      if (currentItem.className.indexOf('el-tree-node') === -1) return;
      var keyCode = ev.keyCode;
      this.treeItems = this.$el.querySelectorAll('.is-focusable[role=treeitem]');
      var currentIndex = this.treeItemArray.indexOf(currentItem);
      var nextIndex;

      if ([38, 40].indexOf(keyCode) > -1) {
        // up、down
        ev.preventDefault();

        if (keyCode === 38) {
          // up
          nextIndex = currentIndex !== 0 ? currentIndex - 1 : 0;
        } else {
          nextIndex = currentIndex < this.treeItemArray.length - 1 ? currentIndex + 1 : 0;
        }

        this.treeItemArray[nextIndex].focus(); // 选中
      }

      if ([37, 39].indexOf(keyCode) > -1) {
        // left、right 展开
        ev.preventDefault();
        currentItem.click(); // 选中
      }

      var hasInput = currentItem.querySelector('[type="checkbox"]');

      if ([13, 32].indexOf(keyCode) > -1 && hasInput) {
        // space enter选中checkbox
        ev.preventDefault();
        hasInput.click();
      }
    },
    fnCheckAll: function fnCheckAll() {
      if (this.nodeKey && this.showCheckAll && this.showCheckbox) {
        this.setChecked(this.root, !this.isCheckedAll, true);
        this.isCheckedAll = !this.isCheckedAll;
      }
    }
  },
  created: function created() {
    var _this = this;

    this.isTree = true;
    this.store = new tree_store_TreeStore({
      key: this.nodeKey,
      data: this.data,
      lazy: this.lazy,
      props: this.props,
      load: this.load,
      currentNodeKey: this.currentNodeKey,
      checkStrictly: this.checkStrictly,
      checkDescendants: this.checkDescendants,
      defaultCheckedKeys: this.defaultCheckedKeys,
      defaultExpandedKeys: this.defaultExpandedKeys,
      autoExpandParent: this.autoExpandParent,
      defaultExpandAll: this.defaultExpandAll,
      filterNodeMethod: this.filterNodeMethod
    });
    this.root = this.store.root;
    var allNodesLength;

    if (this.nodeKey && this.showCheckAll && this.showCheckbox) {
      var originChecked = this.getCheckedKeys(false);
      this.setChecked(this.root, true, true);
      allNodesLength = this.getCheckedKeys(false).length;
      this.setCheckedKeys(originChecked, false);
      var checkedKeys = this.getCheckedNodes(false, false) || [];
      var checkedAll = false;
      var data = this.data;
      data.forEach(function (v, i) {
        checkedAll = checkedAll && checkedKeys.indexOf(v) !== -1;
      });
      this.isCheckedAll = checkedKeys.length !== 0 && checkedAll;
    }

    var dragState = this.dragState;
    this.$on('tree-node-drag-start', function (event, treeNode) {
      if (typeof _this.allowDrag === 'function' && !_this.allowDrag(treeNode.node)) {
        event.preventDefault();
        return false;
      }

      event.dataTransfer.effectAllowed = 'move'; // wrap in try catch to address IE's error when first param is 'text/plain'

      try {
        // setData is required for draggable to work in FireFox
        // the content has to be '' so dragging a node out of the tree won't open a new tab in FireFox
        event.dataTransfer.setData('text/plain', '');
      } catch (e) {}

      dragState.draggingNode = treeNode;

      _this.$emit('node-drag-start', treeNode.node, event);
    });
    this.$on('tree-node-drag-over', function (event, treeNode) {
      var dropNode = findNearestComponent(event.target, 'ElTreeNode');
      var oldDropNode = dragState.dropNode;

      if (oldDropNode && oldDropNode !== dropNode) {
        Object(utils_dom["f" /* removeClass */])(oldDropNode.$el, 'is-drop-inner');
      }

      var draggingNode = dragState.draggingNode;
      if (!draggingNode || !dropNode) return;
      var dropPrev = true;
      var dropInner = true;
      var dropNext = true;
      var userAllowDropInner = true;

      if (typeof _this.allowDrop === 'function') {
        dropPrev = _this.allowDrop(draggingNode.node, dropNode.node, 'prev');
        userAllowDropInner = dropInner = _this.allowDrop(draggingNode.node, dropNode.node, 'inner');
        dropNext = _this.allowDrop(draggingNode.node, dropNode.node, 'next');
      }

      event.dataTransfer.dropEffect = dropInner ? 'move' : 'none';

      if ((dropPrev || dropInner || dropNext) && oldDropNode !== dropNode) {
        if (oldDropNode) {
          _this.$emit('node-drag-leave', draggingNode.node, oldDropNode.node, event);
        }

        _this.$emit('node-drag-enter', draggingNode.node, dropNode.node, event);
      }

      if (dropPrev || dropInner || dropNext) {
        dragState.dropNode = dropNode;
      }

      if (dropNode.node.nextSibling === draggingNode.node) {
        dropNext = false;
      }

      if (dropNode.node.previousSibling === draggingNode.node) {
        dropPrev = false;
      }

      if (dropNode.node.contains(draggingNode.node, false)) {
        dropInner = false;
      }

      if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {
        dropPrev = false;
        dropInner = false;
        dropNext = false;
      }

      var targetPosition = dropNode.$el.getBoundingClientRect();

      var treePosition = _this.$el.getBoundingClientRect();

      var dropType;
      var prevPercent = dropPrev ? dropInner ? 0.25 : dropNext ? 0.45 : 1 : -1;
      var nextPercent = dropNext ? dropInner ? 0.75 : dropPrev ? 0.55 : 0 : 1;
      var indicatorTop = -9999;
      var distance = event.clientY - targetPosition.top;

      if (distance < targetPosition.height * prevPercent) {
        dropType = 'before';
      } else if (distance > targetPosition.height * nextPercent) {
        dropType = 'after';
      } else if (dropInner) {
        dropType = 'inner';
      } else {
        dropType = 'none';
      }

      var iconPosition = dropNode.$el.querySelector('.el-tree-node__expand-icon').getBoundingClientRect();
      var dropIndicator = _this.$refs.dropIndicator;

      if (dropType === 'before') {
        indicatorTop = iconPosition.top - treePosition.top;
      } else if (dropType === 'after') {
        indicatorTop = iconPosition.bottom - treePosition.top;
      }

      dropIndicator.style.top = indicatorTop + 'px';
      dropIndicator.style.left = iconPosition.right - treePosition.left + 'px';

      if (dropType === 'inner') {
        Object(utils_dom["a" /* addClass */])(dropNode.$el, 'is-drop-inner');
      } else {
        Object(utils_dom["f" /* removeClass */])(dropNode.$el, 'is-drop-inner');
      }

      dragState.showDropIndicator = dropType === 'before' || dropType === 'after';
      dragState.allowDrop = dragState.showDropIndicator || userAllowDropInner;
      dragState.dropType = dropType;

      _this.$emit('node-drag-over', draggingNode.node, dropNode.node, event);
    });
    this.$on('tree-node-drag-end', function (event) {
      var draggingNode = dragState.draggingNode,
          dropType = dragState.dropType,
          dropNode = dragState.dropNode;
      event.preventDefault();
      event.dataTransfer.dropEffect = 'move';

      if (draggingNode && dropNode) {
        var draggingNodeCopy = {
          data: draggingNode.node.data
        };

        if (dropType !== 'none') {
          draggingNode.node.remove();
        }

        if (dropType === 'before') {
          dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node);
        } else if (dropType === 'after') {
          dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node);
        } else if (dropType === 'inner') {
          dropNode.node.insertChild(draggingNodeCopy);
        }

        if (dropType !== 'none') {
          _this.store.registerNode(draggingNodeCopy);
        }

        Object(utils_dom["f" /* removeClass */])(dropNode.$el, 'is-drop-inner');

        _this.$emit('node-drag-end', draggingNode.node, dropNode.node, dropType, event);

        if (dropType !== 'none') {
          _this.$emit('node-drop', draggingNode.node, dropNode.node, dropType, event);
        }
      }

      if (draggingNode && !dropNode) {
        _this.$emit('node-drag-end', draggingNode.node, null, dropType, event);
      }

      dragState.showDropIndicator = false;
      dragState.draggingNode = null;
      dragState.dropNode = null;
      dragState.allowDrop = true;
    });
    this.$on('check', function (a, b) {
      if (_this.nodeKey && _this.showCheckAll && _this.showCheckbox) {
        var currentCheckedNodes = b.checkedNodes; // 当前check的节点长度在大于或等于当前节点总数目的时候，
        // 触发check事件的节点不在当前选中的节点数组中时，
        // 上述两个条件 && ；然后将值赋给isCheckedAll watch属性，以达到控制按钮文本的目的

        _this.isCheckedAll = currentCheckedNodes.length >= allNodesLength && currentCheckedNodes.indexOf(a) !== -1;
      }
    });
  },
  mounted: function mounted() {
    this.initTabIndex();
    this.$el.addEventListener('keydown', this.handleKeydown);
  },
  updated: function updated() {
    this.treeItems = this.$el.querySelectorAll('[role=treeitem]');
    this.checkboxItems = this.$el.querySelectorAll('input[type=checkbox]');
  }
});
// CONCATENATED MODULE: ./src/components/eTree/src/tree.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_treevue_type_script_lang_js_ = (treevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./src/components/eTree/src/tree.vue





/* normalize component */

var tree_component = Object(componentNormalizer["a" /* default */])(
  src_treevue_type_script_lang_js_,
  treevue_type_template_id_8aaac264_render,
  treevue_type_template_id_8aaac264_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var src_tree = (tree_component.exports);
// EXTERNAL MODULE: ./src/theme-chalk/src/tree.scss
var theme_chalk_src_tree = __webpack_require__(665);

// CONCATENATED MODULE: ./src/components/eTree/index.js


/* istanbul ignore next */

src_tree.install = function (Vue) {
  Vue.component(src_tree.name, src_tree);
};

/* harmony default export */ var eTree = (src_tree);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/containerMask/src/containerMask.vue?vue&type=template&id=26a776a4&scoped=true&
var containerMaskvue_type_template_id_26a776a4_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.ifShowMask)?_c('div',{staticClass:"ta-loading"},[_c('div',[(_vm.showLoadingIcon)?_c('ta-spin',{attrs:{"tip":_vm.text}}):_vm._e()],1)]):_vm._e()}
var containerMaskvue_type_template_id_26a776a4_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: ./src/components/containerMask/src/containerMask.vue?vue&type=template&id=26a776a4&scoped=true&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--1!./node_modules/babel-loader/lib??ref--12-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/containerMask/src/containerMask.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
/* harmony default export */ var containerMaskvue_type_script_lang_js_ = ({
  name: 'taContainerMask',
  props: {
    show: {
      type: Boolean,
      "default": false
    },
    showLoadingIcon: {
      type: Boolean,
      "default": true
    },
    text: {
      type: String,
      "default": ''
    }
  },
  data: function data() {
    return {
      ifShowMask: this.show
    };
  },
  methods: {
    showMask: function showMask() {
      this.ifShowMask = true;
    },
    hideMask: function hideMask() {
      this.ifShowMask = false;
    }
  },
  watch: {
    show: function show(now, old) {
      now && this.showMask();
      !now && this.hideMask();
    }
  }
});
// CONCATENATED MODULE: ./src/components/containerMask/src/containerMask.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_containerMaskvue_type_script_lang_js_ = (containerMaskvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/components/containerMask/src/containerMask.vue?vue&type=style&index=0&id=26a776a4&scoped=true&lang=scss&
var containerMaskvue_type_style_index_0_id_26a776a4_scoped_true_lang_scss_ = __webpack_require__(666);

// CONCATENATED MODULE: ./src/components/containerMask/src/containerMask.vue






/* normalize component */

var containerMask_component = Object(componentNormalizer["a" /* default */])(
  src_containerMaskvue_type_script_lang_js_,
  containerMaskvue_type_template_id_26a776a4_scoped_true_render,
  containerMaskvue_type_template_id_26a776a4_scoped_true_staticRenderFns,
  false,
  null,
  "26a776a4",
  null
  
)

/* harmony default export */ var containerMask = (containerMask_component.exports);
// CONCATENATED MODULE: ./src/components/containerMask/index.js


containerMask.install = function (Vue, options) {
  Vue.component(containerMask.name, containerMask);
  var maskInstance = Vue.extend(containerMask);
  var mask;

  var initInstance = function initInstance() {
    mask = new maskInstance();
    var maskEl = mask.$mount().$el;
    document.body.appendChild(maskEl);
  };

  this.$mask = {
    showMask: function showMask(options) {
      if (!mask) {
        initInstance();
      }

      if (options.text) {
        mask.text = options.text || '';
      }

      if (options.show) {
        return mask.showMask();
      } else {
        return mask.hideMask();
      }
    }
  };
};

/* harmony default export */ var components_containerMask = (containerMask);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/components/borderLayout/src/borderLayout.vue?vue&type=template&id=6be49762&scoped=true&
var borderLayoutvue_type_template_id_6be49762_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"borderLayout"},[(_vm.layoutCfg.header)?_c('div',{staticClass:"header",class:[_vm.header.showBorder?"showBorder":"",_vm.header.cssClass],style:(_vm.headerStyle)},[(_vm.header.showBar)?_c('div',{staticClass:"toolBar",style:([{height:("" + (_vm.header.barHeight))},_vm.header.toolBarStyle])},[(_vm.header.title)?_c('span',{staticClass:"title"},[_vm._v(_vm._s(_vm.header.title))]):_vm._e(),_vm._v(" "),_c('span',{staticClass:"tool"},[_vm._t("headerExtraContent")],2),_vm._v(" "),(_vm.header.expand )?_c('span',{staticClass:"expand",on:{"click":_vm.headerExpandHandler}},[_vm._v("\n         "+_vm._s(_vm.header.expandText)+"  "),_c('ta-icon',{attrs:{"type":_vm.header.state?'up':'down'}})],1):_vm._e()]):_vm._e(),_vm._v(" "),(_vm.header.state)?_c('div',{staticClass:"layoutCon",style:([{height:(" calc(100% - " + (_vm.header.showBar?("" + (_vm.header.barHeight)):"0px") + ")")},_vm.header.layoutConStyle])},[_vm._t("header")],2):_vm._e()]):_vm._e(),_vm._v(" "),(_vm.layoutCfg.left)?_c('div',{staticClass:"left",class:[_vm.left.showBorder?"showBorder":"",_vm.left.cssClass],style:(_vm.leftStyle)},[(_vm.left.showBar)?_c('div',{staticClass:"toolBar",style:([{height:("" + (_vm.left.barHeight))},_vm.left.toolBarStyle])},[(_vm.left.title && _vm.left.state)?_c('span',{staticClass:"title"},[_vm._v(_vm._s(_vm.left.title))]):_vm._e(),_vm._v(" "),(_vm.left.state)?_c('span',{staticClass:"tool"},[_vm._t("leftExtraContent")],2):_vm._e(),_vm._v(" "),(_vm.left.expand)?_c('span',{staticClass:"expand",staticStyle:{"margin-right":"0px"},on:{"click":_vm.leftExpandHandler}},[(_vm.left.state)?_c('span',[_vm._v(_vm._s(_vm.left.expandText)+"  ")]):_vm._e(),_c('ta-icon',{attrs:{"type":_vm.left.state?'left':'right'}})],1):_vm._e()]):_vm._e(),_vm._v(" "),_c('div',{staticClass:"layoutCon",style:([{height: ("calc(100% - " + (_vm.left.showBar?("" + (_vm.left.barHeight)):"0px") + ")")},_vm.left.layoutConStyle])},[(_vm.left.state)?_vm._t("left"):_vm._e()],2)]):_vm._e(),_vm._v(" "),(_vm.layoutCfg.center)?_c('div',{staticClass:"center",class:[_vm.center.showBorder?"showBorder":"",_vm.center.cssClass],style:(_vm.centerStyle)},[(_vm.center.showBar)?_c('div',{staticClass:"toolBar",style:([{height:("" + (_vm.center.barHeight))},_vm.center.toolBarStyle])},[(_vm.center.title)?_c('span',{staticClass:"title"},[_vm._v(_vm._s(_vm.center.title))]):_vm._e(),_vm._v(" "),_c('span',{staticClass:"tool"},[_vm._t("centerExtraContent")],2)]):_vm._e(),_vm._v(" "),_c('div',{staticClass:"layoutCon",style:([{height:(" calc(100% - " + (_vm.center.showBar?("" + (_vm.center.barHeight)):"0px") + ")")},_vm.center.layoutConStyle])},[_vm._t("default")],2)]):_vm._e(),_vm._v(" "),(_vm.layoutCfg.right)?_c('div',{staticClass:"right",class:[_vm.right.showBorder?"showBorder":"",_vm.right.cssClass],style:(_vm.rightStyle)},[(_vm.right.showBar)?_c('div',{staticClass:"toolBar",style:([{height:("" + (_vm.right.barHeight))},_vm.right.toolBarStyle])},[(_vm.right.title && _vm.right.state)?_c('span',{staticClass:"title"},[_vm._v(_vm._s(_vm.right.title))]):_vm._e(),_vm._v(" "),(_vm.right.state)?_c('span',{staticClass:"tool"},[_vm._t("rightExtraContent")],2):_vm._e(),_vm._v(" "),(_vm.right.expand)?_c('span',{staticClass:"expand",staticStyle:{"margin-right":"0px"},on:{"click":_vm.rightExpandHandler}},[(_vm.right.state)?_c('span',[_vm._v(_vm._s(_vm.right.expandText)+"  ")]):_vm._e(),_c('ta-icon',{attrs:{"type":_vm.right.state?'right':'left'}})],1):_vm._e()]):_vm._e(),_vm._v(" "),_c('div',{staticClass:"layoutCon",style:([{height:(" calc(100% - " + (_vm.right.showBar?("" + (_vm.right.barHeight)):"0px") + ")")},_vm.right.layoutConStyle])},[(_vm.right.state)?_vm._t("right"):_vm._e()],2)]):_vm._e(),_vm._v(" "),(_vm.layoutCfg.footer)?_c('div',{staticClass:"footer",class:[_vm.footer.showBorder?"showBorder":"",_vm.footer.cssClass],style:(_vm.footerStyle)},[(_vm.footer.showBar)?_c('div',{staticClass:"toolBar",style:([{height:("" + (_vm.footer.barHeight))},_vm.footer.toolBarStyle])},[(_vm.footer.title)?_c('span',{staticClass:"title"},[_vm._v(_vm._s(_vm.footer.title))]):_vm._e(),_vm._v(" "),_c('span',{staticClass:"tool"},[_vm._t("footerExtraContent")],2),_vm._v(" "),(_vm.footer.expand )?_c('span',{staticClass:"expand",on:{"click":_vm.footerExpandHandler}},[_vm._v("\n         "+_vm._s(_vm.footer.expandText)+"  "),_c('ta-icon',{attrs:{"type":_vm.footer.state?'down':'up'}})],1):_vm._e()]):_vm._e(),_vm._v(" "),(_vm.footer.state)?_c('div',{staticClass:"layoutCon",style:([{height:(" calc(100% - " + (_vm.footer.showBar?("" + (_vm.footer.barHeight)):"0px") + ")")},_vm.footer.layoutConStyle])},[_vm._t("footer")],2):_vm._e()]):_vm._e()])}
var borderLayoutvue_type_template_id_6be49762_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: ./src/components/borderLayout/src/borderLayout.vue?vue&type=template&id=6be49762&scoped=true&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--1!./node_modules/babel-loader/lib??ref--12-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/borderLayout/src/borderLayout.vue?vue&type=script&lang=js&
function borderLayoutvue_type_script_lang_js_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      borderLayoutvue_type_script_lang_js_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function borderLayoutvue_type_script_lang_js_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
} //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var borderLayoutvue_type_script_lang_js_ = ({
  name: "taBorderLayout",
  props: {
    //布局配置
    layout: {
      type: Object,
      "default": function _default() {
        return {};
      }
    },
    //header配置
    headerCfg: {
      type: Object,
      "default": function _default() {
        return {};
      }
    },
    //left配置
    leftCfg: {
      type: Object,
      "default": function _default() {
        return {};
      }
    },
    centerCfg: {
      type: Object,
      "default": function _default() {
        return {};
      }
    },
    //right配置
    rightCfg: {
      type: Object,
      "default": function _default() {
        return {};
      }
    },
    footerCfg: {
      type: Object,
      "default": function _default() {
        return {};
      }
    }
  },
  data: function data() {
    var defLayout = {
      header: false,
      left: false,
      center: true,
      right: false,
      footer: false
    };
    var defCfg = {
      title: "",
      //是否显示expand按钮
      expand: false,
      expandText: 'more',
      showBar: false,
      barHeight: '62px',
      state: true,
      //是否是展开状态
      showBorder: true,
      //是否显示灰色隔开框,默认显示
      cssClass: '',
      //css
      toolBarStyle: {},
      //工具条的样式
      layoutConStyle: {},
      //容器的样式
      style: {},
      //整个框框的样式
      expandCallback: function expandCallback() {//点击按钮收起或者展开的回调
      }
    };
    return {
      layoutCfg: borderLayoutvue_type_script_lang_js_objectSpread({}, defLayout, this.layout),
      defLayout: borderLayoutvue_type_script_lang_js_objectSpread({}, defLayout, this.layout),
      header: borderLayoutvue_type_script_lang_js_objectSpread({}, defCfg, this.headerCfg),
      left: borderLayoutvue_type_script_lang_js_objectSpread({}, defCfg, this.leftCfg),
      right: borderLayoutvue_type_script_lang_js_objectSpread({}, defCfg, this.rightCfg),
      center: borderLayoutvue_type_script_lang_js_objectSpread({
        title: "",
        showBar: false,
        showBorder: true,
        //是否显示灰色隔开框,默认显示
        barHeight: '62px',
        style: {},
        expandCallback: function expandCallback() {}
      }, this.centerCfg),
      footer: borderLayoutvue_type_script_lang_js_objectSpread({}, defCfg, this.footerCfg)
    };
  },
  computed: {
    headerStyle: function headerStyle() {
      return borderLayoutvue_type_script_lang_js_objectSpread({
        top: "0px",
        height: this.checkCfgData(this.layoutCfg.header),
        width: '100%'
      }, this.header.style);
    },
    leftStyle: function leftStyle() {
      return borderLayoutvue_type_script_lang_js_objectSpread({
        top: this.checkCfgData(this.layoutCfg.header),
        bottom: "0px",
        left: "0px",
        width: this.checkCfgData(this.layoutCfg.left)
      }, this.left.style);
    },
    rightStyle: function rightStyle() {
      return borderLayoutvue_type_script_lang_js_objectSpread({
        top: this.checkCfgData(this.layoutCfg.header),
        bottom: this.checkCfgData(this.layoutCfg.footer),
        right: '0px',
        width: this.checkCfgData(this.layoutCfg.right)
      }, this.right.style);
    },
    centerStyle: function centerStyle() {
      return borderLayoutvue_type_script_lang_js_objectSpread({
        top: this.checkCfgData(this.layoutCfg.header),
        bottom: this.checkCfgData(this.layoutCfg.footer),
        left: this.checkCfgData(this.layoutCfg.left),
        right: this.checkCfgData(this.layoutCfg.right)
      }, this.center.style);
    },
    footerStyle: function footerStyle() {
      return borderLayoutvue_type_script_lang_js_objectSpread({
        bottom: "0px",
        left: this.checkCfgData(this.layoutCfg.left),
        right: '0px',
        height: this.checkCfgData(this.layoutCfg.footer)
      }, this.footer.style);
    }
  },
  created: function created() {
    this.initState();
  },
  methods: {
    //初始化状态
    initState: function initState() {
      this.header.state === false && (this.layoutCfg.header = this.header.barHeight);
      this.left.state === false && (this.layoutCfg.left = "35px");
      this.right.state === false && (this.layoutCfg.right = "35px");
      this.footer.state === false && (this.layoutCfg.footer = this.footer.barHeight);
    },
    //header expand
    headerExpandHandler: function headerExpandHandler() {
      this.header.state = !this.header.state;

      if (this.header.state) {
        this.layoutCfg.header = this.layout.header || this.defLayout.header;
      } else {
        this.layoutCfg.header = this.header.barHeight;
      }

      if (typeof this.header.expandCallback == "function") {
        this.header.expandCallback(this.header.state);
      }
    },
    leftExpandHandler: function leftExpandHandler() {
      this.left.state = !this.left.state;

      if (this.left.state) {
        this.layoutCfg.left = this.layout.left || this.defLayout.left;
      } else {
        this.layoutCfg.left = "35px";
      }

      if (typeof this.left.expandCallback == "function") {
        this.left.expandCallback(this.left.state);
      }
    },
    rightExpandHandler: function rightExpandHandler() {
      this.right.state = !this.right.state;

      if (this.right.state) {
        this.layoutCfg.right = this.layout.right || this.defLayout.right;
      } else {
        this.layoutCfg.right = "35px";
      }

      if (typeof this.right.expandCallback == "function") {
        this.right.expandCallback(this.right.state);
      }
    },
    footerExpandHandler: function footerExpandHandler() {
      this.footer.state = !this.footer.state;

      if (this.footer.state) {
        this.layoutCfg.footer = this.layout.footer || this.defLayout.footer;
      } else {
        this.layoutCfg.footer = this.footer.barHeight;
      }

      if (typeof this.footer.expandCallback == "function") {
        this.footer.expandCallback(this.footer.state);
      }
    },
    //检查配置过来的数据是否正确
    checkCfgData: function checkCfgData(data) {
      return !isNaN(parseInt(data)) ? data : '0px';
    }
  }
});
// CONCATENATED MODULE: ./src/components/borderLayout/src/borderLayout.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_borderLayoutvue_type_script_lang_js_ = (borderLayoutvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/components/borderLayout/src/borderLayout.vue?vue&type=style&index=0&id=6be49762&scoped=true&lang=scss&
var borderLayoutvue_type_style_index_0_id_6be49762_scoped_true_lang_scss_ = __webpack_require__(667);

// CONCATENATED MODULE: ./src/components/borderLayout/src/borderLayout.vue






/* normalize component */

var borderLayout_component = Object(componentNormalizer["a" /* default */])(
  src_borderLayoutvue_type_script_lang_js_,
  borderLayoutvue_type_template_id_6be49762_scoped_true_render,
  borderLayoutvue_type_template_id_6be49762_scoped_true_staticRenderFns,
  false,
  null,
  "6be49762",
  null
  
)

/* harmony default export */ var borderLayout = (borderLayout_component.exports);
// CONCATENATED MODULE: ./src/components/borderLayout/index.js

/* istanbul ignore next */

borderLayout.install = function (Vue) {
  Vue.component(borderLayout.name, borderLayout);
};

/* harmony default export */ var components_borderLayout = (borderLayout);
// CONCATENATED MODULE: ./src/index.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "install", function() { return src_install; });
/* concated harmony reexport formUtil */__webpack_require__.d(__webpack_exports__, "formUtil", function() { return form_util["a" /* default */]; });
/* concated harmony reexport toolUtil */__webpack_require__.d(__webpack_exports__, "toolUtil", function() { return tool_util["a" /* default */]; });
/* concated harmony reexport windowUtil */__webpack_require__.d(__webpack_exports__, "windowUtil", function() { return window_util; });
/* concated harmony reexport globalUtil */__webpack_require__.d(__webpack_exports__, "globalUtil", function() { return global_util["a" /* default */]; });
/* concated harmony reexport version */__webpack_require__.d(__webpack_exports__, "version", function() { return version; });
/* concated harmony reexport notification */__webpack_require__.d(__webpack_exports__, "notification", function() { return notification; });
/* concated harmony reexport Button */__webpack_require__.d(__webpack_exports__, "Button", function() { return components_button; });
/* concated harmony reexport Input */__webpack_require__.d(__webpack_exports__, "Input", function() { return components_input; });
/* concated harmony reexport Affix */__webpack_require__.d(__webpack_exports__, "Affix", function() { return components_affix; });
/* concated harmony reexport Anchor */__webpack_require__.d(__webpack_exports__, "Anchor", function() { return components_anchor; });
/* concated harmony reexport AutoComplete */__webpack_require__.d(__webpack_exports__, "AutoComplete", function() { return auto_complete; });
/* concated harmony reexport Alert */__webpack_require__.d(__webpack_exports__, "Alert", function() { return components_alert; });
/* concated harmony reexport Avatar */__webpack_require__.d(__webpack_exports__, "Avatar", function() { return components_avatar; });
/* concated harmony reexport BackTop */__webpack_require__.d(__webpack_exports__, "BackTop", function() { return back_top; });
/* concated harmony reexport Badge */__webpack_require__.d(__webpack_exports__, "Badge", function() { return badge; });
/* concated harmony reexport Breadcrumb */__webpack_require__.d(__webpack_exports__, "Breadcrumb", function() { return breadcrumb; });
/* concated harmony reexport Calendar */__webpack_require__.d(__webpack_exports__, "Calendar", function() { return components_calendar; });
/* concated harmony reexport Card */__webpack_require__.d(__webpack_exports__, "Card", function() { return card; });
/* concated harmony reexport colorPicker */__webpack_require__.d(__webpack_exports__, "colorPicker", function() { return color_picker; });
/* concated harmony reexport Collapse */__webpack_require__.d(__webpack_exports__, "Collapse", function() { return collapse; });
/* concated harmony reexport Carousel */__webpack_require__.d(__webpack_exports__, "Carousel", function() { return carousel; });
/* concated harmony reexport Cascader */__webpack_require__.d(__webpack_exports__, "Cascader", function() { return cascader; });
/* concated harmony reexport Checkbox */__webpack_require__.d(__webpack_exports__, "Checkbox", function() { return components_checkbox; });
/* concated harmony reexport Col */__webpack_require__.d(__webpack_exports__, "Col", function() { return components_col; });
/* concated harmony reexport DatePicker */__webpack_require__.d(__webpack_exports__, "DatePicker", function() { return date_picker; });
/* concated harmony reexport Divider */__webpack_require__.d(__webpack_exports__, "Divider", function() { return divider; });
/* concated harmony reexport Dropdown */__webpack_require__.d(__webpack_exports__, "Dropdown", function() { return components_dropdown; });
/* concated harmony reexport Form */__webpack_require__.d(__webpack_exports__, "Form", function() { return components_form; });
/* concated harmony reexport Icon */__webpack_require__.d(__webpack_exports__, "Icon", function() { return components_icon; });
/* concated harmony reexport InputNumber */__webpack_require__.d(__webpack_exports__, "InputNumber", function() { return input_number; });
/* concated harmony reexport Layout */__webpack_require__.d(__webpack_exports__, "Layout", function() { return components_layout; });
/* concated harmony reexport List */__webpack_require__.d(__webpack_exports__, "List", function() { return components_list; });
/* concated harmony reexport LocaleProvider */__webpack_require__.d(__webpack_exports__, "LocaleProvider", function() { return locale_provider; });
/* concated harmony reexport message */__webpack_require__.d(__webpack_exports__, "message", function() { return components_message; });
/* concated harmony reexport Menu */__webpack_require__.d(__webpack_exports__, "Menu", function() { return components_menu; });
/* concated harmony reexport Modal */__webpack_require__.d(__webpack_exports__, "Modal", function() { return modal; });
/* concated harmony reexport Pagination */__webpack_require__.d(__webpack_exports__, "Pagination", function() { return components_pagination; });
/* concated harmony reexport Popconfirm */__webpack_require__.d(__webpack_exports__, "Popconfirm", function() { return popconfirm; });
/* concated harmony reexport Progress */__webpack_require__.d(__webpack_exports__, "Progress", function() { return components_progress; });
/* concated harmony reexport Radio */__webpack_require__.d(__webpack_exports__, "Radio", function() { return components_radio; });
/* concated harmony reexport Rate */__webpack_require__.d(__webpack_exports__, "Rate", function() { return rate; });
/* concated harmony reexport Row */__webpack_require__.d(__webpack_exports__, "Row", function() { return components_row; });
/* concated harmony reexport Select */__webpack_require__.d(__webpack_exports__, "Select", function() { return components_select; });
/* concated harmony reexport Slider */__webpack_require__.d(__webpack_exports__, "Slider", function() { return slider; });
/* concated harmony reexport Spin */__webpack_require__.d(__webpack_exports__, "Spin", function() { return spin; });
/* concated harmony reexport Steps */__webpack_require__.d(__webpack_exports__, "Steps", function() { return steps; });
/* concated harmony reexport Switch */__webpack_require__.d(__webpack_exports__, "Switch", function() { return components_switch; });
/* concated harmony reexport Table */__webpack_require__.d(__webpack_exports__, "Table", function() { return components_table; });
/* concated harmony reexport Transfer */__webpack_require__.d(__webpack_exports__, "Transfer", function() { return transfer; });
/* concated harmony reexport Tree */__webpack_require__.d(__webpack_exports__, "Tree", function() { return tree; });
/* concated harmony reexport TreeSelect */__webpack_require__.d(__webpack_exports__, "TreeSelect", function() { return tree_select; });
/* concated harmony reexport Tabs */__webpack_require__.d(__webpack_exports__, "Tabs", function() { return components_tabs; });
/* concated harmony reexport Tag */__webpack_require__.d(__webpack_exports__, "Tag", function() { return components_tag; });
/* concated harmony reexport TimePicker */__webpack_require__.d(__webpack_exports__, "TimePicker", function() { return time_picker; });
/* concated harmony reexport Timeline */__webpack_require__.d(__webpack_exports__, "Timeline", function() { return timeline; });
/* concated harmony reexport Tooltip */__webpack_require__.d(__webpack_exports__, "Tooltip", function() { return tooltip; });
/* concated harmony reexport Upload */__webpack_require__.d(__webpack_exports__, "Upload", function() { return components_upload; });
/* concated harmony reexport Drawer */__webpack_require__.d(__webpack_exports__, "Drawer", function() { return drawer; });
/* concated harmony reexport TaETree */__webpack_require__.d(__webpack_exports__, "TaETree", function() { return eTree; });
/* concated harmony reexport borderLayout */__webpack_require__.d(__webpack_exports__, "borderLayout", function() { return components_borderLayout; });
/* concated harmony reexport containerMask */__webpack_require__.d(__webpack_exports__, "containerMask", function() { return components_containerMask; });
function src_objectSpread_0(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      src_defineProperty_0(target, key, source[key]);
    });
  }

  return target;
}

function src_defineProperty_0(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

 // 引入组件




 // ant 样式

 // ant组件

































 // import { default as Popover } from './components/popover'

























var src_components = [// ant组件
components_affix, components_anchor, auto_complete, components_alert, components_avatar, back_top, badge, breadcrumb, components_button, components_calendar, card, color_picker, collapse, carousel, cascader, components_checkbox, components_col, date_picker, divider, components_dropdown, components_form, components_icon, components_input, input_number, components_layout, components_list, locale_provider, components_menu, modal, components_pagination, popconfirm, // Popover,
components_progress, components_radio, rate, components_row, components_select, slider, spin, steps, components_switch, components_table, transfer, tree, tree_select, components_tabs, components_tag, time_picker, timeline, tooltip, components_upload, drawer, eTree, components_borderLayout, components_containerMask];

var src_install = function install(Vue) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (install.installed) return;
  src_components.forEach(function (component) {
    // Vue.component(component.name, component);
    Vue.use(component);
  });
  Vue.prototype.Base = src_objectSpread_0({}, form_util["a" /* default */], window_util, components_containerMask.$mask);
  Vue.prototype.Tool = tool_util["a" /* default */];
  Vue.prototype.Global = global_util["a" /* default */];
  Vue.prototype.$message = components_message;
  Vue.prototype.$notification = notification;
  Vue.prototype.$info = modal.info;
  Vue.prototype.$success = modal.success;
  Vue.prototype.$error = modal.error;
  Vue.prototype.$warning = modal.warning;
  Vue.prototype.$confirm = modal.confirm;
  window.message = components_message;
  window.notification = notification;
  window.Modal = modal;
  window.Base = Vue.prototype.Base;
};
/* istanbul ignore if */


if (typeof window !== 'undefined' && window.Vue) {
  src_install(window.Vue);
}


/* harmony default export */ var src_0 = __webpack_exports__["default"] = ({
  version: version,
  install: src_install
});

/***/ }),
/* 973 */,
/* 974 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/json2mq/index.js
var json2mq = __webpack_require__(192);
var json2mq_default = /*#__PURE__*/__webpack_require__.n(json2mq);

// EXTERNAL MODULE: external "Vue"
var external_Vue_ = __webpack_require__(10);
var external_Vue_default = /*#__PURE__*/__webpack_require__.n(external_Vue_);

// EXTERNAL MODULE: ./src/components/_util/antRefDirective.js
var antRefDirective = __webpack_require__(48);

// EXTERNAL MODULE: ./src/components/_util/BaseMixin.js
var BaseMixin = __webpack_require__(3);

// EXTERNAL MODULE: ./src/components/_util/vnode.js
var vnode = __webpack_require__(8);

// EXTERNAL MODULE: ./src/components/_util/props-util.js
var props_util = __webpack_require__(1);

// EXTERNAL MODULE: ./node_modules/lodash/debounce.js
var debounce = __webpack_require__(42);
var debounce_default = /*#__PURE__*/__webpack_require__.n(debounce);

// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(4);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: ./src/components/_util/vue-types/index.js
var vue_types = __webpack_require__(0);

// CONCATENATED MODULE: ./src/components/vc-slick/src/default-props.js

var defaultProps = {
  accessibility: vue_types["a" /* default */].bool.def(true),
  // 自定义高度
  adaptiveHeight: vue_types["a" /* default */].bool.def(false),
  afterChange: vue_types["a" /* default */].any.def(null),
  arrows: vue_types["a" /* default */].bool.def(true),
  autoplay: vue_types["a" /* default */].bool.def(false),
  autoplaySpeed: vue_types["a" /* default */].number.def(3000),
  beforeChange: vue_types["a" /* default */].any.def(null),
  centerMode: vue_types["a" /* default */].bool.def(false),
  centerPadding: vue_types["a" /* default */].string.def('50px'),
  cssEase: vue_types["a" /* default */].string.def('ease'),
  dots: vue_types["a" /* default */].bool.def(false),
  dotsClass: vue_types["a" /* default */].string.def('slick-dots'),
  draggable: vue_types["a" /* default */].bool.def(true),
  unslick: vue_types["a" /* default */].bool.def(false),
  easing: vue_types["a" /* default */].string.def('linear'),
  edgeFriction: vue_types["a" /* default */].number.def(0.35),
  fade: vue_types["a" /* default */].bool.def(false),
  focusOnSelect: vue_types["a" /* default */].bool.def(false),
  infinite: vue_types["a" /* default */].bool.def(true),
  initialSlide: vue_types["a" /* default */].number.def(0),
  lazyLoad: vue_types["a" /* default */].any.def(null),
  verticalSwiping: vue_types["a" /* default */].bool.def(false),
  asNavFor: vue_types["a" /* default */].any.def(null),
  // 圆点hover是否暂停
  pauseOnDotsHover: vue_types["a" /* default */].bool.def(false),
  // focus是否暂停
  pauseOnFocus: vue_types["a" /* default */].bool.def(false),
  // hover是否暂停
  pauseOnHover: vue_types["a" /* default */].bool.def(true),
  responsive: vue_types["a" /* default */].any.def(null),
  rows: vue_types["a" /* default */].number.def(1),
  rtl: vue_types["a" /* default */].bool.def(false),
  slide: vue_types["a" /* default */].string.def('div'),
  slidesPerRow: vue_types["a" /* default */].number.def(1),
  slidesToScroll: vue_types["a" /* default */].number.def(1),
  slidesToShow: vue_types["a" /* default */].number.def(1),
  speed: vue_types["a" /* default */].number.def(500),
  swipe: vue_types["a" /* default */].bool.def(true),
  swipeEvent: vue_types["a" /* default */].any.def(null),
  swipeToSlide: vue_types["a" /* default */].bool.def(false),
  touchMove: vue_types["a" /* default */].bool.def(true),
  touchThreshold: vue_types["a" /* default */].number.def(5),
  useCSS: vue_types["a" /* default */].bool.def(true),
  useTransform: vue_types["a" /* default */].bool.def(true),
  variableWidth: vue_types["a" /* default */].bool.def(false),
  vertical: vue_types["a" /* default */].bool.def(false),
  waitForAnimate: vue_types["a" /* default */].bool.def(true),
  children: vue_types["a" /* default */].array,
  __propsSymbol__: vue_types["a" /* default */].any
};
/* harmony default export */ var default_props = (defaultProps);
// CONCATENATED MODULE: ./src/components/vc-slick/src/initial-state.js
var initialState = {
  animating: false,
  autoplaying: null,
  currentDirection: 0,
  currentLeft: null,
  currentSlide: 0,
  direction: 1,
  dragging: false,
  edgeDragged: false,
  initialized: false,
  lazyLoadedList: [],
  listHeight: null,
  listWidth: null,
  scrolling: false,
  slideCount: null,
  slideHeight: null,
  slideWidth: null,
  swipeLeft: null,
  swiped: false,
  // used by swipeEvent. differentites between touch and swipe.
  swiping: false,
  touchObject: {
    startX: 0,
    startY: 0,
    curX: 0,
    curY: 0
  },
  trackStyle: {},
  trackWidth: 0
};
/* harmony default export */ var initial_state = (initialState);
// CONCATENATED MODULE: ./src/components/vc-slick/src/utils/innerSliderUtils.js
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var getOnDemandLazySlides = function getOnDemandLazySlides(spec) {
  var onDemandSlides = [];
  var startIndex = lazyStartIndex(spec);
  var endIndex = lazyEndIndex(spec);

  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {
    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {
      onDemandSlides.push(slideIndex);
    }
  }

  return onDemandSlides;
}; // return list of slides that need to be present

var getRequiredLazySlides = function getRequiredLazySlides(spec) {
  var requiredSlides = [];
  var startIndex = lazyStartIndex(spec);
  var endIndex = lazyEndIndex(spec);

  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {
    requiredSlides.push(slideIndex);
  }

  return requiredSlides;
}; // startIndex that needs to be present

var lazyStartIndex = function lazyStartIndex(spec) {
  return spec.currentSlide - lazySlidesOnLeft(spec);
};
var lazyEndIndex = function lazyEndIndex(spec) {
  return spec.currentSlide + lazySlidesOnRight(spec);
};
var lazySlidesOnLeft = function lazySlidesOnLeft(spec) {
  return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;
};
var lazySlidesOnRight = function lazySlidesOnRight(spec) {
  return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;
}; // get width of an element

var getWidth = function getWidth(elem) {
  return elem && elem.offsetWidth || 0;
};
var getHeight = function getHeight(elem) {
  return elem && elem.offsetHeight || 0;
};
var getSwipeDirection = function getSwipeDirection(touchObject) {
  var verticalSwiping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var swipeAngle;
  var xDist = touchObject.startX - touchObject.curX;
  var yDist = touchObject.startY - touchObject.curY;
  var r = Math.atan2(yDist, xDist);
  swipeAngle = Math.round(r * 180 / Math.PI);

  if (swipeAngle < 0) {
    swipeAngle = 360 - Math.abs(swipeAngle);
  }

  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {
    return 'left';
  }

  if (swipeAngle >= 135 && swipeAngle <= 225) {
    return 'right';
  }

  if (verticalSwiping === true) {
    if (swipeAngle >= 35 && swipeAngle <= 135) {
      return 'up';
    } else {
      return 'down';
    }
  }

  return 'vertical';
}; // whether or not we can go next

var canGoNext = function canGoNext(spec) {
  var canGo = true;

  if (!spec.infinite) {
    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {
      canGo = false;
    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {
      canGo = false;
    }
  }

  return canGo;
}; // given an object and a list of keys, return new object with given keys

var extractObject = function extractObject(spec, keys) {
  var newObject = {};
  keys.forEach(function (key) {
    return newObject[key] = spec[key];
  });
  return newObject;
}; // get initialized state

var initializedState = function initializedState(spec) {
  // spec also contains listRef, trackRef
  var slideCount = spec.children.length;
  var listWidth = Math.ceil(getWidth(spec.listRef));
  var trackWidth = Math.ceil(getWidth(spec.trackRef));
  var slideWidth;

  if (!spec.vertical) {
    var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;

    if (typeof spec.centerPadding === 'string' && spec.centerPadding.slice(-1) === '%') {
      centerPaddingAdj *= listWidth / 100;
    }

    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);
  } else {
    slideWidth = listWidth;
  }

  var slideHeight = spec.listRef && getHeight(spec.listRef.querySelector('[data-index="0"]'));
  var listHeight = slideHeight * spec.slidesToShow;
  var currentSlide = spec.currentSlide === undefined ? spec.initialSlide : spec.currentSlide;

  if (spec.rtl && spec.currentSlide === undefined) {
    currentSlide = slideCount - 1 - spec.initialSlide;
  }

  var lazyLoadedList = spec.lazyLoadedList || [];
  var slidesToLoad = getOnDemandLazySlides({
    currentSlide: currentSlide,
    lazyLoadedList: lazyLoadedList
  }, spec);
  lazyLoadedList.concat(slidesToLoad);
  var state = {
    slideCount: slideCount,
    slideWidth: slideWidth,
    listWidth: listWidth,
    trackWidth: trackWidth,
    currentSlide: currentSlide,
    slideHeight: slideHeight,
    listHeight: listHeight,
    lazyLoadedList: lazyLoadedList
  };

  if (spec.autoplaying === null && spec.autoplay) {
    state['autoplaying'] = 'playing';
  }

  return state;
};
var innerSliderUtils_slideHandler = function slideHandler(spec) {
  var waitForAnimate = spec.waitForAnimate,
      animating = spec.animating,
      fade = spec.fade,
      infinite = spec.infinite,
      index = spec.index,
      slideCount = spec.slideCount,
      lazyLoadedList = spec.lazyLoadedList,
      lazyLoad = spec.lazyLoad,
      currentSlide = spec.currentSlide,
      centerMode = spec.centerMode,
      slidesToScroll = spec.slidesToScroll,
      slidesToShow = spec.slidesToShow,
      useCSS = spec.useCSS;
  if (waitForAnimate && animating) return {};
  var animationSlide = index;
  var finalSlide;
  var animationLeft;
  var finalLeft;
  var state = {};
  var nextState = {};

  if (fade) {
    if (!infinite && (index < 0 || index >= slideCount)) return {};

    if (index < 0) {
      animationSlide = index + slideCount;
    } else if (index >= slideCount) {
      animationSlide = index - slideCount;
    }

    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {
      lazyLoadedList.push(animationSlide);
    }

    state = {
      animating: true,
      currentSlide: animationSlide,
      lazyLoadedList: lazyLoadedList
    };
    nextState = {
      animating: false
    };
  } else {
    finalSlide = animationSlide;

    if (animationSlide < 0) {
      finalSlide = animationSlide + slideCount;
      if (!infinite) finalSlide = 0;else if (slideCount % slidesToScroll !== 0) {
        finalSlide = slideCount - slideCount % slidesToScroll;
      }
    } else if (!canGoNext(spec) && animationSlide > currentSlide) {
      animationSlide = finalSlide = currentSlide;
    } else if (centerMode && animationSlide >= slideCount) {
      animationSlide = infinite ? slideCount : slideCount - 1;
      finalSlide = infinite ? 0 : slideCount - 1;
    } else if (animationSlide >= slideCount) {
      finalSlide = animationSlide - slideCount;
      if (!infinite) finalSlide = slideCount - slidesToShow;else if (slideCount % slidesToScroll !== 0) finalSlide = 0;
    }

    animationLeft = getTrackLeft(_objectSpread({}, spec, {
      slideIndex: animationSlide
    }));
    finalLeft = getTrackLeft(_objectSpread({}, spec, {
      slideIndex: finalSlide
    }));

    if (!infinite) {
      if (animationLeft === finalLeft) animationSlide = finalSlide;
      animationLeft = finalLeft;
    }

    lazyLoad && lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread({}, spec, {
      currentSlide: animationSlide
    })));

    if (!useCSS) {
      state = {
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_objectSpread({}, spec, {
          left: finalLeft
        })),
        lazyLoadedList: lazyLoadedList
      };
    } else {
      state = {
        animating: true,
        currentSlide: finalSlide,
        trackStyle: getTrackAnimateCSS(_objectSpread({}, spec, {
          left: animationLeft
        })),
        lazyLoadedList: lazyLoadedList
      };
      nextState = {
        animating: false,
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_objectSpread({}, spec, {
          left: finalLeft
        })),
        swipeLeft: null
      };
    }
  }

  return {
    state: state,
    nextState: nextState
  };
};
var innerSliderUtils_changeSlide = function changeSlide(spec, options) {
  var previousInt, slideOffset, targetSlide;
  var slidesToScroll = spec.slidesToScroll,
      slidesToShow = spec.slidesToShow,
      slideCount = spec.slideCount,
      currentSlide = spec.currentSlide,
      lazyLoad = spec.lazyLoad,
      infinite = spec.infinite;
  var unevenOffset = slideCount % slidesToScroll !== 0;
  var indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;

  if (options.message === 'previous') {
    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;
    targetSlide = currentSlide - slideOffset;

    if (lazyLoad && !infinite) {
      previousInt = currentSlide - slideOffset;
      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;
    }
  } else if (options.message === 'next') {
    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;
    targetSlide = currentSlide + slideOffset;

    if (lazyLoad && !infinite) {
      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;
    }
  } else if (options.message === 'dots') {
    // Click on dots
    targetSlide = options.index * options.slidesToScroll;

    if (targetSlide === options.currentSlide) {
      return null;
    }
  } else if (options.message === 'children') {
    // Click on the slides
    targetSlide = options.index;

    if (targetSlide === options.currentSlide) {
      return null;
    }

    if (infinite) {
      var direction = siblingDirection(_objectSpread({}, spec, {
        targetSlide: targetSlide
      }));

      if (targetSlide > options.currentSlide && direction === 'left') {
        targetSlide = targetSlide - slideCount;
      } else if (targetSlide < options.currentSlide && direction === 'right') {
        targetSlide = targetSlide + slideCount;
      }
    }
  } else if (options.message === 'index') {
    targetSlide = Number(options.index);

    if (targetSlide === options.currentSlide) {
      return null;
    }
  }

  return targetSlide;
};
var innerSliderUtils_keyHandler = function keyHandler(e, accessibility, rtl) {
  if (e.target.tagName.match('TEXTAREA|INPUT|SELECT') || !accessibility) {
    return '';
  }

  if (e.keyCode === 37) return rtl ? 'next' : 'previous';
  if (e.keyCode === 39) return rtl ? 'previous' : 'next';
  return '';
};
var innerSliderUtils_swipeStart = function swipeStart(e, swipe, draggable) {
  e.target.tagName === 'IMG' && e.preventDefault();
  if (!swipe || !draggable && e.type.indexOf('mouse') !== -1) return '';
  return {
    dragging: true,
    touchObject: {
      startX: e.touches ? e.touches[0].pageX : e.clientX,
      startY: e.touches ? e.touches[0].pageY : e.clientY,
      curX: e.touches ? e.touches[0].pageX : e.clientX,
      curY: e.touches ? e.touches[0].pageY : e.clientY
    }
  };
};
var innerSliderUtils_swipeMove = function swipeMove(e, spec) {
  // spec also contains, trackRef and slideIndex
  var scrolling = spec.scrolling,
      animating = spec.animating,
      vertical = spec.vertical,
      swipeToSlide = spec.swipeToSlide,
      verticalSwiping = spec.verticalSwiping,
      rtl = spec.rtl,
      currentSlide = spec.currentSlide,
      edgeFriction = spec.edgeFriction,
      edgeDragged = spec.edgeDragged,
      onEdge = spec.onEdge,
      swiped = spec.swiped,
      swiping = spec.swiping,
      slideCount = spec.slideCount,
      slidesToScroll = spec.slidesToScroll,
      infinite = spec.infinite,
      touchObject = spec.touchObject,
      swipeEvent = spec.swipeEvent,
      listHeight = spec.listHeight,
      listWidth = spec.listWidth;
  if (scrolling) return;
  if (animating) return e.preventDefault();
  if (vertical && swipeToSlide && verticalSwiping) e.preventDefault();
  var swipeLeft;
  var state = {};
  var curLeft = getTrackLeft(spec);
  touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;
  touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;
  touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));
  var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));

  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {
    return {
      scrolling: true
    };
  }

  if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;
  var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);

  if (verticalSwiping) {
    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;
  }

  var dotCount = Math.ceil(slideCount / slidesToScroll);
  var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);
  var touchSwipeLength = touchObject.swipeLength;

  if (!infinite) {
    if (currentSlide === 0 && swipeDirection === 'right' || currentSlide + 1 >= dotCount && swipeDirection === 'left' || !canGoNext(spec) && swipeDirection === 'left') {
      touchSwipeLength = touchObject.swipeLength * edgeFriction;

      if (edgeDragged === false && onEdge) {
        onEdge(swipeDirection);
        state['edgeDragged'] = true;
      }
    }
  }

  if (!swiped && swipeEvent) {
    swipeEvent(swipeDirection);
    state['swiped'] = true;
  }

  if (!vertical) {
    if (!rtl) {
      swipeLeft = curLeft + touchSwipeLength * positionOffset;
    } else {
      swipeLeft = curLeft - touchSwipeLength * positionOffset;
    }
  } else {
    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;
  }

  if (verticalSwiping) {
    swipeLeft = curLeft + touchSwipeLength * positionOffset;
  }

  state = _objectSpread({}, state, {
    touchObject: touchObject,
    swipeLeft: swipeLeft,
    trackStyle: getTrackCSS(_objectSpread({}, spec, {
      left: swipeLeft
    }))
  });

  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {
    return state;
  }

  if (touchObject.swipeLength > 10) {
    state['swiping'] = true;
    e.preventDefault();
  }

  return state;
};
var innerSliderUtils_swipeEnd = function swipeEnd(e, spec) {
  var dragging = spec.dragging,
      swipe = spec.swipe,
      touchObject = spec.touchObject,
      listWidth = spec.listWidth,
      touchThreshold = spec.touchThreshold,
      verticalSwiping = spec.verticalSwiping,
      listHeight = spec.listHeight,
      currentSlide = spec.currentSlide,
      swipeToSlide = spec.swipeToSlide,
      scrolling = spec.scrolling,
      onSwipe = spec.onSwipe;

  if (!dragging) {
    if (swipe) e.preventDefault();
    return {};
  }

  var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;
  var swipeDirection = getSwipeDirection(touchObject, verticalSwiping); // reset the state of touch related state variables.

  var state = {
    dragging: false,
    edgeDragged: false,
    scrolling: false,
    swiping: false,
    swiped: false,
    swipeLeft: null,
    touchObject: {}
  };

  if (scrolling) {
    return state;
  }

  if (!touchObject.swipeLength) {
    return state;
  }

  if (touchObject.swipeLength > minSwipe) {
    e.preventDefault();

    if (onSwipe) {
      onSwipe(swipeDirection);
    }

    var slideCount, newSlide;

    switch (swipeDirection) {
      case 'left':
      case 'up':
        newSlide = currentSlide + getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state['currentDirection'] = 0;
        break;

      case 'right':
      case 'down':
        newSlide = currentSlide - getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state['currentDirection'] = 1;
        break;

      default:
        slideCount = currentSlide;
    }

    state['triggerSlideHandler'] = slideCount;
  } else {
    // Adjust the track back to it's original position.
    var currentLeft = getTrackLeft(spec);
    state['trackStyle'] = getTrackAnimateCSS(_objectSpread({}, spec, {
      left: currentLeft
    }));
  }

  return state;
};
var getNavigableIndexes = function getNavigableIndexes(spec) {
  var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;
  var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;
  var counter = spec.infinite ? spec.slidesToShow * -1 : 0;
  var indexes = [];

  while (breakpoint < max) {
    indexes.push(breakpoint);
    breakpoint = counter + spec.slidesToScroll;
    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);
  }

  return indexes;
};
var checkNavigable = function checkNavigable(spec, index) {
  var navigables = getNavigableIndexes(spec);
  var prevNavigable = 0;

  if (index > navigables[navigables.length - 1]) {
    index = navigables[navigables.length - 1];
  } else {
    for (var n in navigables) {
      if (index < navigables[n]) {
        index = prevNavigable;
        break;
      }

      prevNavigable = navigables[n];
    }
  }

  return index;
};
var getSlideCount = function getSlideCount(spec) {
  var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;

  if (spec.swipeToSlide) {
    var swipedSlide;
    var slickList = spec.listRef;
    var slides = slickList.querySelectorAll('.slick-slide');
    Array.from(slides).every(function (slide) {
      if (!spec.vertical) {
        if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      } else {
        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      }

      return true;
    });

    if (!swipedSlide) {
      return 0;
    }

    var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;
    var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;
    return slidesTraversed;
  } else {
    return spec.slidesToScroll;
  }
};
var checkSpecKeys = function checkSpecKeys(spec, keysArray) {
  return keysArray.reduce(function (value, key) {
    return value && spec.hasOwnProperty(key);
  }, true) ? null : console.error('Keys Missing:', spec);
};
var getTrackCSS = function getTrackCSS(spec) {
  checkSpecKeys(spec, ['left', 'variableWidth', 'slideCount', 'slidesToShow', 'slideWidth']);
  var trackWidth, trackHeight;
  var trackChildren = spec.slideCount + 2 * spec.slidesToShow;

  if (!spec.vertical) {
    trackWidth = getTotalSlides(spec) * spec.slideWidth;
  } else {
    trackHeight = trackChildren * spec.slideHeight;
  }

  var style = {
    opacity: 1,
    transition: '',
    WebkitTransition: ''
  };

  if (spec.useTransform) {
    var WebkitTransform = !spec.vertical ? 'translate3d(' + spec.left + 'px, 0px, 0px)' : 'translate3d(0px, ' + spec.left + 'px, 0px)';
    var transform = !spec.vertical ? 'translate3d(' + spec.left + 'px, 0px, 0px)' : 'translate3d(0px, ' + spec.left + 'px, 0px)';
    var msTransform = !spec.vertical ? 'translateX(' + spec.left + 'px)' : 'translateY(' + spec.left + 'px)';
    style = _objectSpread({}, style, {
      WebkitTransform: WebkitTransform,
      transform: transform,
      msTransform: msTransform
    });
  } else {
    if (spec.vertical) {
      style['top'] = spec.left;
    } else {
      style['left'] = spec.left;
    }
  }

  if (spec.fade) style = {
    opacity: 1
  };
  if (trackWidth) style.width = trackWidth + 'px';
  if (trackHeight) style.height = trackHeight + 'px'; // Fallback for IE8

  if (window && !window.addEventListener && window.attachEvent) {
    if (!spec.vertical) {
      style.marginLeft = spec.left + 'px';
    } else {
      style.marginTop = spec.left + 'px';
    }
  }

  return style;
};
var getTrackAnimateCSS = function getTrackAnimateCSS(spec) {
  checkSpecKeys(spec, ['left', 'variableWidth', 'slideCount', 'slidesToShow', 'slideWidth', 'speed', 'cssEase']);
  var style = getTrackCSS(spec); // useCSS is true by default so it can be undefined

  if (spec.useTransform) {
    style.WebkitTransition = '-webkit-transform ' + spec.speed + 'ms ' + spec.cssEase;
    style.transition = 'transform ' + spec.speed + 'ms ' + spec.cssEase;
  } else {
    if (spec.vertical) {
      style.transition = 'top ' + spec.speed + 'ms ' + spec.cssEase;
    } else {
      style.transition = 'left ' + spec.speed + 'ms ' + spec.cssEase;
    }
  }

  return style;
};
var getTrackLeft = function getTrackLeft(spec) {
  if (spec.unslick) {
    return 0;
  }

  checkSpecKeys(spec, ['slideIndex', 'trackRef', 'infinite', 'centerMode', 'slideCount', 'slidesToShow', 'slidesToScroll', 'slideWidth', 'listWidth', 'variableWidth', 'slideHeight']);
  var slideIndex = spec.slideIndex,
      trackRef = spec.trackRef,
      infinite = spec.infinite,
      centerMode = spec.centerMode,
      slideCount = spec.slideCount,
      slidesToShow = spec.slidesToShow,
      slidesToScroll = spec.slidesToScroll,
      slideWidth = spec.slideWidth,
      listWidth = spec.listWidth,
      variableWidth = spec.variableWidth,
      slideHeight = spec.slideHeight,
      fade = spec.fade,
      vertical = spec.vertical;
  var slideOffset = 0;
  var targetLeft;
  var targetSlide;
  var verticalOffset = 0;

  if (fade || spec.slideCount === 1) {
    return 0;
  }

  var slidesToOffset = 0;

  if (infinite) {
    slidesToOffset = -getPreClones(spec); // bring active slide to the beginning of visual area
    // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting slidesToScroll children

    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);
    } // shift current slide to center of the frame


    if (centerMode) {
      slidesToOffset += parseInt(slidesToShow / 2);
    }
  } else {
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = slidesToShow - slideCount % slidesToScroll;
    }

    if (centerMode) {
      slidesToOffset = parseInt(slidesToShow / 2);
    }
  }

  slideOffset = slidesToOffset * slideWidth;
  verticalOffset = slidesToOffset * slideHeight;

  if (!vertical) {
    targetLeft = slideIndex * slideWidth * -1 + slideOffset;
  } else {
    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;
  }

  if (variableWidth === true) {
    var targetSlideIndex;
    var trackElem = trackRef;
    targetSlideIndex = slideIndex + getPreClones(spec);
    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];
    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;

    if (centerMode === true) {
      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;
      targetSlide = trackElem && trackElem.children[targetSlideIndex];
      targetLeft = 0;

      for (var slide = 0; slide < targetSlideIndex; slide++) {
        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;
      }

      targetLeft -= parseInt(spec.centerPadding);
      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;
    }
  }

  return targetLeft;
};
var getPreClones = function getPreClones(spec) {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }

  if (spec.variableWidth) {
    return spec.slideCount;
  }

  return spec.slidesToShow + (spec.centerMode ? 1 : 0);
};
var getPostClones = function getPostClones(spec) {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }

  return spec.slideCount;
};
var getTotalSlides = function getTotalSlides(spec) {
  return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);
};
var siblingDirection = function siblingDirection(spec) {
  if (spec.targetSlide > spec.currentSlide) {
    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {
      return 'left';
    }

    return 'right';
  } else {
    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {
      return 'right';
    }

    return 'left';
  }
};
var slidesOnRight = function slidesOnRight(_ref) {
  var slidesToShow = _ref.slidesToShow,
      centerMode = _ref.centerMode,
      rtl = _ref.rtl,
      centerPadding = _ref.centerPadding; // returns no of slides on the right of active slide

  if (centerMode) {
    var right = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0) right += 1;
    if (rtl && slidesToShow % 2 === 0) right += 1;
    return right;
  }

  if (rtl) {
    return 0;
  }

  return slidesToShow - 1;
};
var slidesOnLeft = function slidesOnLeft(_ref2) {
  var slidesToShow = _ref2.slidesToShow,
      centerMode = _ref2.centerMode,
      rtl = _ref2.rtl,
      centerPadding = _ref2.centerPadding; // returns no of slides on the left of active slide

  if (centerMode) {
    var left = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0) left += 1;
    if (!rtl && slidesToShow % 2 === 0) left += 1;
    return left;
  }

  if (rtl) {
    return slidesToShow - 1;
  }

  return 0;
};
var canUseDOM = function canUseDOM() {
  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
};
// CONCATENATED MODULE: ./src/components/vc-slick/src/track.js
function track_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      track_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function track_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}




 // given specifications/props for a slide, fetch all the classes that need to be applied to the slide

var getSlideClasses = function getSlideClasses(spec) {
  var slickActive, slickCenter;
  var centerOffset, index;

  if (spec.rtl) {
    index = spec.slideCount - 1 - spec.index;
  } else {
    index = spec.index;
  }

  var slickCloned = index < 0 || index >= spec.slideCount;

  if (spec.centerMode) {
    centerOffset = Math.floor(spec.slidesToShow / 2);
    slickCenter = (index - spec.currentSlide) % spec.slideCount === 0;

    if (index > spec.currentSlide - centerOffset - 1 && index <= spec.currentSlide + centerOffset) {
      slickActive = true;
    }
  } else {
    slickActive = spec.currentSlide <= index && index < spec.currentSlide + spec.slidesToShow;
  }

  var slickCurrent = index === spec.currentSlide;
  return {
    'slick-slide': true,
    'slick-active': slickActive,
    'slick-center': slickCenter,
    'slick-cloned': slickCloned,
    'slick-current': slickCurrent // dubious in case of RTL

  };
};

var getSlideStyle = function getSlideStyle(spec) {
  var style = {};

  if (spec.variableWidth === undefined || spec.variableWidth === false) {
    style.width = spec.slideWidth + (typeof spec.slideWidth === 'number' ? 'px' : '');
  }

  if (spec.fade) {
    style.position = 'relative';

    if (spec.vertical) {
      style.top = -spec.index * parseInt(spec.slideHeight) + 'px';
    } else {
      style.left = -spec.index * parseInt(spec.slideWidth) + 'px';
    }

    style.opacity = spec.currentSlide === spec.index ? 1 : 0;
    style.transition = 'opacity ' + spec.speed + 'ms ' + spec.cssEase + ', ' + 'visibility ' + spec.speed + 'ms ' + spec.cssEase;
    style.WebkitTransition = 'opacity ' + spec.speed + 'ms ' + spec.cssEase + ', ' + 'visibility ' + spec.speed + 'ms ' + spec.cssEase;
  }

  return style;
};

var getKey = function getKey(child, fallbackKey) {
  return child.key || child.key === 0 && '0' || fallbackKey;
};

var track_renderSlides = function renderSlides(spec, children, createElement) {
  var key;
  var slides = [];
  var preCloneSlides = [];
  var postCloneSlides = [];
  var childrenCount = children.length;
  var startIndex = lazyStartIndex(spec);
  var endIndex = lazyEndIndex(spec);
  children.forEach(function (elem, index) {
    var child;
    var childOnClickOptions = {
      message: 'children',
      index: index,
      slidesToScroll: spec.slidesToScroll,
      currentSlide: spec.currentSlide // in case of lazyLoad, whether or not we want to fetch the slide

    };

    if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index) >= 0) {
      child = elem;
    } else {
      child = createElement('div');
    }

    var childStyle = getSlideStyle(track_objectSpread({}, spec, {
      index: index
    }));
    var slideClass = Object(props_util["f" /* getClass */])(child.context) || '';
    var slideClasses = getSlideClasses(track_objectSpread({}, spec, {
      index: index
    })); // push a cloned element of the desired slide

    slides.push(Object(vnode["a" /* cloneElement */])(child, {
      key: 'original' + getKey(child, index),
      attrs: {
        tabIndex: '-1',
        'data-index': index,
        'aria-hidden': !slideClasses['slick-active']
      },
      "class": classnames_default()(slideClasses, slideClass),
      style: track_objectSpread({
        outline: 'none'
      }, Object(props_util["n" /* getStyle */])(child.context) || {}, childStyle),
      on: {
        click: function click(e) {
          // child.props && child.props.onClick && child.props.onClick(e)
          if (spec.focusOnSelect) {
            spec.focusOnSelect(childOnClickOptions);
          }
        }
      }
    }, true)); // if slide needs to be precloned or postcloned

    if (spec.infinite && spec.fade === false) {
      var preCloneNo = childrenCount - index;

      if (preCloneNo <= getPreClones(spec) && childrenCount !== spec.slidesToShow) {
        key = -preCloneNo;

        if (key >= startIndex) {
          child = elem;
        }

        slideClasses = getSlideClasses(track_objectSpread({}, spec, {
          index: key
        }));
        preCloneSlides.push(Object(vnode["a" /* cloneElement */])(child, {
          key: 'precloned' + getKey(child, key),
          "class": classnames_default()(slideClasses, slideClass),
          attrs: {
            tabIndex: '-1',
            'data-index': key,
            'aria-hidden': !slideClasses['slick-active']
          },
          style: track_objectSpread({}, Object(props_util["n" /* getStyle */])(child.context) || {}, childStyle),
          on: {
            click: function click(e) {
              // child.props && child.props.onClick && child.props.onClick(e)
              if (spec.focusOnSelect) {
                spec.focusOnSelect(childOnClickOptions);
              }
            }
          }
        }));
      }

      if (childrenCount !== spec.slidesToShow) {
        key = childrenCount + index;

        if (key < endIndex) {
          child = elem;
        }

        slideClasses = getSlideClasses(track_objectSpread({}, spec, {
          index: key
        }));
        postCloneSlides.push(Object(vnode["a" /* cloneElement */])(child, {
          key: 'postcloned' + getKey(child, key),
          attrs: {
            tabIndex: '-1',
            'data-index': key,
            'aria-hidden': !slideClasses['slick-active']
          },
          "class": classnames_default()(slideClasses, slideClass),
          style: track_objectSpread({}, Object(props_util["n" /* getStyle */])(child.context) || {}, childStyle),
          on: {
            click: function click(e) {
              // child.props && child.props.onClick && child.props.onClick(e)
              if (spec.focusOnSelect) {
                spec.focusOnSelect(childOnClickOptions);
              }
            }
          }
        }));
      }
    }
  });

  if (spec.rtl) {
    return preCloneSlides.concat(slides, postCloneSlides).reverse();
  } else {
    return preCloneSlides.concat(slides, postCloneSlides);
  }
};

/* harmony default export */ var track = ({
  functional: true,
  render: function render(createElement, context) {
    var h = arguments[0];
    var props = context.props,
        listeners = context.listeners,
        children = context.children,
        data = context.data;
    var slides = track_renderSlides(props, children, createElement);
    var mouseenter = listeners.mouseenter,
        mouseover = listeners.mouseover,
        mouseleave = listeners.mouseleave;
    var mouseEvents = {
      mouseenter: mouseenter,
      mouseover: mouseover,
      mouseleave: mouseleave
    };
    var trackProps = {
      "class": 'slick-track',
      style: props.trackStyle,
      on: track_objectSpread({}, mouseEvents),
      directives: data.directives
    };
    return h("div", trackProps, [slides]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-slick/src/dots.js
function dots_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      dots_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function dots_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}




var getDotCount = function getDotCount(spec) {
  var dots;

  if (spec.infinite) {
    dots = Math.ceil(spec.slideCount / spec.slidesToScroll);
  } else {
    dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;
  }

  return dots;
};

/* harmony default export */ var src_dots = ({
  functional: true,
  render: function render(createElement, context) {
    var h = arguments[0];
    var props = context.props,
        listeners = context.listeners;
    var slideCount = props.slideCount,
        slidesToScroll = props.slidesToScroll,
        slidesToShow = props.slidesToShow,
        infinite = props.infinite,
        currentSlide = props.currentSlide,
        appendDots = props.appendDots,
        customPaging = props.customPaging,
        clickHandler = props.clickHandler,
        dotsClass = props.dotsClass;
    var dotCount = getDotCount({
      slideCount: slideCount,
      slidesToScroll: slidesToScroll,
      slidesToShow: slidesToShow,
      infinite: infinite
    }); // Apply join & split to Array to pre-fill it for IE8
    //
    // Credit: http://stackoverflow.com/a/13735425/1849458

    var mouseenter = listeners.mouseenter,
        mouseover = listeners.mouseover,
        mouseleave = listeners.mouseleave;
    var mouseEvents = {
      mouseenter: mouseenter,
      mouseover: mouseover,
      mouseleave: mouseleave
    };
    var dots = Array.apply(null, Array(dotCount + 1).join('0').split('')).map(function (x, i) {
      var leftBound = i * slidesToScroll;
      var rightBound = i * slidesToScroll + (slidesToScroll - 1);
      var className = classnames_default()({
        'slick-active': currentSlide >= leftBound && currentSlide <= rightBound
      });
      var dotOptions = {
        message: 'dots',
        index: i,
        slidesToScroll: slidesToScroll,
        currentSlide: currentSlide
      };

      function onClick(e) {
        // In Autoplay the focus stays on clicked button even after transition
        // to next slide. That only goes away by click somewhere outside
        if (e) {
          e.preventDefault();
        }

        clickHandler(dotOptions);
      }

      return h("li", {
        key: i,
        "class": className
      }, [Object(vnode["a" /* cloneElement */])(customPaging({
        i: i
      }), {
        on: {
          click: onClick
        }
      })]);
    });
    return Object(vnode["a" /* cloneElement */])(appendDots({
      dots: dots
    }), {
      "class": dotsClass,
      on: dots_objectSpread({}, mouseEvents)
    });
  }
});
// EXTERNAL MODULE: ./node_modules/babel-helper-vue-jsx-merge-props/index.js
var babel_helper_vue_jsx_merge_props = __webpack_require__(5);
var babel_helper_vue_jsx_merge_props_default = /*#__PURE__*/__webpack_require__.n(babel_helper_vue_jsx_merge_props);

// CONCATENATED MODULE: ./src/components/vc-slick/src/arrows.js



function arrows_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      arrows_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function arrows_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}




function noop() {}

var PrevArrow = {
  functional: true,
  clickHandler: function clickHandler(options, handle, e) {
    if (e) {
      e.preventDefault();
    }

    handle(options, e);
  },
  render: function render(createElement, context) {
    var h = arguments[0];
    var props = context.props;
    var clickHandler = props.clickHandler,
        infinite = props.infinite,
        currentSlide = props.currentSlide,
        slideCount = props.slideCount,
        slidesToShow = props.slidesToShow;
    var prevClasses = {
      'slick-arrow': true,
      'slick-prev': true
    };

    var prevHandler = function prevHandler(e) {
      if (e) {
        e.preventDefault();
      }

      clickHandler({
        message: 'previous'
      });
    };

    if (!infinite && (currentSlide === 0 || slideCount <= slidesToShow)) {
      prevClasses['slick-disabled'] = true;
      prevHandler = noop;
    }

    var prevArrowProps = {
      key: '0',
      domProps: {
        'data-role': 'none'
      },
      "class": prevClasses,
      style: {
        display: 'block'
      },
      on: {
        click: prevHandler
      }
    };
    var customProps = {
      currentSlide: currentSlide,
      slideCount: slideCount
    };
    var prevArrow;

    if (props.prevArrow) {
      prevArrow = Object(vnode["a" /* cloneElement */])(props.prevArrow(arrows_objectSpread({}, prevArrowProps, {
        props: customProps
      })), {
        key: '0',
        "class": prevClasses,
        style: {
          display: 'block'
        },
        on: {
          click: prevHandler
        }
      });
    } else {
      prevArrow = h("button", babel_helper_vue_jsx_merge_props_default()([{
        key: '0',
        attrs: {
          type: 'button'
        }
      }, prevArrowProps]), [' ', "Previous"]);
    }

    return prevArrow;
  }
};
var NextArrow = {
  functional: true,
  clickHandler: function clickHandler(options, handle, e) {
    if (e) {
      e.preventDefault();
    }

    handle(options, e);
  },
  render: function render(createElement, context) {
    var h = arguments[0];
    var props = context.props;
    var clickHandler = props.clickHandler,
        currentSlide = props.currentSlide,
        slideCount = props.slideCount;
    var nextClasses = {
      'slick-arrow': true,
      'slick-next': true
    };

    var nextHandler = function nextHandler(e) {
      if (e) {
        e.preventDefault();
      }

      clickHandler({
        message: 'next'
      });
    };

    if (!canGoNext(props)) {
      nextClasses['slick-disabled'] = true;
      nextHandler = noop;
    }

    var nextArrowProps = {
      key: '1',
      domProps: {
        'data-role': 'none'
      },
      "class": nextClasses,
      style: {
        display: 'block'
      },
      on: {
        click: nextHandler
      }
    };
    var customProps = {
      currentSlide: currentSlide,
      slideCount: slideCount
    };
    var nextArrow;

    if (props.nextArrow) {
      nextArrow = Object(vnode["a" /* cloneElement */])(props.nextArrow(arrows_objectSpread({}, nextArrowProps, {
        props: customProps
      })), {
        key: '1',
        "class": nextClasses,
        style: {
          display: 'block'
        },
        on: {
          click: nextHandler
        }
      });
    } else {
      nextArrow = h("button", babel_helper_vue_jsx_merge_props_default()([{
        key: '1',
        attrs: {
          type: 'button'
        }
      }, nextArrowProps]), [' ', "Next"]);
    }

    return nextArrow;
  }
};
// EXTERNAL MODULE: ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var ResizeObserver_es = __webpack_require__(407);

// CONCATENATED MODULE: ./src/components/vc-slick/src/inner-slider.js
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function inner_slider_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      inner_slider_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function inner_slider_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}














external_Vue_default.a.use(antRefDirective["a" /* default */]);

function inner_slider_noop() {}

/* harmony default export */ var inner_slider = ({
  props: inner_slider_objectSpread({}, default_props),
  mixins: [BaseMixin["a" /* default */]],
  data: function data() {
    this.preProps = inner_slider_objectSpread({}, this.$props);
    this.list = null;
    this.track = null;
    this.callbackTimers = [];
    this.clickable = true;
    this.debouncedResize = null;
    return inner_slider_objectSpread({}, initial_state, {
      currentSlide: this.initialSlide,
      slideCount: this.children.length
    });
  },
  methods: {
    listRefHandler: function listRefHandler(ref) {
      this.list = ref;
    },
    trackRefHandler: function trackRefHandler(ref) {
      this.track = ref;
    },
    adaptHeight: function adaptHeight() {
      if (this.adaptiveHeight && this.list) {
        var elem = this.list.querySelector("[data-index=\"".concat(this.currentSlide, "\"]"));
        this.list.style.height = getHeight(elem) + 'px';
      }
    },
    onWindowResized: function onWindowResized(setTrackStyle) {
      var _this = this;

      if (this.debouncedResize) this.debouncedResize.cancel();
      this.debouncedResize = debounce_default()(function () {
        return _this.resizeWindow(setTrackStyle);
      }, 50);
      this.debouncedResize();
    },
    resizeWindow: function resizeWindow() {
      var _this2 = this;

      var setTrackStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (!this.track) return;

      var spec = inner_slider_objectSpread({
        listRef: this.list,
        trackRef: this.track,
        children: this.children
      }, this.$props, this.$data);

      this.updateState(spec, setTrackStyle, function () {
        if (_this2.autoplay) {
          _this2.handleAutoPlay('update');
        } else {
          _this2.pause('paused');
        }
      }); // animating state should be cleared while resizing, otherwise autoplay stops working

      this.setState({
        animating: false
      });
      clearTimeout(this.animationEndCallback);
      delete this.animationEndCallback;
    },
    updateState: function updateState(spec, setTrackStyle, callback) {
      var updatedState = initializedState(spec);
      spec = inner_slider_objectSpread({}, spec, updatedState, {
        slideIndex: updatedState.currentSlide
      });
      var targetLeft = getTrackLeft(spec);
      spec = inner_slider_objectSpread({}, spec, {
        left: targetLeft
      });
      var trackStyle = getTrackCSS(spec);

      if (setTrackStyle || this.children.length !== spec.children.length) {
        updatedState['trackStyle'] = trackStyle;
      }

      this.setState(updatedState, callback);
    },
    ssrInit: function ssrInit() {
      var children = this.children;

      if (this.variableWidth) {
        var _trackWidth = 0;
        var _trackLeft = 0;
        var childrenWidths = [];
        var preClones = getPreClones(inner_slider_objectSpread({}, this.$props, this.$data, {
          slideCount: children.length
        }));
        var postClones = getPostClones(inner_slider_objectSpread({}, this.$props, this.$data, {
          slideCount: children.length
        }));
        children.forEach(function (child) {
          var childWidth = Object(props_util["n" /* getStyle */])(child).width.split('px')[0];
          childrenWidths.push(childWidth);
          _trackWidth += childWidth;
        });

        for (var i = 0; i < preClones; i++) {
          _trackLeft += childrenWidths[childrenWidths.length - 1 - i];
          _trackWidth += childrenWidths[childrenWidths.length - 1 - i];
        }

        for (var _i = 0; _i < postClones; _i++) {
          _trackWidth += childrenWidths[_i];
        }

        for (var _i2 = 0; _i2 < this.currentSlide; _i2++) {
          _trackLeft += childrenWidths[_i2];
        }

        var _trackStyle = {
          width: _trackWidth + 'px',
          left: -_trackLeft + 'px'
        };

        if (this.centerMode) {
          var currentWidth = "".concat(childrenWidths[this.currentSlide], "px");
          _trackStyle.left = "calc(".concat(_trackStyle.left, " + (100% - ").concat(currentWidth, ") / 2 ) ");
        }

        this.setState({
          trackStyle: _trackStyle
        });
        return;
      }

      var childrenCount = children.length;

      var spec = inner_slider_objectSpread({}, this.$props, this.$data, {
        slideCount: childrenCount
      });

      var slideCount = getPreClones(spec) + getPostClones(spec) + childrenCount;
      var trackWidth = 100 / this.slidesToShow * slideCount;
      var slideWidth = 100 / slideCount;
      var trackLeft = -slideWidth * (getPreClones(spec) + this.currentSlide) * trackWidth / 100;

      if (this.centerMode) {
        trackLeft += (100 - slideWidth * trackWidth / 100) / 2;
      }

      var trackStyle = {
        width: trackWidth + '%',
        left: trackLeft + '%'
      };
      this.setState({
        slideWidth: slideWidth + '%',
        trackStyle: trackStyle
      });
    },
    checkImagesLoad: function checkImagesLoad() {
      var _this3 = this;

      var images = document.querySelectorAll('.slick-slide img');
      var imagesCount = images.length;
      var loadedCount = 0;
      Array.prototype.forEach.call(images, function (image) {
        var handler = function handler() {
          return ++loadedCount && loadedCount >= imagesCount && _this3.onWindowResized();
        };

        if (!image.onclick) {
          image.onclick = function () {
            return image.parentNode.focus();
          };
        } else {
          var prevClickHandler = image.onclick;

          image.onclick = function () {
            prevClickHandler();
            image.parentNode.focus();
          };
        }

        if (!image.onload) {
          if (_this3.$props.lazyLoad) {
            image.onload = function () {
              _this3.adaptHeight();

              _this3.callbackTimers.push(setTimeout(_this3.onWindowResized, _this3.speed));
            };
          } else {
            image.onload = handler;

            image.onerror = function () {
              handler();

              _this3.$emit('lazyLoadError');
            };
          }
        }
      });
    },
    progressiveLazyLoad: function progressiveLazyLoad() {
      var slidesToLoad = [];

      var spec = inner_slider_objectSpread({}, this.$props, this.$data);

      for (var index = this.currentSlide; index < this.slideCount + getPostClones(spec); index++) {
        if (this.lazyLoadedList.indexOf(index) < 0) {
          slidesToLoad.push(index);
          break;
        }
      }

      for (var _index = this.currentSlide - 1; _index >= -getPreClones(spec); _index--) {
        if (this.lazyLoadedList.indexOf(_index) < 0) {
          slidesToLoad.push(_index);
          break;
        }
      }

      if (slidesToLoad.length > 0) {
        this.setState(function (state) {
          return {
            lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)
          };
        });
        this.$emit('lazyLoad', slidesToLoad);
      } else {
        if (this.lazyLoadTimer) {
          clearInterval(this.lazyLoadTimer);
          delete this.lazyLoadTimer;
        }
      }
    },
    slideHandler: function slideHandler(index) {
      var _this4 = this;

      var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var _this$$props = this.$props,
          asNavFor = _this$$props.asNavFor,
          currentSlide = _this$$props.currentSlide,
          beforeChange = _this$$props.beforeChange,
          speed = _this$$props.speed,
          afterChange = _this$$props.afterChange;

      var _slideHandler2 = innerSliderUtils_slideHandler(inner_slider_objectSpread({
        index: index
      }, this.$props, this.$data, {
        trackRef: this.track,
        useCSS: this.useCSS && !dontAnimate
      })),
          state = _slideHandler2.state,
          nextState = _slideHandler2.nextState;

      if (!state) return;
      beforeChange && beforeChange(currentSlide, state.currentSlide);
      var slidesToLoad = state.lazyLoadedList.filter(function (value) {
        return _this4.lazyLoadedList.indexOf(value) < 0;
      });

      if (this.$listeners.lazyLoad && slidesToLoad.length > 0) {
        this.$emit('lazyLoad', slidesToLoad);
      }

      this.setState(state, function () {
        asNavFor && asNavFor.innerSlider.currentSlide !== currentSlide && asNavFor.innerSlider.slideHandler(index);
        if (!nextState) return;
        _this4.animationEndCallback = setTimeout(function () {
          var animating = nextState.animating,
              firstBatch = _objectWithoutProperties(nextState, ["animating"]);

          _this4.setState(firstBatch, function () {
            _this4.callbackTimers.push(setTimeout(function () {
              return _this4.setState({
                animating: animating
              });
            }, 10));

            afterChange && afterChange(state.currentSlide);
            delete _this4.animationEndCallback;
          });
        }, speed);
      });
    },
    changeSlide: function changeSlide(options) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var spec = inner_slider_objectSpread({}, this.$props, this.$data);

      var targetSlide = innerSliderUtils_changeSlide(spec, options);

      if (targetSlide !== 0 && !targetSlide) return;

      if (dontAnimate === true) {
        this.slideHandler(targetSlide, dontAnimate);
      } else {
        this.slideHandler(targetSlide);
      }
    },
    clickHandler: function clickHandler(e) {
      if (this.clickable === false) {
        e.stopPropagation();
        e.preventDefault();
      }

      this.clickable = true;
    },
    keyHandler: function keyHandler(e) {
      var dir = innerSliderUtils_keyHandler(e, this.accessibility, this.rtl);

      dir !== '' && this.changeSlide({
        message: dir
      });
    },
    selectHandler: function selectHandler(options) {
      this.changeSlide(options);
    },
    disableBodyScroll: function disableBodyScroll() {
      var preventDefault = function preventDefault(e) {
        e = e || window.event;
        if (e.preventDefault) e.preventDefault();
        e.returnValue = false;
      };

      window.ontouchmove = preventDefault;
    },
    enableBodyScroll: function enableBodyScroll() {
      window.ontouchmove = null;
    },
    swipeStart: function swipeStart(e) {
      if (this.verticalSwiping) {
        this.disableBodyScroll();
      }

      var state = innerSliderUtils_swipeStart(e, this.swipe, this.draggable);

      state !== '' && this.setState(state);
    },
    swipeMove: function swipeMove(e) {
      var state = innerSliderUtils_swipeMove(e, inner_slider_objectSpread({}, this.$props, this.$data, {
        trackRef: this.track,
        listRef: this.list,
        slideIndex: this.currentSlide
      }));

      if (!state) return;

      if (state['swiping']) {
        this.clickable = false;
      }

      this.setState(state);
    },
    swipeEnd: function swipeEnd(e) {
      var state = innerSliderUtils_swipeEnd(e, inner_slider_objectSpread({}, this.$props, this.$data, {
        trackRef: this.track,
        listRef: this.list,
        slideIndex: this.currentSlide
      }));

      if (!state) return;
      var triggerSlideHandler = state['triggerSlideHandler'];
      delete state['triggerSlideHandler'];
      this.setState(state);
      if (triggerSlideHandler === undefined) return;
      this.slideHandler(triggerSlideHandler);

      if (this.$props.verticalSwiping) {
        this.enableBodyScroll();
      }
    },
    slickPrev: function slickPrev() {
      var _this5 = this; // this and fellow methods are wrapped in setTimeout
      // to make sure initialize setState has happened before
      // any of such methods are called


      this.callbackTimers.push(setTimeout(function () {
        return _this5.changeSlide({
          message: 'previous'
        });
      }, 0));
    },
    slickNext: function slickNext() {
      var _this6 = this;

      this.callbackTimers.push(setTimeout(function () {
        return _this6.changeSlide({
          message: 'next'
        });
      }, 0));
    },
    slickGoTo: function slickGoTo(slide) {
      var _this7 = this;

      var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      slide = Number(slide);
      if (isNaN(slide)) return '';
      this.callbackTimers.push(setTimeout(function () {
        return _this7.changeSlide({
          message: 'index',
          index: slide,
          currentSlide: _this7.currentSlide
        }, dontAnimate);
      }, 0));
    },
    play: function play() {
      var nextIndex;

      if (this.rtl) {
        nextIndex = this.currentSlide - this.slidesToScroll;
      } else {
        if (canGoNext(inner_slider_objectSpread({}, this.$props, this.$data))) {
          nextIndex = this.currentSlide + this.slidesToScroll;
        } else {
          return false;
        }
      }

      this.slideHandler(nextIndex);
    },
    handleAutoPlay: function handleAutoPlay(playType) {
      if (this.autoplayTimer) {
        clearInterval(this.autoplayTimer);
      }

      var autoplaying = this.autoplaying;

      if (playType === 'update') {
        if (autoplaying === 'hovered' || autoplaying === 'focused' || autoplaying === 'paused') {
          return;
        }
      } else if (playType === 'leave') {
        if (autoplaying === 'paused' || autoplaying === 'focused') {
          return;
        }
      } else if (playType === 'blur') {
        if (autoplaying === 'paused' || autoplaying === 'hovered') {
          return;
        }
      }

      this.autoplayTimer = setInterval(this.play, this.autoplaySpeed + 50);
      this.setState({
        autoplaying: 'playing'
      });
    },
    pause: function pause(pauseType) {
      if (this.autoplayTimer) {
        clearInterval(this.autoplayTimer);
        this.autoplayTimer = null;
      }

      var autoplaying = this.autoplaying;

      if (pauseType === 'paused') {
        this.setState({
          autoplaying: 'paused'
        });
      } else if (pauseType === 'focused') {
        if (autoplaying === 'hovered' || autoplaying === 'playing') {
          this.setState({
            autoplaying: 'focused'
          });
        }
      } else {
        // pauseType  is 'hovered'
        if (autoplaying === 'playing') {
          this.setState({
            autoplaying: 'hovered'
          });
        }
      }
    },
    onDotsOver: function onDotsOver() {
      this.autoplay && this.pause('hovered');
    },
    onDotsLeave: function onDotsLeave() {
      this.autoplay && this.autoplaying === 'hovered' && this.handleAutoPlay('leave');
    },
    onTrackOver: function onTrackOver() {
      this.autoplay && this.pause('hovered');
    },
    onTrackLeave: function onTrackLeave() {
      this.autoplay && this.autoplaying === 'hovered' && this.handleAutoPlay('leave');
    },
    onSlideFocus: function onSlideFocus() {
      this.autoplay && this.pause('focused');
    },
    onSlideBlur: function onSlideBlur() {
      this.autoplay && this.autoplaying === 'focused' && this.handleAutoPlay('blur');
    },
    customPaging: function customPaging(_ref) {
      var i = _ref.i;
      var h = this.$createElement;
      return h("button", [i + 1]);
    },
    appendDots: function appendDots(_ref2) {
      var dots = _ref2.dots;
      var h = this.$createElement;
      return h("ul", {
        style: {
          display: 'block'
        }
      }, [dots]);
    }
  },
  beforeMount: function beforeMount() {
    this.ssrInit();
    this.$emit('init');

    if (this.lazyLoad) {
      var slidesToLoad = getOnDemandLazySlides(inner_slider_objectSpread({}, this.$props, this.$data));

      if (slidesToLoad.length > 0) {
        this.setState(function (prevState) {
          return {
            lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
          };
        });
        this.$emit('lazyLoad', slidesToLoad);
      }
    }
  },
  mounted: function mounted() {
    var _this8 = this;

    this.$nextTick(function () {
      var spec = inner_slider_objectSpread({
        listRef: _this8.list,
        trackRef: _this8.track,
        children: _this8.children
      }, _this8.$props);

      _this8.updateState(spec, true, function () {
        _this8.adaptHeight();

        _this8.autoplay && _this8.handleAutoPlay('update');
      });

      if (_this8.lazyLoad === 'progressive') {
        _this8.lazyLoadTimer = setInterval(_this8.progressiveLazyLoad, 1000);
      }

      _this8.ro = new ResizeObserver_es["a" /* default */](function () {
        if (_this8.animating) {
          _this8.onWindowResized(false); // don't set trackStyle hence don't break animation


          _this8.callbackTimers.push(setTimeout(function () {
            return _this8.onWindowResized();
          }, _this8.speed));
        } else {
          _this8.onWindowResized();
        }
      });

      _this8.ro.observe(_this8.list);

      Array.prototype.forEach.call(document.querySelectorAll('.slick-slide'), function (slide) {
        slide.onfocus = _this8.$props.pauseOnFocus ? _this8.onSlideFocus : null;
        slide.onblur = _this8.$props.pauseOnFocus ? _this8.onSlideBlur : null;
      }); // To support server-side rendering

      if (!window) {
        return;
      }

      if (window.addEventListener) {
        window.addEventListener('resize', _this8.onWindowResized);
      } else {
        window.attachEvent('onresize', _this8.onWindowResized);
      }
    });
  },
  beforeDestroy: function beforeDestroy() {
    if (this.animationEndCallback) {
      clearTimeout(this.animationEndCallback);
    }

    if (this.lazyLoadTimer) {
      clearInterval(this.lazyLoadTimer);
    }

    if (this.callbackTimers.length) {
      this.callbackTimers.forEach(function (timer) {
        return clearTimeout(timer);
      });
      this.callbackTimers = [];
    }

    if (window.addEventListener) {
      window.removeEventListener('resize', this.onWindowResized);
    } else {
      window.detachEvent('onresize', this.onWindowResized);
    }

    if (this.autoplayTimer) {
      clearInterval(this.autoplayTimer);
    }
  },
  updated: function updated() {
    this.checkImagesLoad();
    this.$emit('reInit');

    if (this.lazyLoad) {
      var slidesToLoad = getOnDemandLazySlides(inner_slider_objectSpread({}, this.$props, this.$data));

      if (slidesToLoad.length > 0) {
        this.setState(function (prevState) {
          return {
            lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
          };
        });
        this.$emit('lazyLoad');
      }
    } // if (this.props.onLazyLoad) {
    //   this.props.onLazyLoad([leftMostSlide])
    // }


    this.adaptHeight();
  },
  watch: {
    __propsSymbol__: function __propsSymbol__() {
      var _this9 = this;

      var nextProps = this.$props;

      var spec = inner_slider_objectSpread({
        listRef: this.list,
        trackRef: this.track
      }, nextProps, this.$data);

      var setTrackStyle = false;

      for (var _i3 = 0, _Object$keys = Object.keys(this.preProps); _i3 < _Object$keys.length; _i3++) {
        var key = _Object$keys[_i3];

        if (!nextProps.hasOwnProperty(key)) {
          setTrackStyle = true;
          break;
        }

        if (_typeof(nextProps[key]) === 'object' || typeof nextProps[key] === 'function' || _typeof(nextProps[key]) === 'symbol') {
          continue;
        }

        if (nextProps[key] !== this.preProps[key]) {
          setTrackStyle = true;
          break;
        }
      }

      this.updateState(spec, setTrackStyle, function () {
        if (_this9.currentSlide >= nextProps.children.length) {
          _this9.changeSlide({
            message: 'index',
            index: nextProps.children.length - nextProps.slidesToShow,
            currentSlide: _this9.currentSlide
          });
        }

        if (nextProps.autoplay) {
          _this9.handleAutoPlay('update');
        } else {
          _this9.pause('paused');
        }
      });
      this.preProps = inner_slider_objectSpread({}, nextProps);
    }
  },
  render: function render() {
    var h = arguments[0];
    var className = classnames_default()('slick-slider', {
      'slick-vertical': this.vertical,
      'slick-initialized': true
    });

    var spec = inner_slider_objectSpread({}, this.$props, this.$data);

    var trackProps = extractObject(spec, ['fade', 'cssEase', 'speed', 'infinite', 'centerMode', 'focusOnSelect', 'currentSlide', 'lazyLoad', 'lazyLoadedList', 'rtl', 'slideWidth', 'slideHeight', 'listHeight', 'vertical', 'slidesToShow', 'slidesToScroll', 'slideCount', 'trackStyle', 'variableWidth', 'unslick', 'centerPadding']);
    var pauseOnHover = this.$props.pauseOnHover;
    trackProps = {
      props: inner_slider_objectSpread({}, trackProps, {
        focusOnSelect: this.focusOnSelect ? this.selectHandler : null
      }),
      directives: [{
        name: 'ant-ref',
        value: this.trackRefHandler
      }],
      on: {
        mouseenter: pauseOnHover ? this.onTrackOver : inner_slider_noop,
        mouseleave: pauseOnHover ? this.onTrackLeave : inner_slider_noop,
        mouseover: pauseOnHover ? this.onTrackOver : inner_slider_noop
      }
    };
    var dots;

    if (this.dots === true && this.slideCount >= this.slidesToShow) {
      var dotProps = extractObject(spec, ['dotsClass', 'slideCount', 'slidesToShow', 'currentSlide', 'slidesToScroll', 'clickHandler', 'children', 'infinite', 'appendDots']);
      dotProps.customPaging = this.customPaging;
      dotProps.appendDots = this.appendDots;
      var _this$$scopedSlots = this.$scopedSlots,
          customPaging = _this$$scopedSlots.customPaging,
          appendDots = _this$$scopedSlots.appendDots;

      if (customPaging) {
        dotProps.customPaging = customPaging;
      }

      if (appendDots) {
        dotProps.appendDots = appendDots;
      }

      var pauseOnDotsHover = this.$props.pauseOnDotsHover;
      dotProps = {
        props: inner_slider_objectSpread({}, dotProps, {
          clickHandler: this.changeSlide
        }),
        on: {
          mouseenter: pauseOnDotsHover ? this.onDotsLeave : inner_slider_noop,
          mouseover: pauseOnDotsHover ? this.onDotsOver : inner_slider_noop,
          mouseleave: pauseOnDotsHover ? this.onDotsLeave : inner_slider_noop
        }
      };
      dots = h(src_dots, dotProps);
    }

    var prevArrow, nextArrow;
    var arrowProps = extractObject(spec, ['infinite', 'centerMode', 'currentSlide', 'slideCount', 'slidesToShow']);
    arrowProps.clickHandler = this.changeSlide;
    var _this$$scopedSlots2 = this.$scopedSlots,
        prevArrowCustom = _this$$scopedSlots2.prevArrow,
        nextArrowCustom = _this$$scopedSlots2.nextArrow;

    if (prevArrowCustom) {
      arrowProps.prevArrow = prevArrowCustom;
    }

    if (nextArrowCustom) {
      arrowProps.nextArrow = nextArrowCustom;
    }

    if (this.arrows) {
      prevArrow = h(PrevArrow, {
        props: arrowProps
      });
      nextArrow = h(NextArrow, {
        props: arrowProps
      });
    }

    var verticalHeightStyle = null;

    if (this.vertical) {
      verticalHeightStyle = {
        height: typeof this.listHeight === 'number' ? "".concat(this.listHeight, "px") : this.listHeight
      };
    }

    var centerPaddingStyle = null;

    if (this.vertical === false) {
      if (this.centerMode === true) {
        centerPaddingStyle = {
          padding: '0px ' + this.centerPadding
        };
      }
    } else {
      if (this.centerMode === true) {
        centerPaddingStyle = {
          padding: this.centerPadding + ' 0px'
        };
      }
    }

    var listStyle = inner_slider_objectSpread({}, verticalHeightStyle, centerPaddingStyle);

    var touchMove = this.touchMove;
    var listProps = {
      directives: [{
        name: 'ant-ref',
        value: this.listRefHandler
      }],
      "class": 'slick-list',
      style: listStyle,
      on: {
        click: this.clickHandler,
        mousedown: touchMove ? this.swipeStart : inner_slider_noop,
        mousemove: this.dragging && touchMove ? this.swipeMove : inner_slider_noop,
        mouseup: touchMove ? this.swipeEnd : inner_slider_noop,
        mouseleave: this.dragging && touchMove ? this.swipeEnd : inner_slider_noop,
        touchstart: touchMove ? this.swipeStart : inner_slider_noop,
        touchmove: this.dragging && touchMove ? this.swipeMove : inner_slider_noop,
        touchend: touchMove ? this.swipeEnd : inner_slider_noop,
        touchcancel: this.dragging && touchMove ? this.swipeEnd : inner_slider_noop,
        keydown: this.accessibility ? this.keyHandler : inner_slider_noop
      }
    };
    var innerSliderProps = {
      "class": className,
      props: {
        dir: 'ltr'
      }
    };

    if (this.unslick) {
      listProps = {
        "class": 'slick-list',
        directives: [{
          name: 'ant-ref',
          value: this.listRefHandler
        }]
      };
      innerSliderProps = {
        "class": className
      };
    }

    return h("div", innerSliderProps, [!this.unslick ? prevArrow : '', h("div", listProps, [h(track, trackProps, [this.children])]), !this.unslick ? nextArrow : '', !this.unslick ? dots : '']);
  }
});
// CONCATENATED MODULE: ./src/components/vc-slick/src/slider.js
function slider_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      slider_defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function slider_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}











var enquire = canUseDOM() && __webpack_require__(292);

external_Vue_default.a.use(antRefDirective["a" /* default */]);
/* harmony default export */ var slider = ({
  props: slider_objectSpread({}, default_props),
  mixins: [BaseMixin["a" /* default */]],
  data: function data() {
    this._responsiveMediaHandlers = [];
    return {
      breakpoint: null
    };
  },
  methods: {
    innerSliderRefHandler: function innerSliderRefHandler(ref) {
      this.innerSlider = ref;
    },
    media: function media(query, handler) {
      // javascript handler for  css media query
      enquire.register(query, handler);

      this._responsiveMediaHandlers.push({
        query: query,
        handler: handler
      });
    },
    slickPrev: function slickPrev() {
      this.innerSlider.slickPrev();
    },
    slickNext: function slickNext() {
      this.innerSlider.slickNext();
    },
    slickGoTo: function slickGoTo(slide) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.innerSlider.slickGoTo(slide, dontAnimate);
    },
    slickPause: function slickPause() {
      this.innerSlider.pause('paused');
    },
    slickPlay: function slickPlay() {
      this.innerSlider.handleAutoPlay('play');
    }
  },
  // handles responsive breakpoints
  beforeMount: function beforeMount() {
    var _this = this; // performance monitoring
    // if (process.env.NODE_ENV !== 'production') {
    // const { whyDidYouUpdate } = require('why-did-you-update')
    // whyDidYouUpdate(React)
    // }


    if (this.responsive) {
      var breakpoints = this.responsive.map(function (breakpt) {
        return breakpt.breakpoint;
      }); // sort them in increasing order of their numerical value

      breakpoints.sort(function (x, y) {
        return x - y;
      });
      breakpoints.forEach(function (breakpoint, index) {
        // media query for each breakpoint
        var bQuery;

        if (index === 0) {
          bQuery = json2mq_default()({
            minWidth: 0,
            maxWidth: breakpoint
          });
        } else {
          bQuery = json2mq_default()({
            minWidth: breakpoints[index - 1] + 1,
            maxWidth: breakpoint
          });
        } // when not using server side rendering


        canUseDOM() && _this.media(bQuery, function () {
          _this.setState({
            breakpoint: breakpoint
          });
        });
      }); // Register media query for full screen. Need to support resize from small to large
      // convert javascript object to media query string

      var query = json2mq_default()({
        minWidth: breakpoints.slice(-1)[0]
      });
      canUseDOM() && this.media(query, function () {
        _this.setState({
          breakpoint: null
        });
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    this._responsiveMediaHandlers.forEach(function (obj) {
      enquire.unregister(obj.query, obj.handler);
    });
  },
  render: function render() {
    var _this2 = this;

    var h = arguments[0];
    var settings;
    var newProps;

    if (this.breakpoint) {
      newProps = this.responsive.filter(function (resp) {
        return resp.breakpoint === _this2.breakpoint;
      });
      settings = newProps[0].settings === 'unslick' ? 'unslick' : slider_objectSpread({}, this.$props, newProps[0].settings);
    } else {
      settings = slider_objectSpread({}, this.$props);
    } // force scrolling by one if centerMode is on


    if (settings.centerMode) {
      if (settings.slidesToScroll > 1 && "production" !== 'production') {
        console.warn("slidesToScroll should be equal to 1 in centerMode, you are using ".concat(settings.slidesToScroll));
      }

      settings.slidesToScroll = 1;
    } // force showing one slide and scrolling by one if the fade mode is on


    if (settings.fade) {
      if (settings.slidesToShow > 1 && "production" !== 'production') {
        console.warn("slidesToShow should be equal to 1 when fade is true, you're using ".concat(settings.slidesToShow));
      }

      if (settings.slidesToScroll > 1 && "production" !== 'production') {
        console.warn("slidesToScroll should be equal to 1 when fade is true, you're using ".concat(settings.slidesToScroll));
      }

      settings.slidesToShow = 1;
      settings.slidesToScroll = 1;
    } // makes sure that children is an array, even when there is only 1 child


    var children = this.$slots["default"] || []; // Children may contain false or null, so we should filter them
    // children may also contain string filled with spaces (in certain cases where we use jsx strings)

    children = children.filter(function (child) {
      if (typeof child === 'string') {
        return !!child.trim();
      }

      return !!child;
    }); // rows and slidesPerRow logic is handled here

    if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {
      console.warn("variableWidth is not supported in case of rows > 1 or slidesPerRow > 1");
      settings.variableWidth = false;
    }

    var newChildren = [];
    var currentWidth = null;

    for (var i = 0; i < children.length; i += settings.rows * settings.slidesPerRow) {
      var newSlide = [];

      for (var j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow) {
        var row = [];

        for (var k = j; k < j + settings.slidesPerRow; k += 1) {
          if (settings.variableWidth && Object(props_util["n" /* getStyle */])(children[k])) {
            currentWidth = Object(props_util["n" /* getStyle */])(children[k]).width;
          }

          if (k >= children.length) break;
          row.push(Object(vnode["a" /* cloneElement */])(children[k], {
            key: 100 * i + 10 * j + k,
            attrs: {
              tabIndex: -1
            },
            style: {
              width: "".concat(100 / settings.slidesPerRow, "%"),
              display: 'inline-block'
            }
          }));
        }

        newSlide.push(h("div", {
          key: 10 * i + j
        }, [row]));
      }

      if (settings.variableWidth) {
        newChildren.push(h("div", {
          key: i,
          style: {
            width: currentWidth
          }
        }, [newSlide]));
      } else {
        newChildren.push(h("div", {
          key: i
        }, [newSlide]));
      }
    }

    if (settings === 'unslick') {
      var className = 'regular slider ' + (this.className || '');
      return h("div", {
        "class": className
      }, [newChildren]);
    } else if (newChildren.length <= settings.slidesToShow) {
      settings.unslick = true;
    }

    var sliderProps = {
      props: slider_objectSpread({}, settings, {
        children: newChildren,
        __propsSymbol__: Symbol()
      }),
      on: slider_objectSpread({}, this.$listeners),
      directives: [{
        name: 'ant-ref',
        value: this.innerSliderRefHandler
      }],
      scopedSlots: this.$scopedSlots
    };
    return h(inner_slider, sliderProps);
  }
});
// CONCATENATED MODULE: ./src/components/vc-slick/src/index.js

/* harmony default export */ var src = __webpack_exports__["default"] = (slider);

/***/ }),
/* 975 */,
/* 976 */,
/* 977 */,
/* 978 */,
/* 979 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/babel-helper-vue-jsx-merge-props/index.js
var babel_helper_vue_jsx_merge_props = __webpack_require__(5);
var babel_helper_vue_jsx_merge_props_default = /*#__PURE__*/__webpack_require__.n(babel_helper_vue_jsx_merge_props);

// EXTERNAL MODULE: ./src/components/_util/vue-types/index.js
var vue_types = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(4);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: ./node_modules/warning/browser.js
var browser = __webpack_require__(26);
var browser_default = /*#__PURE__*/__webpack_require__.n(browser);

// EXTERNAL MODULE: ./src/components/_util/props-util.js
var props_util = __webpack_require__(1);

// EXTERNAL MODULE: ./src/components/_util/vnode.js
var vnode = __webpack_require__(8);

// EXTERNAL MODULE: ./src/components/_util/BaseMixin.js
var BaseMixin = __webpack_require__(3);

// EXTERNAL MODULE: ./src/components/_util/proxyComponent.jsx
var proxyComponent = __webpack_require__(106);

// EXTERNAL MODULE: ./src/components/vc-tree/src/util.js
var util = __webpack_require__(16);

// CONCATENATED MODULE: ./src/components/vc-tree/src/Tree.jsx


function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









/**
 * Thought we still use `cloneElement` to pass `key`,
 * other props can pass with context for future refactor.
 */

var Tree = {
  name: 'Tree',
  mixins: [BaseMixin["a" /* default */]],
  props: Object(props_util["q" /* initDefaultProps */])({
    prefixCls: vue_types["a" /* default */].string,
    tabIndex: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number]),
    children: vue_types["a" /* default */].any,
    treeData: vue_types["a" /* default */].array,
    // Generate treeNode by children
    showLine: vue_types["a" /* default */].bool,
    showIcon: vue_types["a" /* default */].bool,
    icon: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].object, vue_types["a" /* default */].func]),
    focusable: vue_types["a" /* default */].bool,
    selectable: vue_types["a" /* default */].bool,
    disabled: vue_types["a" /* default */].bool,
    multiple: vue_types["a" /* default */].bool,
    checkable: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].object, vue_types["a" /* default */].bool]),
    checkStrictly: vue_types["a" /* default */].bool,
    draggable: vue_types["a" /* default */].bool,
    defaultExpandParent: vue_types["a" /* default */].bool,
    showCheckAll: vue_types["a" /* default */].bool,
    autoExpandParent: vue_types["a" /* default */].bool,
    defaultExpandAll: vue_types["a" /* default */].bool,
    defaultExpandedKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
    expandedKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
    defaultCheckedKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
    checkedKeys: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].number])), vue_types["a" /* default */].object]),
    defaultSelectedKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
    selectedKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
    // onClick: PropTypes.func,
    // onDoubleClick: PropTypes.func,
    // onExpand: PropTypes.func,
    // onCheck: PropTypes.func,
    // onSelect: PropTypes.func,
    loadData: vue_types["a" /* default */].func,
    loadedKeys: vue_types["a" /* default */].arrayOf(vue_types["a" /* default */].string),
    // onMouseEnter: PropTypes.func,
    // onMouseLeave: PropTypes.func,
    // onRightClick: PropTypes.func,
    // onDragStart: PropTypes.func,
    // onDragEnter: PropTypes.func,
    // onDragOver: PropTypes.func,
    // onDragLeave: PropTypes.func,
    // onDragEnd: PropTypes.func,
    // onDrop: PropTypes.func,
    filterTreeNode: vue_types["a" /* default */].func,
    openTransitionName: vue_types["a" /* default */].string,
    openAnimation: vue_types["a" /* default */].oneOfType([vue_types["a" /* default */].string, vue_types["a" /* default */].object]),
    switcherIcon: vue_types["a" /* default */].any,
    _propsSymbol: vue_types["a" /* default */].any
  }, {
    prefixCls: 'rc-tree',
    showLine: false,
    showIcon: true,
    selectable: true,
    multiple: false,
    checkable: false,
    disabled: false,
    checkStrictly: false,
    draggable: false,
    defaultExpandParent: true,
    autoExpandParent: false,
    defaultExpandAll: false,
    defaultExpandedKeys: [],
    defaultCheckedKeys: [],
    defaultSelectedKeys: [],
    showCheckAll: false
  }),
  data: function data() {
    var state = {
      _posEntities: {},
      _keyEntities: {},
      _expandedKeys: [],
      _selectedKeys: [],
      _checkedKeys: [],
      _halfCheckedKeys: [],
      _loadedKeys: [],
      _loadingKeys: [],
      _treeNode: [],
      _prevProps: null,
      _dragOverNodeKey: '',
      _dropPosition: null,
      _dragNodesKeys: [],
      _checkedAllButtonValue: '全选'
    };
    return _objectSpread({}, state, this.getDerivedStateFromProps(Object(props_util["j" /* getOptionProps */])(this), state));
  },
  provide: function provide() {
    return {
      vcTree: this
    };
  },
  watch: {
    __propsSymbol__: function __propsSymbol__() {
      this.setState(this.getDerivedStateFromProps(Object(props_util["j" /* getOptionProps */])(this), this.$data));
    },
    _selectedKeys: function _selectedKeys() {
      this.setState(this.getDerivedStateFromProps(Object(props_util["j" /* getOptionProps */])(this), this.$data));
    }
  },
  methods: {
    getDerivedStateFromProps: function getDerivedStateFromProps(props, prevState) {
      var _prevProps = prevState._prevProps;
      var newState = {
        _prevProps: _objectSpread({}, props)
      };

      function needSync(name) {
        return !_prevProps && name in props || _prevProps && _prevProps[name] !== props[name];
      } // ================== Tree Node ==================


      var treeNode = null; // Check if `treeData` or `children` changed and save into the state.

      if (needSync('treeData')) {
        treeNode = Object(util["g" /* convertDataToTree */])(this.$createElement, props.treeData);
      } else if (needSync('children')) {
        treeNode = props.children;
      } // Tree support filter function which will break the tree structure in the vdm.
      // We cache the treeNodes in state so that we can return the treeNode in event trigger.


      if (treeNode) {
        newState._treeNode = treeNode; // Calculate the entities data for quick match

        var entitiesMap = Object(util["h" /* convertTreeToEntities */])(treeNode);
        newState._posEntities = entitiesMap.posEntities;
        newState._keyEntities = entitiesMap.keyEntities;
      }

      var keyEntities = newState._keyEntities || prevState._keyEntities; // ================ expandedKeys =================

      if (needSync('expandedKeys') || _prevProps && needSync('autoExpandParent')) {
        newState._expandedKeys = props.autoExpandParent || !_prevProps && props.defaultExpandParent ? Object(util["f" /* conductExpandParent */])(props.expandedKeys, keyEntities) : props.expandedKeys;
      } else if (!_prevProps && props.defaultExpandAll) {
        newState._expandedKeys = Object.keys(keyEntities);
      } else if (!_prevProps && props.defaultExpandedKeys) {
        newState._expandedKeys = props.autoExpandParent || props.defaultExpandParent ? Object(util["f" /* conductExpandParent */])(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
      } // ================ selectedKeys =================


      if (props.selectable) {
        if (needSync('selectedKeys')) {
          newState._selectedKeys = Object(util["d" /* calcSelectedKeys */])(props.selectedKeys, props);
        } else if (!_prevProps && props.defaultSelectedKeys) {
          newState._selectedKeys = Object(util["d" /* calcSelectedKeys */])(props.defaultSelectedKeys, props);
        }
      } // ================= checkedKeys =================


      if (props.checkable) {
        var checkedKeyEntity;

        if (needSync('checkedKeys')) {
          checkedKeyEntity = Object(util["m" /* parseCheckedKeys */])(props.checkedKeys) || {};
        } else if (!_prevProps && props.defaultCheckedKeys) {
          checkedKeyEntity = Object(util["m" /* parseCheckedKeys */])(props.defaultCheckedKeys) || {};
        } else if (treeNode) {
          // If treeNode changed, we also need check it
          checkedKeyEntity = {
            checkedKeys: prevState._checkedKeys,
            halfCheckedKeys: prevState._halfCheckedKeys
          };
        }

        if (checkedKeyEntity) {
          var _checkedKeyEntity = checkedKeyEntity,
              _checkedKeyEntity$che = _checkedKeyEntity.checkedKeys,
              checkedKeys = _checkedKeyEntity$che === void 0 ? [] : _checkedKeyEntity$che,
              _checkedKeyEntity$hal = _checkedKeyEntity.halfCheckedKeys,
              halfCheckedKeys = _checkedKeyEntity$hal === void 0 ? [] : _checkedKeyEntity$hal;

          if (!props.checkStrictly) {
            var conductKeys = Object(util["e" /* conductCheck */])(checkedKeys, true, keyEntities);
            checkedKeys = conductKeys.checkedKeys;
            halfCheckedKeys = conductKeys.halfCheckedKeys;
          }

          newState._checkedKeys = checkedKeys;
          newState._halfCheckedKeys = halfCheckedKeys;
        }
      } // ================= loadedKeys ==================


      if (needSync('loadedKeys')) {
        newState._loadedKeys = props.loadedKeys;
      }

      return newState;
    },
    onNodeDragStart: function onNodeDragStart(event, node) {
      var _expandedKeys = this.$data._expandedKeys;
      var eventKey = node.eventKey;
      var children = Object(props_util["m" /* getSlots */])(node)["default"];
      this.dragNode = node;
      this.setState({
        _dragNodesKeys: Object(util["i" /* getDragNodesKeys */])(children, node),
        _expandedKeys: Object(util["b" /* arrDel */])(_expandedKeys, eventKey)
      });

      this.__emit('dragstart', {
        event: event,
        node: node
      });
    },

    /**
     * [Legacy] Select handler is less small than node,
     * so that this will trigger when drag enter node or select handler.
     * This is a little tricky if customize css without padding.
     * Better for use mouse move event to refresh drag state.
     * But let's just keep it to avoid event trigger logic change.
     */
    onNodeDragEnter: function onNodeDragEnter(event, node) {
      var _this = this;

      var expandedKeys = this.$data._expandedKeys;
      var pos = node.pos,
          eventKey = node.eventKey;
      if (!this.dragNode || !node.$refs.selectHandle) return;
      var dropPosition = Object(util["c" /* calcDropPosition */])(event, node); // Skip if drag node is self

      if (this.dragNode.eventKey === eventKey && dropPosition === 0) {
        this.setState({
          _dragOverNodeKey: '',
          _dropPosition: null
        });
        return;
      } // Ref: https://github.com/react-component/tree/issues/132
      // Add timeout to let onDragLevel fire before onDragEnter,
      // so that we can clean drag props for onDragLeave node.
      // Macro task for this:
      // https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-script


      setTimeout(function () {
        // Update drag over node
        _this.setState({
          _dragOverNodeKey: eventKey,
          _dropPosition: dropPosition
        }); // Side effect for delay drag


        if (!_this.delayedDragEnterLogic) {
          _this.delayedDragEnterLogic = {};
        }

        Object.keys(_this.delayedDragEnterLogic).forEach(function (key) {
          clearTimeout(_this.delayedDragEnterLogic[key]);
        });
        _this.delayedDragEnterLogic[pos] = setTimeout(function () {
          var newExpandedKeys = Object(util["a" /* arrAdd */])(expandedKeys, eventKey);

          _this.setState({
            _expandedKeys: newExpandedKeys
          });

          _this.__emit('dragenter', {
            event: event,
            node: node,
            expandedKeys: newExpandedKeys
          });
        }, 400);
      }, 0);
    },
    onNodeDragOver: function onNodeDragOver(event, node) {
      var eventKey = node.eventKey;
      var _this$$data = this.$data,
          _dragOverNodeKey = _this$$data._dragOverNodeKey,
          _dropPosition = _this$$data._dropPosition; // Update drag position

      if (this.dragNode && eventKey === _dragOverNodeKey && node.$refs.selectHandle) {
        var dropPosition = Object(util["c" /* calcDropPosition */])(event, node);
        if (dropPosition === _dropPosition) return;
        this.setState({
          _dropPosition: _dropPosition
        });
      }

      this.__emit('dragover', {
        event: event,
        node: node
      });
    },
    onNodeDragLeave: function onNodeDragLeave(event, node) {
      this.setState({
        _dragOverNodeKey: ''
      });

      this.__emit('dragleave', {
        event: event,
        node: node
      });
    },
    onNodeDragEnd: function onNodeDragEnd(event, node) {
      this.setState({
        _dragOverNodeKey: ''
      });

      this.__emit('dragend', {
        event: event,
        node: node
      });
    },
    onNodeDrop: function onNodeDrop(event, node) {
      var _this$$data2 = this.$data,
          _this$$data2$_dragNod = _this$$data2._dragNodesKeys,
          _dragNodesKeys = _this$$data2$_dragNod === void 0 ? [] : _this$$data2$_dragNod,
          _dropPosition = _this$$data2._dropPosition;

      var eventKey = node.eventKey,
          pos = node.pos;
      this.setState({
        _dragOverNodeKey: ''
      });

      if (_dragNodesKeys.indexOf(eventKey) !== -1) {
        browser_default()(false, 'Can not drop to dragNode(include it\'s children node)');
        return;
      }

      var posArr = Object(util["n" /* posToArr */])(pos);
      var dropResult = {
        event: event,
        node: node,
        dragNode: this.dragNode,
        dragNodesKeys: _dragNodesKeys.slice(),
        dropPosition: _dropPosition + Number(posArr[posArr.length - 1])
      };

      if (_dropPosition !== 0) {
        dropResult.dropToGap = true;
      }

      this.__emit('drop', dropResult);
    },
    onNodeClick: function onNodeClick(e, treeNode) {
      this.__emit('click', e, treeNode);
    },
    onNodeDoubleClick: function onNodeDoubleClick(e, treeNode) {
      this.__emit('doubleclick', e, treeNode);
    },
    onNodeSelect: function onNodeSelect(e, treeNode) {
      var selectedKeys = this.$data._selectedKeys;
      var keyEntities = this.$data._keyEntities;
      var multiple = this.$props.multiple;

      var _getOptionProps = Object(props_util["j" /* getOptionProps */])(treeNode),
          selected = _getOptionProps.selected,
          eventKey = _getOptionProps.eventKey;

      var targetSelected = !selected; // Update selected keys

      if (!targetSelected) {
        selectedKeys = Object(util["b" /* arrDel */])(selectedKeys, eventKey);
      } else if (!multiple) {
        selectedKeys = [eventKey];
      } else {
        selectedKeys = Object(util["a" /* arrAdd */])(selectedKeys, eventKey);
      } // [Legacy] Not found related usage in doc or upper libs


      var selectedNodes = selectedKeys.map(function (key) {
        var entity = keyEntities[key];
        if (!entity) return null;
        return entity.node;
      }).filter(function (node) {
        return node;
      });
      this.setUncontrolledState({
        _selectedKeys: selectedKeys
      });
      var eventObj = {
        event: 'select',
        selected: targetSelected,
        node: treeNode,
        selectedNodes: selectedNodes,
        nativeEvent: e
      };

      this.__emit('select', selectedKeys, eventObj);
    },
    onNodeCheck: function onNodeCheck(e, treeNode, checked) {
      var _this$$data3 = this.$data,
          keyEntities = _this$$data3._keyEntities,
          oriCheckedKeys = _this$$data3._checkedKeys,
          oriHalfCheckedKeys = _this$$data3._halfCheckedKeys;
      var checkStrictly = this.$props.checkStrictly;

      var _getOptionProps2 = Object(props_util["j" /* getOptionProps */])(treeNode),
          eventKey = _getOptionProps2.eventKey; // Prepare trigger arguments


      var checkedObj;
      var eventObj = {
        event: 'check',
        node: treeNode,
        checked: checked,
        nativeEvent: e
      };

      if (checkStrictly) {
        var checkedKeys = checked ? Object(util["a" /* arrAdd */])(oriCheckedKeys, eventKey) : Object(util["b" /* arrDel */])(oriCheckedKeys, eventKey);
        var halfCheckedKeys = Object(util["b" /* arrDel */])(oriHalfCheckedKeys, eventKey);
        checkedObj = {
          checked: checkedKeys,
          halfChecked: halfCheckedKeys
        };
        eventObj.checkedNodes = checkedKeys.map(function (key) {
          return keyEntities[key];
        }).filter(function (entity) {
          return entity;
        }).map(function (entity) {
          return entity.node;
        });
        this.setUncontrolledState({
          _checkedKeys: checkedKeys
        });
      } else {
        var _conductCheck = Object(util["e" /* conductCheck */])([eventKey], checked, keyEntities, {
          checkedKeys: oriCheckedKeys,
          halfCheckedKeys: oriHalfCheckedKeys
        }),
            _checkedKeys2 = _conductCheck.checkedKeys,
            _halfCheckedKeys = _conductCheck.halfCheckedKeys;

        checkedObj = _checkedKeys2; // [Legacy] This is used for `rc-tree-select`

        eventObj.checkedNodes = [];
        eventObj.checkedNodesPositions = [];
        eventObj.halfCheckedKeys = _halfCheckedKeys;

        _checkedKeys2.forEach(function (key) {
          var entity = keyEntities[key];
          if (!entity) return;
          var node = entity.node,
              pos = entity.pos;
          eventObj.checkedNodes.push(node);
          eventObj.checkedNodesPositions.push({
            node: node,
            pos: pos
          });
        });

        this.setUncontrolledState({
          _checkedKeys: _checkedKeys2,
          _halfCheckedKeys: _halfCheckedKeys
        });
      }

      this.__emit('check', checkedObj, eventObj);
    },
    onNodeLoad: function onNodeLoad(treeNode) {
      var _this2 = this;

      return new Promise(function (resolve) {
        // We need to get the latest state of loading/loaded keys
        _this2.setState(function (_ref) {
          var _ref$_loadedKeys = _ref._loadedKeys,
              loadedKeys = _ref$_loadedKeys === void 0 ? [] : _ref$_loadedKeys,
              _ref$_loadingKeys = _ref._loadingKeys,
              loadingKeys = _ref$_loadingKeys === void 0 ? [] : _ref$_loadingKeys;
          var loadData = _this2.$props.loadData;

          var _getOptionProps3 = Object(props_util["j" /* getOptionProps */])(treeNode),
              eventKey = _getOptionProps3.eventKey;

          if (!loadData || loadedKeys.indexOf(eventKey) !== -1 || loadingKeys.indexOf(eventKey) !== -1) {
            return {};
          } // Process load data


          var promise = loadData(treeNode);
          promise.then(function () {
            var newLoadedKeys = Object(util["a" /* arrAdd */])(_this2.$data._loadedKeys, eventKey);

            _this2.setUncontrolledState({
              _loadedKeys: newLoadedKeys
            });

            _this2.setState({
              _loadingKeys: Object(util["b" /* arrDel */])(_this2.$data._loadingKeys, eventKey)
            });

            var eventObj = {
              event: 'load',
              node: treeNode
            };

            _this2.__emit('load', eventObj);

            resolve();
          });
          return {
            _loadingKeys: Object(util["a" /* arrAdd */])(loadingKeys, eventKey)
          };
        });
      });
    },
    onNodeExpand: function onNodeExpand(e, treeNode) {
      var _this3 = this;

      var expandedKeys = this.$data._expandedKeys;
      var loadData = this.$props.loadData;

      var _getOptionProps4 = Object(props_util["j" /* getOptionProps */])(treeNode),
          eventKey = _getOptionProps4.eventKey,
          expanded = _getOptionProps4.expanded; // Update selected keys


      var index = expandedKeys.indexOf(eventKey);
      var targetExpanded = !expanded;
      browser_default()(expanded && index !== -1 || !expanded && index === -1, 'Expand state not sync with index check');

      if (targetExpanded) {
        expandedKeys = Object(util["a" /* arrAdd */])(expandedKeys, eventKey);
      } else {
        expandedKeys = Object(util["b" /* arrDel */])(expandedKeys, eventKey);
      }

      this.setUncontrolledState({
        _expandedKeys: expandedKeys
      });

      this.__emit('expand', expandedKeys, {
        node: treeNode,
        expanded: targetExpanded,
        nativeEvent: e
      }); // Async Load data


      if (targetExpanded && loadData) {
        var loadPromise = this.onNodeLoad(treeNode);
        return loadPromise ? loadPromise.then(function () {
          // [Legacy] Refresh logic
          _this3.setUncontrolledState({
            _expandedKeys: expandedKeys
          });
        }) : null;
      }

      return null;
    },
    onNodeMouseEnter: function onNodeMouseEnter(event, node) {
      this.__emit('mouseenter', {
        event: event,
        node: node
      });
    },
    onNodeMouseLeave: function onNodeMouseLeave(event, node) {
      this.__emit('mouseleave', {
        event: event,
        node: node
      });
    },
    onNodeContextMenu: function onNodeContextMenu(event, node) {
      event.preventDefault();

      this.__emit('rightClick', {
        event: event,
        node: node
      });
    },

    /**
     * Only update the value which is not in props
     */
    setUncontrolledState: function setUncontrolledState(state) {
      var needSync = false;
      var newState = {};
      var props = Object(props_util["j" /* getOptionProps */])(this);
      Object.keys(state).forEach(function (name) {
        if (name.replace('_', '') in props) return;
        needSync = true;
        newState[name] = state[name];
      });

      if (needSync) {
        this.setState(newState);
      }
    },
    isKeyChecked: function isKeyChecked(key) {
      var _this$$data$_checkedK = this.$data._checkedKeys,
          checkedKeys = _this$$data$_checkedK === void 0 ? [] : _this$$data$_checkedK;
      return checkedKeys.indexOf(key) !== -1;
    },

    /**
     * [Legacy] Original logic use `key` as tracking clue.
     * We have to use `cloneElement` to pass `key`.
     */
    renderTreeNode: function renderTreeNode(child, index) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var _this$$data4 = this.$data,
          keyEntities = _this$$data4._keyEntities,
          _this$$data4$_expande = _this$$data4._expandedKeys,
          expandedKeys = _this$$data4$_expande === void 0 ? [] : _this$$data4$_expande,
          _this$$data4$_selecte = _this$$data4._selectedKeys,
          selectedKeys = _this$$data4$_selecte === void 0 ? [] : _this$$data4$_selecte,
          _this$$data4$_halfChe = _this$$data4._halfCheckedKeys,
          halfCheckedKeys = _this$$data4$_halfChe === void 0 ? [] : _this$$data4$_halfChe,
          _this$$data4$_loadedK = _this$$data4._loadedKeys,
          loadedKeys = _this$$data4$_loadedK === void 0 ? [] : _this$$data4$_loadedK,
          _this$$data4$_loading = _this$$data4._loadingKeys,
          loadingKeys = _this$$data4$_loading === void 0 ? [] : _this$$data4$_loading,
          dragOverNodeKey = _this$$data4._dragOverNodeKey,
          dropPosition = _this$$data4._dropPosition;
      var pos = Object(util["k" /* getPosition */])(level, index);
      var key = child.key || pos;

      if (!keyEntities[key]) {
        Object(util["o" /* warnOnlyTreeNode */])();
        return null;
      }

      return Object(vnode["a" /* cloneElement */])(child, {
        props: {
          key: key,
          eventKey: key,
          expanded: expandedKeys.indexOf(key) !== -1,
          selected: selectedKeys.indexOf(key) !== -1,
          loaded: loadedKeys.indexOf(key) !== -1,
          loading: loadingKeys.indexOf(key) !== -1,
          checked: this.isKeyChecked(key),
          halfChecked: halfCheckedKeys.indexOf(key) !== -1,
          pos: pos,
          // [Legacy] Drag props
          dragOver: dragOverNodeKey === key && dropPosition === 0,
          dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
          dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1
        }
      });
    }
  },
  render: function render() {
    var _this4 = this;

    var h = arguments[0];
    var treeNode = this.$data._treeNode;
    var _this$$props = this.$props,
        prefixCls = _this$$props.prefixCls,
        focusable = _this$$props.focusable,
        showLine = _this$$props.showLine,
        _this$$props$tabIndex = _this$$props.tabIndex,
        tabIndex = _this$$props$tabIndex === void 0 ? 0 : _this$$props$tabIndex,
        showCheckAll = _this$$props.showCheckAll;
    var domProps = {};
    var _checkedKeys = this.$data._checkedKeys;
    var entitiesMap = Object(util["h" /* convertTreeToEntities */])(treeNode);
    var keys = Object.keys(entitiesMap.keyEntities);
    var checkedKeysLength;

    if (_checkedKeys === undefined) {
      checkedKeysLength = 0;
    } else {
      checkedKeysLength = _checkedKeys.length || 0;
    }

    this.$data._checkedAllButtonValue = checkedKeysLength === keys.length ? '反选' : '全选';
    return h("ul", babel_helper_vue_jsx_merge_props_default()([domProps, {
      "class": classnames_default()(prefixCls, _defineProperty({}, "".concat(prefixCls, "-show-line"), showLine)),
      attrs: {
        role: 'tree',
        unselectable: 'on',
        tabIndex: focusable ? tabIndex : null
      },
      on: {
        "keyDown": focusable ? this.onKeydown : function () {}
      }
    }]), [showCheckAll ? h("button", {
      "class": "ant-btn ant-btn-primary ant-btn-sm",
      attrs: {
        type: "button"
      },
      on: {
        "click": function click() {
          if (checkedKeysLength === keys.length) {
            _this4.setState({
              _checkedKeys: [],
              _checkedAllButtonValue: '全选',
              _halfCheckedKeys: []
            });
          } else {
            _this4.setState({
              _checkedKeys: keys,
              _halfCheckedKeys: [],
              _checkedAllButtonValue: '反选'
            });
          }
        }
      }
    }, [h("span", [this.$data._checkedAllButtonValue])]) : null, Object(util["l" /* mapChildren */])(treeNode, function (node, index) {
      return _this4.renderTreeNode(node, index);
    })]);
  }
};

/* harmony default export */ var src_Tree = (Object(proxyComponent["a" /* default */])(Tree));
// EXTERNAL MODULE: ./src/components/vc-tree/src/TreeNode.jsx
var TreeNode = __webpack_require__(108);

// CONCATENATED MODULE: ./src/components/vc-tree/src/index.js
/* concated harmony reexport Tree */__webpack_require__.d(__webpack_exports__, "Tree", function() { return Tree; });
/* concated harmony reexport TreeNode */__webpack_require__.d(__webpack_exports__, "TreeNode", function() { return TreeNode["a" /* default */]; });


Tree.TreeNode = TreeNode["a" /* default */];
src_Tree.TreeNode = TreeNode["a" /* default */];

/* harmony default export */ var src = __webpack_exports__["default"] = (src_Tree);

/***/ })
/******/ ]);
});